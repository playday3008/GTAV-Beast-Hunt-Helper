// Generated on 13/01/2026, 10:56:03
// http://localhost:3000
// PR: https://github.com/DottieDot/GTAV-NativeDB/pull/119

// Expected invoker signature:
// `pub inline fn invoke(comptime R: type, hash: u64, args: anytype) !R { ... }`

const windows = @import("std").os.windows;

const ScriptHookZig = @import("ScriptHookZig");
const invoker = ScriptHookZig.Invoker;
const types = ScriptHookZig.Types;

// zig fmt: off

pub const Builtin = struct
{
    /// Pauses execution of the current script, please note this behavior is only seen when called from one of the game script files(ysc). In order to wait an asi script use "static void WAIT(DWORD time);" found in main.h
    pub inline fn wait(ms: c_int) !void { try invoker.invoke(void, 0x4EDE34FBADD967A6, .{ms}); } // 0x4EDE34FBADD967A6 0x7715C03B b323
    /// Examples: \
    ///  g_384A = SYSTEM::START_NEW_SCRIPT("cellphone_flashhand", 1424); \
    ///  l_10D = SYSTEM::START_NEW_SCRIPT("taxiService", 1828); \
    ///  SYSTEM::START_NEW_SCRIPT("AM_MP_YACHT", 5000); \
    ///  SYSTEM::START_NEW_SCRIPT("emergencycall", 512); \
    ///  SYSTEM::START_NEW_SCRIPT("emergencycall", 512);  \
    ///  SYSTEM::START_NEW_SCRIPT("FM_maintain_cloud_header_data", 1424); \
    ///  SYSTEM::START_NEW_SCRIPT("FM_Mission_Controller", 31000); \
    ///  SYSTEM::START_NEW_SCRIPT("tennis_family", 3650); \
    ///  SYSTEM::START_NEW_SCRIPT("Celebrations", 3650);
    /// 
    /// Decompiled examples of usage when starting a script:
    ///  
    ///     SCRIPT::REQUEST_SCRIPT(a_0);
    ///     if (SCRIPT::HAS_SCRIPT_LOADED(a_0)) {
    ///         SYSTEM::START_NEW_SCRIPT(a_0, v_3);
    ///         SCRIPT::SET_SCRIPT_AS_NO_LONGER_NEEDED(a_0);
    ///         return 1;
    ///     }
    ///  
    /// or:
    /// 
    ///     v_2 = "MrsPhilips2";
    ///     SCRIPT::REQUEST_SCRIPT(v_2);
    ///     while (!SCRIPT::HAS_SCRIPT_LOADED(v_2)) {
    ///     SCRIPT::REQUEST_SCRIPT(v_2);
    ///     SYSTEM::WAIT(0);
    ///     }
    ///     sub_8792(36);
    ///     SYSTEM::START_NEW_SCRIPT(v_2, 17000);
    ///     SCRIPT::SET_SCRIPT_AS_NO_LONGER_NEEDED(v_2);
    pub inline fn startNewScript(script_name: [*c]const u8, stack_size: c_int) !c_int { return try invoker.invoke(c_int, 0xE81651AD79516E48, .{script_name, stack_size}); } // 0xE81651AD79516E48 0x3F166D0E b323
    /// return : script thread id, 0 if failed \
    /// Pass pointer to struct of args in p1, size of struct goes into p2
    pub inline fn startNewScriptWithArgs(script_name: [*c]const u8, args: [*c]types.Any, arg_count: c_int, stack_size: c_int) !c_int { return try invoker.invoke(c_int, 0xB8BA7F44DF1575E1, .{script_name, args, arg_count, stack_size}); } // 0xB8BA7F44DF1575E1 0x4A2100E4 b323
    pub inline fn startNewScriptWithNameHash(script_hash: types.Hash, stack_size: c_int) !c_int { return try invoker.invoke(c_int, 0xEB1C67C3A5333A92, .{script_hash, stack_size}); } // 0xEB1C67C3A5333A92 0x8D15BE5D b323
    pub inline fn startNewScriptWithNameHashAndArgs(script_hash: types.Hash, args: [*c]types.Any, arg_count: c_int, stack_size: c_int) !c_int { return try invoker.invoke(c_int, 0xC4BB298BD441BE78, .{script_hash, args, arg_count, stack_size}); } // 0xC4BB298BD441BE78 0xE38A3AD4 b323
    /// Counts up. Every 1000 is 1 real-time second. Use SETTIMERA(int value) to set the timer (e.g.: SETTIMERA(0)).
    pub inline fn timera() !c_int { return try invoker.invoke(c_int, 0x83666F9FB8FEBD4B, .{}); } // 0x83666F9FB8FEBD4B 0x45C8C188 b323
    pub inline fn timerb() !c_int { return try invoker.invoke(c_int, 0xC9D9444186B5A374, .{}); } // 0xC9D9444186B5A374 0x330A9C0C b323
    pub inline fn settimera(value: c_int) !void { try invoker.invoke(void, 0xC1B1E9A034A63A62, .{value}); } // 0xC1B1E9A034A63A62 0x35785333 b323
    pub inline fn settimerb(value: c_int) !void { try invoker.invoke(void, 0x5AE11BC36633DE4E, .{value}); } // 0x5AE11BC36633DE4E 0x27C1B7C6 b323
    /// Gets the current frame time.
    pub inline fn timestep() !f32 { return try invoker.invoke(f32, 0x0000000050597EE2, .{}); } // 0x0000000050597EE2 0x50597EE2 b323
    pub inline fn sin(value: f32) !f32 { return try invoker.invoke(f32, 0x0BADBFA3B172435F, .{value}); } // 0x0BADBFA3B172435F 0xBF987F58 b323
    pub inline fn cos(value: f32) !f32 { return try invoker.invoke(f32, 0xD0FFB162F40A139C, .{value}); } // 0xD0FFB162F40A139C 0x00238FE9 b323
    pub inline fn sqrt(value: f32) !f32 { return try invoker.invoke(f32, 0x71D93B57D07F9804, .{value}); } // 0x71D93B57D07F9804 0x145C7701 b323
    pub inline fn pow(base: f32, exponent: f32) !f32 { return try invoker.invoke(f32, 0xE3621CC40F31FE2E, .{base, exponent}); } // 0xE3621CC40F31FE2E 0x85D134F8 b323
    pub inline fn log10(value: f32) !f32 { return try invoker.invoke(f32, 0xE816E655DE37FE20, .{value}); } // 0xE816E655DE37FE20  b1493
    /// Calculates the magnitude of a vector.
    pub inline fn vmag(vec: types.Vector3) !f32 { return try invoker.invoke(f32, 0x652D2EEEF1D3E62C, .{vec.x, vec.y, vec.z}); } // 0x652D2EEEF1D3E62C 0x1FCF1ECD b323
    /// Calculates the magnitude of a vector but does not perform Sqrt operations. (Its way faster)
    pub inline fn vmag2(vec: types.Vector3) !f32 { return try invoker.invoke(f32, 0xA8CEACB4F35AE058, .{vec.x, vec.y, vec.z}); } // 0xA8CEACB4F35AE058 0xE796E629 b323
    /// Calculates distance between vectors.
    pub inline fn vdist(vec_1__: types.Vector3, vec_2__: types.Vector3) !f32 { return try invoker.invoke(f32, 0x2A488C176D52CCA5, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x2A488C176D52CCA5 0x3C08ECB7 b323
    /// Calculates distance between vectors but does not perform Sqrt operations. (Its way faster)
    pub inline fn vdist2(vec_1__: types.Vector3, vec_2__: types.Vector3) !f32 { return try invoker.invoke(f32, 0xB7A628320EFF8E47, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0xB7A628320EFF8E47 0xC85DEF1F b323
    pub inline fn shiftLeft(value: c_int, bit_shift: c_int) !c_int { return try invoker.invoke(c_int, 0xEDD95A39E5544DE8, .{value, bit_shift}); } // 0xEDD95A39E5544DE8 0x314CC6CD b323
    pub inline fn shiftRight(value: c_int, bit_shift: c_int) !c_int { return try invoker.invoke(c_int, 0x97EF1E5BCE9DC075, .{value, bit_shift}); } // 0x97EF1E5BCE9DC075 0x352633CA b323
    pub inline fn floor(value: f32) !c_int { return try invoker.invoke(c_int, 0xF34EE736CF047844, .{value}); } // 0xF34EE736CF047844 0x32E9BE04 b323
    /// I'm guessing this rounds a float value up to the next whole number, and FLOOR rounds it down
    pub inline fn ceil(value: f32) !c_int { return try invoker.invoke(c_int, 0x11E019C8F43ACC8A, .{value}); } // 0x11E019C8F43ACC8A 0xD536A1DF b323
    pub inline fn round(value: f32) !c_int { return try invoker.invoke(c_int, 0xF2DB717A73826179, .{value}); } // 0xF2DB717A73826179 0x323B0E24 b323
    pub inline fn toFloat(value: c_int) !f32 { return try invoker.invoke(f32, 0xBBDA792448DB5A89, .{value}); } // 0xBBDA792448DB5A89 0x67116627 b323
    /// THREAD_PRIO_HIGHEST = 0 \
    /// THREAD_PRIO_NORMAL = 1 \
    /// THREAD_PRIO_LOWEST = 2 \
    /// THREAD_PRIO_MANUAL_UPDATE = 100
    pub inline fn setThisThreadPriority(priority: c_int) !void { try invoker.invoke(void, 0x42B65DEEF2EDF2A1, .{priority}); } // 0x42B65DEEF2EDF2A1  b877
};

pub const App = struct
{
    pub inline fn appDataValid() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x846AA8E7D55EE5B6, .{}); } // 0x846AA8E7D55EE5B6 0x72BDE002 b323
    pub inline fn appGetInt(property: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xD3A58A12C77D9D4B, .{property}); } // 0xD3A58A12C77D9D4B 0x2942AAD2 b323
    pub inline fn appGetFloat(property: [*c]const u8) !f32 { return try invoker.invoke(f32, 0x1514FB24C02C2322, .{property}); } // 0x1514FB24C02C2322 0xD87F3A1C b323
    pub inline fn appGetString(property: [*c]const u8) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x749B023950D2311C, .{property}); } // 0x749B023950D2311C 0x849CEB80 b323
    pub inline fn appSetInt(property: [*c]const u8, value: c_int) !void { try invoker.invoke(void, 0x607E8E3D3E4F9611, .{property, value}); } // 0x607E8E3D3E4F9611 0x1B509C32 b323
    pub inline fn appSetFloat(property: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0x25D7687C68E0DAA4, .{property, value}); } // 0x25D7687C68E0DAA4 0xF3076135 b323
    pub inline fn appSetString(property: [*c]const u8, value: [*c]const u8) !void { try invoker.invoke(void, 0x3FF2FCEC4B7721B4, .{property, value}); } // 0x3FF2FCEC4B7721B4 0x23DF19A8 b323
    /// Called in the gamescripts like: \
    /// APP::APP_SET_APP("car"); \
    /// APP::APP_SET_APP("dog");
    pub inline fn appSetApp(app_name: [*c]const u8) !void { try invoker.invoke(void, 0xCFD0406ADAF90D2B, .{app_name}); } // 0xCFD0406ADAF90D2B 0x8BAC4146 b323
    pub inline fn appSetBlock(block_name: [*c]const u8) !void { try invoker.invoke(void, 0x262AB456A3D21F93, .{block_name}); } // 0x262AB456A3D21F93 0xC2D54DD9 b323
    pub inline fn appClearBlock() !void { try invoker.invoke(void, 0x5FE1DF3342DB7DBA, .{}); } // 0x5FE1DF3342DB7DBA 0xDAB86A18 b323
    pub inline fn appCloseApp() !void { try invoker.invoke(void, 0xE41C65E07A5F05FC, .{}); } // 0xE41C65E07A5F05FC 0x03767C7A b323
    pub inline fn appCloseBlock() !void { try invoker.invoke(void, 0xE8E3FCF72EAC0EF8, .{}); } // 0xE8E3FCF72EAC0EF8 0xED97B202 b323
    pub inline fn appHasLinkedSocialClubAccount() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71EEE69745088DA0, .{}); } // 0x71EEE69745088DA0 0xD368BA15 b323
    pub inline fn appHasSyncedData(app_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCA52279A7271517F, .{app_name}); } // 0xCA52279A7271517F 0x1DE2A63D b323
    pub inline fn appSaveData() !void { try invoker.invoke(void, 0x95C5D356CDA6E85F, .{}); } // 0x95C5D356CDA6E85F 0x84A3918D b323
    pub inline fn appGetDeletedFileStatus() !c_int { return try invoker.invoke(c_int, 0xC9853A2BE3DED1A6, .{}); } // 0xC9853A2BE3DED1A6 0x784D550B b323
    pub inline fn appDeleteAppData(app_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x44151AEA95C8A003, .{app_name}); } // 0x44151AEA95C8A003 0x2A2FBD1C b323
};

pub const Audio = struct
{
    /// All found occurrences in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/RFb4GTny
    /// 
    /// AUDIO::PLAY_PED_RINGTONE("Remote_Ring", PLAYER::PLAYER_PED_ID(), 1); \
    /// AUDIO::PLAY_PED_RINGTONE("Dial_and_Remote_Ring", PLAYER::PLAYER_PED_ID(), 1);
    /// 
    pub inline fn playPedRingtone(ringtone_name: [*c]const u8, ped: types.Ped, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xF9E56683CA8E11A5, .{ringtone_name, ped, p_2}); } // 0xF9E56683CA8E11A5 0x1D530E47 b323
    pub inline fn isPedRingtonePlaying(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1E8E5E20937E3137, .{ped}); } // 0x1E8E5E20937E3137 0xFE576EE4 b323
    pub inline fn stopPedRingtone(ped: types.Ped) !void { try invoker.invoke(void, 0x6C5AE23EFA885092, .{ped}); } // 0x6C5AE23EFA885092 0xFEEA107C b323
    pub inline fn isMobilePhoneCallOngoing() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7497D2CE2C30D24C, .{}); } // 0x7497D2CE2C30D24C 0x4ED1400A b323
    pub inline fn isMobileInterferenceActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC8B1B2425604CDD0, .{}); } // 0xC8B1B2425604CDD0 0x16FB88B5 b323
    pub inline fn getCurrentTvShowPlayTime() !c_int { return try invoker.invoke(c_int, 0xDD3AA743AB7D4D75, .{}); } // 0xDD3AA743AB7D4D75  b3095
    pub inline fn createNewScriptedConversation() !void { try invoker.invoke(void, 0xD2C91A0B572AAE56, .{}); } // 0xD2C91A0B572AAE56 0xB2BC25F8 b323
    /// NOTE: ones that are -1, 0 - 35 are determined by a function where it gets a TextLabel from a global then runs, \
    /// GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME and depending on what the result is it goes in check order of 0 - 9 then A - Z then z (lowercase). So it will then return 0 - 35 or -1 if it's 'z'. The func to handle that ^^ is func_67 in dialog_handler.c atleast in TU27 Xbox360 scripts.
    /// 
    /// p0 is -1, 0 - 35 \
    /// p1 is a char or string (whatever you wanna call it) \
    /// p2 is Global 10597 + i * 6. 'i' is a while(i < 70) loop \
    /// p3 is again -1, 0 - 35  \
    /// p4 is again -1, 0 - 35  \
    /// p5 is either 0 or 1 (bool ?) \
    /// p6 is either 0 or 1 (The func to determine this is bool) \
    /// p7 is either 0 or 1 (The func to determine this is bool) \
    /// p8 is either 0 or 1 (The func to determine this is bool) \
    /// p9 is 0 - 3 (Determined by func_60 in dialogue_handler.c) \
    /// p10 is either 0 or 1 (The func to determine this is bool) \
    /// p11 is either 0 or 1 (The func to determine this is bool) \
    /// p12 is unknown as in TU27 X360 scripts it only goes to p11.
    pub inline fn addLineToConversation(index: c_int, p_1: [*c]const u8, p_2: [*c]const u8, p_3: c_int, p_4: c_int, p_5: windows.BOOL, p_6: windows.BOOL, p_7: windows.BOOL, p_8: windows.BOOL, p_9: c_int, p_1_0: windows.BOOL, p_1_1: windows.BOOL, p_1_2: windows.BOOL) !void { try invoker.invoke(void, 0xC5EF963405593646, .{index, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2}); } // 0xC5EF963405593646 0x96CD0513 b323
    /// 4 calls in the b617d scripts. The only one with p0 and p2 in clear text:
    /// 
    /// AUDIO::ADD_PED_TO_CONVERSATION(5, l_AF, "DINAPOLI");
    /// 
    /// ================================================= \
    /// One of the 2 calls in dialogue_handler.c p0 is in a while-loop, and so is determined to also possibly be 0 - 15.
    pub inline fn addPedToConversation(index: c_int, ped: types.Ped, p_2: [*c]const u8) !void { try invoker.invoke(void, 0x95D9F4BC443956E7, .{index, ped, p_2}); } // 0x95D9F4BC443956E7 0xF8D5EB86 b323
    pub inline fn setPositionForNullConvPed(p_0: types.Any, p_1: f32, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0x33E3C6C6F2F0B506, .{p_0, p_1, p_2, p_3}); } // 0x33E3C6C6F2F0B506 0x73C6F979 b323
    pub inline fn setEntityForNullConvPed(p_0: c_int, entity: types.Entity) !void { try invoker.invoke(void, 0x892B6AB8F33606F5, .{p_0, entity}); } // 0x892B6AB8F33606F5 0x88203DDA b323
    /// This native controls where the game plays audio from. By default the microphone is positioned on the player. \
    /// When p0 is true the game will play audio from the 3 positions inputted. \
    /// It is recommended to set all 3 positions to the same value as mixing different positions doesn't seem to work well. \
    /// The scripts mostly use it with only one position such as in fbi3.c:  \
    /// AUDIO::SET_MICROPHONE_POSITION(true, ENTITY::GET_ENTITY_COORDS(iLocal_3091, true), ENTITY::GET_ENTITY_COORDS(iLocal_3091, true), ENTITY::GET_ENTITY_COORDS(iLocal_3091, true));
    pub inline fn setMicrophonePosition(toggle: windows.BOOL, vec_1__: types.Vector3, vec_2__: types.Vector3, vec_3__: types.Vector3) !void { try invoker.invoke(void, 0xB6AE90EDDE95C762, .{toggle, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, vec_3__.x, vec_3__.y, vec_3__.z}); } // 0xB6AE90EDDE95C762 0xAD7BB191 b323
    pub inline fn setConversationAudioControlledByAnim(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x0B568201DD99F0EB, .{p_0}); } // 0x0B568201DD99F0EB 0x1193ED6E b323
    pub inline fn setConversationAudioPlaceholder(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x61631F5DF50D1C34, .{p_0}); } // 0x61631F5DF50D1C34  b323
    pub inline fn startScriptPhoneConversation(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x252E5F915EABB675, .{p_0, p_1}); } // 0x252E5F915EABB675 0x38E42D07 b323
    pub inline fn preloadScriptPhoneConversation(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x6004BCB0E226AAEA, .{p_0, p_1}); } // 0x6004BCB0E226AAEA 0x9ACB213A b323
    pub inline fn startScriptConversation(p_0: windows.BOOL, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x6B17C62C9635D2DC, .{p_0, p_1, p_2, p_3}); } // 0x6B17C62C9635D2DC 0xE5DE7D9D b323
    pub inline fn preloadScriptConversation(p_0: windows.BOOL, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x3B3CAD6166916D87, .{p_0, p_1, p_2, p_3}); } // 0x3B3CAD6166916D87 0xDDF5C579 b323
    pub inline fn startPreloadedConversation() !void { try invoker.invoke(void, 0x23641AFE870AF385, .{}); } // 0x23641AFE870AF385 0xA170261B b323
    pub inline fn getIsPreloadedConversationReady() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE73364DB90778FFA, .{}); } // 0xE73364DB90778FFA 0x336F3D35 b323
    pub inline fn isScriptedConversationOngoing() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x16754C556D2EDE3D, .{}); } // 0x16754C556D2EDE3D 0xCB8FD96F b323
    pub inline fn isScriptedConversationLoaded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDF0D54BE7A776737, .{}); } // 0xDF0D54BE7A776737 0xE1870EA9 b323
    pub inline fn getCurrentScriptedConversationLine() !c_int { return try invoker.invoke(c_int, 0x480357EE890C295A, .{}); } // 0x480357EE890C295A 0x9620E41F b323
    pub inline fn pauseScriptedConversation(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x8530AD776CD72B12, .{p_0}); } // 0x8530AD776CD72B12 0xE2C9C6F8 b323
    pub inline fn restartScriptedConversation() !void { try invoker.invoke(void, 0x9AEB285D1818C9AC, .{}); } // 0x9AEB285D1818C9AC 0x6CB24B56 b323
    pub inline fn stopScriptedConversation(p_0: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xD79DEEFB53455EBA, .{p_0}); } // 0xD79DEEFB53455EBA 0xAB77DA7D b323
    pub inline fn skipToNextScriptedConversationLine() !void { try invoker.invoke(void, 0x9663FE6B7A61EB00, .{}); } // 0x9663FE6B7A61EB00 0x85C98304 b323
    /// Example from carsteal3.c: AUDIO::INTERRUPT_CONVERSATION(PLAYER::PLAYER_PED_ID(), "CST4_CFAA", "FRANKLIN"); \
    /// Voicelines can be found in GTAV\x64\audio\sfx in files starting with "SS_" which seems to mean scripted speech.
    pub inline fn interruptConversation(ped: types.Ped, voiceline: [*c]const u8, speaker: [*c]const u8) !void { try invoker.invoke(void, 0xA018A12E5C5C2FA6, .{ped, voiceline, speaker}); } // 0xA018A12E5C5C2FA6 0xF3A67AF3 b323
    /// One call found in the b617d scripts:
    /// 
    /// AUDIO::INTERRUPT_CONVERSATION_AND_PAUSE(NETWORK::NET_TO_PED(l_3989._f26F[0/*1*/]), "CONV_INTERRUPT_QUIT_IT", "LESTER");
    pub inline fn interruptConversationAndPause(ped: types.Ped, p_1: [*c]const u8, speaker: [*c]const u8) !void { try invoker.invoke(void, 0x8A694D7A68F8DC38, .{ped, p_1, speaker}); } // 0x8A694D7A68F8DC38 0xDD4A3F1F b323
    pub inline fn getVariationChosenForScriptedLine(p_0: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0xAA19F5572C38B564, .{p_0}); } // 0xAA19F5572C38B564 0xB58B8FF3 b323
    pub inline fn setNoDuckingForConversation(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xB542DE8C3D1CB210, .{p_0}); } // 0xB542DE8C3D1CB210 0x789D8C6C b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn registerScriptWithAudio(p_0: c_int) !void { try invoker.invoke(void, 0xC6ED9D5092438D91, .{p_0}); } // 0xC6ED9D5092438D91 0xA6203643 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn unregisterScriptWithAudio() !void { try invoker.invoke(void, 0xA8638BE228D4751A, .{}); } // 0xA8638BE228D4751A 0x66728EFE b323
    /// All occurrences and usages found in b617d: https://pastebin.com/NzZZ2Tmm \
    /// Full list of mission audio bank names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/missionAudioBankNames.json \
    /// p2 is always -1
    pub inline fn requestMissionAudioBank(audio_bank: [*c]const u8, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7345BDD95E62E0F2, .{audio_bank, p_1, p_2}); } // 0x7345BDD95E62E0F2 0x916E37CA b323
    /// All occurrences and usages found in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/XZ1tmGEz \
    /// Full list of ambient audio bank names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientAudioBankNames.json \
    /// p2 is always -1
    pub inline fn requestAmbientAudioBank(audio_bank: [*c]const u8, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFE02FFBED8CA9D99, .{audio_bank, p_1, p_2}); } // 0xFE02FFBED8CA9D99 0x23C88BC7 b323
    /// All occurrences and usages found in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/AkmDAVn6 \
    /// Full list of script audio bank names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scriptAudioBankNames.json \
    /// p2 is always -1
    pub inline fn requestScriptAudioBank(audio_bank: [*c]const u8, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2F844A8B08D76685, .{audio_bank, p_1, p_2}); } // 0x2F844A8B08D76685 0x21322887 b323
    /// p2 is always -1
    pub inline fn hintMissionAudioBank(audio_bank: [*c]const u8, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x40763EA7B9B783E7, .{audio_bank, p_1, p_2}); } // 0x40763EA7B9B783E7  b573
    /// p2 is always -1
    pub inline fn hintAmbientAudioBank(audio_bank: [*c]const u8, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8F8C0E370AE62F5C, .{audio_bank, p_1, p_2}); } // 0x8F8C0E370AE62F5C 0xF1850DDC b323
    /// p2 is always -1
    pub inline fn hintScriptAudioBank(audio_bank: [*c]const u8, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFB380A29641EC31A, .{audio_bank, p_1, p_2}); } // 0xFB380A29641EC31A 0x41FA0E51 b323
    pub inline fn releaseMissionAudioBank() !void { try invoker.invoke(void, 0x0EC92A1BF0857187, .{}); } // 0x0EC92A1BF0857187 0x8E8824C7 b323
    pub inline fn releaseAmbientAudioBank() !void { try invoker.invoke(void, 0x65475A218FFAA93D, .{}); } // 0x65475A218FFAA93D 0x8C938784 b323
    /// Full list of script audio bank names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scriptAudioBankNames.json
    pub inline fn releaseNamedScriptAudioBank(audio_bank: [*c]const u8) !void { try invoker.invoke(void, 0x77ED170667F50170, .{audio_bank}); } // 0x77ED170667F50170 0x16707ABC b323
    pub inline fn releaseScriptAudioBank() !void { try invoker.invoke(void, 0x7A2D8AD0A9EB9C3F, .{}); } // 0x7A2D8AD0A9EB9C3F 0x22F865E5 b323
    pub inline fn unhintAmbientAudioBank() !void { try invoker.invoke(void, 0x19AF7ED9B9D23058, .{}); } // 0x19AF7ED9B9D23058 0xA58BBF4F b323
    pub inline fn unhintScriptAudioBank() !void { try invoker.invoke(void, 0x9AC92EED5E4793AB, .{}); } // 0x9AC92EED5E4793AB 0xE67446E9 b323
    pub inline fn unhintNamedScriptAudioBank(audio_bank: [*c]const u8) !void { try invoker.invoke(void, 0x11579D940949C49E, .{audio_bank}); } // 0x11579D940949C49E  b678
    pub inline fn getSoundId() !c_int { return try invoker.invoke(c_int, 0x430386FE9BF80B45, .{}); } // 0x430386FE9BF80B45 0x6AE0AD56 b323
    pub inline fn releaseSoundId(sound_id: c_int) !void { try invoker.invoke(void, 0x353FC880830B88FA, .{sound_id}); } // 0x353FC880830B88FA 0x9C080899 b323
    /// All found occurrences in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/A8Ny8AHZ
    /// 
    /// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
    pub inline fn playSound(sound_id: c_int, audio_name: [*c]const u8, audio_ref: [*c]const u8, p_3: windows.BOOL, p_4: types.Any, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x7FF4944CC209192D, .{sound_id, audio_name, audio_ref, p_3, p_4, p_5}); } // 0x7FF4944CC209192D 0xB6E1917F b323
    /// List: https://pastebin.com/DCeRiaLJ
    /// 
    /// All occurrences as of Cayo Perico Heist DLC (b2189), sorted alphabetically and identical lines removed: https://git.io/JtLxM
    /// 
    /// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
    pub inline fn playSoundFrontend(sound_id: c_int, audio_name: [*c]const u8, audio_ref: [*c]const u8, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x67C540AA08E4A6F5, .{sound_id, audio_name, audio_ref, p_3}); } // 0x67C540AA08E4A6F5 0x2E458F74 b323
    /// Only call found in the b617d scripts:
    /// 
    /// AUDIO::PLAY_DEFERRED_SOUND_FRONTEND("BACK", "HUD_FREEMODE_SOUNDSET");
    /// 
    /// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
    pub inline fn playDeferredSoundFrontend(sound_name: [*c]const u8, soundset_name: [*c]const u8) !void { try invoker.invoke(void, 0xCADA5A0D0702381E, .{sound_name, soundset_name}); } // 0xCADA5A0D0702381E 0xC70E6CFA b323
    /// All found occurrences in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/f2A7vTj0  \
    /// No changes made in b678d.
    /// 
    /// gtaforums.com/topic/795622-audio-for-mods
    /// 
    /// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
    pub inline fn playSoundFromEntity(sound_id: c_int, audio_name: [*c]const u8, entity: types.Entity, audio_ref: [*c]const u8, is_network: windows.BOOL, p_5: types.Any) !void { try invoker.invoke(void, 0xE65F427EB70AB1ED, .{sound_id, audio_name, entity, audio_ref, is_network, p_5}); } // 0xE65F427EB70AB1ED 0x95AE00F8 b323
    /// Only used with "formation_flying_blips_soundset" and "biker_formation_blips_soundset". \
    /// p1 is always the model of p2
    pub inline fn playSoundFromEntityHash(sound_id: c_int, model: types.Hash, entity: types.Entity, sound_set_hash: types.Hash, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0x5B9853296731E88D, .{sound_id, model, entity, sound_set_hash, p_4, p_5}); } // 0x5B9853296731E88D  b877
    /// All found occurrences in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/eeFc5DiW
    /// 
    /// gtaforums.com/topic/795622-audio-for-mods
    /// 
    /// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
    pub inline fn playSoundFromCoord(sound_id: c_int, audio_name: [*c]const u8, vec: types.Vector3, audio_ref: [*c]const u8, is_network: windows.BOOL, range: c_int, p_8: windows.BOOL) !void { try invoker.invoke(void, 0x8D8686B622B88120, .{sound_id, audio_name, vec.x, vec.y, vec.z, audio_ref, is_network, range, p_8}); } // 0x8D8686B622B88120 0xCAD3E2D5 b323
    pub inline fn updateSoundCoord(sound_id: c_int, vec: types.Vector3) !void { try invoker.invoke(void, 0x7EC3C679D0E7E46B, .{sound_id, vec.x, vec.y, vec.z}); } // 0x7EC3C679D0E7E46B  b678
    pub inline fn stopSound(sound_id: c_int) !void { try invoker.invoke(void, 0xA3B0C41BA5CC0BB5, .{sound_id}); } // 0xA3B0C41BA5CC0BB5 0xCD7F4030 b323
    /// Could this be used alongside either,  \
    /// SET_NETWORK_ID_EXISTS_ON_ALL_MACHINES or _SET_NETWORK_ID_SYNC_TO_PLAYER to make it so other players can hear the sound while online? It'd be a bit troll-fun to be able to play the Zancudo UFO creepy sounds globally.
    pub inline fn getNetworkIdFromSoundId(sound_id: c_int) !c_int { return try invoker.invoke(c_int, 0x2DE3F0A134FFBC0D, .{sound_id}); } // 0x2DE3F0A134FFBC0D 0x2576F610 b323
    pub inline fn getSoundIdFromNetworkId(net_id: c_int) !c_int { return try invoker.invoke(c_int, 0x75262FD12D0A1C84, .{net_id}); } // 0x75262FD12D0A1C84 0xD064D4DC b323
    pub inline fn setVariableOnSound(sound_id: c_int, variable: [*c]const u8, p_2: f32) !void { try invoker.invoke(void, 0xAD6B3148A78AE9B6, .{sound_id, variable, p_2}); } // 0xAD6B3148A78AE9B6 0x606EE5FA b323
    /// From the scripts, p0:
    /// 
    /// "ArmWrestlingIntensity", \
    /// "INOUT", \
    /// "Monkey_Stream", \
    /// "ZoomLevel"
    pub inline fn setVariableOnStream(variable: [*c]const u8, p_1: f32) !void { try invoker.invoke(void, 0x2F9D3834AEB9EF79, .{variable, p_1}); } // 0x2F9D3834AEB9EF79 0xF67BB44C b323
    pub inline fn overrideUnderwaterStream(p_0: [*c]const u8, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xF2A9CDABCEA04BD6, .{p_0, p_1}); } // 0xF2A9CDABCEA04BD6 0x9A083B7E b323
    /// AUDIO::SET_VARIABLE_ON_UNDER_WATER_STREAM("inTunnel", 1.0); \
    /// AUDIO::SET_VARIABLE_ON_UNDER_WATER_STREAM("inTunnel", 0.0);
    pub inline fn setVariableOnUnderWaterStream(variable_name: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0x733ADF241531E5C2, .{variable_name, value}); } // 0x733ADF241531E5C2 0x62D026BE b323
    pub inline fn hasSoundFinished(sound_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFCBDCE714A7C88E5, .{sound_id}); } // 0xFCBDCE714A7C88E5 0xE85AEC2E b323
    /// Plays ambient speech. See also _0x444180DB.
    /// 
    /// ped: The ped to play the ambient speech. \
    /// speechName: Name of the speech to play, eg. "GENERIC_HI". \
    /// speechParam: Can be one of the following: \
    /// SPEECH_PARAMS_STANDARD \
    /// SPEECH_PARAMS_ALLOW_REPEAT \
    /// SPEECH_PARAMS_BEAT \
    /// SPEECH_PARAMS_FORCE \
    /// SPEECH_PARAMS_FORCE_FRONTEND \
    /// SPEECH_PARAMS_FORCE_NO_REPEAT_FRONTEND \
    /// SPEECH_PARAMS_FORCE_NORMAL \
    /// SPEECH_PARAMS_FORCE_NORMAL_CLEAR \
    /// SPEECH_PARAMS_FORCE_NORMAL_CRITICAL \
    /// SPEECH_PARAMS_FORCE_SHOUTED \
    /// SPEECH_PARAMS_FORCE_SHOUTED_CLEAR \
    /// SPEECH_PARAMS_FORCE_SHOUTED_CRITICAL \
    /// SPEECH_PARAMS_FORCE_PRELOAD_ONLY \
    /// SPEECH_PARAMS_MEGAPHONE \
    /// SPEECH_PARAMS_HELI \
    /// SPEECH_PARAMS_FORCE_MEGAPHONE \
    /// SPEECH_PARAMS_FORCE_HELI \
    /// SPEECH_PARAMS_INTERRUPT \
    /// SPEECH_PARAMS_INTERRUPT_SHOUTED \
    /// SPEECH_PARAMS_INTERRUPT_SHOUTED_CLEAR \
    /// SPEECH_PARAMS_INTERRUPT_SHOUTED_CRITICAL \
    /// SPEECH_PARAMS_INTERRUPT_NO_FORCE \
    /// SPEECH_PARAMS_INTERRUPT_FRONTEND \
    /// SPEECH_PARAMS_INTERRUPT_NO_FORCE_FRONTEND \
    /// SPEECH_PARAMS_ADD_BLIP \
    /// SPEECH_PARAMS_ADD_BLIP_ALLOW_REPEAT \
    /// SPEECH_PARAMS_ADD_BLIP_FORCE \
    /// SPEECH_PARAMS_ADD_BLIP_SHOUTED \
    /// SPEECH_PARAMS_ADD_BLIP_SHOUTED_FORCE \
    /// SPEECH_PARAMS_ADD_BLIP_INTERRUPT \
    /// SPEECH_PARAMS_ADD_BLIP_INTERRUPT_FORCE \
    /// SPEECH_PARAMS_FORCE_PRELOAD_ONLY_SHOUTED \
    /// SPEECH_PARAMS_FORCE_PRELOAD_ONLY_SHOUTED_CLEAR \
    /// SPEECH_PARAMS_FORCE_PRELOAD_ONLY_SHOUTED_CRITICAL \
    /// SPEECH_PARAMS_SHOUTED \
    /// SPEECH_PARAMS_SHOUTED_CLEAR \
    /// SPEECH_PARAMS_SHOUTED_CRITICAL
    /// 
    /// Note: A list of Name and Parameters can be found here https://pastebin.com/1GZS5dCL
    /// 
    /// Full list of speeches and voices names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/speeches.json
    pub inline fn playPedAmbientSpeechNative(ped: types.Ped, speech_name: [*c]const u8, speech_param: [*c]const u8, p_3: types.Any) !void { try invoker.invoke(void, 0x8E04FEDD28D42462, .{ped, speech_name, speech_param, p_3}); } // 0x8E04FEDD28D42462 0x5C57B85D b323
    /// Plays ambient speech. See also _0x5C57B85D.
    /// 
    /// See PLAY_PED_AMBIENT_SPEECH_NATIVE for parameter specifications.
    /// 
    /// Full list of speeches and voices names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/speeches.json
    pub inline fn playPedAmbientSpeechAndCloneNative(ped: types.Ped, speech_name: [*c]const u8, speech_param: [*c]const u8, p_3: types.Any) !void { try invoker.invoke(void, 0xC6941B4A3A8FBBB9, .{ped, speech_name, speech_param, p_3}); } // 0xC6941B4A3A8FBBB9 0x444180DB b323
    /// This is the same as PLAY_PED_AMBIENT_SPEECH_NATIVE and PLAY_PED_AMBIENT_SPEECH_AND_CLONE_NATIVE but it will allow you to play a speech file from a specific voice file. It works on players and all peds, even animals.
    /// 
    /// EX (C#): \
    /// GTA.Native.Function.Call(Hash.PLAY_PED_AMBIENT_SPEECH_WITH_VOICE_NATIVE, Game.Player.Character, "GENERIC_INSULT_HIGH", "s_m_y_sheriff_01_white_full_01", "SPEECH_PARAMS_FORCE_SHOUTED", 0);
    /// 
    /// The first param is the ped you want to play it on, the second is the speech name, the third is the voice name, the fourth is the speech param, and the last param is usually always 0.
    /// 
    /// Full list of speeches and voices names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/speeches.json
    pub inline fn playPedAmbientSpeechWithVoiceNative(ped: types.Ped, speech_name: [*c]const u8, voice_name: [*c]const u8, speech_param: [*c]const u8, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x3523634255FC3318, .{ped, speech_name, voice_name, speech_param, p_4}); } // 0x3523634255FC3318 0x8386AE28 b323
    /// Full list of speeches and voices names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/speeches.json
    pub inline fn playAmbientSpeechFromPositionNative(speech_name: [*c]const u8, voice_name: [*c]const u8, vec: types.Vector3, speech_param: [*c]const u8) !void { try invoker.invoke(void, 0xED640017ED337E45, .{speech_name, voice_name, vec.x, vec.y, vec.z, speech_param}); } // 0xED640017ED337E45 0xA1A1402E b323
    /// This native enables the audio flag "TrevorRageIsOverridden" and sets the voice effect to `voiceEffect`
    pub inline fn overrideTrevorRage(voice_effect: [*c]const u8) !void { try invoker.invoke(void, 0x13AD665062541A7E, .{voice_effect}); } // 0x13AD665062541A7E 0x05B9B5CF b323
    pub inline fn resetTrevorRage() !void { try invoker.invoke(void, 0xE78503B10C4314E0, .{}); } // 0xE78503B10C4314E0 0xE80CF0D4 b323
    pub inline fn setPlayerAngry(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEA241BB04110F091, .{ped, toggle}); } // 0xEA241BB04110F091 0x782CA58D b323
    /// Needs another parameter [int p2]. The signature is PED::PLAY_PAIN(Ped ped, int painID, int p1, int p2);
    /// 
    /// Last 2 parameters always seem to be 0.
    /// 
    /// EX: Function.Call(Hash.PLAY_PAIN, TestPed, 6, 0, 0);
    /// 
    /// Known Pain IDs \
    /// ________________________
    /// 
    /// 1 - Doesn't seem to do anything. Does NOT crash the game like previously said. (Latest patch) \
    /// 6 - Scream (Short) \
    /// 7 - Scared Scream (Kinda Long) \
    /// 8 - On Fire
    /// 
    pub inline fn playPain(ped: types.Ped, pain_i_d: c_int, p_1: c_int, p_3: types.Any) !void { try invoker.invoke(void, 0xBC9AE166038A5CEC, .{ped, pain_i_d, p_1, p_3}); } // 0xBC9AE166038A5CEC 0x874BD6CB b323
    pub inline fn releaseWeaponAudio() !void { try invoker.invoke(void, 0xCE4AC0439F607045, .{}); } // 0xCE4AC0439F607045 0x6096504C b323
    /// mode can be any of these:  \
    /// SLOWMO_T1_TRAILER_SMASH \
    /// SLOWMO_T1_RAYFIRE_EXPLOSION \
    /// SLOWMO_PROLOGUE_VAULT \
    /// NIGEL_02_SLOWMO_SETTING \
    /// JSH_EXIT_TUNNEL_SLOWMO \
    /// SLOWMO_BIG_SCORE_JUMP \
    /// SLOWMO_FIB4_TRUCK_SMASH \
    /// SLOWMO_EXTREME_04 \
    /// SLOW_MO_METH_HOUSE_RAYFIRE \
    /// BARRY_02_SLOWMO \
    /// BARRY_01_SLOWMO
    pub inline fn activateAudioSlowmoMode(mode: [*c]const u8) !void { try invoker.invoke(void, 0xD01005D2BA2EB778, .{mode}); } // 0xD01005D2BA2EB778 0x59A3A17D b323
    /// see ACTIVATE_AUDIO_SLOWMO_MODE for modes
    pub inline fn deactivateAudioSlowmoMode(mode: [*c]const u8) !void { try invoker.invoke(void, 0xDDC635D5B3262C56, .{mode}); } // 0xDDC635D5B3262C56 0x0E387BFE b323
    /// Audio List \
    /// gtaforums.com/topic/795622-audio-for-mods/
    /// 
    /// All found occurrences in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/FTeAj4yZ
    pub inline fn setAmbientVoiceName(ped: types.Ped, name: [*c]const u8) !void { try invoker.invoke(void, 0x6C8065A3B780185B, .{ped, name}); } // 0x6C8065A3B780185B 0xBD2EA1A1 b323
    pub inline fn setAmbientVoiceNameHash(ped: types.Ped, hash: types.Hash) !void { try invoker.invoke(void, 0x9A53DED9921DE990, .{ped, hash}); } // 0x9A53DED9921DE990  b463
    pub inline fn getAmbientVoiceNameHash(ped: types.Ped) !types.Hash { return try invoker.invoke(types.Hash, 0x5E203DA2BA15D436, .{ped}); } // 0x5E203DA2BA15D436  b463
    /// Assigns some ambient voice to the ped.
    pub inline fn setPedVoiceFull(ped: types.Ped) !void { try invoker.invoke(void, 0x40CF0D12D142A9E8, .{ped}); } // 0x40CF0D12D142A9E8  b323
    pub inline fn setPedRaceAndVoiceGroup(ped: types.Ped, p_1: c_int, voice_group: types.Hash) !void { try invoker.invoke(void, 0x1B7ABE26CBCBF8C7, .{ped, p_1, voice_group}); } // 0x1B7ABE26CBCBF8C7  b372
    /// From the scripts:
    /// 
    /// AUDIO::SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("PAIGE_PVG")); \
    /// AUDIO::SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("TALINA_PVG")); \
    /// AUDIO::SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("FEMALE_LOST_BLACK_PVG")); \
    /// AUDIO::SET_PED_VOICE_GROUP(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("FEMALE_LOST_WHITE_PVG"));
    pub inline fn setPedVoiceGroup(ped: types.Ped, voice_group_hash: types.Hash) !void { try invoker.invoke(void, 0x7CDC8C3B89F661B3, .{ped, voice_group_hash}); } // 0x7CDC8C3B89F661B3  b323
    /// Dat151RelType == 29
    pub inline fn setPedVoiceGroupFromRaceToPvg(ped: types.Ped, voice_group_hash: types.Hash) !void { try invoker.invoke(void, 0x0BABC1345ABBFB16, .{ped, voice_group_hash}); } // 0x0BABC1345ABBFB16  b2699
    /// BOOL p1: 0 = Female; 1 = Male
    pub inline fn setPedGender(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xA5342D390CDA41D6, .{ped, p_1}); } // 0xA5342D390CDA41D6  b323
    pub inline fn stopCurrentPlayingSpeech(ped: types.Ped) !void { try invoker.invoke(void, 0x7A73D05A607734C7, .{ped}); } // 0x7A73D05A607734C7 0x5B7463F4 b323
    pub inline fn stopCurrentPlayingAmbientSpeech(ped: types.Ped) !void { try invoker.invoke(void, 0xB8BEC0CA6F0EDB0F, .{ped}); } // 0xB8BEC0CA6F0EDB0F 0xBB8E64BF b323
    pub inline fn isAmbientSpeechPlaying(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9072C8B49907BFAD, .{ped}); } // 0x9072C8B49907BFAD 0x1972E8AA b323
    pub inline fn isScriptedSpeechPlaying(p_0: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCC9AA18DCC7084F4, .{p_0}); } // 0xCC9AA18DCC7084F4 0x2C653904 b323
    pub inline fn isAnySpeechPlaying(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x729072355FA39EC9, .{ped}); } // 0x729072355FA39EC9 0x2B74A6D6 b323
    pub inline fn isAnyPositionalSpeechPlaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x30CA2EF91D15ADF8, .{}); } // 0x30CA2EF91D15ADF8  b2189
    /// Checks if the ped can play the speech or has the speech file, p2 is usually false.
    pub inline fn doesContextExistForThisPed(ped: types.Ped, speech_name: [*c]const u8, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x49B99BF3FDA89A7A, .{ped, speech_name, p_2}); } // 0x49B99BF3FDA89A7A 0x8BD5F11E b323
    pub inline fn isPedInCurrentConversation(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x049E937F18F4020C, .{ped}); } // 0x049E937F18F4020C 0x7B2F0743 b323
    /// Sets the ped drunk sounds.  Only works with PLAYER_PED_ID
    /// 
    /// ====================================================
    /// 
    /// As mentioned above, this only sets the drunk sound to ped/player.
    /// 
    /// To give the Ped a drunk effect with drunk walking animation try using SET_PED_MOVEMENT_CLIPSET
    /// 
    /// Below is an example
    /// 
    /// if (!Function.Call<bool>(Hash.HAS_ANIM_SET_LOADED, "move_m@drunk@verydrunk")) \
    ///                 {
    ///                     Function.Call(Hash.REQUEST_ANIM_SET, "move_m@drunk@verydrunk");
    ///                 }
    ///                 Function.Call(Hash.SET_PED_MOVEMENT_CLIPSET, Ped.Handle, "move_m@drunk@verydrunk", 0x3E800000);
    /// 
    /// 
    /// 
    /// And to stop the effect use \
    /// RESET_PED_MOVEMENT_CLIPSET
    pub inline fn setPedIsDrunk(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x95D2D383D5396B8A, .{ped, toggle}); } // 0x95D2D383D5396B8A 0xD2EA77A3 b323
    /// Plays sounds from a ped with chop model. For example it used to play bark or sniff sounds. p1 is always 3 or 4294967295 in decompiled scripts. By a quick disassembling I can assume that this arg is unused. \
    /// This native is works only when you call it on the ped with right model (ac_chop only ?) \
    /// Speech Name can be: CHOP_SNIFF_SEQ CHOP_WHINE CHOP_LICKS_MOUTH CHOP_PANT bark GROWL SNARL BARK_SEQ
    pub inline fn playAnimalVocalization(ped_handle: types.Ped, p_1: c_int, speech_name: [*c]const u8) !void { try invoker.invoke(void, 0xEE066C7006C49C0A, .{ped_handle, p_1, speech_name}); } // 0xEE066C7006C49C0A 0x498849F3 b323
    pub inline fn isAnimalVocalizationPlaying(ped_handle: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC265DF9FB44A9FBD, .{ped_handle}); } // 0xC265DF9FB44A9FBD 0x0CBAF2EF b323
    /// mood can be 0 or 1 (it's not a boolean value!). Effects audio of the animal.
    pub inline fn setAnimalMood(animal: types.Ped, mood: c_int) !void { try invoker.invoke(void, 0xCC97B29285B1DC3B, .{animal, mood}); } // 0xCC97B29285B1DC3B 0x3EA7C6CB b323
    pub inline fn playPedAudioEventAnim(ped_handle: types.Ped, audio_event: [*c]const u8) !void { try invoker.invoke(void, 0xAD2191A6E3543189, .{ped_handle, audio_event}); } // 0xAD2191A6E3543189  b3717
    pub inline fn isMobilePhoneRadioActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB35CE999E8EF317E, .{}); } // 0xB35CE999E8EF317E 0x6E502A5B b323
    pub inline fn setMobilePhoneRadioState(state: windows.BOOL) !void { try invoker.invoke(void, 0xBF286C554784F3DF, .{state}); } // 0xBF286C554784F3DF 0xE1E0ED34 b323
    /// Returns 255 (radio off index) if the function fails.
    pub inline fn getPlayerRadioStationIndex() !c_int { return try invoker.invoke(c_int, 0xE8AF77C4C06ADC93, .{}); } // 0xE8AF77C4C06ADC93 0x1C4946AC b323
    /// Returns active radio station name
    pub inline fn getPlayerRadioStationName() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xF6D733C32076AD03, .{}); } // 0xF6D733C32076AD03 0xD909C107 b323
    /// Converts radio station index to string. Use HUD::GET_FILENAME_FOR_AUDIO_CONVERSATION to get the user-readable text.
    pub inline fn getRadioStationName(radio_station: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xB28ECA15046CA8B9, .{radio_station}); } // 0xB28ECA15046CA8B9 0x3DF493BC b323
    pub inline fn getPlayerRadioStationGenre() !c_int { return try invoker.invoke(c_int, 0xA571991A7FE6CCEB, .{}); } // 0xA571991A7FE6CCEB 0x872CF0EA b323
    pub inline fn isRadioRetuning() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA151A7394A214E65, .{}); } // 0xA151A7394A214E65 0xCF29097B b323
    pub inline fn isRadioFadedOut() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0626A247D2405330, .{}); } // 0x0626A247D2405330 0x815CAE99 b323
    /// Tune Forward...
    pub inline fn setRadioRetuneUp() !void { try invoker.invoke(void, 0xFF266D1D0EB1195D, .{}); } // 0xFF266D1D0EB1195D 0x53DB6994 b323
    /// Tune Backwards...
    pub inline fn setRadioRetuneDown() !void { try invoker.invoke(void, 0xDD6BCF9E94425DF9, .{}); } // 0xDD6BCF9E94425DF9 0xD70ECC80 b323
    /// List of radio stations that are in the wheel, in clockwise order, as of LS Tuners DLC: https://git.io/J8a3k \
    /// An older list including hidden radio stations: https://pastebin.com/Kj9t38KF
    pub inline fn setRadioToStationName(station_name: [*c]const u8) !void { try invoker.invoke(void, 0xC69EDA28699D5107, .{station_name}); } // 0xC69EDA28699D5107 0x7B36E35E b323
    /// List of radio stations that are in the wheel, in clockwise order, as of LS Tuners DLC: https://git.io/J8a3k \
    /// An older list including hidden radio stations: https://pastebin.com/Kj9t38KF
    pub inline fn setVehRadioStation(vehicle: types.Vehicle, radio_station: [*c]const u8) !void { try invoker.invoke(void, 0x1B9C0099CB942AC6, .{vehicle, radio_station}); } // 0x1B9C0099CB942AC6 0xE391F55F b323
    pub inline fn setVehHasNormalRadio(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x3E45765F3FBB582F, .{vehicle}); } // 0x3E45765F3FBB582F  b2372
    pub inline fn isVehicleRadioOn(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0BE4BE946463F917, .{vehicle}); } // 0x0BE4BE946463F917  b505
    pub inline fn setVehForcedRadioThisFrame(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xC1805D05E6D4FE10, .{vehicle}); } // 0xC1805D05E6D4FE10 0x7ABB89D2 b323
    /// Full list of static emitters by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/staticEmitters.json
    pub inline fn setEmitterRadioStation(emitter_name: [*c]const u8, radio_station: [*c]const u8, p_2: types.Any) !void { try invoker.invoke(void, 0xACF57305B12AF907, .{emitter_name, radio_station, p_2}); } // 0xACF57305B12AF907 0x87431585 b323
    /// Example: \
    /// AUDIO::SET_STATIC_EMITTER_ENABLED((Any*)"LOS_SANTOS_VANILLA_UNICORN_01_STAGE", false);    AUDIO::SET_STATIC_EMITTER_ENABLED((Any*)"LOS_SANTOS_VANILLA_UNICORN_02_MAIN_ROOM", false);    AUDIO::SET_STATIC_EMITTER_ENABLED((Any*)"LOS_SANTOS_VANILLA_UNICORN_03_BACK_ROOM", false);
    /// 
    /// This turns off surrounding sounds not connected directly to peds.
    /// 
    /// Full list of static emitters by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/staticEmitters.json
    pub inline fn setStaticEmitterEnabled(emitter_name: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x399D2D3B33F1B8EB, .{emitter_name, toggle}); } // 0x399D2D3B33F1B8EB 0x91F72E92 b323
    /// Full list of static emitters by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/staticEmitters.json
    pub inline fn linkStaticEmitterToEntity(emitter_name: [*c]const u8, entity: types.Entity) !void { try invoker.invoke(void, 0x651D3228960D08AF, .{emitter_name, entity}); } // 0x651D3228960D08AF  b505
    /// Sets radio station by index.
    pub inline fn setRadioToStationIndex(radio_station: c_int) !void { try invoker.invoke(void, 0xA619B168B8A8570F, .{radio_station}); } // 0xA619B168B8A8570F 0x1D82766D b323
    pub inline fn setFrontendRadioActive(active: windows.BOOL) !void { try invoker.invoke(void, 0xF7F26C6E9CC9EBB8, .{active}); } // 0xF7F26C6E9CC9EBB8 0xB1172075 b323
    /// "news" that play on the radio after you've done something in story mode(?)
    pub inline fn unlockMissionNewsStory(news_story: c_int) !void { try invoker.invoke(void, 0xB165AB7C248B2DC1, .{news_story}); } // 0xB165AB7C248B2DC1 0xCCD9ABE4 b323
    pub inline fn isMissionNewsStoryUnlocked(news_story: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x66E49BF55B4B1874, .{news_story}); } // 0x66E49BF55B4B1874 0x27305D37 b323
    pub inline fn getAudibleMusicTrackTextId() !c_int { return try invoker.invoke(c_int, 0x50B196FC9ED6545B, .{}); } // 0x50B196FC9ED6545B 0xA2B88CA7 b323
    pub inline fn playEndCreditsMusic(play: windows.BOOL) !void { try invoker.invoke(void, 0xCD536C4D33DCC900, .{play}); } // 0xCD536C4D33DCC900 0x8E88B3CC b323
    pub inline fn skipRadioForward() !void { try invoker.invoke(void, 0x6DDBBDD98E2E9C25, .{}); } // 0x6DDBBDD98E2E9C25 0x10D36630 b323
    pub inline fn freezeRadioStation(radio_station: [*c]const u8) !void { try invoker.invoke(void, 0x344F393B027E38C3, .{radio_station}); } // 0x344F393B027E38C3 0x286BF543 b323
    pub inline fn unfreezeRadioStation(radio_station: [*c]const u8) !void { try invoker.invoke(void, 0xFC00454CF60B91DD, .{radio_station}); } // 0xFC00454CF60B91DD 0x4D46202C b323
    pub inline fn setRadioAutoUnfreeze(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC1AA9F53CE982990, .{toggle}); } // 0xC1AA9F53CE982990 0xA40196BF b323
    pub inline fn setInitialPlayerStation(radio_station: [*c]const u8) !void { try invoker.invoke(void, 0x88795F13FACDA88D, .{radio_station}); } // 0x88795F13FACDA88D 0x9B069233 b323
    pub inline fn setUserRadioControlEnabled(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x19F21E63AE6EAE4E, .{toggle}); } // 0x19F21E63AE6EAE4E 0x52E054CE b323
    /// Only found this one in the decompiled scripts:
    /// 
    /// AUDIO::SET_RADIO_TRACK("RADIO_03_HIPHOP_NEW", "ARM1_RADIO_STARTS");
    /// 
    pub inline fn setRadioTrack(radio_station: [*c]const u8, radio_track: [*c]const u8) !void { try invoker.invoke(void, 0xB39786F201FEE30B, .{radio_station, radio_track}); } // 0xB39786F201FEE30B 0x76E96212 b323
    pub inline fn setRadioTrackWithStartOffset(radio_station_name: [*c]const u8, mix_name: [*c]const u8, p_2: c_int) !void { try invoker.invoke(void, 0x2CB0075110BE1E56, .{radio_station_name, mix_name, p_2}); } // 0x2CB0075110BE1E56  b1493
    pub inline fn setNextRadioTrack(radio_name: [*c]const u8, radio_track: [*c]const u8, p_2: [*c]const u8, p_3: [*c]const u8) !void { try invoker.invoke(void, 0x55ECF4D13D9903B0, .{radio_name, radio_track, p_2, p_3}); } // 0x55ECF4D13D9903B0  b1868
    pub inline fn setVehicleRadioLoud(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBB6F1CAEC68B0BCE, .{vehicle, toggle}); } // 0xBB6F1CAEC68B0BCE 0x8D9EDD99 b323
    pub inline fn canVehicleReceiveCbRadio(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x032A116663A4D5AC, .{vehicle}); } // 0x032A116663A4D5AC 0xCBA99F4A b323
    pub inline fn setMobileRadioEnabledDuringGameplay(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1098355A16064BB3, .{toggle}); } // 0x1098355A16064BB3 0x990085F0 b323
    pub inline fn doesPlayerVehHaveRadio() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x109697E2FFBAC8A1, .{}); } // 0x109697E2FFBAC8A1 0x46B0C696 b323
    pub inline fn isPlayerVehRadioEnable() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5F43D83FD6738741, .{}); } // 0x5F43D83FD6738741 0x2A3E5E8B b323
    /// can't seem to enable radio on cop cars etc
    pub inline fn setVehicleRadioEnabled(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3B988190C0AA6C0B, .{vehicle, toggle}); } // 0x3B988190C0AA6C0B 0x6F812CAB b323
    pub inline fn setPositionedPlayerVehicleRadioEmitterEnabled(p_0: types.Any) !void { try invoker.invoke(void, 0xDA07819E452FFE8F, .{p_0}); } // 0xDA07819E452FFE8F  b505
    /// Examples:
    /// 
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_KILL_MICHAEL", 1); \
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_KILL_MICHAEL", 1); \
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_KILL_TREVOR", 1); \
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "END_CREDITS_SAVE_MICHAEL_TREVOR", 1); \
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "OFF_ROAD_RADIO_ROCK_LIST", 1); \
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_06_COUNTRY", "MAGDEMO2_RADIO_DINGHY", 1); \
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_16_SILVERLAKE", "SEA_RACE_RADIO_PLAYLIST", 1); \
    /// AUDIO::SET_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK", "OFF_ROAD_RADIO_ROCK_LIST", 1);
    pub inline fn setCustomRadioTrackList(radio_station: [*c]const u8, track_list_name: [*c]const u8, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x4E404A9361F75BB2, .{radio_station, track_list_name, p_2}); } // 0x4E404A9361F75BB2 0x128C3873 b323
    /// 3 calls in the b617d scripts, removed duplicate.
    /// 
    /// AUDIO::CLEAR_CUSTOM_RADIO_TRACK_LIST("RADIO_16_SILVERLAKE"); \
    /// AUDIO::CLEAR_CUSTOM_RADIO_TRACK_LIST("RADIO_01_CLASS_ROCK");
    pub inline fn clearCustomRadioTrackList(radio_station: [*c]const u8) !void { try invoker.invoke(void, 0x1654F24A88A8E3FE, .{radio_station}); } // 0x1654F24A88A8E3FE 0x1D766976 b323
    pub inline fn getNumUnlockedRadioStations() !c_int { return try invoker.invoke(c_int, 0xF1620ECB50E01DE7, .{}); } // 0xF1620ECB50E01DE7 0xCC91FCF5 b323
    pub inline fn findRadioStationIndex(station_name_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x8D67489793FF428B, .{station_name_hash}); } // 0x8D67489793FF428B 0xECA1512F b323
    /// 6 calls in the b617d scripts, removed identical lines:
    /// 
    /// AUDIO::SET_RADIO_STATION_MUSIC_ONLY("RADIO_01_CLASS_ROCK", 1); \
    /// AUDIO::SET_RADIO_STATION_MUSIC_ONLY(AUDIO::GET_RADIO_STATION_NAME(10), 0); \
    /// AUDIO::SET_RADIO_STATION_MUSIC_ONLY(AUDIO::GET_RADIO_STATION_NAME(10), 1);
    pub inline fn setRadioStationMusicOnly(radio_station: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x774BD811F656A122, .{radio_station, toggle}); } // 0x774BD811F656A122 0xB1FF7137 b323
    pub inline fn setRadioFrontendFadeTime(fade_time: f32) !void { try invoker.invoke(void, 0x2C96CDB04FCA358E, .{fade_time}); } // 0x2C96CDB04FCA358E 0xC8B514E2 b323
    /// AUDIO::UNLOCK_RADIO_STATION_TRACK_LIST("RADIO_16_SILVERLAKE", "MIRRORPARK_LOCKED");
    pub inline fn unlockRadioStationTrackList(radio_station: [*c]const u8, track_list_name: [*c]const u8) !void { try invoker.invoke(void, 0x031ACB6ABA18C729, .{radio_station, track_list_name}); } // 0x031ACB6ABA18C729 0xBE998184 b323
    pub inline fn lockRadioStationTrackList(radio_station: [*c]const u8, track_list_name: [*c]const u8) !void { try invoker.invoke(void, 0xFF5E5EA2DCEEACF3, .{radio_station, track_list_name}); } // 0xFF5E5EA2DCEEACF3  b2372
    /// Just a nullsub (i.e. does absolutely nothing) since build 1604.
    pub inline fn updateUnlockableDjRadioTracks(enable_mixes: windows.BOOL) !void { try invoker.invoke(void, 0x47AED84213A47510, .{enable_mixes}); } // 0x47AED84213A47510  b1493
    /// Disables the radio station (hides it from the radio wheel).
    pub inline fn lockRadioStation(radio_station_name: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x477D9DB48F889591, .{radio_station_name, toggle}); } // 0x477D9DB48F889591  b1493
    /// Doesn't have an effect in Story Mode.
    pub inline fn setRadioStationAsFavourite(radio_station: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4CAFEBFA21EC188D, .{radio_station, toggle}); } // 0x4CAFEBFA21EC188D  b2372
    pub inline fn isRadioStationFavourited(radio_station: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2B1784DB08AFEA79, .{radio_station}); } // 0x2B1784DB08AFEA79  b2699
    pub inline fn getNextAudibleBeat(out_1: [*c]f32, out_2: [*c]f32, out_3: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC64A06D939F826F5, .{out_1, out_2, out_3}); } // 0xC64A06D939F826F5  b1493
    /// Changes start time of a tracklist (milliseconds) \
    /// R* uses a random int: MISC::GET_RANDOM_INT_IN_RANGE(0, 13) * 60000)
    pub inline fn forceMusicTrackList(radio_station: [*c]const u8, track_list_name: [*c]const u8, milliseconds: c_int) !void { try invoker.invoke(void, 0x4E0AF9114608257C, .{radio_station, track_list_name, milliseconds}); } // 0x4E0AF9114608257C  b2372
    pub inline fn getCurrentTrackPlayTime(radio_station_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x3E65CDE5215832C1, .{radio_station_name}); } // 0x3E65CDE5215832C1  b1493
    pub inline fn getCurrentTrackSoundName(radio_station_name: [*c]const u8) !types.Hash { return try invoker.invoke(types.Hash, 0x34D66BC058019CE0, .{radio_station_name}); } // 0x34D66BC058019CE0  b1493
    pub inline fn setVehicleMissileWarningEnabled(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF3365489E0DD50F9, .{vehicle, toggle}); } // 0xF3365489E0DD50F9 0x8AFC488D b323
    /// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
    pub inline fn setAmbientZoneState(zone_name: [*c]const u8, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xBDA07E5950085E46, .{zone_name, p_1, p_2}); } // 0xBDA07E5950085E46 0x2849CAC9 b323
    /// This function also has a p2, unknown. Signature AUDIO::CLEAR_AMBIENT_ZONE_STATE(const char* zoneName, bool p1, Any p2);
    /// 
    /// Still needs more research.
    /// 
    /// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
    pub inline fn clearAmbientZoneState(zone_name: [*c]const u8, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x218DD44AAAC964FF, .{zone_name, p_1}); } // 0x218DD44AAAC964FF 0xCDFF3C82 b323
    pub inline fn setAmbientZoneListState(ambient_zone: [*c]const u8, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x9748FA4DE50CCE3E, .{ambient_zone, p_1, p_2}); } // 0x9748FA4DE50CCE3E 0xBF80B412 b323
    pub inline fn clearAmbientZoneListState(ambient_zone: [*c]const u8, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x120C48C614909FA4, .{ambient_zone, p_1}); } // 0x120C48C614909FA4 0x38B9B8D4 b323
    /// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
    pub inline fn setAmbientZoneStatePersistent(ambient_zone: [*c]const u8, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x1D6650420CEC9D3B, .{ambient_zone, p_1, p_2}); } // 0x1D6650420CEC9D3B 0xC1FFB672 b323
    /// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
    pub inline fn setAmbientZoneListStatePersistent(ambient_zone: [*c]const u8, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xF3638DAE8C4045E1, .{ambient_zone, p_1, p_2}); } // 0xF3638DAE8C4045E1 0x5F5A2605 b323
    /// Full list of ambient zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ambientZones.json
    pub inline fn isAmbientZoneEnabled(ambient_zone: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x01E2817A479A7F9B, .{ambient_zone}); } // 0x01E2817A479A7F9B 0xBFABD872 b323
    pub inline fn refreshClosestOceanShoreline() !void { try invoker.invoke(void, 0x5D2BFAAB8D956E0E, .{}); } // 0x5D2BFAAB8D956E0E  b573
    /// All occurrences found in b617d, sorted alphabetically and identical lines removed: 
    /// 
    /// AUDIO::SET_CUTSCENE_AUDIO_OVERRIDE("_AK"); \
    /// AUDIO::SET_CUTSCENE_AUDIO_OVERRIDE("_CUSTOM"); \
    /// AUDIO::SET_CUTSCENE_AUDIO_OVERRIDE("_TOOTHLESS"); \
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn setCutsceneAudioOverride(name: [*c]const u8) !void { try invoker.invoke(void, 0x3B4BF5F0859204D9, .{name}); } // 0x3B4BF5F0859204D9 0xCE1332B7 b323
    pub inline fn setVariableOnSynchSceneAudio(variable_name: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0xBCC29F935ED07688, .{variable_name, value}); } // 0xBCC29F935ED07688 0xD63CF33A b323
    /// Plays the given police radio message.
    /// 
    /// All found occurrences in b617d, sorted alphabetically and identical lines removed: https://pastebin.com/GBnsQ5hr \
    /// Full list of police report names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/policeReportNames.json
    pub inline fn playPoliceReport(name: [*c]const u8, p_1: f32) !c_int { return try invoker.invoke(c_int, 0xDFEBD56D9BD1EB16, .{name, p_1}); } // 0xDFEBD56D9BD1EB16 0x3F277B62 b323
    pub inline fn cancelAllPoliceReports() !void { try invoker.invoke(void, 0xB4F90FAF7670B16F, .{}); } // 0xB4F90FAF7670B16F  b323
    /// Plays the siren sound of a vehicle which is otherwise activated when fastly double-pressing the horn key. \
    /// Only works on vehicles with a police siren.
    pub inline fn blipSiren(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x1B9025BDA76822B6, .{vehicle}); } // 0x1B9025BDA76822B6 0xC0EB6924 b323
    /// Overrides the vehicle's horn hash. \
    /// When changing this hash on a vehicle, it will not return the 'overwritten' hash. It will still always return the default horn hash (same as GET_VEHICLE_DEFAULT_HORN)
    /// 
    /// vehicle - the vehicle whose horn should be overwritten
    pub inline fn overrideVehHorn(vehicle: types.Vehicle, override: windows.BOOL, horn_hash: c_int) !void { try invoker.invoke(void, 0x3CDC1E622CCE0356, .{vehicle, override, horn_hash}); } // 0x3CDC1E622CCE0356 0x2ACAB783 b323
    /// Checks whether the horn of a vehicle is currently played.
    pub inline fn isHornActive(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9D6BFC12B05C6121, .{vehicle}); } // 0x9D6BFC12B05C6121 0x20E2BDD0 b323
    /// Makes pedestrians sound their horn longer, faster and more agressive when they use their horn.
    pub inline fn setAggressiveHorns(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x395BF71085D1B1D9, .{toggle}); } // 0x395BF71085D1B1D9 0x01D6EABE b323
    /// Does nothing (it's a nullsub).
    pub inline fn setRadioPositionAudioMute(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x02E93C796ABD3A97, .{p_0}); } // 0x02E93C796ABD3A97 0x3C395AEE b323
    pub inline fn setVehicleConversationsPersist(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x58BB377BEC7CD5F4, .{p_0, p_1}); } // 0x58BB377BEC7CD5F4 0x8CE63FA1 b323
    pub inline fn setVehicleConversationsPersistNew(p_0: windows.BOOL, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x9BD7BD55E4533183, .{p_0, p_1, p_2}); } // 0x9BD7BD55E4533183  b1290
    pub inline fn isStreamPlaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD11FA52EB849D978, .{}); } // 0xD11FA52EB849D978 0xF1F51A14 b323
    pub inline fn getStreamPlayTime() !c_int { return try invoker.invoke(c_int, 0x4E72BBDBCA58A3DB, .{}); } // 0x4E72BBDBCA58A3DB 0xB4F0AD56 b323
    /// Example: \
    /// AUDIO::LOAD_STREAM("CAR_STEAL_1_PASSBY", "CAR_STEAL_1_SOUNDSET");
    /// 
    /// All found occurrences in the b678d decompiled scripts: https://pastebin.com/3rma6w5w
    /// 
    /// Stream names often ends with "_MASTER", "_SMALL" or "_STREAM". Also "_IN", "_OUT" and numbers.   
    /// 
    /// soundSet is often set to 0 in the scripts. These are common to end the soundSets: "_SOUNDS", "_SOUNDSET" and numbers.
    /// 
    /// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
    pub inline fn loadStream(stream_name: [*c]const u8, sound_set: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1F1F957154EC51DF, .{stream_name, sound_set}); } // 0x1F1F957154EC51DF 0x0D89599D b323
    /// Example: \
    /// AUDIO::LOAD_STREAM_WITH_START_OFFSET("STASH_TOXIN_STREAM", 2400, "FBI_05_SOUNDS");
    /// 
    /// Only called a few times in the scripts.
    /// 
    /// Full list of audio / sound names by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/soundNames.json
    pub inline fn loadStreamWithStartOffset(stream_name: [*c]const u8, start_offset: c_int, sound_set: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x59C16B79F53B3712, .{stream_name, start_offset, sound_set}); } // 0x59C16B79F53B3712 0xE5B5745C b323
    pub inline fn playStreamFromPed(ped: types.Ped) !void { try invoker.invoke(void, 0x89049DD63C08B5D1, .{ped}); } // 0x89049DD63C08B5D1 0xA1D7FABE b323
    pub inline fn playStreamFromVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xB70374A758007DFA, .{vehicle}); } // 0xB70374A758007DFA 0xF8E4BDA2 b323
    /// Used with AUDIO::LOAD_STREAM
    /// 
    /// Example from finale_heist2b.c4: \
    /// TASK::TASK_SYNCHRONIZED_SCENE(l_4C8[2/*14*/], l_4C8[2/*14*/]._f7, l_30A, "push_out_vault_l", 4.0, -1.5, 5, 713, 4.0, 0); \
    ///                     PED::SET_SYNCHRONIZED_SCENE_PHASE(l_4C8[2/*14*/]._f7, 0.0);
    ///                     PED::FORCE_PED_AI_AND_ANIMATION_UPDATE(l_4C8[2/*14*/], 0, 0);
    ///                     PED::SET_PED_COMBAT_ATTRIBUTES(l_4C8[2/*14*/], 38, 1);
    ///                     PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(l_4C8[2/*14*/], 1);
    ///                     if (AUDIO::LOAD_STREAM("Gold_Cart_Push_Anim_01", "BIG_SCORE_3B_SOUNDS")) {
    ///                         AUDIO::PLAY_STREAM_FROM_OBJECT(l_36F[0/*1*/]);
    ///                     }
    pub inline fn playStreamFromObject(object: types.Object) !void { try invoker.invoke(void, 0xEBAA9B64D76356FD, .{object}); } // 0xEBAA9B64D76356FD 0xC5266BF7 b323
    pub inline fn playStreamFrontend() !void { try invoker.invoke(void, 0x58FCE43488F9F5F4, .{}); } // 0x58FCE43488F9F5F4 0x2C2A16BC b323
    pub inline fn playStreamFromPosition(vec: types.Vector3) !void { try invoker.invoke(void, 0x21442F412E8DE56B, .{vec.x, vec.y, vec.z}); } // 0x21442F412E8DE56B 0x6FE5D865 b323
    pub inline fn stopStream() !void { try invoker.invoke(void, 0xA4718A1419D18151, .{}); } // 0xA4718A1419D18151 0xD1E364DE b323
    pub inline fn stopPedSpeaking(ped: types.Ped, shaking: windows.BOOL) !void { try invoker.invoke(void, 0x9D64D7405520E3D3, .{ped, shaking}); } // 0x9D64D7405520E3D3 0xFF92B49D b323
    pub inline fn blockAllSpeechFromPed(ped: types.Ped, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xF8AD2EED7C47E8FE, .{ped, p_1, p_2}); } // 0xF8AD2EED7C47E8FE  b1734
    pub inline fn stopPedSpeakingSynced(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xAB6781A5F3101470, .{ped, p_1}); } // 0xAB6781A5F3101470  b1868
    pub inline fn disablePedPainAudio(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA9A41C1E940FB0E8, .{ped, toggle}); } // 0xA9A41C1E940FB0E8 0x3B8E2D5F b323
    /// Common in the scripts: \
    /// AUDIO::IS_AMBIENT_SPEECH_DISABLED(PLAYER::PLAYER_PED_ID());
    pub inline fn isAmbientSpeechDisabled(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x932C2D096A2C3FFF, .{ped}); } // 0x932C2D096A2C3FFF 0x109D1F89 b323
    pub inline fn blockSpeechContextGroup(p_0: [*c]const u8, p_1: c_int) !void { try invoker.invoke(void, 0xA8A7D434AFB4B97B, .{p_0, p_1}); } // 0xA8A7D434AFB4B97B  b1493
    pub inline fn unblockSpeechContextGroup(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x2ACABED337622DF2, .{p_0}); } // 0x2ACABED337622DF2  b1493
    pub inline fn setSirenWithNoDriver(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1FEF0683B96EBCF2, .{vehicle, toggle}); } // 0x1FEF0683B96EBCF2 0x77182D58 b323
    pub inline fn setSirenBypassMpDriverCheck(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF584CF8529B51434, .{vehicle, toggle}); } // 0xF584CF8529B51434  b2372
    pub inline fn triggerSirenAudio(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x66C3FB05206041BA, .{vehicle}); } // 0x66C3FB05206041BA  b1290
    pub inline fn setHornPermanentlyOn(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x9C11908013EA4715, .{vehicle}); } // 0x9C11908013EA4715 0xDE8BA3CD b323
    pub inline fn setHornEnabled(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x76D683C108594D0E, .{vehicle, toggle}); } // 0x76D683C108594D0E 0x6EB92D05 b323
    pub inline fn setAudioVehiclePriority(vehicle: types.Vehicle, p_1: types.Any) !void { try invoker.invoke(void, 0xE5564483E407F914, .{vehicle, p_1}); } // 0xE5564483E407F914 0x271A9766 b323
    pub inline fn setHornPermanentlyOnTime(vehicle: types.Vehicle, time: f32) !void { try invoker.invoke(void, 0x9D3AF56E94C9AE98, .{vehicle, time}); } // 0x9D3AF56E94C9AE98 0x2F0A16D1 b323
    pub inline fn useSirenAsHorn(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFA932DE350266EF8, .{vehicle, toggle}); } // 0xFA932DE350266EF8 0xC6BC16F3 b323
    /// This native sets the audio of the specified vehicle to the audioName (p1).
    /// 
    /// Use the audioNameHash found in vehicles.meta
    /// 
    /// Example: \
    /// _SET_VEHICLE_AUDIO(veh, "ADDER"); \
    /// The selected vehicle will now have the audio of the Adder.
    pub inline fn forceUseAudioGameObject(vehicle: types.Vehicle, audio_name: [*c]const u8) !void { try invoker.invoke(void, 0x4F0C413926060B38, .{vehicle, audio_name}); } // 0x4F0C413926060B38 0x33B0B007 b323
    pub inline fn preloadVehicleAudioBank(vehicle_model: types.Hash) !void { try invoker.invoke(void, 0xCA4CEA6AE0000A7E, .{vehicle_model}); } // 0xCA4CEA6AE0000A7E  b1180
    pub inline fn setVehicleStartupRevSound(vehicle: types.Vehicle, p_1: [*c]const u8, p_2: [*c]const u8) !void { try invoker.invoke(void, 0xF1F8157B8C3F171C, .{vehicle, p_1, p_2}); } // 0xF1F8157B8C3F171C 0x1C0C5E4C b323
    pub inline fn resetVehicleStartupRevSound(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xD2DCCD8E16E20997, .{vehicle}); } // 0xD2DCCD8E16E20997  b323
    pub inline fn setVehicleForceReverseWarning(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x97FFB4ADEED08066, .{p_0, p_1}); } // 0x97FFB4ADEED08066  b2372
    pub inline fn isVehicleAudiblyDamaged(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5DB8010EE71FDEF2, .{vehicle}); } // 0x5DB8010EE71FDEF2 0x6E660D3F b323
    pub inline fn setVehicleAudioEngineDamageFactor(vehicle: types.Vehicle, damage_factor: f32) !void { try invoker.invoke(void, 0x59E7B488451F4D3A, .{vehicle, damage_factor}); } // 0x59E7B488451F4D3A 0x23BE6432 b323
    /// intensity: 0.0f - 1.0f, only used once with 1.0f in R* Scripts (nigel2) \
    /// Makes an engine rattling noise when you decelerate, you need to be going faster to hear lower values
    pub inline fn setVehicleAudioBodyDamageFactor(vehicle: types.Vehicle, intensity: f32) !void { try invoker.invoke(void, 0x01BB4D577D38BD9E, .{vehicle, intensity}); } // 0x01BB4D577D38BD9E 0xE81FAC68 b323
    /// Called together with SET_VEHICLE_TYRES_CAN_BURST
    pub inline fn forceVehicleEngineSynth_(vehicle: types.Vehicle, force: windows.BOOL) !void { try invoker.invoke(void, 0xEB7D0E1FCC8FE17A, .{vehicle, force}); } // 0xEB7D0E1FCC8FE17A  b3258
    pub inline fn enableVehicleFanbeltDamage(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1C073274E065C6D2, .{vehicle, toggle}); } // 0x1C073274E065C6D2 0x9365E042 b323
    pub inline fn enableVehicleExhaustPops(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2BE4BC731D039D5A, .{vehicle, toggle}); } // 0x2BE4BC731D039D5A 0x2A60A90E b323
    /// SET_VEHICLE_BOOST_ACTIVE(vehicle, 1, 0); \
    /// SET_VEHICLE_BOOST_ACTIVE(vehicle, 0, 0); 
    /// 
    /// Will give a boost-soundeffect.
    pub inline fn setVehicleBoostActive(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4A04DE7CAB2739A1, .{vehicle, toggle}); } // 0x4A04DE7CAB2739A1 0x072F15F2 b323
    pub inline fn setPlayerVehicleAlarmAudioActive(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6FDDAD856E36988A, .{vehicle, toggle}); } // 0x6FDDAD856E36988A 0x934BE749 b323
    pub inline fn setScriptUpdateDoorAudio(door_hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x06C0023BED16DD6B, .{door_hash, toggle}); } // 0x06C0023BED16DD6B 0xE61110A2 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn playVehicleDoorOpenSound(vehicle: types.Vehicle, door_id: c_int) !void { try invoker.invoke(void, 0x3A539D52857EA82D, .{vehicle, door_id}); } // 0x3A539D52857EA82D 0x84930330 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn playVehicleDoorCloseSound(vehicle: types.Vehicle, door_id: c_int) !void { try invoker.invoke(void, 0x62A456AA4769EF34, .{vehicle, door_id}); } // 0x62A456AA4769EF34 0xBA2CF407 b323
    /// Works for planes only.
    pub inline fn enableStallWarningSounds(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC15907D667F7CFB2, .{vehicle, toggle}); } // 0xC15907D667F7CFB2 0x563B635D b323
    pub inline fn enableDragRaceStationaryWarningSounds_(vehicle: types.Vehicle, enable: windows.BOOL) !void { try invoker.invoke(void, 0xBEFB80290414FD4F, .{vehicle, enable}); } // 0xBEFB80290414FD4F  b3095
    /// Hardcoded to return 1
    pub inline fn isGameInControlOfMusic() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6D28DC1671E334FD, .{}); } // 0x6D28DC1671E334FD 0x7643170D b323
    pub inline fn setGpsActive(active: windows.BOOL) !void { try invoker.invoke(void, 0x3BD3F52BA9B1E4E8, .{active}); } // 0x3BD3F52BA9B1E4E8 0x0FC3379A b323
    /// Called 38 times in the scripts. There are 5 different audioNames used. \
    ///  One unknown removed below.
    /// 
    /// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("DEAD"); \
    /// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("FRANKLIN_BIG_01"); \
    /// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("GENERIC_FAILED"); \
    /// AUDIO::PLAY_MISSION_COMPLETE_AUDIO("TREVOR_SMALL_01");
    pub inline fn playMissionCompleteAudio(audio_name: [*c]const u8) !void { try invoker.invoke(void, 0xB138AAB8A70D3C69, .{audio_name}); } // 0xB138AAB8A70D3C69 0x3033EA1D b323
    pub inline fn isMissionCompletePlaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x19A30C23F5827F8A, .{}); } // 0x19A30C23F5827F8A 0x939982A1 b323
    pub inline fn isMissionCompleteReadyForUi() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6F259F82D873B8B8, .{}); } // 0x6F259F82D873B8B8 0xCBE09AEC b323
    pub inline fn blockDeathJingle(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF154B8D1775B2DEC, .{toggle}); } // 0xF154B8D1775B2DEC 0xD2858D8A b323
    /// Used to prepare a scene where the surrounding sound is muted or a bit changed. This does not play any sound.
    /// 
    /// List of all usable scene names found in b617d. Sorted alphabetically and identical names removed: https://pastebin.com/MtM9N9CC \
    /// Full list of audio scene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/audioSceneNames.json
    pub inline fn startAudioScene(scene: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x013A80FC08F6E4F2, .{scene}); } // 0x013A80FC08F6E4F2 0xE48D757B b323
    /// Full list of audio scene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/audioSceneNames.json
    pub inline fn stopAudioScene(scene: [*c]const u8) !void { try invoker.invoke(void, 0xDFE8422B3B94E688, .{scene}); } // 0xDFE8422B3B94E688 0xA08D8C58 b323
    pub inline fn stopAudioScenes() !void { try invoker.invoke(void, 0xBAC7FC81A75EC1A1, .{}); } // 0xBAC7FC81A75EC1A1 0xF6C7342A b323
    /// Full list of audio scene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/audioSceneNames.json
    pub inline fn isAudioSceneActive(scene: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB65B60556E2A9225, .{scene}); } // 0xB65B60556E2A9225 0xACBED05C b323
    /// Full list of audio scene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/audioSceneNames.json
    pub inline fn setAudioSceneVariable(scene: [*c]const u8, variable: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0xEF21A9EF089A2668, .{scene, variable, value}); } // 0xEF21A9EF089A2668 0x19BB3CE8 b323
    pub inline fn setAudioScriptCleanupTime(time: c_int) !void { try invoker.invoke(void, 0xA5F377B175A699C5, .{time}); } // 0xA5F377B175A699C5 0xE812925D b323
    /// All found occurrences in b678d: \
    /// https://pastebin.com/ceu67jz8
    pub inline fn addEntityToAudioMixGroup(entity: types.Entity, group_name: [*c]const u8, p_2: f32) !void { try invoker.invoke(void, 0x153973AB99FE8980, .{entity, group_name, p_2}); } // 0x153973AB99FE8980 0x2BC93264 b323
    pub inline fn removeEntityFromAudioMixGroup(entity: types.Entity, p_1: f32) !void { try invoker.invoke(void, 0x18EB48CFC41F2EA0, .{entity, p_1}); } // 0x18EB48CFC41F2EA0 0x308ED0EC b323
    pub inline fn audioIsMusicPlaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x845FFC3A4FEEFA3E, .{}); } // 0x845FFC3A4FEEFA3E  b323
    /// This is an alias of AUDIO_IS_MUSIC_PLAYING.
    pub inline fn audioIsScriptedMusicPlaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2DD39BF3E2F9C47F, .{}); } // 0x2DD39BF3E2F9C47F  b463
    /// All music event names found in the b617d scripts: https://pastebin.com/GnYt0R3P \
    /// Full list of music event names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/musicEventNames.json
    pub inline fn prepareMusicEvent(event_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1E5185B72EF5158A, .{event_name}); } // 0x1E5185B72EF5158A 0x534A5C1C b323
    /// All music event names found in the b617d scripts: https://pastebin.com/GnYt0R3P \
    /// Full list of music event names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/musicEventNames.json
    pub inline fn cancelMusicEvent(event_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5B17A90291133DA5, .{event_name}); } // 0x5B17A90291133DA5 0x89FF942D b323
    /// List of all usable event names found in b617d used with this native. Sorted alphabetically and identical names removed: https://pastebin.com/RzDFmB1W
    /// 
    /// All music event names found in the b617d scripts: https://pastebin.com/GnYt0R3P \
    /// Full list of music event names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/musicEventNames.json
    pub inline fn triggerMusicEvent(event_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x706D57B0F50DA710, .{event_name}); } // 0x706D57B0F50DA710 0xB6094948 b323
    pub inline fn isMusicOneshotPlaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA097AB275061FB21, .{}); } // 0xA097AB275061FB21 0x2705C4D5 b323
    pub inline fn getMusicPlaytime() !c_int { return try invoker.invoke(c_int, 0xE7A0D23DC414507B, .{}); } // 0xE7A0D23DC414507B 0xD633C809 b323
    pub inline fn setGlobalRadioSignalLevel(p_0: types.Any) !void { try invoker.invoke(void, 0x159B7318403A1CD8, .{p_0}); } // 0x159B7318403A1CD8  b1103
    pub inline fn recordBrokenGlass(vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0xFBE20329593DEC9D, .{vec.x, vec.y, vec.z, radius}); } // 0xFBE20329593DEC9D 0x53FC3FEC b323
    pub inline fn clearAllBrokenGlass() !void { try invoker.invoke(void, 0xB32209EFFDC04913, .{}); } // 0xB32209EFFDC04913 0xE6B033BF b323
    pub inline fn scriptOverridesWindElevation(p_0: windows.BOOL, p_1: types.Any) !void { try invoker.invoke(void, 0x70B8EC8FC108A634, .{p_0, p_1}); } // 0x70B8EC8FC108A634 0x95050CAD b323
    pub inline fn setPedWallaDensity(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0x149AEE66F0CB3A99, .{p_0, p_1}); } // 0x149AEE66F0CB3A99 0xE64F97A0 b323
    pub inline fn setPedInteriorWallaDensity(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0x8BF907833BE275DE, .{p_0, p_1}); } // 0x8BF907833BE275DE 0x2CD26D69 b323
    pub inline fn forcePedPanicWalla() !void { try invoker.invoke(void, 0x062D5EAD4DA2FA6A, .{}); } // 0x062D5EAD4DA2FA6A 0xD87AF337 b323
    /// Example:
    /// 
    /// bool prepareAlarm = AUDIO::PREPARE_ALARM("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS"); \
    /// Full list of alarm names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/alarmSounds.json
    pub inline fn prepareAlarm(alarm_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9D74AE343DB65533, .{alarm_name}); } // 0x9D74AE343DB65533 0x084932E8 b323
    /// Example:
    /// 
    /// This will start the alarm at Fort Zancudo.
    /// 
    /// AUDIO::START_ALARM("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS", 1);
    /// 
    /// First parameter (char) is the name of the alarm. \
    /// Second parameter (bool) is unknown, it does not seem to make a difference if this one is 0 or 1.
    /// 
    /// ----------
    /// 
    /// It DOES make a difference but it has to do with the duration or something I dunno yet
    /// 
    /// ----------
    /// 
    ///  Found in the b617d scripts:
    /// 
    ///  AUDIO::START_ALARM("AGENCY_HEIST_FIB_TOWER_ALARMS", 0); \
    ///  AUDIO::START_ALARM("AGENCY_HEIST_FIB_TOWER_ALARMS_UPPER", 1); \
    ///  AUDIO::START_ALARM("AGENCY_HEIST_FIB_TOWER_ALARMS_UPPER_B", 0); \
    ///  AUDIO::START_ALARM("BIG_SCORE_HEIST_VAULT_ALARMS", a_0); \
    ///  AUDIO::START_ALARM("FBI_01_MORGUE_ALARMS", 1); \
    ///  AUDIO::START_ALARM("FIB_05_BIOTECH_LAB_ALARMS", 0); \
    ///  AUDIO::START_ALARM("JEWEL_STORE_HEIST_ALARMS", 0); \
    ///  AUDIO::START_ALARM("PALETO_BAY_SCORE_ALARM", 1); \
    ///  AUDIO::START_ALARM("PALETO_BAY_SCORE_CHICKEN_FACTORY_ALARM", 0); \
    ///  AUDIO::START_ALARM("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS", 1); \
    ///  AUDIO::START_ALARM("PORT_OF_LS_HEIST_SHIP_ALARMS", 0); \
    ///  AUDIO::START_ALARM("PRISON_ALARMS", 0); \
    ///  AUDIO::START_ALARM("PROLOGUE_VAULT_ALARMS", 0); \
    /// Full list of alarm names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/alarmSounds.json
    pub inline fn startAlarm(alarm_name: [*c]const u8, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x0355EF116C4C97B2, .{alarm_name, p_2}); } // 0x0355EF116C4C97B2 0x703F524B b323
    /// Example:
    /// 
    /// This will stop the alarm at Fort Zancudo.
    /// 
    /// AUDIO::STOP_ALARM("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS", 1);
    /// 
    /// First parameter (char) is the name of the alarm. \
    /// Second parameter (bool) has to be true (1) to have any effect. \
    /// Full list of alarm names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/alarmSounds.json
    pub inline fn stopAlarm(alarm_name: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA1CADDCD98415A41, .{alarm_name, toggle}); } // 0xA1CADDCD98415A41 0xF987BE8C b323
    pub inline fn stopAllAlarms(stop: windows.BOOL) !void { try invoker.invoke(void, 0x2F794A877ADD4C92, .{stop}); } // 0x2F794A877ADD4C92 0xC3CB9DC6 b323
    /// Example:
    /// 
    /// bool playing = AUDIO::IS_ALARM_PLAYING("PORT_OF_LS_HEIST_FORT_ZANCUDO_ALARMS"); \
    /// Full list of alarm names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/alarmSounds.json
    pub inline fn isAlarmPlaying(alarm_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x226435CB96CCFC8C, .{alarm_name}); } // 0x226435CB96CCFC8C 0x9D8E1D23 b323
    /// Returns hash of default vehicle horn
    /// 
    /// Hash is stored in audVehicleAudioEntity
    pub inline fn getVehicleDefaultHorn(vehicle: types.Vehicle) !types.Hash { return try invoker.invoke(types.Hash, 0x02165D55000219AC, .{vehicle}); } // 0x02165D55000219AC 0xE84ABC19 b323
    pub inline fn getVehicleDefaultHornIgnoreMods(vehicle: types.Vehicle) !types.Hash { return try invoker.invoke(types.Hash, 0xACB5DCCA1EC76840, .{vehicle}); } // 0xACB5DCCA1EC76840 0xFD4B5B3B b323
    pub inline fn resetPedAudioFlags(ped: types.Ped) !void { try invoker.invoke(void, 0xF54BB7B61036F335, .{ped}); } // 0xF54BB7B61036F335 0xDF720C86 b323
    /// Enables/disables ped's "loud" footstep sound.
    pub inline fn setPedFootstepsEventsEnabled(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0653B735BFBDFE87, .{ped, toggle}); } // 0x0653B735BFBDFE87  b1493
    /// Enables/disables ped's "quiet" footstep sound.
    pub inline fn setPedClothEventsEnabled(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x29DA3CA8D8B2692D, .{ped, toggle}); } // 0x29DA3CA8D8B2692D  b1493
    /// Sets audio flag "OverridePlayerGroundMaterial"
    pub inline fn overridePlayerGroundMaterial(hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD2CC78CD3D0B50F9, .{hash, toggle}); } // 0xD2CC78CD3D0B50F9 0xC307D531 b323
    pub inline fn useFootstepScriptSweeteners(ped: types.Ped, p_1: windows.BOOL, hash: types.Hash) !void { try invoker.invoke(void, 0xBF4DC1784BE94DFA, .{ped, p_1, hash}); } // 0xBF4DC1784BE94DFA 0xD99E275B b323
    /// Sets audio flag "OverrideMicrophoneSettings"
    pub inline fn overrideMicrophoneSettings(hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x75773E11BA459E90, .{hash, toggle}); } // 0x75773E11BA459E90  b323
    pub inline fn freezeMicrophone() !void { try invoker.invoke(void, 0xD57AAAE0E2214D11, .{}); } // 0xD57AAAE0E2214D11 0x2B9D91E8 b323
    /// If value is set to true, and ambient siren sound will be played. \
    /// Appears to enable/disable an audio flag.
    pub inline fn distantCopCarSirens(value: windows.BOOL) !void { try invoker.invoke(void, 0x552369F549563AD5, .{value}); } // 0x552369F549563AD5 0x13EB5861 b323
    pub inline fn setSirenCanBeControlledByAudio(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x43FA0DFC5DF87815, .{vehicle, p_1}); } // 0x43FA0DFC5DF87815 0x7BED1872 b323
    pub inline fn enableStuntJumpAudio() !void { try invoker.invoke(void, 0xB81CF134AEB56FFB, .{}); } // 0xB81CF134AEB56FFB  b791
    /// Possible flag names: \
    /// "ActivateSwitchWheelAudio" \
    /// "AllowAmbientSpeechInSlowMo" \
    /// "AllowCutsceneOverScreenFade" \
    /// "AllowForceRadioAfterRetune" \
    /// "AllowPainAndAmbientSpeechToPlayDuringCutscene" \
    /// "AllowPlayerAIOnMission" \
    /// "AllowPoliceScannerWhenPlayerHasNoControl" \
    /// "AllowRadioDuringSwitch" \
    /// "AllowRadioOverScreenFade" \
    /// "AllowScoreAndRadio" \
    /// "AllowScriptedSpeechInSlowMo" \
    /// "AvoidMissionCompleteDelay" \
    /// "DisableAbortConversationForDeathAndInjury" \
    /// "DisableAbortConversationForRagdoll" \
    /// "DisableBarks" \
    /// "DisableFlightMusic" \
    /// "DisableReplayScriptStreamRecording" \
    /// "EnableHeadsetBeep" \
    /// "ForceConversationInterrupt" \
    /// "ForceSeamlessRadioSwitch" \
    /// "ForceSniperAudio" \
    /// "FrontendRadioDisabled" \
    /// "HoldMissionCompleteWhenPrepared" \
    /// "IsDirectorModeActive" \
    /// "IsPlayerOnMissionForSpeech" \
    /// "ListenerReverbDisabled" \
    /// "LoadMPData" \
    /// "MobileRadioInGame" \
    /// "OnlyAllowScriptTriggerPoliceScanner" \
    /// "PlayMenuMusic" \
    /// "PoliceScannerDisabled" \
    /// "ScriptedConvListenerMaySpeak" \
    /// "SpeechDucksScore" \
    /// "SuppressPlayerScubaBreathing" \
    /// "WantedMusicDisabled" \
    /// "WantedMusicOnMission"
    /// 
    /// ------------------------------- \
    /// No added flag names between b393d and b573d, including b573d.
    /// 
    /// #######################################################################
    /// 
    /// "IsDirectorModeActive" is an audio flag which will allow you to play speech infinitely without any pauses like in Director Mode.
    /// 
    /// -----------------------------------------------------------------------
    /// 
    /// All flag IDs and hashes:
    /// 
    /// ID: 00 | Hash: 0x0FED7A7F \
    /// ID: 01 | Hash: 0x20A7858F \
    /// ID: 02 | Hash: 0xA11C2259 \
    /// ID: 03 | Hash: 0x08DE4700 \
    /// ID: 04 | Hash: 0x989F652F \
    /// ID: 05 | Hash: 0x3C9E76BA \
    /// ID: 06 | Hash: 0xA805FEB0 \
    /// ID: 07 | Hash: 0x4B94EA26 \
    /// ID: 08 | Hash: 0x803ACD34 \
    /// ID: 09 | Hash: 0x7C741226 \
    /// ID: 10 | Hash: 0x31DB9EBD \
    /// ID: 11 | Hash: 0xDF386F18 \
    /// ID: 12 | Hash: 0x669CED42 \
    /// ID: 13 | Hash: 0x51F22743 \
    /// ID: 14 | Hash: 0x2052B35C \
    /// ID: 15 | Hash: 0x071472DC \
    /// ID: 16 | Hash: 0xF9928BCC \
    /// ID: 17 | Hash: 0x7ADBDD48 \
    /// ID: 18 | Hash: 0xA959BA1A \
    /// ID: 19 | Hash: 0xBBE89B60 \
    /// ID: 20 | Hash: 0x87A08871 \
    /// ID: 21 | Hash: 0xED1057CE \
    /// ID: 22 | Hash: 0x1584AD7A \
    /// ID: 23 | Hash: 0x8582CFCB \
    /// ID: 24 | Hash: 0x7E5E2FB0 \
    /// ID: 25 | Hash: 0xAE4F72DB \
    /// ID: 26 | Hash: 0x5D16D1FA \
    /// ID: 27 | Hash: 0x06B2F4B8 \
    /// ID: 28 | Hash: 0x5D4CDC96 \
    /// ID: 29 | Hash: 0x8B5A48BA \
    /// ID: 30 | Hash: 0x98FBD539 \
    /// ID: 31 | Hash: 0xD8CB0473 \
    /// ID: 32 | Hash: 0x5CBB4874 \
    /// ID: 33 | Hash: 0x2E9F93A9 \
    /// ID: 34 | Hash: 0xD93BEA86 \
    /// ID: 35 | Hash: 0x92109B7D \
    /// ID: 36 | Hash: 0xB7EC9E4D \
    /// ID: 37 | Hash: 0xCABDBB1D \
    /// ID: 38 | Hash: 0xB3FD4A52 \
    /// ID: 39 | Hash: 0x370D94E5 \
    /// ID: 40 | Hash: 0xA0F7938F \
    /// ID: 41 | Hash: 0xCBE1CE81 \
    /// ID: 42 | Hash: 0xC27F1271 \
    /// ID: 43 | Hash: 0x9E3258EB \
    /// ID: 44 | Hash: 0x551CDA5B \
    /// ID: 45 | Hash: 0xCB6D663C \
    /// ID: 46 | Hash: 0x7DACE87F \
    /// ID: 47 | Hash: 0xF9DE416F \
    /// ID: 48 | Hash: 0x882E6E9E \
    /// ID: 49 | Hash: 0x16B447E7 \
    /// ID: 50 | Hash: 0xBD867739 \
    /// ID: 51 | Hash: 0xA3A58604 \
    /// ID: 52 | Hash: 0x7E046BBC \
    /// ID: 53 | Hash: 0xD95FDB98 \
    /// ID: 54 | Hash: 0x5842C0ED \
    /// ID: 55 | Hash: 0x285FECC6 \
    /// ID: 56 | Hash: 0x9351AC43 \
    /// ID: 57 | Hash: 0x50032E75 \
    /// ID: 58 | Hash: 0xAE6D0D59 \
    /// ID: 59 | Hash: 0xD6351785 \
    /// ID: 60 | Hash: 0xD25D71BC \
    /// ID: 61 | Hash: 0x1F7F6423 \
    /// ID: 62 | Hash: 0xE24C3AA6 \
    /// ID: 63 | Hash: 0xBFFDD2B7
    pub inline fn setAudioFlag(flag_name: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB9EFD5C25018725A, .{flag_name, toggle}); } // 0xB9EFD5C25018725A 0x1C09C9E0 b323
    /// p1 is always 0 in the scripts
    pub inline fn prepareSynchronizedAudioEvent(audio_event: [*c]const u8, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC7ABCACA4985A766, .{audio_event, p_1}); } // 0xC7ABCACA4985A766 0xE1D91FD0 b323
    pub inline fn prepareSynchronizedAudioEventForScene(scene_i_d: c_int, audio_event: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x029FE7CD1B7E2E75, .{scene_i_d, audio_event}); } // 0x029FE7CD1B7E2E75 0x7652DD49 b323
    pub inline fn playSynchronizedAudioEvent(scene_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8B2FD4560E55DD2D, .{scene_i_d}); } // 0x8B2FD4560E55DD2D 0x507F3241 b323
    pub inline fn stopSynchronizedAudioEvent(scene_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x92D6A88E64A94430, .{scene_i_d}); } // 0x92D6A88E64A94430 0xADEED2B4 b323
    pub inline fn initSynchSceneAudioWithPosition(audio_event: [*c]const u8, vec: types.Vector3) !void { try invoker.invoke(void, 0xC8EDE9BDBCCBA6D4, .{audio_event, vec.x, vec.y, vec.z}); } // 0xC8EDE9BDBCCBA6D4 0x55A21772 b323
    pub inline fn initSynchSceneAudioWithEntity(audio_event: [*c]const u8, entity: types.Entity) !void { try invoker.invoke(void, 0x950A154B8DAB6185, .{audio_event, entity}); } // 0x950A154B8DAB6185 0xA17F9AB0 b323
    /// Needs to be called every frame. \
    /// Audio mode to apply this frame: https://alloc8or.re/gta5/doc/enums/audSpecialEffectMode.txt
    pub inline fn setAudioSpecialEffectMode(mode: c_int) !void { try invoker.invoke(void, 0x12561FCBB62D5B9C, .{mode}); } // 0x12561FCBB62D5B9C 0x62B43677 b323
    /// Found in the b617d scripts, duplicates removed:  
    /// 
    /// AUDIO::SET_PORTAL_SETTINGS_OVERRIDE("V_CARSHOWROOM_PS_WINDOW_UNBROKEN", "V_CARSHOWROOM_PS_WINDOW_BROKEN");
    /// 
    ///  AUDIO::SET_PORTAL_SETTINGS_OVERRIDE("V_CIA_PS_WINDOW_UNBROKEN", "V_CIA_PS_WINDOW_BROKEN");
    /// 
    ///  AUDIO::SET_PORTAL_SETTINGS_OVERRIDE("V_DLC_HEIST_APARTMENT_DOOR_CLOSED", "V_DLC_HEIST_APARTMENT_DOOR_OPEN");
    /// 
    ///  AUDIO::SET_PORTAL_SETTINGS_OVERRIDE("V_FINALEBANK_PS_VAULT_INTACT", "V_FINALEBANK_PS_VAULT_BLOWN");
    /// 
    ///  AUDIO::SET_PORTAL_SETTINGS_OVERRIDE("V_MICHAEL_PS_BATHROOM_WITH_WINDOW", "V_MICHAEL_PS_BATHROOM_WITHOUT_WINDOW");
    pub inline fn setPortalSettingsOverride(p_0: [*c]const u8, p_1: [*c]const u8) !void { try invoker.invoke(void, 0x044DBAD7A7FA2BE5, .{p_0, p_1}); } // 0x044DBAD7A7FA2BE5 0x8AD670EC b323
    pub inline fn setIndividualPortalSettingsOverride(interior_name_hash: types.Hash, room_index: c_int, door_index: c_int, new_portal_settings_name: [*c]const u8) !void { try invoker.invoke(void, 0xC9D623C5A3D8FD5D, .{interior_name_hash, room_index, door_index, new_portal_settings_name}); } // 0xC9D623C5A3D8FD5D  b3570
    ///  Found in the b617d scripts, duplicates removed: 
    /// 
    ///  AUDIO::REMOVE_PORTAL_SETTINGS_OVERRIDE("V_CARSHOWROOM_PS_WINDOW_UNBROKEN"); \
    ///  AUDIO::REMOVE_PORTAL_SETTINGS_OVERRIDE("V_CIA_PS_WINDOW_UNBROKEN"); \
    ///  AUDIO::REMOVE_PORTAL_SETTINGS_OVERRIDE("V_DLC_HEIST_APARTMENT_DOOR_CLOSED"); \
    ///  AUDIO::REMOVE_PORTAL_SETTINGS_OVERRIDE("V_FINALEBANK_PS_VAULT_INTACT"); \
    ///  AUDIO::REMOVE_PORTAL_SETTINGS_OVERRIDE("V_MICHAEL_PS_BATHROOM_WITH_WINDOW");
    pub inline fn removePortalSettingsOverride(p_0: [*c]const u8) !void { try invoker.invoke(void, 0xB4BBFD9CD8B3922B, .{p_0}); } // 0xB4BBFD9CD8B3922B 0xD24B4D0C b323
    pub inline fn removeIndividualPortalSettingsOverride(interior_name_hash: types.Hash, room_index: c_int, door_index: c_int) !void { try invoker.invoke(void, 0x8EF105736194F80C, .{interior_name_hash, room_index, door_index}); } // 0x8EF105736194F80C  b3570
    pub inline fn stopSmokeGrenadeExplosionSounds() !void { try invoker.invoke(void, 0xE4E6DD5566D28C82, .{}); } // 0xE4E6DD5566D28C82 0x7262B5BA b323
    pub inline fn getMusicVolSlider() !c_int { return try invoker.invoke(c_int, 0x3A48AB4445D499BE, .{}); } // 0x3A48AB4445D499BE 0x93A44A1F b323
    pub inline fn requestTennisBanks(ped: types.Ped) !void { try invoker.invoke(void, 0x4ADA3F19BE4A6047, .{ped}); } // 0x4ADA3F19BE4A6047 0x13777A0B b323
    pub inline fn unrequestTennisBanks() !void { try invoker.invoke(void, 0x0150B6FF25A9E2E5, .{}); } // 0x0150B6FF25A9E2E5 0x1134F68B b323
    pub inline fn setSkipMinigunSpinUpAudio(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xBEF34B1D9624D5DD, .{p_0}); } // 0xBEF34B1D9624D5DD 0xE0047BFD b323
    pub inline fn stopCutsceneAudio() !void { try invoker.invoke(void, 0x806058BBDC136E06, .{}); } // 0x806058BBDC136E06 0x55461BE6 b323
    pub inline fn hasLoadedMpDataSet() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x544810ED9DB6BBE6, .{}); } // 0x544810ED9DB6BBE6  b323
    pub inline fn hasLoadedSpDataSet() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5B50ABB1FE3746F4, .{}); } // 0x5B50ABB1FE3746F4  b323
    pub inline fn getVehicleHornSoundIndex(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xD53F3A29BCE2580E, .{vehicle}); } // 0xD53F3A29BCE2580E  b1365
    pub inline fn setVehicleHornSoundIndex(vehicle: types.Vehicle, value: c_int) !void { try invoker.invoke(void, 0x0350E7E17BA767D0, .{vehicle, value}); } // 0x0350E7E17BA767D0  b1365
};

pub const Brain = struct
{
    /// BRAIN::ADD_SCRIPT_TO_RANDOM_PED("pb_prostitute", ${s_f_y_hooker_01}, 100, 0);
    /// 
    /// - Nacorpio
    /// 
    /// -----
    /// 
    /// Hardcoded to not work in Multiplayer.
    pub inline fn addScriptToRandomPed(name: [*c]const u8, model: types.Hash, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0x4EE5367468A65CCC, .{name, model, p_2, p_3}); } // 0x4EE5367468A65CCC 0xECC76C3D b323
    /// Registers a script for any object with a specific model hash.
    /// 
    /// BRAIN::REGISTER_OBJECT_SCRIPT_BRAIN("ob_telescope", ${prop_telescope_01}, 100, 4.0, -1, 9);
    /// 
    /// - Nacorpio
    pub inline fn registerObjectScriptBrain(script_name: [*c]const u8, model_hash: types.Hash, p_2: c_int, activation_range: f32, p_4: c_int, p_5: c_int) !void { try invoker.invoke(void, 0x0BE84C318BA6EC22, .{script_name, model_hash, p_2, activation_range, p_4, p_5}); } // 0x0BE84C318BA6EC22 0xB6BCC608 b323
    pub inline fn isObjectWithinBrainActivationRange(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCCBA154209823057, .{object}); } // 0xCCBA154209823057 0xBA4CAA56 b323
    pub inline fn registerWorldPointScriptBrain(script_name: [*c]const u8, activation_range: f32, p_2: c_int) !void { try invoker.invoke(void, 0x3CDC7136613284BD, .{script_name, activation_range, p_2}); } // 0x3CDC7136613284BD 0x725D91F7 b323
    /// Gets whether the world point the calling script is registered to is within desired range of the player.
    pub inline fn isWorldPointWithinBrainActivationRange() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC5042CC6F5E3D450, .{}); } // 0xC5042CC6F5E3D450 0x2CF305A0 b323
    pub inline fn enableScriptBrainSet(brain_set: c_int) !void { try invoker.invoke(void, 0x67AA4D73F0CFA86B, .{brain_set}); } // 0x67AA4D73F0CFA86B 0x2765919F b323
    pub inline fn disableScriptBrainSet(brain_set: c_int) !void { try invoker.invoke(void, 0x14D8518E9760F08F, .{brain_set}); } // 0x14D8518E9760F08F 0xFBD13FAD b323
    pub inline fn reactivateAllWorldBrainsThatAreWaitingTillOutOfRange() !void { try invoker.invoke(void, 0x0B40ED49D7D6FF84, .{}); } // 0x0B40ED49D7D6FF84 0x19B27825 b323
    pub inline fn reactivateAllObjectBrainsThatAreWaitingTillOutOfRange() !void { try invoker.invoke(void, 0x4D953DF78EBF8158, .{}); } // 0x4D953DF78EBF8158 0xF3A3AB08 b323
    /// Possible values:
    /// 
    /// act_cinema \
    /// am_mp_carwash_launch \
    /// am_mp_carwash_control \
    /// am_mp_property_ext \
    /// chop \
    /// fairgroundHub \
    /// launcher_BasejumpHeli \
    /// launcher_BasejumpPack \
    /// launcher_CarWash \
    /// launcher_golf \
    /// launcher_Hunting_Ambient \
    /// launcher_MrsPhilips \
    /// launcher_OffroadRacing \
    /// launcher_pilotschool \
    /// launcher_Racing \
    /// launcher_rampage \
    /// launcher_rampage \
    /// launcher_range \
    /// launcher_stunts \
    /// launcher_stunts \
    /// launcher_tennis \
    /// launcher_Tonya \
    /// launcher_Triathlon \
    /// launcher_Yoga \
    /// ob_mp_bed_low \
    /// ob_mp_bed_med
    pub inline fn reactivateNamedWorldBrainsWaitingTillOutOfRange(script_name: [*c]const u8) !void { try invoker.invoke(void, 0x6D6840CEE8845831, .{script_name}); } // 0x6D6840CEE8845831 0x949FE53E b323
    /// Looks like a cousin of above function _6D6840CEE8845831 as it was found among them. Must be similar
    /// 
    /// Here are possible values of argument - 
    /// 
    /// "ob_tv" \
    /// "launcher_Darts"
    pub inline fn reactivateNamedObjectBrainsWaitingTillOutOfRange(script_name: [*c]const u8) !void { try invoker.invoke(void, 0x6E91B04E08773030, .{script_name}); } // 0x6E91B04E08773030 0x29CE8BAA b323
};

pub const Cam = struct
{
    /// ease - smooth transition between the camera's positions \
    /// easeTime - Time in milliseconds for the transition to happen
    /// 
    /// If you have created a script (rendering) camera, and want to go back to the  \
    /// character (gameplay) camera, call this native with render set to 0. \
    /// Setting ease to 1 will smooth the transition.
    pub inline fn renderScriptCams(render: windows.BOOL, ease: windows.BOOL, ease_time: c_int, p_3: windows.BOOL, p_4: windows.BOOL, p_5: types.Any) !void { try invoker.invoke(void, 0x07E5B515DB0636FC, .{render, ease, ease_time, p_3, p_4, p_5}); } // 0x07E5B515DB0636FC 0x74337969 b323
    /// This native makes the gameplay camera zoom into first person/third person with a special effect.
    pub inline fn stopRenderingScriptCamsUsingCatchUp(render: windows.BOOL, p_1: f32, p_2: c_int, p_3: types.Any) !void { try invoker.invoke(void, 0xC819F3CBB62BF692, .{render, p_1, p_2, p_3}); } // 0xC819F3CBB62BF692 0xD3C08183 b323
    /// "DEFAULT_SCRIPTED_CAMERA" \
    /// "DEFAULT_ANIMATED_CAMERA" \
    /// "DEFAULT_SPLINE_CAMERA" \
    /// "DEFAULT_SCRIPTED_FLY_CAMERA" \
    /// "TIMED_SPLINE_CAMERA"
    pub inline fn createCam(cam_name: [*c]const u8, p_1: windows.BOOL) !types.Cam { return try invoker.invoke(types.Cam, 0xC3981DCE61D9E13F, .{cam_name, p_1}); } // 0xC3981DCE61D9E13F 0xE9BF2A7D b323
    /// camName is always set to "DEFAULT_SCRIPTED_CAMERA" in Rockstar's scripts. \
    /// ------------ \
    /// Camera names found in the b617d scripts: \
    /// "DEFAULT_ANIMATED_CAMERA" \
    /// "DEFAULT_SCRIPTED_CAMERA" \
    /// "DEFAULT_SCRIPTED_FLY_CAMERA" \
    /// "DEFAULT_SPLINE_CAMERA" \
    /// ------------ \
    /// Side Note: It seems p8 is basically to represent what would be the bool p1 within CREATE_CAM native. As well as the p9 since it's always 2 in scripts seems to represent what would be the last param within SET_CAM_ROT native which normally would be 2.
    pub inline fn createCamWithParams(cam_name: [*c]const u8, pos__: types.Vector3, rot__: types.Vector3, fov: f32, p_8: windows.BOOL, p_9: c_int) !types.Cam { return try invoker.invoke(types.Cam, 0xB51194800B257161, .{cam_name, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, fov, p_8, p_9}); } // 0xB51194800B257161 0x23B02F15 b323
    pub inline fn createCamera(cam_hash: types.Hash, p_1: windows.BOOL) !types.Cam { return try invoker.invoke(types.Cam, 0x5E3CF89C6BCCA67D, .{cam_hash, p_1}); } // 0x5E3CF89C6BCCA67D 0x5D6739AE b323
    /// p9 uses 2 by default
    pub inline fn createCameraWithParams(cam_hash: types.Hash, pos__: types.Vector3, rot__: types.Vector3, fov: f32, p_8: windows.BOOL, p_9: types.Any) !types.Cam { return try invoker.invoke(types.Cam, 0x6ABFA3E16460F22D, .{cam_hash, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, fov, p_8, p_9}); } // 0x6ABFA3E16460F22D 0x0688BE9A b323
    /// BOOL param indicates whether the cam should be destroyed if it belongs to the calling script.
    pub inline fn destroyCam(cam: types.Cam, b_script_host_cam: windows.BOOL) !void { try invoker.invoke(void, 0x865908C81A2C22E9, .{cam, b_script_host_cam}); } // 0x865908C81A2C22E9 0xC39302BD b323
    /// BOOL param indicates whether the cam should be destroyed if it belongs to the calling script.
    pub inline fn destroyAllCams(b_script_host_cam: windows.BOOL) !void { try invoker.invoke(void, 0x8E5FB15663F79120, .{b_script_host_cam}); } // 0x8E5FB15663F79120 0x10C151CE b323
    /// Returns whether or not the passed camera handle exists.
    pub inline fn doesCamExist(cam: types.Cam) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA7A932170592B50E, .{cam}); } // 0xA7A932170592B50E 0x1EF89DC0 b323
    /// Set camera as active/inactive.
    pub inline fn setCamActive(cam: types.Cam, active: windows.BOOL) !void { try invoker.invoke(void, 0x026FB97D0A425F84, .{cam, active}); } // 0x026FB97D0A425F84 0x064659C2 b323
    /// Returns whether or not the passed camera handle is active.
    pub inline fn isCamActive(cam: types.Cam) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDFB2B516207D3534, .{cam}); } // 0xDFB2B516207D3534 0x4B58F177 b323
    pub inline fn isCamRendering(cam: types.Cam) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x02EC0AF5C5A49B7A, .{cam}); } // 0x02EC0AF5C5A49B7A 0x6EC6B5B2 b323
    pub inline fn getRenderingCam() !types.Cam { return try invoker.invoke(types.Cam, 0x5234F9F10919EABA, .{}); } // 0x5234F9F10919EABA 0x0FCF4DF1 b323
    pub inline fn getCamCoord(cam: types.Cam) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xBAC038F7459AE5AE, .{cam}); } // 0xBAC038F7459AE5AE 0x7C40F09C b323
    /// The last parameter, as in other "ROT" methods, is usually 2.
    pub inline fn getCamRot(cam: types.Cam, rotation_order: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x7D304C1C955E3E12, .{cam, rotation_order}); } // 0x7D304C1C955E3E12 0xDAC84C9F b323
    pub inline fn getCamFov(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0xC3330A45CCCDB26A, .{cam}); } // 0xC3330A45CCCDB26A 0xD6E9FCF5 b323
    pub inline fn getCamNearClip(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0xC520A34DAFBF24B1, .{cam}); } // 0xC520A34DAFBF24B1 0xCFCD35EE b323
    pub inline fn getCamFarClip(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0xB60A9CFEB21CA6AA, .{cam}); } // 0xB60A9CFEB21CA6AA 0x09F119B8 b323
    pub inline fn getCamNearDof(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0xC2612D223D915A1C, .{cam}); } // 0xC2612D223D915A1C  b2699
    pub inline fn getCamFarDof(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0x255F8DAFD540D397, .{cam}); } // 0x255F8DAFD540D397 0x98C5CCE9 b323
    pub inline fn getCamDofStrength(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0x06D153C0B99B6128, .{cam}); } // 0x06D153C0B99B6128  b2699
    pub inline fn setCamParams(cam: types.Cam, pos__: types.Vector3, rot__: types.Vector3, field_of_view: f32, p_8: types.Any, p_9: c_int, p_1_0: c_int, p_1_1: c_int) !void { try invoker.invoke(void, 0xBFD8727AEA3CCEBA, .{cam, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, field_of_view, p_8, p_9, p_1_0, p_1_1}); } // 0xBFD8727AEA3CCEBA 0x2167CEBF b323
    /// Sets the position of the cam.
    pub inline fn setCamCoord(cam: types.Cam, pos__: types.Vector3) !void { try invoker.invoke(void, 0x4D41783FB745E42E, .{cam, pos__.x, pos__.y, pos__.z}); } // 0x4D41783FB745E42E 0x7A8053AF b323
    /// Sets the rotation of the cam. \
    /// Last parameter unknown.
    /// 
    /// Last parameter seems to always be set to 2.
    pub inline fn setCamRot(cam: types.Cam, rot__: types.Vector3, rotation_order: c_int) !void { try invoker.invoke(void, 0x85973643155D0B07, .{cam, rot__.x, rot__.y, rot__.z, rotation_order}); } // 0x85973643155D0B07 0xEE38B3C1 b323
    /// Sets the field of view of the cam. \
    /// --------------------------------------------- \
    /// Min: 1.0f \
    /// Max: 130.0f
    pub inline fn setCamFov(cam: types.Cam, field_of_view: f32) !void { try invoker.invoke(void, 0xB13C14F66A00D047, .{cam, field_of_view}); } // 0xB13C14F66A00D047 0xD3D5D74F b323
    pub inline fn setCamNearClip(cam: types.Cam, near_clip: f32) !void { try invoker.invoke(void, 0xC7848EFCCC545182, .{cam, near_clip}); } // 0xC7848EFCCC545182 0x46DB13B1 b323
    pub inline fn setCamFarClip(cam: types.Cam, far_clip: f32) !void { try invoker.invoke(void, 0xAE306F2A904BF86E, .{cam, far_clip}); } // 0xAE306F2A904BF86E 0x0D23E381 b323
    pub inline fn forceCamFarClip(cam: types.Cam, p_1: f32) !void { try invoker.invoke(void, 0xAABD62873FFB1A33, .{cam, p_1}); } // 0xAABD62873FFB1A33  b2189
    pub inline fn setCamMotionBlurStrength(cam: types.Cam, strength: f32) !void { try invoker.invoke(void, 0x6F0F77FBA9A8F2E6, .{cam, strength}); } // 0x6F0F77FBA9A8F2E6 0xFD6E0D67 b323
    pub inline fn setCamNearDof(cam: types.Cam, near_d_o_f: f32) !void { try invoker.invoke(void, 0x3FA4BF0A7AB7DE2C, .{cam, near_d_o_f}); } // 0x3FA4BF0A7AB7DE2C 0xF28254DF b323
    pub inline fn setCamFarDof(cam: types.Cam, far_d_o_f: f32) !void { try invoker.invoke(void, 0xEDD91296CD01AEE0, .{cam, far_d_o_f}); } // 0xEDD91296CD01AEE0 0x58515E8E b323
    pub inline fn setCamDofStrength(cam: types.Cam, dof_strength: f32) !void { try invoker.invoke(void, 0x5EE29B4D7D5DF897, .{cam, dof_strength}); } // 0x5EE29B4D7D5DF897 0x3CC4EB3F b323
    pub inline fn setCamDofPlanes(cam: types.Cam, p_1: f32, p_2: f32, p_3: f32, p_4: f32) !void { try invoker.invoke(void, 0x3CF48F6F96E749DC, .{cam, p_1, p_2, p_3, p_4}); } // 0x3CF48F6F96E749DC 0xAD6C2B8F b323
    pub inline fn setCamUseShallowDofMode(cam: types.Cam, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x16A96863A17552BB, .{cam, toggle}); } // 0x16A96863A17552BB 0x8306C256 b323
    pub inline fn setUseHiDof() !void { try invoker.invoke(void, 0xA13B0222F3D94A94, .{}); } // 0xA13B0222F3D94A94 0x8BBF2950 b323
    /// Only used in R* Script fm_mission_controller_2020
    pub inline fn setUseHiDofOnSyncedSceneThisUpdate() !void { try invoker.invoke(void, 0x731A880555DA3647, .{}); } // 0x731A880555DA3647  b2699
    pub inline fn setCamDofOverriddenFocusDistance(camera: types.Cam, p_1: f32) !void { try invoker.invoke(void, 0xF55E4046F6F831DC, .{camera, p_1}); } // 0xF55E4046F6F831DC  b323
    pub inline fn setCamDofOverriddenFocusDistanceBlendLevel(p_0: types.Any, p_1: f32) !void { try invoker.invoke(void, 0xE111A7C0D200CBC5, .{p_0, p_1}); } // 0xE111A7C0D200CBC5  b323
    /// This native has its name defined inside its codE
    /// 
    pub inline fn setCamDofFnumberOfLens(camera: types.Cam, p_1: f32) !void { try invoker.invoke(void, 0x7DD234D6F3914C5B, .{camera, p_1}); } // 0x7DD234D6F3914C5B  b323
    /// Native name labeled within its code
    pub inline fn setCamDofFocalLengthMultiplier(camera: types.Cam, multiplier: f32) !void { try invoker.invoke(void, 0x47B595D60664CFFA, .{camera, multiplier}); } // 0x47B595D60664CFFA  b1011
    /// This native has a name defined inside its code
    pub inline fn setCamDofFocusDistanceBias(camera: types.Cam, p_1: f32) !void { try invoker.invoke(void, 0xC669EEA5D031B7DE, .{camera, p_1}); } // 0xC669EEA5D031B7DE  b323
    /// This native has a name defined inside its code
    pub inline fn setCamDofMaxNearInFocusDistance(camera: types.Cam, p_1: f32) !void { try invoker.invoke(void, 0xC3654A441402562D, .{camera, p_1}); } // 0xC3654A441402562D  b323
    /// This native has a name defined inside its code
    pub inline fn setCamDofMaxNearInFocusDistanceBlendLevel(camera: types.Cam, p_1: f32) !void { try invoker.invoke(void, 0x2C654B4943BDDF7C, .{camera, p_1}); } // 0x2C654B4943BDDF7C  b323
    /// This native has a name defined inside its code
    pub inline fn setCamDofShouldKeepLookAtTargetInFocus(camera: types.Cam, state: windows.BOOL) !void { try invoker.invoke(void, 0x7CF3AF51DCFE4108, .{camera, state}); } // 0x7CF3AF51DCFE4108  b2944
    /// Last param determines if its relative to the Entity
    pub inline fn attachCamToEntity(cam: types.Cam, entity: types.Entity, offset__: types.Vector3, is_relative: windows.BOOL) !void { try invoker.invoke(void, 0xFEDB7D269E8C60E3, .{cam, entity, offset__.x, offset__.y, offset__.z, is_relative}); } // 0xFEDB7D269E8C60E3 0xAD7C45F6 b323
    pub inline fn attachCamToPedBone(cam: types.Cam, ped: types.Ped, bone_index: c_int, vec: types.Vector3, heading: windows.BOOL) !void { try invoker.invoke(void, 0x61A3DBA14AB7F411, .{cam, ped, bone_index, vec.x, vec.y, vec.z, heading}); } // 0x61A3DBA14AB7F411 0x506BB35C b323
    pub inline fn hardAttachCamToPedBone(cam: types.Cam, ped: types.Ped, bone_index: c_int, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: f32, p_9: windows.BOOL) !void { try invoker.invoke(void, 0x149916F50C34A40D, .{cam, ped, bone_index, p_3, p_4, p_5, p_6, p_7, p_8, p_9}); } // 0x149916F50C34A40D  b1180
    /// Example from am_mp_drone script: 
    /// 
    /// CAM::HARD_ATTACH_CAM_TO_ENTITY(Local_190.f_169, NETWORK::NET_TO_OBJ(Local_190.f_159), 0f, 0f, 180f, Var0, 1);
    pub inline fn hardAttachCamToEntity(cam: types.Cam, entity: types.Entity, rot__: types.Vector3, offset__: types.Vector3, is_relative: windows.BOOL) !void { try invoker.invoke(void, 0x202A5ED9CE01D6E7, .{cam, entity, rot__.x, rot__.y, rot__.z, offset__.x, offset__.y, offset__.z, is_relative}); } // 0x202A5ED9CE01D6E7  b2189
    /// This native works with vehicles only. Bone indexes are usually given by this native GET_ENTITY_BONE_INDEX_BY_NAME.
    pub inline fn attachCamToVehicleBone(cam: types.Cam, vehicle: types.Vehicle, bone_index: c_int, relative_rotation: windows.BOOL, rot__: types.Vector3, offset__: types.Vector3, fixed_direction: windows.BOOL) !void { try invoker.invoke(void, 0x8DB3F12A02CAEF72, .{cam, vehicle, bone_index, relative_rotation, rot__.x, rot__.y, rot__.z, offset__.x, offset__.y, offset__.z, fixed_direction}); } // 0x8DB3F12A02CAEF72  b1290
    pub inline fn detachCam(cam: types.Cam) !void { try invoker.invoke(void, 0xA2FABBE87F4BAD82, .{cam}); } // 0xA2FABBE87F4BAD82 0xF4FBF14A b323
    /// The native seems to only be called once.
    /// 
    /// The native is used as so, \
    /// CAM::SET_CAM_INHERIT_ROLL_VEHICLE(l_544, getElem(2, &l_525, 4)); \
    /// In the exile1 script.
    pub inline fn setCamInheritRollVehicle(cam: types.Cam, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x45F1DE9C34B93AE6, .{cam, p_1}); } // 0x45F1DE9C34B93AE6 0xE4BD5342 b323
    pub inline fn pointCamAtCoord(cam: types.Cam, vec: types.Vector3) !void { try invoker.invoke(void, 0xF75497BB865F0803, .{cam, vec.x, vec.y, vec.z}); } // 0xF75497BB865F0803 0x914BC21A b323
    /// p5 always seems to be 1 i.e TRUE
    pub inline fn pointCamAtEntity(cam: types.Cam, entity: types.Entity, p_2: f32, p_3: f32, p_4: f32, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x5640BFF86B16E8DC, .{cam, entity, p_2, p_3, p_4, p_5}); } // 0x5640BFF86B16E8DC 0x7597A0F7 b323
    /// Parameters p0-p5 seems correct. The bool p6 is unknown, but through every X360 script it's always 1. Please correct p0-p5 if any prove to be wrong. 
    pub inline fn pointCamAtPedBone(cam: types.Cam, ped: types.Ped, bone_index: c_int, vec: types.Vector3, p_6: windows.BOOL) !void { try invoker.invoke(void, 0x68B2B5F33BA63C41, .{cam, ped, bone_index, vec.x, vec.y, vec.z, p_6}); } // 0x68B2B5F33BA63C41 0x09F47049 b323
    pub inline fn stopCamPointing(cam: types.Cam) !void { try invoker.invoke(void, 0xF33AB75780BA57DE, .{cam}); } // 0xF33AB75780BA57DE 0x5435F6A5 b323
    /// Allows you to aim and shoot at the direction the camera is facing.
    pub inline fn setCamAffectsAiming(cam: types.Cam, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8C1DC7770C51DC8D, .{cam, toggle}); } // 0x8C1DC7770C51DC8D 0x0C74F9AF b323
    /// Rotates the radar to match the camera's Z rotation
    pub inline fn setCamControlsMiniMapHeading(cam: types.Cam, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x661B5C8654ADD825, .{cam, toggle}); } // 0x661B5C8654ADD825 0xE1A0B2F1 b323
    /// When set to true shadows appear more smooth but less detailed. \
    /// Set to false by default.
    pub inline fn setCamIsInsideVehicle(cam: types.Cam, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA2767257A320FC82, .{cam, toggle}); } // 0xA2767257A320FC82  b323
    pub inline fn allowMotionBlurDecay(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x271017B9BA825366, .{p_0, p_1}); } // 0x271017B9BA825366 0x43220969 b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn setCamDebugName(camera: types.Cam, name: [*c]const u8) !void { try invoker.invoke(void, 0x1B93E0107865DD40, .{camera, name}); } // 0x1B93E0107865DD40 0x9B00DF3F b323
    pub inline fn getDebugCam() !types.Cam { return try invoker.invoke(types.Cam, 0x77C3CEC46BE286F6, .{}); } // 0x77C3CEC46BE286F6  b2372
    /// I filled p1-p6 (the floats) as they are as other natives with 6 floats in a row are similar and I see no other method. So if a test from anyone proves them wrong please correct.
    /// 
    /// p7 (length) determines the length of the spline, affects camera path and duration of transition between previous node and this one
    /// 
    /// p8 big values ~100 will slow down the camera movement before reaching this node
    /// 
    /// p9 != 0 seems to override the rotation/pitch (bool?)
    pub inline fn addCamSplineNode(camera: types.Cam, vec: types.Vector3, rot__: types.Vector3, length: c_int, smoothing_style: c_int, rotation_order: c_int) !void { try invoker.invoke(void, 0x8609C75EC438FB3B, .{camera, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, length, smoothing_style, rotation_order}); } // 0x8609C75EC438FB3B 0xAD3C7EAA b323
    /// p0 is the spline camera to which the node is being added. \
    /// p1 is the camera used to create the node. \
    /// p3 is always 3 in scripts. It might be smoothing style or rotation order.
    pub inline fn addCamSplineNodeUsingCameraFrame(cam: types.Cam, cam_2: types.Cam, length: c_int, p_3: c_int) !void { try invoker.invoke(void, 0x0A9F2A468B328E74, .{cam, cam_2, length, p_3}); } // 0x0A9F2A468B328E74 0x30510511 b323
    /// p0 is the spline camera to which the node is being added. \
    /// p1 is the camera used to create the node. \
    /// p3 is always 3 in scripts. It might be smoothing style or rotation order.
    pub inline fn addCamSplineNodeUsingCamera(cam: types.Cam, cam_2: types.Cam, length: c_int, p_3: c_int) !void { try invoker.invoke(void, 0x0FB82563989CF4FB, .{cam, cam_2, length, p_3}); } // 0x0FB82563989CF4FB 0xBA6C085B b323
    /// p2 is always 2 in scripts. It might be smoothing style or rotation order.
    pub inline fn addCamSplineNodeUsingGameplayFrame(cam: types.Cam, length: c_int, p_2: c_int) !void { try invoker.invoke(void, 0x609278246A29CA34, .{cam, length, p_2}); } // 0x609278246A29CA34 0xB4737F03 b323
    pub inline fn setCamSplinePhase(cam: types.Cam, p_1: f32) !void { try invoker.invoke(void, 0x242B5874F0A4E052, .{cam, p_1}); } // 0x242B5874F0A4E052 0xF0AED233 b323
    /// Can use this with SET_CAM_SPLINE_PHASE to set the float it this native returns.
    /// 
    /// (returns 1.0f when no nodes has been added, reached end of non existing spline)
    pub inline fn getCamSplinePhase(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0xB5349E36C546509A, .{cam}); } // 0xB5349E36C546509A 0x39784DD9 b323
    /// I'm pretty sure the parameter is the camera as usual, but I am not certain so I'm going to leave it as is.
    pub inline fn getCamSplineNodePhase(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0xD9D0E694C8282C96, .{cam}); } // 0xD9D0E694C8282C96 0x7B9522F6 b323
    /// I named p1 as timeDuration as it is obvious. I'm assuming tho it is ran in ms(Milliseconds) as usual.
    pub inline fn setCamSplineDuration(cam: types.Cam, time_duration: c_int) !void { try invoker.invoke(void, 0x1381539FEE034CDA, .{cam, time_duration}); } // 0x1381539FEE034CDA 0x3E91FC8A b323
    pub inline fn setCamSplineSmoothingStyle(cam: types.Cam, smoothing_style: c_int) !void { try invoker.invoke(void, 0xD1B0F412F109EA5D, .{cam, smoothing_style}); } // 0xD1B0F412F109EA5D 0x15E141CE b323
    pub inline fn getCamSplineNodeIndex(cam: types.Cam) !c_int { return try invoker.invoke(c_int, 0xB22B17DF858716A6, .{cam}); } // 0xB22B17DF858716A6 0xF8AEB6BD b323
    pub inline fn setCamSplineNodeEase(cam: types.Cam, easing_function: c_int, p_2: c_int, p_3: f32) !void { try invoker.invoke(void, 0x83B8201ED82A9A2D, .{cam, easing_function, p_2, p_3}); } // 0x83B8201ED82A9A2D 0x21D275DA b323
    pub inline fn setCamSplineNodeVelocityScale(cam: types.Cam, p_1: c_int, scale: f32) !void { try invoker.invoke(void, 0xA6385DEB180F319F, .{cam, p_1, scale}); } // 0xA6385DEB180F319F 0xA3BD9E94 b323
    pub inline fn overrideCamSplineVelocity(cam: types.Cam, p_1: c_int, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0x40B62FA033EB0346, .{cam, p_1, p_2, p_3}); } // 0x40B62FA033EB0346 0x326A17E2 b323
    /// Max value for p1 is 15.
    pub inline fn overrideCamSplineMotionBlur(cam: types.Cam, p_1: c_int, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0x7DCF7C708D292D55, .{cam, p_1, p_2, p_3}); } // 0x7DCF7C708D292D55 0x633179E6 b323
    pub inline fn setCamSplineNodeExtraFlags(cam: types.Cam, p_1: c_int, flags: c_int) !void { try invoker.invoke(void, 0x7BF1A54AE67AC070, .{cam, p_1, flags}); } // 0x7BF1A54AE67AC070 0xC90B2DDC b323
    pub inline fn isCamSplinePaused(cam: types.Cam) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0290F35C0AD97864, .{cam}); } // 0x0290F35C0AD97864 0x60B34FF5 b323
    pub inline fn interpolateCamWithParams_(camera: types.Cam, campos__: types.Vector3, camrot__: types.Vector3, fov: f32, duration: c_int, pos_curve_type: c_int, rot_curve_type: c_int, rot_order: c_int, fov_curve_type: c_int) !void { try invoker.invoke(void, 0xDDA77EE33C005AAF, .{camera, campos__.x, campos__.y, campos__.z, camrot__.x, camrot__.y, camrot__.z, fov, duration, pos_curve_type, rot_curve_type, rot_order, fov_curve_type}); } // 0xDDA77EE33C005AAF  b3258
    pub inline fn activateCamWithInterpAndFovCurve_(cam_to: types.Cam, cam_from: types.Cam, duration: c_int, ease_location: c_int, ease_rotation: c_int, ease_fov: c_int) !void { try invoker.invoke(void, 0x34CFC4C2A38E83E3, .{cam_to, cam_from, duration, ease_location, ease_rotation, ease_fov}); } // 0x34CFC4C2A38E83E3  b3258
    /// Previous declaration void SET_CAM_ACTIVE_WITH_INTERP(Cam camTo, Cam camFrom, int duration, BOOL easeLocation, BOOL easeRotation) is completely wrong. The last two params are integers not BOOLs...
    /// 
    pub inline fn setCamActiveWithInterp(cam_to: types.Cam, cam_from: types.Cam, duration: c_int, ease_location: c_int, ease_rotation: c_int) !void { try invoker.invoke(void, 0x9FBDA379383A52A4, .{cam_to, cam_from, duration, ease_location, ease_rotation}); } // 0x9FBDA379383A52A4 0x7983E7F0 b323
    pub inline fn isCamInterpolating(cam: types.Cam) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x036F97C908C2B52C, .{cam}); } // 0x036F97C908C2B52C 0x7159CB5D b323
    /// Possible shake types (updated b617d):
    /// 
    /// DEATH_FAIL_IN_EFFECT_SHAKE \
    /// DRUNK_SHAKE \
    /// FAMILY5_DRUG_TRIP_SHAKE \
    /// HAND_SHAKE \
    /// JOLT_SHAKE \
    /// LARGE_EXPLOSION_SHAKE \
    /// MEDIUM_EXPLOSION_SHAKE \
    /// SMALL_EXPLOSION_SHAKE \
    /// ROAD_VIBRATION_SHAKE \
    /// SKY_DIVING_SHAKE \
    /// VIBRATE_SHAKE
    /// 
    /// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
    pub inline fn shakeCam(cam: types.Cam, @"type": [*c]const u8, amplitude: f32) !void { try invoker.invoke(void, 0x6A25241C340D3822, .{cam, @"type", amplitude}); } // 0x6A25241C340D3822 0x1D4211B0 b323
    /// Example from michael2 script.
    /// 
    /// CAM::ANIMATED_SHAKE_CAM(l_5069, "shake_cam_all@", "light", "", 1f);
    pub inline fn animatedShakeCam(cam: types.Cam, p_1: [*c]const u8, p_2: [*c]const u8, p_3: [*c]const u8, amplitude: f32) !void { try invoker.invoke(void, 0xA2746EEAE3E577CD, .{cam, p_1, p_2, p_3, amplitude}); } // 0xA2746EEAE3E577CD 0xE1168767 b323
    pub inline fn isCamShaking(cam: types.Cam) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6B24BFE83A2BE47B, .{cam}); } // 0x6B24BFE83A2BE47B 0x0961FD9B b323
    pub inline fn setCamShakeAmplitude(cam: types.Cam, amplitude: f32) !void { try invoker.invoke(void, 0xD93DB43B82BC0D00, .{cam, amplitude}); } // 0xD93DB43B82BC0D00 0x60FF6382 b323
    pub inline fn stopCamShaking(cam: types.Cam, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xBDECF64367884AC3, .{cam, p_1}); } // 0xBDECF64367884AC3 0x40D0EB87 b323
    /// CAM::SHAKE_SCRIPT_GLOBAL("HAND_SHAKE", 0.2);
    /// 
    /// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
    pub inline fn shakeScriptGlobal(p_0: [*c]const u8, p_1: f32) !void { try invoker.invoke(void, 0xF4C8CF9E353AFECA, .{p_0, p_1}); } // 0xF4C8CF9E353AFECA 0x2B0F05CD b323
    /// CAM::ANIMATED_SHAKE_SCRIPT_GLOBAL("SHAKE_CAM_medium", "medium", "", 0.5f);
    /// 
    /// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
    pub inline fn animatedShakeScriptGlobal(p_0: [*c]const u8, p_1: [*c]const u8, p_2: [*c]const u8, p_3: f32) !void { try invoker.invoke(void, 0xC2EAE3FB8CDBED31, .{p_0, p_1, p_2, p_3}); } // 0xC2EAE3FB8CDBED31 0xCB75BD9C b323
    /// In drunk_controller.c4, sub_309 \
    /// if (CAM::IS_SCRIPT_GLOBAL_SHAKING()) { \
    ///     CAM::STOP_SCRIPT_GLOBAL_SHAKING(0);
    /// }
    pub inline fn isScriptGlobalShaking() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC912AF078AF19212, .{}); } // 0xC912AF078AF19212 0x6AEFE6A5 b323
    /// In drunk_controller.c4, sub_309 \
    /// if (CAM::IS_SCRIPT_GLOBAL_SHAKING()) { \
    ///     CAM::STOP_SCRIPT_GLOBAL_SHAKING(0);
    /// }
    pub inline fn stopScriptGlobalShaking(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x1C9D7949FA533490, .{p_0}); } // 0x1C9D7949FA533490 0x26FCFB96 b323
    /// p1: 0..16
    pub inline fn triggerVehiclePartBrokenCameraShake(vehicle: types.Vehicle, p_1: c_int, p_2: f32) !void { try invoker.invoke(void, 0x5D96CFB59DA076A0, .{vehicle, p_1, p_2}); } // 0x5D96CFB59DA076A0  b2060
    /// Atleast one time in a script for the zRot Rockstar uses GET_ENTITY_HEADING to help fill the parameter.
    /// 
    /// p9 is unknown at this time. \
    /// p10 throughout all the X360 Scripts is always 2.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn playCamAnim(cam: types.Cam, anim_name: [*c]const u8, anim_dictionary: [*c]const u8, vec: types.Vector3, rot__: types.Vector3, p_9: windows.BOOL, p_1_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9A2D0FB2E7852392, .{cam, anim_name, anim_dictionary, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, p_9, p_1_0}); } // 0x9A2D0FB2E7852392 0xBCEFB87E b323
    pub inline fn isCamPlayingAnim(cam: types.Cam, anim_name: [*c]const u8, anim_dictionary: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC90621D8A0CEECF2, .{cam, anim_name, anim_dictionary}); } // 0xC90621D8A0CEECF2 0xB998CB49 b323
    pub inline fn setCamAnimCurrentPhase(cam: types.Cam, phase: f32) !void { try invoker.invoke(void, 0x4145A4C44FF3B5A6, .{cam, phase}); } // 0x4145A4C44FF3B5A6 0x3CB1D17F b323
    pub inline fn getCamAnimCurrentPhase(cam: types.Cam) !f32 { return try invoker.invoke(f32, 0xA10B2DB49E92A6B0, .{cam}); } // 0xA10B2DB49E92A6B0 0x345F72D0 b323
    /// Examples:
    /// 
    /// CAM::PLAY_SYNCHRONIZED_CAM_ANIM(l_2734, NETWORK::NETWORK_GET_LOCAL_SCENE_FROM_NETWORK_ID(l_2739), "PLAYER_EXIT_L_CAM", "mp_doorbell");
    /// 
    /// CAM::PLAY_SYNCHRONIZED_CAM_ANIM(l_F0D[7/*1*/], l_F4D[15/*1*/], "ah3b_attackheli_cam2", "missheistfbi3b_helicrash");
    pub inline fn playSynchronizedCamAnim(p_0: types.Any, p_1: types.Any, anim_name: [*c]const u8, anim_dictionary: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE32EFE9AB4A9AA0C, .{p_0, p_1, anim_name, anim_dictionary}); } // 0xE32EFE9AB4A9AA0C 0x9458459E b323
    pub inline fn setFlyCamHorizontalResponse(cam: types.Cam, p_1: f32, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0x503F5920162365B2, .{cam, p_1, p_2, p_3}); } // 0x503F5920162365B2 0x56F9ED27 b323
    pub inline fn setFlyCamVerticalResponse(cam: types.Cam, p_1: f32, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0xE827B9382CFB41BA, .{cam, p_1, p_2, p_3}); } // 0xE827B9382CFB41BA  b791
    pub inline fn setFlyCamMaxHeight(cam: types.Cam, height: f32) !void { try invoker.invoke(void, 0xF9D02130ECDD1D77, .{cam, height}); } // 0xF9D02130ECDD1D77 0x71570DBA b323
    pub inline fn setFlyCamCoordAndConstrain(cam: types.Cam, vec: types.Vector3) !void { try invoker.invoke(void, 0xC91C6C55199308CA, .{cam, vec.x, vec.y, vec.z}); } // 0xC91C6C55199308CA 0x60B345DE b323
    pub inline fn setFlyCamVerticalControlsThisUpdate(cam: types.Cam) !void { try invoker.invoke(void, 0xC8B5C4A79CC18B94, .{cam}); } // 0xC8B5C4A79CC18B94 0x44473EFC b323
    pub inline fn wasFlyCamConstrainedOnPreviousUdpate(cam: types.Cam) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5C48A1D6E3B33179, .{cam}); } // 0x5C48A1D6E3B33179 0xDA931D65 b323
    pub inline fn isScreenFadedOut() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB16FCE9DDC7BA182, .{}); } // 0xB16FCE9DDC7BA182 0x9CAA05FA b323
    pub inline fn isScreenFadedIn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5A859503B0C08678, .{}); } // 0x5A859503B0C08678 0x4F37276D b323
    pub inline fn isScreenFadingOut() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x797AC7CB535BA28F, .{}); } // 0x797AC7CB535BA28F 0x79275A57 b323
    pub inline fn isScreenFadingIn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5C544BC6C57AC575, .{}); } // 0x5C544BC6C57AC575 0xC7C82800 b323
    /// Fades the screen in.
    /// 
    /// duration: The time the fade should take, in milliseconds.
    pub inline fn doScreenFadeIn(duration: c_int) !void { try invoker.invoke(void, 0xD4E8E24955024033, .{duration}); } // 0xD4E8E24955024033 0x66C1BDEE b323
    /// Fades the screen out.
    /// 
    /// duration: The time the fade should take, in milliseconds.
    pub inline fn doScreenFadeOut(duration: c_int) !void { try invoker.invoke(void, 0x891B5B39AC6302AF, .{duration}); } // 0x891B5B39AC6302AF 0x89D01805 b323
    pub inline fn setWidescreenBorders(p_0: windows.BOOL, p_1: c_int) !void { try invoker.invoke(void, 0xDCD4EA924F42D01A, .{p_0, p_1}); } // 0xDCD4EA924F42D01A 0x1A75DC9A b323
    pub inline fn areWidescreenBordersActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4879E4FE39074CDF, .{}); } // 0x4879E4FE39074CDF  b372
    pub inline fn getGameplayCamCoord() !types.Vector3 { return try invoker.invoke(types.Vector3, 0x14D6F5678D8F1B37, .{}); } // 0x14D6F5678D8F1B37 0x9388CF79 b323
    /// p0 dosen't seem to change much, I tried it with 0, 1, 2: \
    /// 0-Pitch(X): -70.000092 \
    /// 0-Roll(Y): -0.000001 \
    /// 0-Yaw(Z): -43.886459 \
    /// 1-Pitch(X): -70.000092 \
    /// 1-Roll(Y): -0.000001 \
    /// 1-Yaw(Z): -43.886463 \
    /// 2-Pitch(X): -70.000092 \
    /// 2-Roll(Y): -0.000002 \
    /// 2-Yaw(Z): -43.886467
    pub inline fn getGameplayCamRot(rotation_order: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x837765A25378F0BB, .{rotation_order}); } // 0x837765A25378F0BB 0x13A010B5 b323
    pub inline fn getGameplayCamFov() !f32 { return try invoker.invoke(f32, 0x65019750A0324133, .{}); } // 0x65019750A0324133 0x4D6B3BFA b323
    /// some camera effect that is used in the drunk-cheat, and turned off (by setting it to 0.0) along with the shaking effects once the drunk cheat is disabled.
    pub inline fn setGameplayCamMotionBlurScalingThisUpdate(p_0: f32) !void { try invoker.invoke(void, 0x487A82C650EB7799, .{p_0}); } // 0x487A82C650EB7799 0xA6E73135 b323
    /// some camera effect that is (also) used in the drunk-cheat, and turned off (by setting it to 0.0) along with the shaking effects once the drunk cheat is disabled.
    pub inline fn setGameplayCamMaxMotionBlurStrengthThisUpdate(p_0: f32) !void { try invoker.invoke(void, 0x0225778816FDC28C, .{p_0}); } // 0x0225778816FDC28C 0x1126E37C b323
    pub inline fn getGameplayCamRelativeHeading() !f32 { return try invoker.invoke(f32, 0x743607648ADD4587, .{}); } // 0x743607648ADD4587 0xCAF839C2 b323
    /// Sets the camera position relative to heading in float from -360 to +360.
    /// 
    /// Heading is alwyas 0 in aiming camera.
    pub inline fn setGameplayCamRelativeHeading(heading: f32) !void { try invoker.invoke(void, 0xB4EC2312F4E5B1F1, .{heading}); } // 0xB4EC2312F4E5B1F1 0x20C6217C b323
    pub inline fn getGameplayCamRelativePitch() !f32 { return try invoker.invoke(f32, 0x3A6867B4845BEDA2, .{}); } // 0x3A6867B4845BEDA2 0xFC5A4946 b323
    /// This native sets the camera's pitch (rotation on the x-axis).
    pub inline fn setGameplayCamRelativePitch(angle: f32, scaling_factor: f32) !void { try invoker.invoke(void, 0x6D0858B8EDFD2B7D, .{angle, scaling_factor}); } // 0x6D0858B8EDFD2B7D 0x6381B963 b323
    pub inline fn resetGameplayCamFullAttachParentTransformTimer() !void { try invoker.invoke(void, 0x7295C203DD659DFE, .{}); } // 0x7295C203DD659DFE  b2699
    pub inline fn forceCameraRelativeHeadingAndPitch(roll: f32, pitch: f32, yaw: f32) !void { try invoker.invoke(void, 0x48608C3464F58AB4, .{roll, pitch, yaw}); } // 0x48608C3464F58AB4  b505
    pub inline fn forceBonnetCameraRelativeHeadingAndPitch(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0x28B022A17B068A3A, .{p_0, p_1}); } // 0x28B022A17B068A3A  b1734
    /// Does nothing
    pub inline fn setFirstPersonShooterCameraHeading(yaw: f32) !void { try invoker.invoke(void, 0x103991D4A307D472, .{yaw}); } // 0x103991D4A307D472  b323
    pub inline fn setFirstPersonShooterCameraPitch(pitch: f32) !void { try invoker.invoke(void, 0x759E13EBC1C15C5A, .{pitch}); } // 0x759E13EBC1C15C5A  b323
    pub inline fn setScriptedCameraIsFirstPersonThisFrame(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x469F2ECDEC046337, .{p_0}); } // 0x469F2ECDEC046337  b323
    /// Possible shake types (updated b617d):
    /// 
    /// DEATH_FAIL_IN_EFFECT_SHAKE \
    /// DRUNK_SHAKE \
    /// FAMILY5_DRUG_TRIP_SHAKE \
    /// HAND_SHAKE \
    /// JOLT_SHAKE \
    /// LARGE_EXPLOSION_SHAKE \
    /// MEDIUM_EXPLOSION_SHAKE \
    /// SMALL_EXPLOSION_SHAKE \
    /// ROAD_VIBRATION_SHAKE \
    /// SKY_DIVING_SHAKE \
    /// VIBRATE_SHAKE
    /// 
    /// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
    pub inline fn shakeGameplayCam(shake_name: [*c]const u8, intensity: f32) !void { try invoker.invoke(void, 0xFD55E49555E017CF, .{shake_name, intensity}); } // 0xFD55E49555E017CF 0xF2EFE660 b323
    pub inline fn isGameplayCamShaking() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x016C090630DF1F89, .{}); } // 0x016C090630DF1F89 0x3457D681 b323
    /// Sets the amplitude for the gameplay (i.e. 3rd or 1st) camera to shake. Used in script "drunk_controller.ysc.c4" to simulate making the player drunk.
    pub inline fn setGameplayCamShakeAmplitude(amplitude: f32) !void { try invoker.invoke(void, 0xA87E00932DB4D85D, .{amplitude}); } // 0xA87E00932DB4D85D 0x9219D44A b323
    pub inline fn stopGameplayCamShaking(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x0EF93E9F3D08C178, .{p_0}); } // 0x0EF93E9F3D08C178 0xFD569E4E b323
    /// Forces gameplay cam to specified ped as if you were the ped or spectating it
    pub inline fn setGameplayCamFollowPedThisUpdate(ped: types.Ped) !void { try invoker.invoke(void, 0x8BBACBF51DA047A8, .{ped}); } // 0x8BBACBF51DA047A8 0x7D3007A2 b323
    /// Examples when this function will return 0 are: \
    /// - During busted screen. \
    /// - When player is coming out from a hospital. \
    /// - When player is coming out from a police station. \
    /// - When player is buying gun from AmmuNation.
    pub inline fn isGameplayCamRendering() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x39B5D1B10383F0C8, .{}); } // 0x39B5D1B10383F0C8 0x0EF276DA b323
    pub inline fn isInterpolatingFromScriptCams() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3044240D2E0FA842, .{}); } // 0x3044240D2E0FA842 0xC0B00C20 b323
    pub inline fn isInterpolatingToScriptCams() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x705A276EBFF3133D, .{}); } // 0x705A276EBFF3133D 0x60C23785 b323
    pub inline fn setGameplayCamAltitudeFovScalingState(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xDB90C6CCA48940F1, .{p_0}); } // 0xDB90C6CCA48940F1 0x20BFF6E5 b323
    /// Shows the crosshair even if it wouldn't show normally. Only works for one frame, so make sure to call it repeatedly.
    pub inline fn disableGameplayCamAltitudeFovScalingThisUpdate() !void { try invoker.invoke(void, 0xEA7F0AD7E9BA676F, .{}); } // 0xEA7F0AD7E9BA676F 0xA61FF9AC b323
    pub inline fn isGameplayCamLookingBehind() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x70FDA869F3317EA9, .{}); } // 0x70FDA869F3317EA9 0x33C83F17 b323
    pub inline fn setGameplayCamIgnoreEntityCollisionThisUpdate(entity: types.Entity) !void { try invoker.invoke(void, 0x2AED6301F67007D5, .{entity}); } // 0x2AED6301F67007D5 0x2701A9AD b323
    pub inline fn disableCamCollisionForObject(entity: types.Entity) !void { try invoker.invoke(void, 0x49482F9FCD825AAA, .{entity}); } // 0x49482F9FCD825AAA 0xC4736ED3 b323
    pub inline fn bypassCameraCollisionBuoyancyTestThisUpdate() !void { try invoker.invoke(void, 0xA7092AFE81944852, .{}); } // 0xA7092AFE81944852  b2189
    pub inline fn setGameplayCamEntityToLimitFocusOverBoundingSphereThisUpdate(entity: types.Entity) !void { try invoker.invoke(void, 0xFD3151CD37EA2245, .{entity}); } // 0xFD3151CD37EA2245  b323
    /// Sets some flag on cinematic camera
    pub inline fn disableFirstPersonCameraWaterClippingTestThisUpdate() !void { try invoker.invoke(void, 0xB1381B97F70C7B30, .{}); } // 0xB1381B97F70C7B30  b1180
    pub inline fn setFollowCamIgnoreAttachParentMovementThisUpdate() !void { try invoker.invoke(void, 0xDD79DF9F4D26E1C9, .{}); } // 0xDD79DF9F4D26E1C9 0x6B0E9D57 b323
    pub inline fn isSphereVisible(vec: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE33D59DA70B58FDF, .{vec.x, vec.y, vec.z, radius}); } // 0xE33D59DA70B58FDF 0xDD1329E2 b323
    pub inline fn isFollowPedCamActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC6D3D26810C8E0F9, .{}); } // 0xC6D3D26810C8E0F9 0x9F9E856C b323
    /// From the scripts:
    /// 
    /// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_ATTACHED_TO_ROPE_CAMERA", 0); \
    /// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_ON_EXILE1_LADDER_CAMERA", 1500); \
    /// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_CAMERA", 0); \
    /// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_CAMERA", 3000); \
    /// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_FAMILY5_CAMERA", 0); \
    /// CAM::SET_FOLLOW_PED_CAM_THIS_UPDATE("FOLLOW_PED_SKY_DIVING_CAMERA", 0);
    pub inline fn setFollowPedCamThisUpdate(cam_name: [*c]const u8, p_1: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x44A113DD6FFC48D1, .{cam_name, p_1}); } // 0x44A113DD6FFC48D1 0x1425F6AC b323
    pub inline fn useScriptCamForAmbientPopulationOriginThisFrame(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x271401846BD26E92, .{p_0, p_1}); } // 0x271401846BD26E92 0x8DC53629 b323
    pub inline fn setFollowPedCamLadderAlignThisUpdate() !void { try invoker.invoke(void, 0xC8391C309684595A, .{}); } // 0xC8391C309684595A 0x1F9DE6E4 b323
    /// minimum: Degrees between -180f and 180f. \
    /// maximum: Degrees between -180f and 180f.
    /// 
    /// Clamps the gameplay camera's current yaw.
    /// 
    /// Eg. SET_THIRD_PERSON_CAM_RELATIVE_HEADING_LIMITS_THIS_UPDATE(0.0f, 0.0f) will set the horizontal angle directly behind the player.
    pub inline fn setThirdPersonCamRelativeHeadingLimitsThisUpdate(minimum: f32, maximum: f32) !void { try invoker.invoke(void, 0x8F993D26E0CA5E8E, .{minimum, maximum}); } // 0x8F993D26E0CA5E8E 0x749909AC b323
    /// minimum: Degrees between -90f and 90f. \
    /// maximum: Degrees between -90f and 90f.
    /// 
    /// Clamps the gameplay camera's current pitch.
    /// 
    /// Eg. SET_THIRD_PERSON_CAM_RELATIVE_PITCH_LIMITS_THIS_UPDATE(0.0f, 0.0f) will set the vertical angle directly behind the player.
    pub inline fn setThirdPersonCamRelativePitchLimitsThisUpdate(minimum: f32, maximum: f32) !void { try invoker.invoke(void, 0xA516C198B7DCA1E1, .{minimum, maximum}); } // 0xA516C198B7DCA1E1 0xFA3A16E7 b323
    /// Seems to animate the gameplay camera zoom.
    /// 
    /// Eg. SET_THIRD_PERSON_CAM_ORBIT_DISTANCE_LIMITS_THIS_UPDATE(1f, 1000f); \
    /// will animate the camera zooming in from 1000 meters away.
    /// 
    /// Game scripts use it like this:
    /// 
    /// // Setting this to 1 prevents V key from changing zoom \
    /// PLAYER::SET_PLAYER_FORCED_ZOOM(PLAYER::PLAYER_ID(), 1);
    /// 
    /// // These restrict how far you can move cam up/down left/right \
    /// CAM::SET_THIRD_PERSON_CAM_RELATIVE_HEADING_LIMITS_THIS_UPDATE(-20f, 50f); \
    /// CAM::SET_THIRD_PERSON_CAM_RELATIVE_PITCH_LIMITS_THIS_UPDATE(-60f, 0f);
    /// 
    /// CAM::SET_THIRD_PERSON_CAM_ORBIT_DISTANCE_LIMITS_THIS_UPDATE(1f, 1f);
    pub inline fn setThirdPersonCamOrbitDistanceLimitsThisUpdate(p_0: f32, distance: f32) !void { try invoker.invoke(void, 0xDF2E1F7742402E81, .{p_0, distance}); } // 0xDF2E1F7742402E81 0x77340650 b323
    pub inline fn getThirdPersonCamMinOrbitDistanceSpring_() !f32 { return try invoker.invoke(f32, 0xBC456FB703431785, .{}); } // 0xBC456FB703431785  b3095
    pub inline fn getThirdPersonCamMaxOrbitDistanceSpring_() !f32 { return try invoker.invoke(f32, 0xD4592A16D36673ED, .{}); } // 0xD4592A16D36673ED  b3095
    /// Forces gameplay cam to specified vehicle as if you were in it
    pub inline fn setInVehicleCamStateThisUpdate(p_0: types.Vehicle, p_1: c_int) !void { try invoker.invoke(void, 0xE9EA16D6E54CDCA4, .{p_0, p_1}); } // 0xE9EA16D6E54CDCA4 0x4B22C5CB b323
    /// Disables first person camera for the current frame.
    /// 
    /// Found in decompiled scripts: \
    /// GRAPHICS::DRAW_DEBUG_TEXT_2D("Disabling First Person Cam", 0.5, 0.8, 0.0, 0, 0, 255, 255); \
    /// CAM::DISABLE_ON_FOOT_FIRST_PERSON_VIEW_THIS_UPDATE();
    pub inline fn disableOnFootFirstPersonViewThisUpdate() !void { try invoker.invoke(void, 0xDE2EF5DA284CC8DF, .{}); } // 0xDE2EF5DA284CC8DF  b323
    pub inline fn disableFirstPersonFlashEffectThisUpdate() !void { try invoker.invoke(void, 0x59424BD75174C9B1, .{}); } // 0x59424BD75174C9B1  b323
    pub inline fn blockFirstPersonOrientationResetThisUpdate() !void { try invoker.invoke(void, 0x9F97DA93681F87EA, .{}); } // 0x9F97DA93681F87EA  b1734
    pub inline fn getFollowPedCamZoomLevel() !c_int { return try invoker.invoke(c_int, 0x33E6C8EFD0CD93E9, .{}); } // 0x33E6C8EFD0CD93E9 0x57583DF1 b323
    /// See viewmode enum in CAM.GET_FOLLOW_VEHICLE_CAM_VIEW_MODE for return value
    pub inline fn getFollowPedCamViewMode() !c_int { return try invoker.invoke(c_int, 0x8D4D46230B2C353A, .{}); } // 0x8D4D46230B2C353A 0xA65FF946 b323
    /// Sets the type of Player camera:
    /// 
    /// 0 - Third Person Close \
    /// 1 - Third Person Mid \
    /// 2 - Third Person Far \
    /// 4 - First Person
    pub inline fn setFollowPedCamViewMode(view_mode: c_int) !void { try invoker.invoke(void, 0x5A4F9EDF1673F704, .{view_mode}); } // 0x5A4F9EDF1673F704 0x495DBE8D b323
    pub inline fn isFollowVehicleCamActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCBBDE6D335D6D496, .{}); } // 0xCBBDE6D335D6D496 0x8DD49B77 b323
    pub inline fn setFollowVehicleCamHighAngleModeThisUpdate(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x91EF6EE6419E5B97, .{p_0}); } // 0x91EF6EE6419E5B97 0x9DB5D391 b323
    pub inline fn setFollowVehicleCamHighAngleModeEveryUpdate(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x9DFE13ECDC1EC196, .{p_0, p_1}); } // 0x9DFE13ECDC1EC196 0x92302899 b323
    pub inline fn setTableGamesCameraThisUpdate(hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x79C0E43EB9B944E2, .{hash}); } // 0x79C0E43EB9B944E2  b1734
    pub inline fn getFollowVehicleCamZoomLevel() !c_int { return try invoker.invoke(c_int, 0xEE82280AB767B690, .{}); } // 0xEE82280AB767B690 0x8CD67DE3 b323
    pub inline fn setFollowVehicleCamZoomLevel(zoom_level: c_int) !void { try invoker.invoke(void, 0x19464CB6E4078C8A, .{zoom_level}); } // 0x19464CB6E4078C8A 0x8F55EBBE b323
    /// Returns the type of camera:
    /// 
    /// enum _viewmode //0xA11D7CA8 \
    /// { \
    ///     THIRD_PERSON_NEAR = 0,
    ///     THIRD_PERSON_MEDIUM = 1,
    ///     THIRD_PERSON_FAR = 2,
    ///     CINEMATIC = 3,
    ///     FIRST_PERSON = 4
    /// };
    pub inline fn getFollowVehicleCamViewMode() !c_int { return try invoker.invoke(c_int, 0xA4FF579AC0E3AAAE, .{}); } // 0xA4FF579AC0E3AAAE 0xA4B4DB03 b323
    /// Sets the type of Player camera in vehicles: \
    /// viewmode: see CAM.GET_FOLLOW_VEHICLE_CAM_VIEW_MODE
    pub inline fn setFollowVehicleCamViewMode(view_mode: c_int) !void { try invoker.invoke(void, 0xAC253D7842768F48, .{view_mode}); } // 0xAC253D7842768F48 0xC4FBBBD3 b323
    /// context: see _GET_CAM_ACTIVE_VIEW_MODE_CONTEXT
    pub inline fn getCamViewModeForContext(context: c_int) !c_int { return try invoker.invoke(c_int, 0xEE778F8C7E1142E2, .{context}); } // 0xEE778F8C7E1142E2 0xF3B148A6 b323
    /// context: see _GET_CAM_ACTIVE_VIEW_MODE_CONTEXT, viewmode: see CAM.GET_FOLLOW_VEHICLE_CAM_VIEW_MODE
    pub inline fn setCamViewModeForContext(context: c_int, view_mode: c_int) !void { try invoker.invoke(void, 0x2A2173E46DAECD12, .{context, view_mode}); } // 0x2A2173E46DAECD12 0x1DEBCB45 b323
    /// enum Context \
    /// { \
    ///     ON_FOOT,
    ///     IN_VEHICLE,
    ///     ON_BIKE,
    ///     IN_BOAT,
    ///     IN_AIRCRAFT,
    ///     IN_SUBMARINE,
    ///     IN_HELI,
    ///     IN_TURRET
    /// };
    pub inline fn getCamActiveViewModeContext() !c_int { return try invoker.invoke(c_int, 0x19CAFA3C87F7C2FF, .{}); } // 0x19CAFA3C87F7C2FF  b323
    pub inline fn useVehicleCamStuntSettingsThisUpdate() !void { try invoker.invoke(void, 0x6493CF69859B116A, .{}); } // 0x6493CF69859B116A  b791
    /// Sets gameplay camera to hash
    pub inline fn useDedicatedStuntCameraThisUpdate(cam_name: [*c]const u8) !void { try invoker.invoke(void, 0x425A920FDB9A0DDA, .{cam_name}); } // 0x425A920FDB9A0DDA  b1180
    pub inline fn forceVehicleCamStuntSettingsThisUpdate() !void { try invoker.invoke(void, 0x0AA27680A0BD43FA, .{}); } // 0x0AA27680A0BD43FA  b1103
    pub inline fn setFollowVehicleCamSeatThisUpdate(seat_index: c_int) !void { try invoker.invoke(void, 0x5C90CAB09951A12F, .{seat_index}); } // 0x5C90CAB09951A12F  b1365
    pub inline fn isAimCamActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x68EDDA28A5976D07, .{}); } // 0x68EDDA28A5976D07 0xC24B4F6F b323
    pub inline fn isAimCamActiveInAccurateMode() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74BD83EA840F6BC9, .{}); } // 0x74BD83EA840F6BC9 0x8F320DE4 b323
    pub inline fn isFirstPersonAimCamActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5E346D934122613F, .{}); } // 0x5E346D934122613F 0xD6280468 b323
    pub inline fn disableAimCamThisUpdate() !void { try invoker.invoke(void, 0x1A31FE0049E542F6, .{}); } // 0x1A31FE0049E542F6 0x1BAA7182 b323
    pub inline fn getFirstPersonAimCamZoomFactor() !f32 { return try invoker.invoke(f32, 0x7EC52CC40597D170, .{}); } // 0x7EC52CC40597D170 0x33951005 b323
    pub inline fn setFirstPersonAimCamZoomFactor(zoom_factor: f32) !void { try invoker.invoke(void, 0x70894BD0915C5BCA, .{zoom_factor}); } // 0x70894BD0915C5BCA 0x9F4AF763 b323
    pub inline fn setFirstPersonAimCamZoomFactorLimitsThisUpdate(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0xCED08CBE8EBB97C7, .{p_0, p_1}); } // 0xCED08CBE8EBB97C7 0x68BA0730 b323
    pub inline fn setFirstPersonAimCamRelativeHeadingLimitsThisUpdate(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0x2F7F2B26DD3F18EE, .{p_0, p_1}); } // 0x2F7F2B26DD3F18EE 0x2F29F0D5 b323
    pub inline fn setFirstPersonAimCamRelativePitchLimitsThisUpdate(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0xBCFC632DB7673BF0, .{p_0, p_1}); } // 0xBCFC632DB7673BF0 0x76DAC96C b323
    pub inline fn setFirstPersonAimCamNearClipThisUpdate(p_0: f32) !void { try invoker.invoke(void, 0x0AF7B437918103B3, .{p_0}); } // 0x0AF7B437918103B3 0x0E21069D b323
    pub inline fn setThirdPersonAimCamNearClipThisUpdate(p_0: f32) !void { try invoker.invoke(void, 0x42156508606DE65E, .{p_0}); } // 0x42156508606DE65E 0x71E9C63E b323
    pub inline fn setAllowCustomVehicleDriveByCamThisUpdate(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x4008EDF7D6E48175, .{p_0}); } // 0x4008EDF7D6E48175 0xD1EEBC45 b323
    pub inline fn forceTightspaceCustomFramingThisUpdate() !void { try invoker.invoke(void, 0x380B4968D1E09E55, .{}); } // 0x380B4968D1E09E55  b1290
    pub inline fn getFinalRenderedCamCoord() !types.Vector3 { return try invoker.invoke(types.Vector3, 0xA200EB1EE790F448, .{}); } // 0xA200EB1EE790F448 0x9C84BDA0 b323
    /// p0 seems to consistently be 2 across scripts
    /// 
    /// Function is called faily often by CAM::CREATE_CAM_WITH_PARAMS
    pub inline fn getFinalRenderedCamRot(rotation_order: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x5B4E4C817FCC2DFB, .{rotation_order}); } // 0x5B4E4C817FCC2DFB 0x1FFBEFC5 b323
    pub inline fn getFinalRenderedRemotePlayerCamRot(player: types.Player, rotation_order: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x26903D9CD1175F2C, .{player, rotation_order}); } // 0x26903D9CD1175F2C 0xACADF916 b323
    /// Gets some camera fov
    pub inline fn getFinalRenderedCamFov() !f32 { return try invoker.invoke(f32, 0x80EC114669DAEFF4, .{}); } // 0x80EC114669DAEFF4 0x721B763B b323
    pub inline fn getFinalRenderedRemotePlayerCamFov(player: types.Player) !f32 { return try invoker.invoke(f32, 0x5F35F6732C3FBBA0, .{player}); } // 0x5F35F6732C3FBBA0 0x23E3F106 b323
    pub inline fn getFinalRenderedCamNearClip() !f32 { return try invoker.invoke(f32, 0xD0082607100D7193, .{}); } // 0xD0082607100D7193 0x457AE195 b323
    pub inline fn getFinalRenderedCamFarClip() !f32 { return try invoker.invoke(f32, 0xDFC8CBC606FDB0FC, .{}); } // 0xDFC8CBC606FDB0FC 0x46CB3A49 b323
    pub inline fn getFinalRenderedCamNearDof() !f32 { return try invoker.invoke(f32, 0xA03502FC581F7D9B, .{}); } // 0xA03502FC581F7D9B 0x19297A7A b323
    pub inline fn getFinalRenderedCamFarDof() !f32 { return try invoker.invoke(f32, 0x9780F32BCAF72431, .{}); } // 0x9780F32BCAF72431 0xF24777CA b323
    pub inline fn getFinalRenderedCamMotionBlurStrength() !f32 { return try invoker.invoke(f32, 0x162F9D995753DC19, .{}); } // 0x162F9D995753DC19 0x38992E83 b323
    pub inline fn setGameplayCoordHint(vec: types.Vector3, duration: c_int, blend_out_duration: c_int, blend_in_duration: c_int, p_6: c_int) !void { try invoker.invoke(void, 0xD51ADCD2D8BC0FB3, .{vec.x, vec.y, vec.z, duration, blend_out_duration, blend_in_duration, p_6}); } // 0xD51ADCD2D8BC0FB3 0xF27483C9 b323
    pub inline fn setGameplayPedHint(ped: types.Ped, vec_1__: types.Vector3, p_4: windows.BOOL, duration: c_int, blend_out_duration: c_int, blend_in_duration: c_int) !void { try invoker.invoke(void, 0x2B486269ACD548D3, .{ped, vec_1__.x, vec_1__.y, vec_1__.z, p_4, duration, blend_out_duration, blend_in_duration}); } // 0x2B486269ACD548D3 0x7C27343E b323
    /// Focuses the camera on the specified vehicle.
    pub inline fn setGameplayVehicleHint(vehicle: types.Vehicle, offset__: types.Vector3, p_4: windows.BOOL, time: c_int, ease_in_time: c_int, ease_out_time: c_int) !void { try invoker.invoke(void, 0xA2297E18F3E71C2E, .{vehicle, offset__.x, offset__.y, offset__.z, p_4, time, ease_in_time, ease_out_time}); } // 0xA2297E18F3E71C2E 0x2C9A11D8 b323
    pub inline fn setGameplayObjectHint(object: types.Object, offset__: types.Vector3, p_4: windows.BOOL, time: c_int, ease_in_time: c_int, ease_out_time: c_int) !void { try invoker.invoke(void, 0x83E87508A2CA2AC6, .{object, offset__.x, offset__.y, offset__.z, p_4, time, ease_in_time, ease_out_time}); } // 0x83E87508A2CA2AC6 0x2ED5E2F8 b323
    /// p8 could be some sort of flag. Scripts use: \
    /// -244429742 \
    /// 0 \
    /// 1726668277 \
    /// 1844968929
    pub inline fn setGameplayEntityHint(entity: types.Entity, offset__: types.Vector3, p_4: windows.BOOL, time: c_int, ease_in_time: c_int, ease_out_time: c_int, p_8: c_int) !void { try invoker.invoke(void, 0x189E955A8313E298, .{entity, offset__.x, offset__.y, offset__.z, p_4, time, ease_in_time, ease_out_time, p_8}); } // 0x189E955A8313E298 0x66C32306 b323
    pub inline fn isGameplayHintActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE520FF1AD2785B40, .{}); } // 0xE520FF1AD2785B40 0xAD8DA205 b323
    pub inline fn stopGameplayHint(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xF46C581C61718916, .{p_0}); } // 0xF46C581C61718916 0x1BC28B7B b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn stopGameplayHintBeingCancelledThisUpdate(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xCCD078C2665D2973, .{p_0}); } // 0xCCD078C2665D2973 0xCAFEE798 b323
    pub inline fn stopCodeGameplayHint(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x247ACBC4ABBC9D1C, .{p_0}); } // 0x247ACBC4ABBC9D1C  b323
    pub inline fn isCodeGameplayHintActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBF72910D0F26F025, .{}); } // 0xBF72910D0F26F025  b323
    pub inline fn setGameplayHintFov(_f_o_v: f32) !void { try invoker.invoke(void, 0x513403FB9C56211F, .{_f_o_v}); } // 0x513403FB9C56211F 0x96FD173B b323
    pub inline fn setGameplayHintFollowDistanceScalar(value: f32) !void { try invoker.invoke(void, 0xF8BDBF3D573049A1, .{value}); } // 0xF8BDBF3D573049A1 0x72E8CD3A b323
    pub inline fn setGameplayHintBaseOrbitPitchOffset(value: f32) !void { try invoker.invoke(void, 0xD1F8363DFAD03848, .{value}); } // 0xD1F8363DFAD03848 0x79472AE3 b323
    pub inline fn setGameplayHintCameraRelativeSideOffset(x_offset: f32) !void { try invoker.invoke(void, 0x5D7B620DAE436138, .{x_offset}); } // 0x5D7B620DAE436138 0xFC7464A0 b323
    pub inline fn setGameplayHintCameraRelativeVerticalOffset(y_offset: f32) !void { try invoker.invoke(void, 0xC92717EF615B6704, .{y_offset}); } // 0xC92717EF615B6704 0x3554AA0E b323
    pub inline fn setGameplayHintCameraBlendToFollowPedMediumViewMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE3433EADAAF7EE40, .{toggle}); } // 0xE3433EADAAF7EE40 0x2F0CE859 b323
    pub inline fn setCinematicButtonActive(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x51669F7D1FB53D9F, .{p_0}); } // 0x51669F7D1FB53D9F 0x3FBC5D00 b323
    pub inline fn isCinematicCamRendering() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB15162CB5826E9E8, .{}); } // 0xB15162CB5826E9E8 0x80471AD9 b323
    /// p0 argument found in the b617d scripts: "DRUNK_SHAKE"
    /// 
    /// Full list of cam shake types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/camShakeTypesCompact.json
    pub inline fn shakeCinematicCam(shake_type: [*c]const u8, amount: f32) !void { try invoker.invoke(void, 0xDCE214D9ED58F3CF, .{shake_type, amount}); } // 0xDCE214D9ED58F3CF 0x61815F31 b323
    pub inline fn isCinematicCamShaking() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBBC08F6B4CB8FF0A, .{}); } // 0xBBC08F6B4CB8FF0A 0x8376D939 b323
    pub inline fn setCinematicCamShakeAmplitude(p_0: f32) !void { try invoker.invoke(void, 0xC724C701C30B2FE7, .{p_0}); } // 0xC724C701C30B2FE7 0x67510C4B b323
    pub inline fn stopCinematicCamShaking(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x2238E588E588A6D7, .{p_0}); } // 0x2238E588E588A6D7 0x71C12904 b323
    pub inline fn disableCinematicBonnetCameraThisUpdate() !void { try invoker.invoke(void, 0xADFF1B2A555F5FBA, .{}); } // 0xADFF1B2A555F5FBA 0x5AC6DAC9 b323
    pub inline fn disableCinematicVehicleIdleModeThisUpdate() !void { try invoker.invoke(void, 0x62ECFCFDEE7885D6, .{}); } // 0x62ECFCFDEE7885D6 0x837F8581 b323
    /// Resets the vehicle idle camera timer. Calling this in a loop will disable the idle camera.
    pub inline fn invalidateCinematicVehicleIdleMode() !void { try invoker.invoke(void, 0x9E4CFFF989258472, .{}); } // 0x9E4CFFF989258472 0x65DDE8AF b323
    /// Resets the idle camera timer. Calling that in a loop once every few seconds is enough to disable the idle cinematic camera.
    pub inline fn invalidateIdleCam() !void { try invoker.invoke(void, 0xF4F2C0D4EE209E20, .{}); } // 0xF4F2C0D4EE209E20 0xD75CDD75 b323
    pub inline fn isCinematicIdleCamRendering() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCA9D2AA3E326D720, .{}); } // 0xCA9D2AA3E326D720 0x96A07066 b323
    pub inline fn isCinematicFirstPersonVehicleInteriorCamRendering() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4F32C0D5A90A9B40, .{}); } // 0x4F32C0D5A90A9B40  b323
    /// hash is always JOAAT("CAMERA_MAN_SHOT") in decompiled scripts
    pub inline fn createCinematicShot(p_0: types.Hash, time: c_int, p_2: windows.BOOL, entity: types.Entity) !void { try invoker.invoke(void, 0x741B0129D4560F31, .{p_0, time, p_2, entity}); } // 0x741B0129D4560F31 0xAC494E35 b323
    /// Hash is always JOAAT("CAMERA_MAN_SHOT") in decompiled scripts
    pub inline fn isCinematicShotActive(p_0: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCC9F3371A7C28BC9, .{p_0}); } // 0xCC9F3371A7C28BC9 0xA4049042 b323
    /// Only used once in carsteal3 with p0 set to -1096069633 (CAMERA_MAN_SHOT)
    pub inline fn stopCinematicShot(p_0: types.Hash) !void { try invoker.invoke(void, 0x7660C6E75D3A078E, .{p_0}); } // 0x7660C6E75D3A078E 0xD78358C5 b323
    pub inline fn forceCinematicRenderingThisUpdate(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA41BCD7213805AAC, .{toggle}); } // 0xA41BCD7213805AAC 0xFBB85E02 b323
    pub inline fn setCinematicNewsChannelActiveThisUpdate() !void { try invoker.invoke(void, 0xDC9DA9E8789F5246, .{}); } // 0xDC9DA9E8789F5246 0x4938C82F b323
    /// Toggles the vehicle cinematic cam; requires the player ped to be in a vehicle to work.
    pub inline fn setCinematicModeActive(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDCF0754AC3D6FD4E, .{toggle}); } // 0xDCF0754AC3D6FD4E 0x2009E747 b323
    pub inline fn isInVehicleMobilePhoneCameraRendering() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1F2300CB7FA7B7F6, .{}); } // 0x1F2300CB7FA7B7F6 0x6739AD55 b323
    pub inline fn disableCinematicSlowMoThisUpdate() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x17FCA7199A530203, .{}); } // 0x17FCA7199A530203  b323
    pub inline fn isBonnetCinematicCamRendering() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD7360051C885628B, .{}); } // 0xD7360051C885628B 0x1DD55F13 b372
    /// Tests some cinematic camera flags
    pub inline fn isCinematicCamInputActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF5F1E89A970B7796, .{}); } // 0xF5F1E89A970B7796 0x1A900C84 b1493
    pub inline fn ignoreMenuPreferenceForBonnetCameraThisUpdate() !void { try invoker.invoke(void, 0x7B8A361C1813FBEF, .{}); } // 0x7B8A361C1813FBEF  b573
    pub inline fn bypassCutsceneCamRenderingThisUpdate() !void { try invoker.invoke(void, 0xDB629FFD9285FA06, .{}); } // 0xDB629FFD9285FA06  b323
    pub inline fn stopCutsceneCamShaking(p_0: types.Any) !void { try invoker.invoke(void, 0x324C5AA411DA7737, .{p_0}); } // 0x324C5AA411DA7737  b323
    /// Hardcoded to only work in multiplayer.
    pub inline fn setCutsceneCamFarClipThisUpdate(p_0: f32) !void { try invoker.invoke(void, 0x12DED8CA53D47EA5, .{p_0}); } // 0x12DED8CA53D47EA5 0x067BA6F5 b323
    pub inline fn getFocusPedOnScreen(p_0: f32, p_1: c_int, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: c_int, p_8: c_int) !types.Ped { return try invoker.invoke(types.Ped, 0x89215EC747DF244A, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0x89215EC747DF244A 0xFD99BE2B b323
    pub inline fn disableNearClipScanThisUpdate() !void { try invoker.invoke(void, 0x5A43C76F7FC7BA5F, .{}); } // 0x5A43C76F7FC7BA5F 0xE206C450 b323
    /// if p0 is 0, effect is cancelled
    /// 
    /// if p0 is 1, effect zooms in, gradually tilts cam clockwise apx 30 degrees, wobbles slowly. Motion blur is active until cancelled.
    /// 
    /// if p0 is 2, effect immediately tilts cam clockwise apx 30 degrees, begins to wobble slowly, then gradually tilts cam back to normal. The wobbling will continue until the effect is cancelled.
    pub inline fn setCamDeathFailEffectState(p_0: c_int) !void { try invoker.invoke(void, 0x80C8B1846639BB19, .{p_0}); } // 0x80C8B1846639BB19 0xB06CCD38 b323
    pub inline fn setFirstPersonFlashEffectType(p_0: types.Any) !void { try invoker.invoke(void, 0x5C41E6BABC9E2112, .{p_0}); } // 0x5C41E6BABC9E2112  b323
    /// From b617 scripts:
    /// 
    /// CAM::SET_FIRST_PERSON_FLASH_EFFECT_VEHICLE_MODEL_NAME("DINGHY"); \
    /// CAM::SET_FIRST_PERSON_FLASH_EFFECT_VEHICLE_MODEL_NAME("ISSI2"); \
    /// CAM::SET_FIRST_PERSON_FLASH_EFFECT_VEHICLE_MODEL_NAME("SPEEDO");
    pub inline fn setFirstPersonFlashEffectVehicleModelName(vehicle_name: [*c]const u8) !void { try invoker.invoke(void, 0x21E253A7F8DA5DFB, .{vehicle_name}); } // 0x21E253A7F8DA5DFB  b323
    pub inline fn setFirstPersonFlashEffectVehicleModelHash(vehicle_model: types.Hash) !void { try invoker.invoke(void, 0x11FA5D3479C7DD47, .{vehicle_model}); } // 0x11FA5D3479C7DD47  b323
    pub inline fn isAllowedIndependentCameraModes() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEAF0FA793D05C592, .{}); } // 0xEAF0FA793D05C592  b323
    pub inline fn cameraPreventCollisionSettingsForTripleheadInInteriorsThisUpdate() !void { try invoker.invoke(void, 0x62374889A4D59F72, .{}); } // 0x62374889A4D59F72  b877
    pub inline fn replayGetMaxDistanceAllowedFromPlayer() !f32 { return try invoker.invoke(f32, 0x8BFCEB5EA1B161B6, .{}); } // 0x8BFCEB5EA1B161B6  b323
};

pub const Clock = struct
{
    /// SET_CLOCK_TIME(12, 34, 56);
    pub inline fn setClockTime(hour: c_int, minute: c_int, second: c_int) !void { try invoker.invoke(void, 0x47C3B5848C3E45D8, .{hour, minute, second}); } // 0x47C3B5848C3E45D8 0x26F6AF14 b323
    pub inline fn pauseClock(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4055E40BD2DBEC1D, .{toggle}); } // 0x4055E40BD2DBEC1D 0xB02D6124 b323
    pub inline fn advanceClockTimeTo(hour: c_int, minute: c_int, second: c_int) !void { try invoker.invoke(void, 0xC8CA9670B9D83B3B, .{hour, minute, second}); } // 0xC8CA9670B9D83B3B 0x57B8DA7C b323
    pub inline fn addToClockTime(hours: c_int, minutes: c_int, seconds: c_int) !void { try invoker.invoke(void, 0xD716F30D8C8980E2, .{hours, minutes, seconds}); } // 0xD716F30D8C8980E2 0xCC40D20D b323
    /// Gets the current ingame hour, expressed without zeros. (09:34 will be represented as 9)
    pub inline fn getClockHours() !c_int { return try invoker.invoke(c_int, 0x25223CA6B4D20B7F, .{}); } // 0x25223CA6B4D20B7F 0x7EF8316F b323
    /// Gets the current ingame clock minute.
    pub inline fn getClockMinutes() !c_int { return try invoker.invoke(c_int, 0x13D2B8ADD79640F2, .{}); } // 0x13D2B8ADD79640F2 0x94AAC486 b323
    /// Gets the current ingame clock second. Note that ingame clock seconds change really fast since a day in GTA is only 48 minutes in real life.
    pub inline fn getClockSeconds() !c_int { return try invoker.invoke(c_int, 0x494E97C2EF27C470, .{}); } // 0x494E97C2EF27C470 0x099C927E b323
    pub inline fn setClockDate(day: c_int, month: c_int, year: c_int) !void { try invoker.invoke(void, 0xB096419DF0D06CE7, .{day, month, year}); } // 0xB096419DF0D06CE7 0x96891C94 b323
    /// Gets the current day of the week.
    /// 
    /// 0: Sunday \
    /// 1: Monday \
    /// 2: Tuesday \
    /// 3: Wednesday \
    /// 4: Thursday \
    /// 5: Friday \
    /// 6: Saturday
    pub inline fn getClockDayOfWeek() !c_int { return try invoker.invoke(c_int, 0xD972E4BD7AEB235F, .{}); } // 0xD972E4BD7AEB235F 0x84E4A289 b323
    pub inline fn getClockDayOfMonth() !c_int { return try invoker.invoke(c_int, 0x3D10BC92A4DB1D35, .{}); } // 0x3D10BC92A4DB1D35 0xC7A5ACB7 b323
    pub inline fn getClockMonth() !c_int { return try invoker.invoke(c_int, 0xBBC72712E80257A1, .{}); } // 0xBBC72712E80257A1 0x3C48A3D5 b323
    pub inline fn getClockYear() !c_int { return try invoker.invoke(c_int, 0x961777E64BDAF717, .{}); } // 0x961777E64BDAF717 0xB8BECF15 b323
    pub inline fn getMillisecondsPerGameMinute() !c_int { return try invoker.invoke(c_int, 0x2F8B4D1C595B11DB, .{}); } // 0x2F8B4D1C595B11DB 0x3B74095C b323
    /// Gets system time as year, month, day, hour, minute and second.
    /// 
    /// Example usage:
    /// 
    ///     int year;
    ///  int month; \
    ///     int day;
    ///   int hour;
    ///  int minute; \
    ///    int second;
    /// 
    ///  TIME::GET_POSIX_TIME(&year, &month, &day, &hour, &minute, &second);
    /// 
    pub inline fn getPosixTime(year: [*c]c_int, month: [*c]c_int, day: [*c]c_int, hour: [*c]c_int, minute: [*c]c_int, second: [*c]c_int) !void { try invoker.invoke(void, 0xDA488F299A5B164E, .{year, month, day, hour, minute, second}); } // 0xDA488F299A5B164E 0xE15A5281 b323
    /// Gets current UTC time
    pub inline fn getUtcTime(year: [*c]c_int, month: [*c]c_int, day: [*c]c_int, hour: [*c]c_int, minute: [*c]c_int, second: [*c]c_int) !void { try invoker.invoke(void, 0x8117E09A19EEF4D3, .{year, month, day, hour, minute, second}); } // 0x8117E09A19EEF4D3 0xC589CD7D b323
    /// Gets local system time as year, month, day, hour, minute and second.
    /// 
    /// Example usage:
    /// 
    /// int year; \
    /// int month; \
    /// int day; \
    /// int hour; \
    /// int minute; \
    /// int second; \
    /// or use std::tm struct
    /// 
    /// TIME::GET_LOCAL_TIME(&year, &month, &day, &hour, &minute, &second);
    /// 
    pub inline fn getLocalTime(year: [*c]c_int, month: [*c]c_int, day: [*c]c_int, hour: [*c]c_int, minute: [*c]c_int, second: [*c]c_int) !void { try invoker.invoke(void, 0x50C7A99057A69748, .{year, month, day, hour, minute, second}); } // 0x50C7A99057A69748 0x124BCFA2 b323
};

pub const Cutscene = struct
{
    /// flags: Usually 8 \
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn requestCutscene(cutscene_name: [*c]const u8, flags: c_int) !void { try invoker.invoke(void, 0x7A86743F475D9E09, .{cutscene_name, flags}); } // 0x7A86743F475D9E09 0xB5977853 b323
    /// flags: Usually 8
    /// 
    /// playbackFlags: Which scenes should be played. \
    /// Example: 0x105 (bit 0, 2 and 8 set) will enable scene 1, 3 and 9. \
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn requestCutsceneWithPlaybackList(cutscene_name: [*c]const u8, playback_flags: c_int, flags: c_int) !void { try invoker.invoke(void, 0xC23DE0E91C30B58C, .{cutscene_name, playback_flags, flags}); } // 0xC23DE0E91C30B58C 0xD98F656A b323
    pub inline fn removeCutscene() !void { try invoker.invoke(void, 0x440AF51A3462B86F, .{}); } // 0x440AF51A3462B86F 0x8052F533 b323
    pub inline fn hasCutsceneLoaded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC59F528E9AB9F339, .{}); } // 0xC59F528E9AB9F339 0xF9998582 b323
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn hasThisCutsceneLoaded(cutscene_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x228D3D94F8A11C3C, .{cutscene_name}); } // 0x228D3D94F8A11C3C 0x3C5619F2 b323
    /// Sets the cutscene's owning thread ID.
    pub inline fn setScriptCanStartCutscene(thread_id: c_int) !void { try invoker.invoke(void, 0x8D9DF6ECA8768583, .{thread_id}); } // 0x8D9DF6ECA8768583 0x25A2CABC b323
    pub inline fn canRequestAssetsForCutsceneEntity() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB56BBBCC2955D9CB, .{}); } // 0xB56BBBCC2955D9CB 0xDD8878E9 b323
    pub inline fn isCutscenePlaybackFlagSet(flag: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71B74D2AE19338D0, .{flag}); } // 0x71B74D2AE19338D0 0x7B93CDAA b323
    pub inline fn setCutsceneEntityStreamingFlags(cutscene_ent_name: [*c]const u8, p_1: c_int, p_2: c_int) !void { try invoker.invoke(void, 0x4C61C75BEE8184C2, .{cutscene_ent_name, p_1, p_2}); } // 0x4C61C75BEE8184C2 0x47DB08A9 b323
    /// Simply loads the cutscene and doesn't do extra stuff that REQUEST_CUTSCENE does. \
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn requestCutFile(cutscene_name: [*c]const u8) !void { try invoker.invoke(void, 0x06A3524161C502BA, .{cutscene_name}); } // 0x06A3524161C502BA 0x0D732CD6 b323
    /// Simply checks if the cutscene has loaded and doesn't check via CutSceneManager as opposed to HAS_[THIS]_CUTSCENE_LOADED. \
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn hasCutFileLoaded(cutscene_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA1C996C2A744262E, .{cutscene_name}); } // 0xA1C996C2A744262E 0x56D5B144 b323
    /// Simply unloads the cutscene and doesn't do extra stuff that REMOVE_CUTSCENE does. \
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn removeCutFile(cutscene_name: [*c]const u8) !void { try invoker.invoke(void, 0xD00D76A7DFC9D852, .{cutscene_name}); } // 0xD00D76A7DFC9D852 0xB70D7C6D b323
    pub inline fn getCutFileOffset(cutscene_name: [*c]const u8, index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x1FA904B60E492336, .{cutscene_name, index}); } // 0x1FA904B60E492336  b3570
    /// Full list of cutscene names by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/cutsceneNames.json
    pub inline fn getCutFileConcatCount(cutscene_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x0ABC54DE641DC0FC, .{cutscene_name}); } // 0x0ABC54DE641DC0FC 0xFD8B1AC2 b323
    /// flags: Usually 0.
    pub inline fn startCutscene(flags: c_int) !void { try invoker.invoke(void, 0x186D5CB5E7B0FF7B, .{flags}); } // 0x186D5CB5E7B0FF7B 0x210106F6 b323
    /// flags: Usually 0.
    pub inline fn startCutsceneAtCoords(vec: types.Vector3, flags: c_int) !void { try invoker.invoke(void, 0x1C9ADDA3244A1FBF, .{vec.x, vec.y, vec.z, flags}); } // 0x1C9ADDA3244A1FBF 0x58BEA436 b323
    pub inline fn stopCutscene(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xC7272775B4DC786E, .{p_0}); } // 0xC7272775B4DC786E 0x5EE84DC7 b323
    pub inline fn stopCutsceneImmediately() !void { try invoker.invoke(void, 0xD220BDD222AC4A1E, .{}); } // 0xD220BDD222AC4A1E 0xF528A2AD b323
    /// p3 could be heading. Needs more research.
    pub inline fn setCutsceneOrigin(vec: types.Vector3, p_3: f32, p_4: c_int) !void { try invoker.invoke(void, 0xB812B3FD1C01CF27, .{vec.x, vec.y, vec.z, p_3, p_4}); } // 0xB812B3FD1C01CF27 0xB0AD7792 b323
    pub inline fn setCutsceneOriginAndOrientation(vec_1__: types.Vector3, vec_2__: types.Vector3, p_6: c_int) !void { try invoker.invoke(void, 0x011883F41211432A, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_6}); } // 0x011883F41211432A  b323
    pub inline fn getCutsceneTime() !c_int { return try invoker.invoke(c_int, 0xE625BEABBAFFDAB9, .{}); } // 0xE625BEABBAFFDAB9 0x53F5B5AB b323
    pub inline fn getCutscenePlayTime() !c_int { return try invoker.invoke(c_int, 0x710286BC5EF4D6E1, .{}); } // 0x710286BC5EF4D6E1  b3258
    pub inline fn getCutsceneTotalDuration() !c_int { return try invoker.invoke(c_int, 0xEE53B14A19E480D4, .{}); } // 0xEE53B14A19E480D4 0x0824EBE8 b323
    pub inline fn getCutsceneEndTime() !c_int { return try invoker.invoke(c_int, 0x971D7B15BCDBEF99, .{}); } // 0x971D7B15BCDBEF99  b1734
    pub inline fn getCutscenePlayDuration() !c_int { return try invoker.invoke(c_int, 0x5D583F71C901F2A3, .{}); } // 0x5D583F71C901F2A3  b2802
    pub inline fn wasCutsceneSkipped() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x40C8656EDAEDD569, .{}); } // 0x40C8656EDAEDD569 0xC9B6949D b323
    pub inline fn hasCutsceneFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7C0A893088881D57, .{}); } // 0x7C0A893088881D57 0x5DED14B4 b323
    pub inline fn isCutsceneActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x991251AFC3981F84, .{}); } // 0x991251AFC3981F84 0xCCE2FE9D b323
    pub inline fn isCutscenePlaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD3C2E180A40F031E, .{}); } // 0xD3C2E180A40F031E 0xA3A78392 b323
    pub inline fn getCutsceneSectionPlaying() !c_int { return try invoker.invoke(c_int, 0x49010A6A396553D8, .{}); } // 0x49010A6A396553D8 0x1026F0D6 b323
    pub inline fn getEntityIndexOfCutsceneEntity(cutscene_ent_name: [*c]const u8, model_hash: types.Hash) !types.Entity { return try invoker.invoke(types.Entity, 0x0A2E9FDB9A8C62F6, .{cutscene_ent_name, model_hash}); } // 0x0A2E9FDB9A8C62F6 0x1D09ABC7 b323
    pub inline fn getCutsceneConcatSectionPlaying() !c_int { return try invoker.invoke(c_int, 0x583DF8E3D4AFBD98, .{}); } // 0x583DF8E3D4AFBD98 0x5AE68AE6 b323
    /// This function is hard-coded to always return 1.
    pub inline fn isCutsceneAuthorized(cutscene_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4CEBC1ED31E8925E, .{cutscene_name}); } // 0x4CEBC1ED31E8925E  b323
    pub inline fn doesCutsceneHandleExist(cutscene_handle: c_int) !c_int { return try invoker.invoke(c_int, 0x4FCD976DA686580C, .{cutscene_handle}); } // 0x4FCD976DA686580C  b1290
    pub inline fn registerEntityForCutscene(cutscene_ped: types.Ped, cutscene_ent_name: [*c]const u8, p_2: c_int, model_hash: types.Hash, p_4: c_int) !void { try invoker.invoke(void, 0xE40C1C56DF95C2E8, .{cutscene_ped, cutscene_ent_name, p_2, model_hash, p_4}); } // 0xE40C1C56DF95C2E8 0x7CBC3EC7 b323
    pub inline fn getEntityIndexOfRegisteredEntity(cutscene_ent_name: [*c]const u8, model_hash: types.Hash) !types.Entity { return try invoker.invoke(types.Entity, 0xC0741A26499654CD, .{cutscene_ent_name, model_hash}); } // 0xC0741A26499654CD 0x46D18755 b323
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn setVehicleModelPlayerWillExitScene(model_hash: types.Hash) !void { try invoker.invoke(void, 0x7F96F23FA9B73327, .{model_hash}); } // 0x7F96F23FA9B73327  b323
    /// Only used twice in R* scripts
    pub inline fn setCutsceneTriggerArea(vec_1__: types.Vector3, vec_2__: types.Vector3) !void { try invoker.invoke(void, 0x9896CE4721BE84BA, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x9896CE4721BE84BA 0x9D76D9DE b323
    /// modelHash (p1) was always 0 in R* scripts
    pub inline fn canSetEnterStateForRegisteredEntity(cutscene_ent_name: [*c]const u8, model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x645D0B458D8E17B5, .{cutscene_ent_name, model_hash}); } // 0x645D0B458D8E17B5 0x55C30B26 b323
    pub inline fn canSetExitStateForRegisteredEntity(cutscene_ent_name: [*c]const u8, model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C6A6451C79E4662, .{cutscene_ent_name, model_hash}); } // 0x4C6A6451C79E4662 0x8FF5D3C4 b323
    pub inline fn canSetExitStateForCamera(p_0: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB2CBCD0930DFB420, .{p_0}); } // 0xB2CBCD0930DFB420 0xEDAE6C02 b323
    /// Toggles a value (bool) for cutscenes.
    pub inline fn setPadCanShakeDuringCutscene(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC61B86C9F61EB404, .{toggle}); } // 0xC61B86C9F61EB404 0x35721A08 b323
    pub inline fn setCutsceneFadeValues(p_0: windows.BOOL, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x8093F23ABACCC7D4, .{p_0, p_1, p_2, p_3}); } // 0x8093F23ABACCC7D4 0xD19EF0DD b323
    pub inline fn setCutsceneMultiheadFade(p_0: windows.BOOL, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x20746F7B1032A3C7, .{p_0, p_1, p_2, p_3}); } // 0x20746F7B1032A3C7  b323
    pub inline fn setCutsceneMultiheadFadeManual(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x06EE9048FD080382, .{p_0}); } // 0x06EE9048FD080382  b323
    pub inline fn isMultiheadFadeUp() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0FE76168A189DDB, .{}); } // 0xA0FE76168A189DDB  b323
    pub inline fn networkSetMocapCutsceneCanBeSkipped(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2F137B508DE238F2, .{toggle}); } // 0x2F137B508DE238F2 0x8338DA1D b323
    pub inline fn setCarGeneratorsCanUpdateDuringCutscene(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xE36A98D8AB3D3C66, .{p_0}); } // 0xE36A98D8AB3D3C66 0x04377C10 b323
    pub inline fn canUseMobilePhoneDuringCutscene() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5EDEF0CF8C1DAB3C, .{}); } // 0x5EDEF0CF8C1DAB3C 0xDBD88708 b323
    pub inline fn setCutsceneCanBeSkipped(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x41FAA8FB2ECE8720, .{p_0}); } // 0x41FAA8FB2ECE8720 0x28D54A7F b323
    pub inline fn setCanDisplayMinimapDuringCutsceneThisUpdate() !void { try invoker.invoke(void, 0x2131046957F31B04, .{}); } // 0x2131046957F31B04 0xB60CFBB9 b323
    /// Full list of ped components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedComponentVariations.json
    pub inline fn setCutscenePedComponentVariation(cutscene_ent_name: [*c]const u8, component_id: c_int, drawable_id: c_int, texture_id: c_int, model_hash: types.Hash) !void { try invoker.invoke(void, 0xBA01E7B6DEEFBBC9, .{cutscene_ent_name, component_id, drawable_id, texture_id, model_hash}); } // 0xBA01E7B6DEEFBBC9 0x6AF994A1 b323
    pub inline fn setCutscenePedComponentVariationFromPed(cutscene_ent_name: [*c]const u8, ped: types.Ped, model_hash: types.Hash) !void { try invoker.invoke(void, 0x2A56C06EBEF2B0D9, .{cutscene_ent_name, ped, model_hash}); } // 0x2A56C06EBEF2B0D9 0x1E7DA95E b323
    pub inline fn doesCutsceneEntityExist(cutscene_ent_name: [*c]const u8, model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x499EF20C5DB25C59, .{cutscene_ent_name, model_hash}); } // 0x499EF20C5DB25C59 0x58E67409 b323
    /// Thanks R*! ;)
    /// 
    /// if ((l_161 == 0) || (l_161 == 2)) { \
    ///     sub_2ea27("Trying to set Jimmy prop variation");
    ///     CUTSCENE::SET_CUTSCENE_PED_PROP_VARIATION("Jimmy_Boston", 1, 0, 0, 0);
    /// }
    /// 
    /// Full list of ped components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedComponentVariations.json
    pub inline fn setCutscenePedPropVariation(cutscene_ent_name: [*c]const u8, component_id: c_int, drawable_id: c_int, texture_id: c_int, model_hash: types.Hash) !void { try invoker.invoke(void, 0x0546524ADE2E9723, .{cutscene_ent_name, component_id, drawable_id, texture_id, model_hash}); } // 0x0546524ADE2E9723 0x22E9A9DE b323
    /// Possibly HAS_CUTSCENE_CUT_THIS_FRAME, needs more research.
    pub inline fn hasCutsceneCutThisFrame() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x708BDD8CD795B043, .{}); } // 0x708BDD8CD795B043 0x4315A7C5 b323
};

pub const Datafile = struct
{
    /// Adds the given requestID to the watch list.
    pub inline fn datafileWatchRequestId(request_id: c_int) !void { try invoker.invoke(void, 0xAD6875BBC0FC899C, .{request_id}); } // 0xAD6875BBC0FC899C 0x621388FF b323
    pub inline fn datafileClearWatchList() !void { try invoker.invoke(void, 0x6CC86E78358D5119, .{}); } // 0x6CC86E78358D5119 0x5B39D0AC b323
    pub inline fn datafileIsValidRequestId(index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFCCAE5B92A830878, .{index}); } // 0xFCCAE5B92A830878 0x01393D16 b323
    pub inline fn datafileHasLoadedFileData(request_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x15FF52B809DB2353, .{request_id}); } // 0x15FF52B809DB2353 0x36FB8B3F b323
    pub inline fn datafileHasValidFileData(request_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF8CC1EBE0B62E29F, .{request_id}); } // 0xF8CC1EBE0B62E29F 0x2A9411DA b323
    pub inline fn datafileSelectActiveFile(request_id: c_int, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x22DA66936E0FFF37, .{request_id, p_1}); } // 0x22DA66936E0FFF37 0xB41064A4 b323
    pub inline fn datafileDeleteRequestedFile(request_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8F5EA1C01D65A100, .{request_id}); } // 0x8F5EA1C01D65A100 0x9DB63CFF b323
    pub inline fn ugcCreateContent(data: [*c]types.Any, data_count: c_int, content_name: [*c]const u8, description: [*c]const u8, tags_csv: [*c]const u8, content_type_name: [*c]const u8, publish: windows.BOOL, p_7: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC84527E235FCA219, .{data, data_count, content_name, description, tags_csv, content_type_name, publish, p_7}); } // 0xC84527E235FCA219 0xF09157B0 b323
    pub inline fn ugcCreateMission(content_name: [*c]const u8, description: [*c]const u8, tags_csv: [*c]const u8, content_type_name: [*c]const u8, publish: windows.BOOL, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA5EFC3E847D60507, .{content_name, description, tags_csv, content_type_name, publish, p_5}); } // 0xA5EFC3E847D60507 0xD96860FC b323
    pub inline fn ugcUpdateContent(content_id: [*c]const u8, data: [*c]types.Any, data_count: c_int, content_name: [*c]const u8, description: [*c]const u8, tags_csv: [*c]const u8, content_type_name: [*c]const u8, p_7: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x648E7A5434AF7969, .{content_id, data, data_count, content_name, description, tags_csv, content_type_name, p_7}); } // 0x648E7A5434AF7969 0x459F2683 b323
    pub inline fn ugcUpdateMission(content_id: [*c]const u8, content_name: [*c]const u8, description: [*c]const u8, tags_csv: [*c]const u8, content_type_name: [*c]const u8, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4645DE9980999E93, .{content_id, content_name, description, tags_csv, content_type_name, p_5}); } // 0x4645DE9980999E93 0xDBB83E2B b323
    pub inline fn ugcSetPlayerData(content_id: [*c]const u8, rating: f32, content_type_name: [*c]const u8, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x692D808C34A82143, .{content_id, rating, content_type_name, p_3}); } // 0x692D808C34A82143 0xBB6321BD b323
    pub inline fn datafileSelectUgcData(p_0: c_int, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA69AC4ADE82B57A4, .{p_0, p_1}); } // 0xA69AC4ADE82B57A4 0xE8D56DA2 b323
    pub inline fn datafileSelectUgcStats(p_0: c_int, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9CB0BFA7A9342C3D, .{p_0, p_1, p_2}); } // 0x9CB0BFA7A9342C3D 0xCB6A351E b323
    pub inline fn datafileSelectUgcPlayerData(p_0: c_int, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x52818819057F2B40, .{p_0, p_1}); } // 0x52818819057F2B40 0xA4D1B30E b323
    pub inline fn datafileSelectCreatorStats(p_0: c_int, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x01095C95CD46B624, .{p_0, p_1}); } // 0x01095C95CD46B624 0xB8515B2F b323
    /// Loads a User-Generated Content (UGC) file. These files can be found in "[GTA5]\data\ugc" and "[GTA5]\common\patch\ugc". They seem to follow a naming convention, most likely of "[name]_[part].ugc". See example below for usage.
    /// 
    /// Returns whether or not the file was successfully loaded.
    /// 
    /// Example: \
    /// DATAFILE::DATAFILE_LOAD_OFFLINE_UGC("RockstarPlaylists") // loads "rockstarplaylists_00.ugc"
    pub inline fn datafileLoadOfflineUgc(filename: [*c]const u8, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC5238C011AF405E4, .{filename, p_1}); } // 0xC5238C011AF405E4 0x660C468E b323
    pub inline fn datafileCreate(p_0: c_int) !void { try invoker.invoke(void, 0xD27058A1CA2B13EE, .{p_0}); } // 0xD27058A1CA2B13EE 0x95F8A221 b323
    pub inline fn datafileDelete(p_0: c_int) !void { try invoker.invoke(void, 0x9AB9C1CFC8862DFB, .{p_0}); } // 0x9AB9C1CFC8862DFB 0xDEF31B0A b323
    pub inline fn datafileStoreMissionHeader(p_0: c_int) !void { try invoker.invoke(void, 0x2ED61456317B8178, .{p_0}); } // 0x2ED61456317B8178 0x4E03F632 b323
    pub inline fn datafileFlushMissionHeader() !void { try invoker.invoke(void, 0xC55854C7D7274882, .{}); } // 0xC55854C7D7274882 0xF11F956F b323
    pub inline fn datafileGetFileDict(p_0: c_int) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0x906B778CA1DC72B6, .{p_0}); } // 0x906B778CA1DC72B6 0x86DDF9C2 b323
    pub inline fn datafileStartSaveToCloud(filename: [*c]const u8, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x83BCCE3224735F05, .{filename, p_1}); } // 0x83BCCE3224735F05 0x768CBB35 b323
    pub inline fn datafileUpdateSaveToCloud(p_0: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4DFDD9EB705F8140, .{p_0}); } // 0x4DFDD9EB705F8140 0x0B4087F7 b323
    pub inline fn datafileIsSavePending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBEDB96A7584AA8CF, .{}); } // 0xBEDB96A7584AA8CF 0x5DCD0796 b323
    pub inline fn datafileLoadOfflineUgcForAdditionalDataFile(p_0: types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA6EEF01087181EDD, .{p_0, p_1}); } // 0xA6EEF01087181EDD  b2189
    pub inline fn datafileDeleteForAdditionalDataFile(p_0: types.Any) !void { try invoker.invoke(void, 0x6AD0BD5E087866CB, .{p_0}); } // 0x6AD0BD5E087866CB  b2189
    pub inline fn datafileGetFileDictForAdditionalDataFile(p_0: types.Any) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0xDBF860CF1DB8E599, .{p_0}); } // 0xDBF860CF1DB8E599  b2189
    pub inline fn datadictSetBool(object_data: [*c]types.Any, key: [*c]const u8, value: windows.BOOL) !void { try invoker.invoke(void, 0x35124302A556A325, .{object_data, key, value}); } // 0x35124302A556A325 0x9B29D99B b323
    pub inline fn datadictSetInt(object_data: [*c]types.Any, key: [*c]const u8, value: c_int) !void { try invoker.invoke(void, 0xE7E035450A7948D5, .{object_data, key, value}); } // 0xE7E035450A7948D5 0xEFCF554A b323
    pub inline fn datadictSetFloat(object_data: [*c]types.Any, key: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0xC27E1CC2D795105E, .{object_data, key, value}); } // 0xC27E1CC2D795105E 0xE972CACF b323
    pub inline fn datadictSetString(object_data: [*c]types.Any, key: [*c]const u8, value: [*c]const u8) !void { try invoker.invoke(void, 0x8FF3847DADD8E30C, .{object_data, key, value}); } // 0x8FF3847DADD8E30C 0xD437615C b323
    pub inline fn datadictSetVector(object_data: [*c]types.Any, key: [*c]const u8, value__: types.Vector3) !void { try invoker.invoke(void, 0x4CD49B76338C7DEE, .{object_data, key, value__.x, value__.y, value__.z}); } // 0x4CD49B76338C7DEE 0x75FC6C3C b323
    pub inline fn datadictCreateDict(object_data: [*c]types.Any, key: [*c]const u8) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0xA358F56F10732EE1, .{object_data, key}); } // 0xA358F56F10732EE1 0x96A8E05F b323
    pub inline fn datadictCreateArray(object_data: [*c]types.Any, key: [*c]const u8) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0x5B11728527CA6E5F, .{object_data, key}); } // 0x5B11728527CA6E5F 0x03939B8D b323
    pub inline fn datadictGetBool(object_data: [*c]types.Any, key: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1186940ED72FFEEC, .{object_data, key}); } // 0x1186940ED72FFEEC 0x8876C872 b323
    pub inline fn datadictGetInt(object_data: [*c]types.Any, key: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x78F06F6B1FB5A80C, .{object_data, key}); } // 0x78F06F6B1FB5A80C 0xA6C68693 b323
    pub inline fn datadictGetFloat(object_data: [*c]types.Any, key: [*c]const u8) !f32 { return try invoker.invoke(f32, 0x06610343E73B9727, .{object_data, key}); } // 0x06610343E73B9727 0xA92C1AF4 b323
    pub inline fn datadictGetString(object_data: [*c]types.Any, key: [*c]const u8) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x3D2FD9E763B24472, .{object_data, key}); } // 0x3D2FD9E763B24472 0x942160EC b323
    pub inline fn datadictGetVector(object_data: [*c]types.Any, key: [*c]const u8) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x46CD3CB66E0825CC, .{object_data, key}); } // 0x46CD3CB66E0825CC 0xE84A127A b323
    pub inline fn datadictGetDict(object_data: [*c]types.Any, key: [*c]const u8) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0xB6B9DDC412FCEEE2, .{object_data, key}); } // 0xB6B9DDC412FCEEE2 0xC9C13D8D b323
    pub inline fn datadictGetArray(object_data: [*c]types.Any, key: [*c]const u8) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0x7A983AA9DA2659ED, .{object_data, key}); } // 0x7A983AA9DA2659ED 0x1F2F7D00 b323
    /// Types: \
    /// 1 = Boolean \
    /// 2 = Integer \
    /// 3 = Float \
    /// 4 = String \
    /// 5 = Vector3 \
    /// 6 = Object \
    /// 7 = Array
    pub inline fn datadictGetType(object_data: [*c]types.Any, key: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x031C55ED33227371, .{object_data, key}); } // 0x031C55ED33227371 0x2678342A b323
    pub inline fn dataarrayAddBool(array_data: [*c]types.Any, value: windows.BOOL) !void { try invoker.invoke(void, 0xF8B0F5A43E928C76, .{array_data, value}); } // 0xF8B0F5A43E928C76 0x08174B90 b323
    pub inline fn dataarrayAddInt(array_data: [*c]types.Any, value: c_int) !void { try invoker.invoke(void, 0xCABDB751D86FE93B, .{array_data, value}); } // 0xCABDB751D86FE93B 0xF29C0B36 b323
    pub inline fn dataarrayAddFloat(array_data: [*c]types.Any, value: f32) !void { try invoker.invoke(void, 0x57A995FD75D37F56, .{array_data, value}); } // 0x57A995FD75D37F56 0xE4302123 b323
    pub inline fn dataarrayAddString(array_data: [*c]types.Any, value: [*c]const u8) !void { try invoker.invoke(void, 0x2F0661C155AEEEAA, .{array_data, value}); } // 0x2F0661C155AEEEAA 0xF3C01350 b323
    pub inline fn dataarrayAddVector(array_data: [*c]types.Any, value__: types.Vector3) !void { try invoker.invoke(void, 0x407F8D034F70F0C2, .{array_data, value__.x, value__.y, value__.z}); } // 0x407F8D034F70F0C2 0x16F464B6 b323
    pub inline fn dataarrayAddDict(array_data: [*c]types.Any) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0x6889498B3E19C797, .{array_data}); } // 0x6889498B3E19C797 0xC174C71B b323
    pub inline fn dataarrayGetBool(array_data: [*c]types.Any, array_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x50C1B2874E50C114, .{array_data, array_index}); } // 0x50C1B2874E50C114 0xA2E5F921 b323
    pub inline fn dataarrayGetInt(array_data: [*c]types.Any, array_index: c_int) !c_int { return try invoker.invoke(c_int, 0x3E5AE19425CD74BE, .{array_data, array_index}); } // 0x3E5AE19425CD74BE 0xBB120CFC b323
    pub inline fn dataarrayGetFloat(array_data: [*c]types.Any, array_index: c_int) !f32 { return try invoker.invoke(f32, 0xC0C527B525D7CFB5, .{array_data, array_index}); } // 0xC0C527B525D7CFB5 0x08AD2CC2 b323
    pub inline fn dataarrayGetString(array_data: [*c]types.Any, array_index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xD3F2FFEB8D836F52, .{array_data, array_index}); } // 0xD3F2FFEB8D836F52 0x93F985A6 b323
    pub inline fn dataarrayGetVector(array_data: [*c]types.Any, array_index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x8D2064E5B64A628A, .{array_data, array_index}); } // 0x8D2064E5B64A628A 0x80E3DA55 b323
    pub inline fn dataarrayGetDict(array_data: [*c]types.Any, array_index: c_int) ![*c]types.Any { return try invoker.invoke([*c]types.Any, 0x8B5FADCC4E3A145F, .{array_data, array_index}); } // 0x8B5FADCC4E3A145F 0xECE81278 b323
    pub inline fn dataarrayGetCount(array_data: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0x065DB281590CEA2D, .{array_data}); } // 0x065DB281590CEA2D 0xA8A21766 b323
    /// Types: \
    /// 1 = Boolean \
    /// 2 = Integer \
    /// 3 = Float \
    /// 4 = String \
    /// 5 = Vector3 \
    /// 6 = Object \
    /// 7 = Array
    pub inline fn dataarrayGetType(array_data: [*c]types.Any, array_index: c_int) !c_int { return try invoker.invoke(c_int, 0x3A0014ADB172A3C5, .{array_data, array_index}); } // 0x3A0014ADB172A3C5 0xFA2402C8 b323
};

pub const Decorator = struct
{
    pub inline fn decorSetTime(entity: types.Entity, property_name: [*c]const u8, timestamp: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x95AED7B8E39ECAA4, .{entity, property_name, timestamp}); } // 0x95AED7B8E39ECAA4 0xBBAEEF94 b323
    /// This function sets metadata of type bool to specified entity.
    /// 
    pub inline fn decorSetBool(entity: types.Entity, property_name: [*c]const u8, value: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6B1E8E2ED1335B71, .{entity, property_name, value}); } // 0x6B1E8E2ED1335B71 0x8E101F5C b323
    pub inline fn decorSetFloat(entity: types.Entity, property_name: [*c]const u8, value: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x211AB1DD8D0F363A, .{entity, property_name, value}); } // 0x211AB1DD8D0F363A 0xBC7BD5CB b323
    /// Sets property to int.
    pub inline fn decorSetInt(entity: types.Entity, property_name: [*c]const u8, value: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0CE3AA5E1CA19E10, .{entity, property_name, value}); } // 0x0CE3AA5E1CA19E10 0xDB718B21 b323
    pub inline fn decorGetBool(entity: types.Entity, property_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDACE671663F2F5DB, .{entity, property_name}); } // 0xDACE671663F2F5DB 0xDBCE51E0 b323
    pub inline fn decorGetFloat(entity: types.Entity, property_name: [*c]const u8) !f32 { return try invoker.invoke(f32, 0x6524A2F114706F43, .{entity, property_name}); } // 0x6524A2F114706F43 0x8DE5382F b323
    pub inline fn decorGetInt(entity: types.Entity, property_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xA06C969B02A97298, .{entity, property_name}); } // 0xA06C969B02A97298 0xDDDE59B5 b323
    /// Returns whether or not the specified property is set for the entity.
    pub inline fn decorExistOn(entity: types.Entity, property_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x05661B80A8C9165F, .{entity, property_name}); } // 0x05661B80A8C9165F 0x74EF9C40 b323
    pub inline fn decorRemove(entity: types.Entity, property_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x00EE9F297C738720, .{entity, property_name}); } // 0x00EE9F297C738720 0xE0E2640B b323
    /// https://alloc8or.re/gta5/doc/enums/eDecorType.txt
    pub inline fn decorRegister(property_name: [*c]const u8, @"type": c_int) !void { try invoker.invoke(void, 0x9FD90732F56403CE, .{property_name, @"type"}); } // 0x9FD90732F56403CE 0x68BD42A9 b323
    /// type: see DECOR_REGISTER
    pub inline fn decorIsRegisteredAsType(property_name: [*c]const u8, @"type": c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4F14F9F870D6FBC8, .{property_name, @"type"}); } // 0x4F14F9F870D6FBC8 0x7CF0971D b323
    /// Called after all decorator type initializations.
    pub inline fn decorRegisterLock() !void { try invoker.invoke(void, 0xA9D14EEA259F9248, .{}); } // 0xA9D14EEA259F9248 0x7F3F1C02 b323
};

pub const Dlc = struct
{
    pub inline fn areAnyCcsPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x241FCA5B1AA14F75, .{}); } // 0x241FCA5B1AA14F75 0x0AF83036 b323
    /// Returns true if the given DLC pack is present.
    pub inline fn isDlcPresent(dlc_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x812595A0644CE1DE, .{dlc_hash}); } // 0x812595A0644CE1DE 0x1F321943 b323
    /// This function is hard-coded to always return 1.
    pub inline fn dlcCheckCloudDataCorrect() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF2E07819EF1A5289, .{}); } // 0xF2E07819EF1A5289 0x881B1FDB b323
    /// This function is hard-coded to always return 0.
    pub inline fn getExtracontentCloudResult() !c_int { return try invoker.invoke(c_int, 0x9489659372A81585, .{}); } // 0x9489659372A81585 0xC2169164 b323
    /// This function is hard-coded to always return 1.
    pub inline fn dlcCheckCompatPackConfiguration() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA213B11DFF526300, .{}); } // 0xA213B11DFF526300 0xF79A97F5 b323
    pub inline fn getEverHadBadPackOrder() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8D30F648014A92B5, .{}); } // 0x8D30F648014A92B5 0xF69B729C b323
    pub inline fn getIsLoadingScreenActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x10D0A8F259E93EC9, .{}); } // 0x10D0A8F259E93EC9 0x517B601B b323
    pub inline fn getIsInitialLoadingScreenActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC4637A6D03C24CC3, .{}); } // 0xC4637A6D03C24CC3  b1734
    /// Sets the value of the specified variable to 0. \
    /// Always returns true.
    pub inline fn hasCloudRequestsFinished(p_0: [*c]windows.BOOL, unused: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x46E2B844905BC5F0, .{p_0, unused}); } // 0x46E2B844905BC5F0 0x6087C10C b323
    /// Unloads GROUP_MAP (GTAO/MP) DLC data and loads GROUP_MAP_SP DLC. Neither are loaded by default, ON_ENTER_MP is a cognate to this function and loads MP DLC (and unloads SP DLC by extension). \
    /// Works in singleplayer.
    pub inline fn onEnterSp() !void { try invoker.invoke(void, 0xD7C10C4A637992C9, .{}); } // 0xD7C10C4A637992C9 0x8BF60FC3 b323
    /// This loads the GTA:O dlc map parts (high end garages, apartments). \
    /// Works in singleplayer. \
    /// In order to use GTA:O heist IPL's you have to call this native with the following params: SET_INSTANCE_PRIORITY_MODE(1);
    pub inline fn onEnterMp() !void { try invoker.invoke(void, 0x0888C3502DBBEEF5, .{}); } // 0x0888C3502DBBEEF5 0xC65586A9 b323
};

pub const Entity = struct
{
    /// Checks whether an entity exists in the game world.
    pub inline fn doesEntityExist(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7239B21A38F536BA, .{entity}); } // 0x7239B21A38F536BA 0x3AC90869 b323
    pub inline fn doesEntityBelongToThisScript(entity: types.Entity, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDDE6DF5AE89981D2, .{entity, p_1}); } // 0xDDE6DF5AE89981D2 0xACFEB3F9 b323
    pub inline fn doesEntityHaveDrawable(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x060D6E96F8B8E48D, .{entity}); } // 0x060D6E96F8B8E48D 0xA5B33300 b323
    pub inline fn doesEntityHavePhysics(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDA95EA3317CC5064, .{entity}); } // 0xDA95EA3317CC5064 0x9BCD2979 b323
    pub inline fn doesEntityHaveSkeleton(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x764EB96874EFFDC1, .{entity}); } // 0x764EB96874EFFDC1  b2699
    pub inline fn doesEntityHaveAnimDirector(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2158E81A6AF65EA9, .{entity}); } // 0x2158E81A6AF65EA9  b2699
    /// P3 is always 3 as far as i cant tell
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn hasEntityAnimFinished(entity: types.Entity, anim_dict: [*c]const u8, anim_name: [*c]const u8, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x20B711662962B472, .{entity, anim_dict, anim_name, p_3}); } // 0x20B711662962B472 0x1D9CAB92 b323
    pub inline fn hasEntityBeenDamagedByAnyObject(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x95EB9964FF5C5C65, .{entity}); } // 0x95EB9964FF5C5C65 0x6B74582E b323
    pub inline fn hasEntityBeenDamagedByAnyPed(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x605F5A140F202491, .{entity}); } // 0x605F5A140F202491 0x53FD4A25 b323
    pub inline fn hasEntityBeenDamagedByAnyVehicle(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDFD5033FDBA0A9C8, .{entity}); } // 0xDFD5033FDBA0A9C8 0x878C2CE0 b323
    /// Entity 1 = Victim \
    /// Entity 2 = Attacker
    /// 
    /// p2 seems to always be 1
    pub inline fn hasEntityBeenDamagedByEntity(entity_1: types.Entity, entity_2: types.Entity, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC86D67D52A707CF8, .{entity_1, entity_2, p_2}); } // 0xC86D67D52A707CF8 0x07FC77E0 b323
    /// traceType is always 17 in the scripts.
    /// 
    /// There is other codes used for traceType: \
    /// 19 - in jewelry_prep1a \
    /// 126 - in am_hunt_the_beast \
    /// 256 & 287 - in fm_mission_controller
    pub inline fn hasEntityClearLosToEntity(entity_1: types.Entity, entity_2: types.Entity, trace_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFCDFF7B72D23A1AC, .{entity_1, entity_2, trace_type}); } // 0xFCDFF7B72D23A1AC 0x53576FA7 b323
    pub inline fn hasEntityClearLosToEntityAdjustForCover(entity_1: types.Entity, entity_2: types.Entity, trace_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x394BDE2A7BBA031E, .{entity_1, entity_2, trace_type}); } // 0x394BDE2A7BBA031E  b1868
    /// Has the entity1 got a clear line of sight to the other entity2 from the direction entity1 is facing. \
    /// This is one of the most CPU demanding BOOL natives in the game; avoid calling this in things like nested for-loops
    pub inline fn hasEntityClearLosToEntityInFront(entity_1: types.Entity, entity_2: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0267D00AF114F17A, .{entity_1, entity_2}); } // 0x0267D00AF114F17A 0x210D87C8 b323
    /// Called on tick. \
    /// Tested with vehicles, returns true whenever the vehicle is touching any entity.
    /// 
    /// Note: for vehicles, the wheels can touch the ground and it will still return false, but if the body of the vehicle touches the ground, it will return true.
    pub inline fn hasEntityCollidedWithAnything(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8BAD02F0368D9E14, .{entity}); } // 0x8BAD02F0368D9E14 0x662A2F41 b323
    pub inline fn getLastEntityHitByEntity_(entity: types.Entity) !types.Entity { return try invoker.invoke(types.Entity, 0xA75EE4F689B85391, .{entity}); } // 0xA75EE4F689B85391  b2802
    pub inline fn getLastMaterialHitByEntity(entity: types.Entity) !types.Hash { return try invoker.invoke(types.Hash, 0x5C3D0A935F535C4C, .{entity}); } // 0x5C3D0A935F535C4C 0xC0E3AA47 b323
    pub inline fn getCollisionNormalOfLastHitForEntity(entity: types.Entity) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xE465D4AB7CA6AE72, .{entity}); } // 0xE465D4AB7CA6AE72 0xAB415C07 b323
    /// Based on carmod_shop script decompile this takes a vehicle parameter. It is called when repair is done on initial enter.
    pub inline fn forceEntityAiAndAnimationUpdate(entity: types.Entity) !void { try invoker.invoke(void, 0x40FDEDB72F8293B2, .{entity}); } // 0x40FDEDB72F8293B2 0x58D9775F b323
    /// Returns a float value representing animation's current playtime with respect to its total playtime. This value increasing in a range from [0 to 1] and wrap back to 0 when it reach 1.
    /// 
    /// Example: \
    /// 0.000000 - mark the starting of animation. \
    /// 0.500000 - mark the midpoint of the animation. \
    /// 1.000000 - mark the end of animation.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn getEntityAnimCurrentTime(entity: types.Entity, anim_dict: [*c]const u8, anim_name: [*c]const u8) !f32 { return try invoker.invoke(f32, 0x346D81500D088F42, .{entity, anim_dict, anim_name}); } // 0x346D81500D088F42 0x83943F41 b323
    /// Returns a float value representing animation's total playtime in milliseconds.
    /// 
    /// Example: \
    /// GET_ENTITY_ANIM_TOTAL_TIME(PLAYER_ID(),"amb@world_human_yoga@female@base","base_b")  \
    /// return 20800.000000
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn getEntityAnimTotalTime(entity: types.Entity, anim_dict: [*c]const u8, anim_name: [*c]const u8) !f32 { return try invoker.invoke(f32, 0x50BD2730B191E360, .{entity, anim_dict, anim_name}); } // 0x50BD2730B191E360 0x433A9D18 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn getAnimDuration(anim_dict: [*c]const u8, anim_name: [*c]const u8) !f32 { return try invoker.invoke(f32, 0xFEDDF04D62B8D790, .{anim_dict, anim_name}); } // 0xFEDDF04D62B8D790 0x8B5E3E3D b323
    pub inline fn getEntityAttachedTo(entity: types.Entity) !types.Entity { return try invoker.invoke(types.Entity, 0x48C2BED9180FE123, .{entity}); } // 0x48C2BED9180FE123 0xFE1589F9 b323
    /// Gets the current coordinates for a specified entity. \
    /// `entity` = The entity to get the coordinates from. \
    /// `alive` = Unused by the game, potentially used by debug builds of GTA in order to assert whether or not an entity was alive.
    pub inline fn getEntityCoords(entity: types.Entity, alive: windows.BOOL) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x3FEF770D40960D5A, .{entity, alive}); } // 0x3FEF770D40960D5A 0x1647F1CB b323
    /// Gets the entity's forward vector.
    pub inline fn getEntityForwardVector(entity: types.Entity) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x0A794A5A57F8DF91, .{entity}); } // 0x0A794A5A57F8DF91 0x84DCECBF b323
    /// Gets the X-component of the entity's forward vector.
    pub inline fn getEntityForwardX(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0x8BB4EF4214E0E6D5, .{entity}); } // 0x8BB4EF4214E0E6D5 0x49FAE914 b323
    /// Gets the Y-component of the entity's forward vector.
    pub inline fn getEntityForwardY(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0x866A4A5FAE349510, .{entity}); } // 0x866A4A5FAE349510 0x9E2F917C b323
    /// Returns the heading of the entity in degrees. Also know as the "Yaw" of an entity.
    pub inline fn getEntityHeading(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0xE83D4F9BA2A38914, .{entity}); } // 0xE83D4F9BA2A38914 0x972CC383 b323
    /// Gets the heading of the entity physics in degrees, which tends to be more accurate than just "GET_ENTITY_HEADING". This can be clearly seen while, for example, ragdolling a ped/player.
    /// 
    /// NOTE: The name and description of this native are based on independent research. If you find this native to be more suitable under a different name and/or described differently, please feel free to do so.
    pub inline fn getEntityHeadingFromEulers(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0x846BF6291198A71E, .{entity}); } // 0x846BF6291198A71E 0x9320E642 b323
    /// Returns an integer value of entity's current health.
    /// 
    /// Example of range for ped: \
    /// - Player [0 to 200] \
    /// - Ped [100 to 200] \
    /// - Vehicle [0 to 1000] \
    /// - Object [0 to 1000]
    /// 
    /// Health is actually a float value but this native casts it to int. \
    /// In order to get the actual value, do: \
    /// float health = *(float *)(entityAddress + 0x280);
    pub inline fn getEntityHealth(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0xEEF059FAD016D209, .{entity}); } // 0xEEF059FAD016D209 0x8E3222B7 b323
    /// Return an integer value of entity's maximum health.
    /// 
    /// Example: \
    /// - Player = 200 \
    /// - Ped = 150
    pub inline fn getEntityMaxHealth(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0x15D757606D170C3C, .{entity}); } // 0x15D757606D170C3C 0xC7AE6AA1 b323
    /// For instance: ENTITY::SET_ENTITY_MAX_HEALTH(PLAYER::PLAYER_PED_ID(), 200); // director_mode.c4: 67849
    pub inline fn setEntityMaxHealth(entity: types.Entity, value: c_int) !void { try invoker.invoke(void, 0x166E7CF68597D8B5, .{entity, value}); } // 0x166E7CF68597D8B5 0x96F84DF8 b323
    pub inline fn getEntityHeight(entity: types.Entity, vec: types.Vector3, at_top: windows.BOOL, in_world_coords: windows.BOOL) !f32 { return try invoker.invoke(f32, 0x5A504562485944DD, .{entity, vec.x, vec.y, vec.z, at_top, in_world_coords}); } // 0x5A504562485944DD 0xEE443481 b323
    /// Return height (z-dimension) above ground.  \
    /// Example: The pilot in a titan plane is 1.844176 above ground.
    /// 
    /// How can i convert it to meters? \
    /// Everything seems to be in meters, probably this too.
    pub inline fn getEntityHeightAboveGround(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0x1DD55701034110E5, .{entity}); } // 0x1DD55701034110E5 0x57F56A4D b323
    pub inline fn getEntityMatrix(entity: types.Entity, forward_vector: [*c]types.Vector3, right_vector: [*c]types.Vector3, up_vector: [*c]types.Vector3, position: [*c]types.Vector3) !void { try invoker.invoke(void, 0xECB2FC7235A7D137, .{entity, forward_vector, right_vector, up_vector, position}); } // 0xECB2FC7235A7D137 0xEB9EB001 b323
    /// Returns the model hash from the entity
    pub inline fn getEntityModel(entity: types.Entity) !types.Hash { return try invoker.invoke(types.Hash, 0x9F47B058362C84B5, .{entity}); } // 0x9F47B058362C84B5 0xDAFCB3EC b323
    /// Converts world coords (posX - Z) to coords relative to the entity
    /// 
    /// Example: \
    /// posX is given as 50 \
    /// entity's x coord is 40 \
    /// the returned x coord will then be 10 or -10, not sure haven't used this in a while (think it is 10 though).
    pub inline fn getOffsetFromEntityGivenWorldCoords(entity: types.Entity, pos__: types.Vector3) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x2274BC1C4885E333, .{entity, pos__.x, pos__.y, pos__.z}); } // 0x2274BC1C4885E333 0x6477EC9E b323
    /// Offset values are relative to the entity.
    /// 
    /// x = left/right \
    /// y = forward/backward \
    /// z = up/down
    pub inline fn getOffsetFromEntityInWorldCoords(entity: types.Entity, offset__: types.Vector3) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x1899F328B0E12848, .{entity, offset__.x, offset__.y, offset__.z}); } // 0x1899F328B0E12848 0xABCF043A b323
    pub inline fn getEntityPitch(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0xD45DC2893621E1FE, .{entity}); } // 0xD45DC2893621E1FE 0xFCE6ECE5 b323
    /// w is the correct parameter name!
    pub inline fn getEntityQuaternion(entity: types.Entity, x: [*c]f32, y: [*c]f32, z: [*c]f32, w: [*c]f32) !void { try invoker.invoke(void, 0x7B3703D2D32DFA18, .{entity, x, y, z, w}); } // 0x7B3703D2D32DFA18 0x5154EC90 b323
    /// Displays the current ROLL axis of the entity [-180.0000/180.0000+] \
    /// (Sideways Roll) such as a vehicle tipped on its side
    pub inline fn getEntityRoll(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0x831E0242595560DF, .{entity}); } // 0x831E0242595560DF 0x36610842 b323
    /// rotationOrder is the order yaw, pitch and roll is applied. Usually 2. Returns a vector where the Z coordinate is the yaw.
    /// 
    /// rotationOrder refers to the order yaw pitch roll is applied; value ranges from 0 to 5 and is usually *2* in scripts. \
    /// What you use for rotationOrder when getting must be the same as rotationOrder when setting the rotation.
    /// 
    /// What it returns is the yaw on the z part of the vector, which makes sense considering R* considers z as vertical. Here's a picture for those of you who don't understand pitch, yaw, and roll: www.allstar.fiu.edu/aero/images/pic5-1.gif
    /// 
    /// Rotation Orders: \
    /// 0: ZYX - Rotate around the z-axis, then the y-axis and finally the x-axis. \
    /// 1: YZX - Rotate around the y-axis, then the z-axis and finally the x-axis. \
    /// 2: ZXY - Rotate around the z-axis, then the x-axis and finally the y-axis. \
    /// 3: XZY - Rotate around the x-axis, then the z-axis and finally the y-axis. \
    /// 4: YXZ - Rotate around the y-axis, then the x-axis and finally the z-axis. \
    /// 5: XYZ - Rotate around the x-axis, then the y-axis and finally the z-axis.
    pub inline fn getEntityRotation(entity: types.Entity, rotation_order: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xAFBD61CC738D9EB9, .{entity, rotation_order}); } // 0xAFBD61CC738D9EB9 0x8FF45B04 b323
    pub inline fn getEntityRotationVelocity(entity: types.Entity) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x213B91045D09B983, .{entity}); } // 0x213B91045D09B983 0x9BF8A73F b323
    /// Returns the name of the script that owns/created the entity or nullptr. Second parameter is unused, can just be a nullptr.
    pub inline fn getEntityScript(entity: types.Entity, script: [*c]types.ScrHandle) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xA6E9C38DB51D7748, .{entity, script}); } // 0xA6E9C38DB51D7748 0xB7F70784 b323
    /// result is in meters per second
    /// 
    /// ------------------------------------------------------------ \
    /// So would the conversion to mph and km/h, be along the lines of this.
    /// 
    /// float speed = GET_ENTITY_SPEED(veh); \
    /// float kmh = (speed * 3.6); \
    /// float mph = (speed * 2.236936); \
    /// ------------------------------------------------------------
    pub inline fn getEntitySpeed(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0xD5037BA82E12416F, .{entity}); } // 0xD5037BA82E12416F 0x9E1E4798 b323
    /// Relative can be used for getting speed relative to the frame of the vehicle, to determine for example, if you are going in reverse (-y speed) or not (+y speed). 
    pub inline fn getEntitySpeedVector(entity: types.Entity, relative: windows.BOOL) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x9A8D700A51CB7B0D, .{entity, relative}); } // 0x9A8D700A51CB7B0D 0x3ED2B997 b323
    pub inline fn getEntityUprightValue(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0x95EED5A694951F9F, .{entity}); } // 0x95EED5A694951F9F 0xF4268190 b323
    pub inline fn getEntityVelocity(entity: types.Entity) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x4805D2B1D8CF94A9, .{entity}); } // 0x4805D2B1D8CF94A9 0xC14C9B6B b323
    /// Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).
    pub inline fn getObjectIndexFromEntityIndex(entity: types.Entity) !types.Object { return try invoker.invoke(types.Object, 0xD7E3B9735C0F89D6, .{entity}); } // 0xD7E3B9735C0F89D6 0xBC5A9C58 b323
    /// Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).
    pub inline fn getPedIndexFromEntityIndex(entity: types.Entity) !types.Ped { return try invoker.invoke(types.Ped, 0x04A2A40C73395041, .{entity}); } // 0x04A2A40C73395041 0xC46F74AC b323
    /// Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).
    pub inline fn getVehicleIndexFromEntityIndex(entity: types.Entity) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x4B53F92932ADFAC0, .{entity}); } // 0x4B53F92932ADFAC0 0xC69CF43D b323
    /// Returns the coordinates of an entity-bone.
    pub inline fn getWorldPositionOfEntityBone(entity: types.Entity, bone_index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x44A8FCB8ED227738, .{entity, bone_index}); } // 0x44A8FCB8ED227738 0x7C6339DF b323
    pub inline fn getNearestPlayerToEntity(entity: types.Entity) !types.Player { return try invoker.invoke(types.Player, 0x7196842CB375CDB3, .{entity}); } // 0x7196842CB375CDB3 0xCE17FDEC b323
    pub inline fn getNearestPlayerToEntityOnTeam(entity: types.Entity, team: c_int) !types.Player { return try invoker.invoke(types.Player, 0x4DC9A62F844D9337, .{entity, team}); } // 0x4DC9A62F844D9337 0xB1808F56 b323
    pub inline fn getNearestParticipantToEntity(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0xFFBD7052D65BE0FF, .{entity}); } // 0xFFBD7052D65BE0FF  b2944
    /// Returns: \
    /// 0 = no entity \
    /// 1 = ped \
    /// 2 = vehicle \
    /// 3 = object
    pub inline fn getEntityType(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0x8ACD366038D14505, .{entity}); } // 0x8ACD366038D14505 0x0B1BD08D b323
    /// A population type, from the following enum: https://alloc8or.re/gta5/doc/enums/ePopulationType.txt
    pub inline fn getEntityPopulationType(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0xF6F5161F4534EDFF, .{entity}); } // 0xF6F5161F4534EDFF 0xFC30DDFF b323
    pub inline fn isAnEntity(handle: types.ScrHandle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x731EC8A916BD11A1, .{handle}); } // 0x731EC8A916BD11A1 0xD4B9715A b323
    pub inline fn isEntityAPed(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x524AC5ECEA15343E, .{entity}); } // 0x524AC5ECEA15343E 0x55D33EAB b323
    pub inline fn isEntityAMissionEntity(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0A7B270912999B3C, .{entity}); } // 0x0A7B270912999B3C 0x2632E124 b323
    pub inline fn isEntityAVehicle(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6AC7003FA6E5575E, .{entity}); } // 0x6AC7003FA6E5575E 0xBE800B01 b323
    pub inline fn isEntityAnObject(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8D68C8FD0FACA94E, .{entity}); } // 0x8D68C8FD0FACA94E 0x3F52E561 b323
    /// Checks if entity is within x/y/zSize distance of x/y/z. 
    /// 
    /// Last three are unknown ints, almost always p7 = 0, p8 = 1, p9 = 0
    pub inline fn isEntityAtCoord(entity: types.Entity, pos__: types.Vector3, size__: types.Vector3, p_7: windows.BOOL, p_8: windows.BOOL, p_9: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x20B60995556D004F, .{entity, pos__.x, pos__.y, pos__.z, size__.x, size__.y, size__.z, p_7, p_8, p_9}); } // 0x20B60995556D004F 0xD749B606 b323
    /// Checks if entity1 is within the box defined by x/y/zSize of entity2.
    /// 
    /// Last three parameters are almost alwasy p5 = 0, p6 = 1, p7 = 0
    pub inline fn isEntityAtEntity(entity_1: types.Entity, entity_2: types.Entity, size__: types.Vector3, p_5: windows.BOOL, p_6: windows.BOOL, p_7: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x751B70C3D034E187, .{entity_1, entity_2, size__.x, size__.y, size__.z, p_5, p_6, p_7}); } // 0x751B70C3D034E187 0xDABDCB52 b323
    /// Whether the entity is attached to any other entity.
    pub inline fn isEntityAttached(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB346476EF1A64897, .{entity}); } // 0xB346476EF1A64897 0xEC1479D5 b323
    pub inline fn isEntityAttachedToAnyObject(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCF511840CEEDE0CC, .{entity}); } // 0xCF511840CEEDE0CC 0x0B5DE340 b323
    pub inline fn isEntityAttachedToAnyPed(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB1632E9A5F988D11, .{entity}); } // 0xB1632E9A5F988D11 0x9D7A609C b323
    pub inline fn isEntityAttachedToAnyVehicle(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x26AA915AD89BFB4B, .{entity}); } // 0x26AA915AD89BFB4B 0xDE5C995E b323
    pub inline fn isEntityAttachedToEntity(from: types.Entity, to: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEFBE71898A993728, .{from, to}); } // 0xEFBE71898A993728 0xB0ABFEA8 b323
    pub inline fn isEntityDead(entity: types.Entity, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5F9532F3B5CC2551, .{entity, p_1}); } // 0x5F9532F3B5CC2551 0xB6F7CBAC b323
    pub inline fn isEntityInAir(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x886E37EC497200B6, .{entity}); } // 0x886E37EC497200B6 0xA4157987 b323
    /// `p8` is a debug flag invoking functions in the same path as ``DRAW_MARKER`` \
    /// `p10` is some entity flag check, also used in `IS_ENTITY_AT_ENTITY`, `IS_ENTITY_IN_AREA`, and `IS_ENTITY_AT_COORD`. \
    /// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
    pub inline fn isEntityInAngledArea(entity: types.Entity, vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, debug: windows.BOOL, include_z: windows.BOOL, p_1_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x51210CED3DA1C78A, .{entity, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, debug, include_z, p_1_0}); } // 0x51210CED3DA1C78A 0x883622FA b323
    pub inline fn isEntityInArea(entity: types.Entity, vec_1__: types.Vector3, vec_2__: types.Vector3, p_7: windows.BOOL, p_8: windows.BOOL, p_9: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x54736AA40E271165, .{entity, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_7, p_8, p_9}); } // 0x54736AA40E271165 0x8C2DFA9D b323
    /// Full list of zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/zones.json
    pub inline fn isEntityInZone(entity: types.Entity, zone: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB6463CF6AF527071, .{entity, zone}); } // 0xB6463CF6AF527071 0x45C82B21 b323
    pub inline fn isEntityInWater(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCFB0A0D8EDD145A3, .{entity}); } // 0xCFB0A0D8EDD145A3 0x4C3C2508 b323
    /// Get how much of the entity is submerged.  1.0f is whole entity.
    pub inline fn getEntitySubmergedLevel(entity: types.Entity) !f32 { return try invoker.invoke(f32, 0xE81AFC1BC4CC41CE, .{entity}); } // 0xE81AFC1BC4CC41CE 0x0170F68C b323
    pub inline fn setEntityRequiresMoreExpensiveRiverCheck(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x694E00132F2823ED, .{entity, toggle}); } // 0x694E00132F2823ED 0x40C84A74 b323
    /// Returns true if the entity is in between the minimum and maximum values for the 2d screen coords.  \
    /// This means that it will return true even if the entity is behind a wall for example, as long as you're looking at their location.  \
    /// Chipping
    pub inline fn isEntityOnScreen(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE659E47AF827484B, .{entity}); } // 0xE659E47AF827484B 0xC1FEC5ED b323
    /// See also PED::IS_SCRIPTED_SCENARIO_PED_USING_CONDITIONAL_ANIM 0x6EC47A344923E1ED 0x3C30B447
    /// 
    /// Taken from ENTITY::IS_ENTITY_PLAYING_ANIM(PLAYER::PLAYER_PED_ID(), "creatures@shark@move", "attack_player", 3)
    /// 
    /// p4 is always 3 in the scripts.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn isEntityPlayingAnim(entity: types.Entity, anim_dict: [*c]const u8, anim_name: [*c]const u8, task_flag: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1F0B79228E461EC9, .{entity, anim_dict, anim_name, task_flag}); } // 0x1F0B79228E461EC9 0x0D130D34 b323
    /// a static ped will not react to natives like "APPLY_FORCE_TO_ENTITY" or "SET_ENTITY_VELOCITY" and oftentimes will not react to task-natives like "TASK::TASK_COMBAT_PED". The only way I know of to make one of these peds react is to ragdoll them (or sometimes to use CLEAR_PED_TASKS_IMMEDIATELY(). Static peds include almost all far-away peds, beach-combers, peds in certain scenarios, peds crossing a crosswalk, peds walking to get back into their cars, and others. If anyone knows how to make a ped non-static without ragdolling them, please edit this with the solution.
    pub inline fn isEntityStatic(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1218E6886D3D8327, .{entity}); } // 0x1218E6886D3D8327 0x928E12E9 b323
    pub inline fn isEntityTouchingEntity(entity: types.Entity, target_entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x17FFC1B2BA35A494, .{entity, target_entity}); } // 0x17FFC1B2BA35A494 0x6B931477 b323
    pub inline fn isEntityTouchingModel(entity: types.Entity, model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0F42323798A58C8C, .{entity, model_hash}); } // 0x0F42323798A58C8C 0x307E7611 b323
    pub inline fn isEntityUpright(entity: types.Entity, angle: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5333F526F6AB19AA, .{entity, angle}); } // 0x5333F526F6AB19AA 0x3BCDF4E1 b323
    pub inline fn isEntityUpsidedown(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1DBD58820FA61D71, .{entity}); } // 0x1DBD58820FA61D71 0x5ACAA48F b323
    pub inline fn isEntityVisible(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x47D6F43D77935C75, .{entity}); } // 0x47D6F43D77935C75 0x120B4ED5 b323
    pub inline fn isEntityVisibleToScript(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD796CB5BA8F20E32, .{entity}); } // 0xD796CB5BA8F20E32 0x5D240E9D b323
    pub inline fn isEntityOccluded(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE31C2C72B8692B64, .{entity}); } // 0xE31C2C72B8692B64 0x46BC5B40 b323
    pub inline fn wouldEntityBeOccluded(entity_model_hash: types.Hash, vec: types.Vector3, p_4: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEE5D2A122E09EC42, .{entity_model_hash, vec.x, vec.y, vec.z, p_4}); } // 0xEE5D2A122E09EC42 0xEA127CBC b323
    pub inline fn isEntityWaitingForWorldCollision(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD05BFF0C0A12C68F, .{entity}); } // 0xD05BFF0C0A12C68F 0x00AB7A4A b323
    /// Applies a force to the specified entity.
    /// 
    /// **List of force types (p1)**: \
    /// public enum ForceType \
    /// { \
    ///     MinForce = 0,
    ///     MaxForceRot = 1,
    ///     MinForce2 = 2,
    ///     MaxForceRot2 = 3,
    ///     ForceNoRot = 4,
    ///     ForceRotPlusForce = 5
    /// } \
    /// Research/documentation on the gtaforums can be found here https://gtaforums.com/topic/885669-precisely-define-object-physics/) and here https://gtaforums.com/topic/887362-apply-forces-and-momentums-to-entityobject/.
    /// 
    /// p6/relative - makes the xyz force not relative to world coords, but to something else \
    /// p7/highForce - setting false will make the force really low
    pub inline fn applyForceToEntityCenterOfMass(entity: types.Entity, force_type: c_int, vec: types.Vector3, p_5: windows.BOOL, is_direction_rel: windows.BOOL, is_force_rel: windows.BOOL, p_8: windows.BOOL) !void { try invoker.invoke(void, 0x18FF00FC7EFF559E, .{entity, force_type, vec.x, vec.y, vec.z, p_5, is_direction_rel, is_force_rel, p_8}); } // 0x18FF00FC7EFF559E 0x28924E98 b323
    /// Documented here: \
    /// gtaforums.com/topic/885669-precisely-define-object-physics/ \
    /// gtaforums.com/topic/887362-apply-forces-and-momentums-to-entityobject/
    /// 
    /// forceFlags: \
    /// First bit (lowest): Strong force flag, factor 100 \
    /// Second bit: Unkown flag \
    /// Third bit: Momentum flag=1 (vector (x,y,z) is a momentum, more research needed) \
    /// If higher bits are unequal 0 the function doesn't applay any forces at all. \
    /// (As integer possible values are 0-7)
    /// 
    /// 0: weak force \
    /// 1: strong force \
    /// 2: same as 0 (2nd bit?) \
    /// 3: same as 1 \
    /// 4: weak momentum \
    /// 5: strong momentum \
    /// 6: same as 4 \
    /// 7: same as 5
    /// 
    /// isLocal: vector defined in local (body-fixed) coordinate frame \
    /// isMassRel: if true the force gets multiplied with the objects mass (this is why it was known as highForce) and different objects will have the same acceleration.
    /// 
    /// p8 !!! Whenever I set this !=0, my script stopped.
    pub inline fn applyForceToEntity(entity: types.Entity, force_flags: c_int, vec: types.Vector3, off__: types.Vector3, bone_index: c_int, is_direction_rel: windows.BOOL, ignore_up_vec: windows.BOOL, is_force_rel: windows.BOOL, p_1_2: windows.BOOL, p_1_3: windows.BOOL) !void { try invoker.invoke(void, 0xC5F68BE9613E2D18, .{entity, force_flags, vec.x, vec.y, vec.z, off__.x, off__.y, off__.z, bone_index, is_direction_rel, ignore_up_vec, is_force_rel, p_1_2, p_1_3}); } // 0xC5F68BE9613E2D18 0xC1C0855A b323
    /// Attaches entity1 to bone (boneIndex) of entity2.
    /// 
    /// boneIndex - this is different to boneID, use GET_PED_BONE_INDEX to get the index from the ID. use the index for attaching to specific bones. entity1 will be attached to entity2's centre if bone index given doesn't correspond to bone indexes for that entity type.
    /// 
    /// useSoftPinning - if set to false attached entity will not detach when fixed \
    /// collision - controls collision between the two entities (FALSE disables collision). \
    /// isPed - pitch doesnt work when false and roll will only work on negative numbers (only peds) \
    /// vertexIndex - position of vertex \
    /// fixedRot - if false it ignores entity vector 
    /// 
    pub inline fn attachEntityToEntity(entity_1: types.Entity, entity_2: types.Entity, bone_index: c_int, pos__: types.Vector3, rot__: types.Vector3, p_9: windows.BOOL, use_soft_pinning: windows.BOOL, collision: windows.BOOL, is_ped: windows.BOOL, vertex_index: c_int, fixed_rot: windows.BOOL, p_1_5: types.Any) !void { try invoker.invoke(void, 0x6B9BBD38AB0796DF, .{entity_1, entity_2, bone_index, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, p_9, use_soft_pinning, collision, is_ped, vertex_index, fixed_rot, p_1_5}); } // 0x6B9BBD38AB0796DF 0xEC024237 b323
    pub inline fn attachEntityBoneToEntityBone(entity_1: types.Entity, entity_2: types.Entity, bone_index_1: c_int, bone_index_2: c_int, p_4: windows.BOOL, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x5C48B75732C8456C, .{entity_1, entity_2, bone_index_1, bone_index_2, p_4, p_5}); } // 0x5C48B75732C8456C  b791
    pub inline fn attachEntityBoneToEntityBoneYForward(entity_1: types.Entity, entity_2: types.Entity, bone_index_1: c_int, bone_index_2: c_int, p_4: windows.BOOL, p_5: windows.BOOL) !void { try invoker.invoke(void, 0xFD1695C5D3B05439, .{entity_1, entity_2, bone_index_1, bone_index_2, p_4, p_5}); } // 0xFD1695C5D3B05439  b791
    /// breakForce is the amount of force required to break the bond. \
    /// p14 - is always 1 in scripts \
    /// p15 - is 1 or 0 in scripts - unknoun what it does \
    /// p16 - controls collision between the two entities (FALSE disables collision). \
    /// p17 - do not teleport entity to be attached to the position of the bone Index of the target entity (if 1, entity will not be teleported to target bone) \
    /// p18 - is always 2 in scripts.
    /// 
    /// 
    pub inline fn attachEntityToEntityPhysically(entity_1: types.Entity, entity_2: types.Entity, bone_index_1: c_int, bone_index_2: c_int, pos_1__: types.Vector3, pos_2__: types.Vector3, rot__: types.Vector3, break_force: f32, fixed_rot: windows.BOOL, p_1_5: windows.BOOL, collision: windows.BOOL, p_1_7: windows.BOOL, p_1_8: c_int) !void { try invoker.invoke(void, 0xC3675780C92F90F9, .{entity_1, entity_2, bone_index_1, bone_index_2, pos_1__.x, pos_1__.y, pos_1__.z, pos_2__.x, pos_2__.y, pos_2__.z, rot__.x, rot__.y, rot__.z, break_force, fixed_rot, p_1_5, collision, p_1_7, p_1_8}); } // 0xC3675780C92F90F9 0x0547417F b323
    pub inline fn attachEntityToEntityPhysicallyOverrideInverseMass(first_entity_index: types.Entity, second_entity_index: types.Entity, first_entity_bone_index: c_int, second_entity_bone_index: c_int, secondentityoffset__: types.Vector3, firstentityoffset__: types.Vector3, vecrotation__: types.Vector3, physical_strength: f32, constrain_rotation: windows.BOOL, do_initial_warp: windows.BOOL, collide_with_entity: windows.BOOL, add_initial_seperation: windows.BOOL, rot_order: c_int, inv_mass_scale_a: f32, inv_mass_scale_b: f32) !void { try invoker.invoke(void, 0x168A09D1B25B0BA4, .{first_entity_index, second_entity_index, first_entity_bone_index, second_entity_bone_index, secondentityoffset__.x, secondentityoffset__.y, secondentityoffset__.z, firstentityoffset__.x, firstentityoffset__.y, firstentityoffset__.z, vecrotation__.x, vecrotation__.y, vecrotation__.z, physical_strength, constrain_rotation, do_initial_warp, collide_with_entity, add_initial_seperation, rot_order, inv_mass_scale_a, inv_mass_scale_b}); } // 0x168A09D1B25B0BA4  b2944
    /// Called to update entity attachments.
    pub inline fn processEntityAttachments(entity: types.Entity) !void { try invoker.invoke(void, 0xF4080490ADC51C6F, .{entity}); } // 0xF4080490ADC51C6F 0x6909BA59 b323
    /// Returns the index of the bone. If the bone was not found, -1 will be returned. 
    /// 
    /// list: \
    /// https://pastebin.com/D7JMnX1g
    /// 
    /// BoneNames: \
    ///   chassis,
    ///   windscreen,
    ///    seat_pside_r,
    ///  seat_dside_r, \
    ///  bodyshell, \
    ///     suspension_lm,
    ///     suspension_lr,
    ///     platelight,
    ///    attach_female,
    ///     attach_male,
    ///   bonnet,
    ///    boot,
    ///  chassis_dummy,  //Center of the dummy \
    ///  chassis_Control,    //Not found yet \
    ///    door_dside_f,   //Door left, front
    ///     door_dside_r,   //Door left, back
    ///  door_pside_f,   //Door right, front \
    ///    door_pside_r,   //Door right, back
    ///     Gun_GripR,
    ///     windscreen_f,
    ///  platelight, //Position where the light above the numberplate is located \
    ///    VFX_Emitter,
    ///   window_lf,  //Window left, front
    ///   window_lr,  //Window left, back
    ///    window_rf,  //Window right, front
    ///  window_rr,  //Window right, back \
    ///   engine, //Position of the engine
    ///   gun_ammo,
    ///  ROPE_ATTATCH,   //Not misspelled. In script "finale_heist2b.c4". \
    ///     wheel_lf,   //Wheel left, front
    ///    wheel_lr,   //Wheel left, back
    ///     wheel_rf,   //Wheel right, front
    ///   wheel_rr,   //Wheel right, back
    ///    exhaust,    //Exhaust. shows only the position of the stock-exhaust
    ///    overheat,   //A position on the engine(not exactly sure, how to name it)
    ///   misc_e, //Not a car-bone.
    ///  seat_dside_f,   //Driver-seat \
    ///  seat_pside_f,   //Seat next to driver \
    ///  Gun_Nuzzle, \
    ///    seat_r
    /// 
    /// I doubt that the function is case-sensitive, since I found a "Chassis" and a "chassis". - Just tested: Definitely not case-sensitive.
    /// 
    /// 
    pub inline fn getEntityBoneIndexByName(entity: types.Entity, bone_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xFB71170B7E76ACBA, .{entity, bone_name}); } // 0xFB71170B7E76ACBA 0xE4ECAC22 b323
    pub inline fn clearEntityLastDamageEntity(entity: types.Entity) !void { try invoker.invoke(void, 0xA72CD9CA74A5ECBA, .{entity}); } // 0xA72CD9CA74A5ECBA 0x2B83F43B b323
    /// Deletes the specified entity, then sets the handle pointed to by the pointer to NULL.
    pub inline fn deleteEntity(entity: [*c]types.Entity) !void { try invoker.invoke(void, 0xAE3CBE5BF394C9C9, .{entity}); } // 0xAE3CBE5BF394C9C9 0xFAA3D236 b323
    /// If `collision` is set to true, both entities won't collide with the other until the distance between them is above 4 meters. \
    /// Set `dynamic` to true to keep velocity after dettaching
    pub inline fn detachEntity(entity: types.Entity, dynamic: windows.BOOL, collision: windows.BOOL) !void { try invoker.invoke(void, 0x961AC54BF0613F5D, .{entity, dynamic, collision}); } // 0x961AC54BF0613F5D 0xC8EFCB41 b323
    /// Freezes or unfreezes an entity preventing its coordinates to change by the player if set to `true`. You can still change the entity position using SET_ENTITY_COORDS.
    pub inline fn freezeEntityPosition(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x428CA6DBD1094446, .{entity, toggle}); } // 0x428CA6DBD1094446 0x65C16D57 b323
    /// True means it can be deleted by the engine when switching lobbies/missions/etc, false means the script is expected to clean it up.
    /// 
    /// "Allow Freeze If No Collision"
    pub inline fn setEntityShouldFreezeWaitingOnCollision(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3910051CCECDB00C, .{entity, toggle}); } // 0x3910051CCECDB00C 0xD3850671 b323
    /// delta and bitset are guessed fields. They are based on the fact that most of the calls have 0 or nil field types passed in.
    /// 
    /// The only time bitset has a value is 0x4000 and the only time delta has a value is during stealth with usually <1.0f values.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn playEntityAnim(entity: types.Entity, anim_name: [*c]const u8, anim_dict: [*c]const u8, p_3: f32, loop: windows.BOOL, stay_in_anim: windows.BOOL, p_6: windows.BOOL, delta: f32, bitset: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7FB218262B810701, .{entity, anim_name, anim_dict, p_3, loop, stay_in_anim, p_6, delta, bitset}); } // 0x7FB218262B810701 0x878753D5 b323
    /// p4 and p7 are usually 1000.0f.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn playSynchronizedEntityAnim(entity: types.Entity, synced_scene: c_int, animation: [*c]const u8, prop_name: [*c]const u8, p_4: f32, p_5: f32, p_6: types.Any, p_7: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC77720A12FE14A86, .{entity, synced_scene, animation, prop_name, p_4, p_5, p_6, p_7}); } // 0xC77720A12FE14A86 0x012760AA b323
    /// p6,p7 probably animname and animdict
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn playSynchronizedMapEntityAnim(vec_1__: types.Vector3, x_2: f32, y_2: types.Any, z_2: f32, p_6: [*c]const u8, p_7: [*c]const u8, p_8: f32, p_9: f32, p_1_0: types.Any, p_1_1: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB9C54555ED30FBC4, .{vec_1__.x, vec_1__.y, vec_1__.z, x_2, y_2, z_2, p_6, p_7, p_8, p_9, p_1_0, p_1_1}); } // 0xB9C54555ED30FBC4 0xEB4CBA74 b323
    pub inline fn stopSynchronizedMapEntityAnim(vec_1__: types.Vector3, x_2: f32, y_2: types.Any, z_2: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x11E79CAB7183B6F5, .{vec_1__.x, vec_1__.y, vec_1__.z, x_2, y_2, z_2}); } // 0x11E79CAB7183B6F5 0x7253D5B2 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// RAGEPluginHook list: docs.ragepluginhook.net/html/62951c37-a440-478c-b389-c471230ddfc5.htm
    pub inline fn stopEntityAnim(entity: types.Entity, animation: [*c]const u8, anim_group: [*c]const u8, p_3: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x28004F88151E03E0, .{entity, animation, anim_group, p_3}); } // 0x28004F88151E03E0 0xC4769830 b323
    pub inline fn stopSynchronizedEntityAnim(entity: types.Entity, p_1: f32, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x43D3807C077261E3, .{entity, p_1, p_2}); } // 0x43D3807C077261E3 0xE27D2FC1 b323
    /// if (ENTITY::HAS_ANIM_EVENT_FIRED(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("CreateObject")))
    pub inline fn hasAnimEventFired(entity: types.Entity, action_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEAF4CD9EA3E7E922, .{entity, action_hash}); } // 0xEAF4CD9EA3E7E922 0x66571CA0 b323
    /// In the script "player_scene_t_bbfight.c4": \
    /// "if (ENTITY::FIND_ANIM_EVENT_PHASE(&l_16E, &l_19F[v_4/*16*/], v_9, &v_A, &v_B))" \
    /// -- &l_16E (p0) is requested as an anim dictionary earlier in the script. \
    /// -- &l_19F[v_4/*16*/] (p1) is used in other natives in the script as the "animation" param. \
    /// -- v_9 (p2) is instantiated as "victim_fall"; I'm guessing that's another anim \
    /// --v_A and v_B (p3 & p4) are both set as -1.0, but v_A is used immediately after this native for:  \
    /// "if (v_A < ENTITY::GET_ENTITY_ANIM_CURRENT_TIME(...))" \
    /// Both v_A and v_B are seemingly used to contain both Vector3's and floats, so I can't say what either really is other than that they are both output parameters. p4 looks more like a *Vector3 though
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn findAnimEventPhase(anim_dictionary: [*c]const u8, anim_name: [*c]const u8, p_2: [*c]const u8, p_3: [*c]types.Any, p_4: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x07F1BE2BCCAA27A7, .{anim_dictionary, anim_name, p_2, p_3, p_4}); } // 0x07F1BE2BCCAA27A7 0xC41DDA62 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn setEntityAnimCurrentTime(entity: types.Entity, anim_dictionary: [*c]const u8, anim_name: [*c]const u8, time: f32) !void { try invoker.invoke(void, 0x4487C259F0F70977, .{entity, anim_dictionary, anim_name, time}); } // 0x4487C259F0F70977 0x99D90735 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn setEntityAnimSpeed(entity: types.Entity, anim_dictionary: [*c]const u8, anim_name: [*c]const u8, speed_multiplier: f32) !void { try invoker.invoke(void, 0x28D1A16553C51776, .{entity, anim_dictionary, anim_name, speed_multiplier}); } // 0x28D1A16553C51776 0x3990C90A b323
    /// Makes the specified entity (ped, vehicle or object) persistent. Persistent entities will not automatically be removed by the engine.
    /// 
    /// p1 has no effect when either its on or off  \
    /// maybe a quick disassembly will tell us what it does
    /// 
    /// p2 has no effect when either its on or off  \
    /// maybe a quick disassembly will tell us what it does
    pub inline fn setEntityAsMissionEntity(entity: types.Entity, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xAD738C3085FE7E11, .{entity, p_1, p_2}); } // 0xAD738C3085FE7E11 0x5D1F9E0F b323
    /// Marks the specified entity (ped, vehicle or object) as no longer needed if its population type is set to the mission type. \
    /// If the entity is ped, it will also clear their tasks immediately just like when CLEAR_PED_TASKS_IMMEDIATELY is called. \
    /// Entities marked as no longer needed, will be deleted as the engine sees fit. \
    /// Use this if you just want to just let the game delete the ped: \
    /// void MarkPedAsAmbientPed(Ped ped) { \
    ///   auto addr = getScriptHandleBaseAddress(ped);
    /// 
    ///   if (!addr) {
    ///     return;
    ///   }
    /// 
    ///   //the game uses only lower 4 bits as entity population type 
    ///   BYTE origValue = *(BYTE *)(addr + 0xDA);
    ///   *(BYTE *)(addr + 0xDA) = ((origValue & 0xF0) | ePopulationType::POPTYPE_RANDOM_AMBIENT);
    /// }
    pub inline fn setEntityAsNoLongerNeeded(entity: [*c]types.Entity) !void { try invoker.invoke(void, 0xB736A491E64A32CF, .{entity}); } // 0xB736A491E64A32CF 0xADF2267C b323
    /// This is an alias of SET_ENTITY_AS_NO_LONGER_NEEDED.
    pub inline fn setPedAsNoLongerNeeded(ped: [*c]types.Ped) !void { try invoker.invoke(void, 0x2595DD4236549CE3, .{ped}); } // 0x2595DD4236549CE3 0x9A388380 b323
    /// This is an alias of SET_ENTITY_AS_NO_LONGER_NEEDED.
    pub inline fn setVehicleAsNoLongerNeeded(vehicle: [*c]types.Vehicle) !void { try invoker.invoke(void, 0x629BFA74418D6239, .{vehicle}); } // 0x629BFA74418D6239 0x9B0E10BE b323
    /// This is an alias of SET_ENTITY_AS_NO_LONGER_NEEDED.
    pub inline fn setObjectAsNoLongerNeeded(object: [*c]types.Object) !void { try invoker.invoke(void, 0x3AE22DEB5BA5A3E6, .{object}); } // 0x3AE22DEB5BA5A3E6 0x3F6B949F b323
    pub inline fn setEntityCanBeDamaged(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1760FFA8AB074D66, .{entity, toggle}); } // 0x1760FFA8AB074D66 0x60B6E744 b323
    pub inline fn getEntityCanBeDamaged(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD95CC5D2AB15A09F, .{entity}); } // 0xD95CC5D2AB15A09F 0xE4938B5D b757
    pub inline fn setEntityCanBeDamagedByRelationshipGroup(entity: types.Entity, b_can_be_damaged: windows.BOOL, rel_group: c_int) !void { try invoker.invoke(void, 0xE22D8FDE858B8119, .{entity, b_can_be_damaged, rel_group}); } // 0xE22D8FDE858B8119 0x34165B5D b323
    pub inline fn setEntityCanOnlyBeDamagedByScriptParticipants(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x352E2B5CF420BF3B, .{entity, toggle}); } // 0x352E2B5CF420BF3B  b573
    /// Sets whether the entity can be targeted without being in line-of-sight.
    pub inline fn setEntityCanBeTargetedWithoutLos(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD3997889736FD899, .{entity, toggle}); } // 0xD3997889736FD899 0x3B13797C b323
    pub inline fn setEntityCollision(entity: types.Entity, toggle: windows.BOOL, keep_physics: windows.BOOL) !void { try invoker.invoke(void, 0x1A9205C1B9EE827F, .{entity, toggle, keep_physics}); } // 0x1A9205C1B9EE827F 0x139FD37D b323
    pub inline fn getEntityCollisionDisabled(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCCF1E97BEFDAE480, .{entity}); } // 0xCCF1E97BEFDAE480 0xE8C0C629 b323
    pub inline fn setEntityCompletelyDisableCollision(entity: types.Entity, toggle: windows.BOOL, keep_physics: windows.BOOL) !void { try invoker.invoke(void, 0x9EBC85ED0FFFE51C, .{entity, toggle, keep_physics}); } // 0x9EBC85ED0FFFE51C 0xBD0D4831 b323
    /// p7 is always 1 in the scripts. Set to 1, an area around the destination coords for the moved entity is cleared from other entities. 
    ///  
    /// Often ends with 1, 0, 0, 1); in the scripts. It works. 
    /// 
    /// Axis - Invert Axis Flags
    pub inline fn setEntityCoords(entity: types.Entity, pos__: types.Vector3, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL, clear_area: windows.BOOL) !void { try invoker.invoke(void, 0x06843DA7060A026B, .{entity, pos__.x, pos__.y, pos__.z, x_axis, y_axis, z_axis, clear_area}); } // 0x06843DA7060A026B 0xDF70B41B b323
    pub inline fn setEntityCoordsWithoutPlantsReset(entity: types.Entity, pos__: types.Vector3, alive: windows.BOOL, dead_flag: windows.BOOL, ragdoll_flag: windows.BOOL, clear_area: windows.BOOL) !void { try invoker.invoke(void, 0x621873ECE1178967, .{entity, pos__.x, pos__.y, pos__.z, alive, dead_flag, ragdoll_flag, clear_area}); } // 0x621873ECE1178967 0x749B282E b323
    /// Axis - Invert Axis Flags
    pub inline fn setEntityCoordsNoOffset(entity: types.Entity, pos__: types.Vector3, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL) !void { try invoker.invoke(void, 0x239A3351AC1DA385, .{entity, pos__.x, pos__.y, pos__.z, x_axis, y_axis, z_axis}); } // 0x239A3351AC1DA385 0x4C83DE8D b323
    pub inline fn setEntityDynamic(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1718DE8E3F2823CA, .{entity, toggle}); } // 0x1718DE8E3F2823CA 0x236F525B b323
    /// Set the heading of an entity in degrees also known as "Yaw".
    pub inline fn setEntityHeading(entity: types.Entity, heading: f32) !void { try invoker.invoke(void, 0x8E2530AA8ADA980E, .{entity, heading}); } // 0x8E2530AA8ADA980E 0xE0FF064D b323
    /// health >= 0 \
    /// male ped ~= 100 - 200 \
    /// female ped ~= 0 - 100
    pub inline fn setEntityHealth(entity: types.Entity, health: c_int, instigator: types.Entity, weapon_type: types.Hash) !void { try invoker.invoke(void, 0x6B76DC1F3AE6E6A3, .{entity, health, instigator, weapon_type}); } // 0x6B76DC1F3AE6E6A3 0xFBCD1831 b323
    /// Sets a ped or an object totally invincible. It doesn't take any kind of damage. Peds will not ragdoll on explosions and the tazer animation won't apply either.
    /// 
    /// If you use this for a ped and you want Ragdoll to stay enabled, then do: \
    /// *(DWORD *)(pedAddress + 0x188) |= (1 << 9);
    /// 
    /// Use this if you want to get the invincibility status: \
    ///   bool IsPedInvincible(Ped ped)
    ///  { \
    ///      auto addr = getScriptHandleBaseAddress(ped);    
    /// 
    ///         if (addr)
    ///      {
    ///          DWORD flag = *(DWORD *)(addr + 0x188);
    ///             return ((flag & (1 << 8)) != 0) || ((flag & (1 << 9)) != 0);
    ///       }
    /// 
    ///        return false;
    ///  }
    pub inline fn setEntityInvincible(entity: types.Entity, toggle: windows.BOOL, dont_reset_on_cleanup: windows.BOOL) !void { try invoker.invoke(void, 0x3882114BDE571AD4, .{entity, toggle, dont_reset_on_cleanup}); } // 0x3882114BDE571AD4 0xC1213A21 b323
    pub inline fn setEntityIsTargetPriority(entity: types.Entity, p_1: windows.BOOL, p_2: f32) !void { try invoker.invoke(void, 0xEA02E132F5C68722, .{entity, p_1, p_2}); } // 0xEA02E132F5C68722 0x9729EE32 b323
    pub inline fn setEntityLights(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7CFBA6A80BDF3874, .{entity, toggle}); } // 0x7CFBA6A80BDF3874 0xE8FC85AF b323
    /// Loads collision grid for an entity spawned outside of a player's loaded area. This allows peds to execute tasks rather than sit dormant because of a lack of a physics grid. \
    /// Certainly not the main usage of this native but when set to true for a Vehicle, it will prevent the vehicle to explode if it is spawned far away from the player.
    pub inline fn setEntityLoadCollisionFlag(entity: types.Entity, toggle: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0x0DC7CABAB1E9B67E, .{entity, toggle, p_2}); } // 0x0DC7CABAB1E9B67E 0xC52F295B b323
    pub inline fn hasCollisionLoadedAroundEntity(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE9676F61BC0B3321, .{entity}); } // 0xE9676F61BC0B3321 0x851687F9 b323
    pub inline fn setEntityMaxSpeed(entity: types.Entity, speed: f32) !void { try invoker.invoke(void, 0x0E46A3FCBDE2A1B1, .{entity, speed}); } // 0x0E46A3FCBDE2A1B1 0x46AFFED3 b323
    pub inline fn setEntityOnlyDamagedByPlayer(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x79F020FF9EDC0748, .{entity, toggle}); } // 0x79F020FF9EDC0748 0x4B707F50 b323
    pub inline fn setEntityOnlyDamagedByRelationshipGroup(entity: types.Entity, p_1: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0x7022BD828FA0B082, .{entity, p_1, p_2}); } // 0x7022BD828FA0B082 0x202237E2 b323
    /// Enable / disable each type of damage.
    /// 
    /// waterProof is damage related to water not drowning \
    /// -------------- \
    /// p7 is to to '1' in am_mp_property_ext/int: ENTITY::SET_ENTITY_PROOFS(uParam0->f_19, true, true, true, true, true, true, 1, true);
    /// 
    pub inline fn setEntityProofs(entity: types.Entity, bullet_proof: windows.BOOL, fire_proof: windows.BOOL, explosion_proof: windows.BOOL, collision_proof: windows.BOOL, melee_proof: windows.BOOL, steam_proof: windows.BOOL, dont_reset_on_cleanup: windows.BOOL, water_proof: windows.BOOL) !void { try invoker.invoke(void, 0xFAEE099C6F890BB8, .{entity, bullet_proof, fire_proof, explosion_proof, collision_proof, melee_proof, steam_proof, dont_reset_on_cleanup, water_proof}); } // 0xFAEE099C6F890BB8 0x7E9EAB66 b323
    pub inline fn getEntityProofs(entity: types.Entity, bullet_proof: [*c]windows.BOOL, fire_proof: [*c]windows.BOOL, explosion_proof: [*c]windows.BOOL, collision_proof: [*c]windows.BOOL, melee_proof: [*c]windows.BOOL, steam_proof: [*c]windows.BOOL, p_7: [*c]windows.BOOL, drown_proof: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBE8CD9BE829BBEBF, .{entity, bullet_proof, fire_proof, explosion_proof, collision_proof, melee_proof, steam_proof, p_7, drown_proof}); } // 0xBE8CD9BE829BBEBF  b1604
    /// w is the correct parameter name!
    pub inline fn setEntityQuaternion(entity: types.Entity, vec: types.Vector4) !void { try invoker.invoke(void, 0x77B21BE7AC540F07, .{entity, vec.x, vec.y, vec.z, vec.w}); } // 0x77B21BE7AC540F07 0x83B6046F b323
    pub inline fn setEntityRecordsCollisions(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0A50A1EEDAD01E65, .{entity, toggle}); } // 0x0A50A1EEDAD01E65 0x6B189A1A b323
    /// rotationOrder refers to the order yaw pitch roll is applied \
    /// value ranges from 0 to 5. What you use for rotationOrder when setting must be the same as rotationOrder when getting the rotation.  \
    /// Unsure what value corresponds to what rotation order, more testing will be needed for that. \
    /// For the most part R* uses 1 or 2 as the order. \
    /// p5 is usually set as true
    /// 
    pub inline fn setEntityRotation(entity: types.Entity, pitch: f32, roll: f32, yaw: f32, rotation_order: c_int, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x8524A8B0171D5E07, .{entity, pitch, roll, yaw, rotation_order, p_5}); } // 0x8524A8B0171D5E07 0x0A345EFE b323
    /// p2 is always 0.
    pub inline fn setEntityVisible(entity: types.Entity, toggle: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xEA1C610A04DB6BBB, .{entity, toggle, p_2}); } // 0xEA1C610A04DB6BBB 0xD043E8E1 b323
    pub inline fn setEntityWaterReflectionFlag(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC34BC448DA29F5E9, .{entity, toggle}); } // 0xC34BC448DA29F5E9  b573
    pub inline fn setEntityMirrorReflectionFlag(entity: types.Entity, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xE66377CDDADA4810, .{entity, p_1}); } // 0xE66377CDDADA4810  b1734
    /// Note that the third parameter(denoted as z) is "up and down" with positive numbers encouraging upwards movement.
    pub inline fn setEntityVelocity(entity: types.Entity, vec: types.Vector3) !void { try invoker.invoke(void, 0x1C99BB7B6E96D16F, .{entity, vec.x, vec.y, vec.z}); } // 0x1C99BB7B6E96D16F 0xFF5A1988 b323
    pub inline fn setEntityAngularVelocity(entity: types.Entity, vec: types.Vector3) !void { try invoker.invoke(void, 0x8339643499D1222E, .{entity, vec.x, vec.y, vec.z}); } // 0x8339643499D1222E  b2372
    pub inline fn setEntityHasGravity(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4A4722448F18EEF5, .{entity, toggle}); } // 0x4A4722448F18EEF5 0xE2F262BF b323
    /// LOD distance can be 0 to 0xFFFF (higher values will result in 0xFFFF) as it is actually stored as a 16-bit value (aka uint16_t).
    pub inline fn setEntityLodDist(entity: types.Entity, value: c_int) !void { try invoker.invoke(void, 0x5927F96A78577363, .{entity, value}); } // 0x5927F96A78577363 0xD7ACC7AD b323
    /// Returns the LOD distance of an entity.
    pub inline fn getEntityLodDist(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0x4159C2762B5791D6, .{entity}); } // 0x4159C2762B5791D6 0x4DA3D51F b323
    /// skin - everything alpha except skin \
    /// Set entity alpha level. Ranging from 0 to 255 but chnages occur after every 20 percent (after every 51).
    pub inline fn setEntityAlpha(entity: types.Entity, alpha_level: c_int, skin: windows.BOOL) !void { try invoker.invoke(void, 0x44A0870B7E92D7C0, .{entity, alpha_level, skin}); } // 0x44A0870B7E92D7C0 0xAE667CB0 b323
    pub inline fn getEntityAlpha(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0x5A47B3B5E63E94C6, .{entity}); } // 0x5A47B3B5E63E94C6 0x1560B017 b323
    pub inline fn resetEntityAlpha(entity: types.Entity) !void { try invoker.invoke(void, 0x9B1E824FFBB7027A, .{entity}); } // 0x9B1E824FFBB7027A 0x8A30761C b323
    /// Similar to RESET_ENTITY_ALPHA
    pub inline fn resetPickupEntityGlow(entity: types.Entity) !void { try invoker.invoke(void, 0x490861B88F4FD846, .{entity}); } // 0x490861B88F4FD846  b944
    pub inline fn setPickupCollidesWithProjectiles(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xCEA7C8E1B48FF68C, .{p_0, p_1}); } // 0xCEA7C8E1B48FF68C  b678
    /// Only called once in the scripts.
    /// 
    /// Related to weapon objects.
    /// 
    pub inline fn setEntitySortBias(entity: types.Entity, p_1: f32) !void { try invoker.invoke(void, 0x5C3B791D580E0BC2, .{entity, p_1}); } // 0x5C3B791D580E0BC2  b323
    pub inline fn setEntityAlwaysPrerender(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xACAD101E1FB66689, .{entity, toggle}); } // 0xACAD101E1FB66689 0xD8FF798A b323
    pub inline fn setEntityRenderScorched(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x730F5F8D3F0F2050, .{entity, toggle}); } // 0x730F5F8D3F0F2050 0xAAC9317B b323
    /// Example here: www.gtaforums.com/topic/830463-help-with-turning-lights-green-and-causing-peds-to-crash-into-each-other/#entry1068211340
    /// 
    /// 0 = green \
    /// 1 = red \
    /// 2 = yellow \
    /// 3 = reset changes \
    /// changing lights may not change the behavior of vehicles
    pub inline fn setEntityTrafficlightOverride(entity: types.Entity, state: c_int) !void { try invoker.invoke(void, 0x57C5DB656185EAC4, .{entity, state}); } // 0x57C5DB656185EAC4 0xC47F5B91 b323
    pub inline fn setEntityIsInVehicle(entity: types.Entity) !void { try invoker.invoke(void, 0x78E8E3A640178255, .{entity}); } // 0x78E8E3A640178255  b323
    /// Only works with objects!
    pub inline fn createModelSwap(vec: types.Vector3, radius: f32, original_model: types.Hash, new_model: types.Hash, p_6: windows.BOOL) !void { try invoker.invoke(void, 0x92C47782FDA8B2A3, .{vec.x, vec.y, vec.z, radius, original_model, new_model, p_6}); } // 0x92C47782FDA8B2A3 0x0BC12F9E b323
    pub inline fn removeModelSwap(vec: types.Vector3, radius: f32, original_model: types.Hash, new_model: types.Hash, p_6: windows.BOOL) !void { try invoker.invoke(void, 0x033C0F9A64E229AE, .{vec.x, vec.y, vec.z, radius, original_model, new_model, p_6}); } // 0x033C0F9A64E229AE 0xCE0AA8BC b323
    /// p5 = sets as true in scripts \
    /// Same as the comment for CREATE_MODEL_SWAP unless for some reason p5 affects it this only works with objects as well.
    /// 
    /// Network players do not see changes done with this.
    pub inline fn createModelHide(vec: types.Vector3, radius: f32, model_hash: types.Hash, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x8A97BCA30A0CE478, .{vec.x, vec.y, vec.z, radius, model_hash, p_5}); } // 0x8A97BCA30A0CE478 0x7BD5CF2F b323
    pub inline fn createModelHideExcludingScriptObjects(vec: types.Vector3, radius: f32, model_hash: types.Hash, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x3A52AE588830BF7F, .{vec.x, vec.y, vec.z, radius, model_hash, p_5}); } // 0x3A52AE588830BF7F 0x07AAF22C b323
    /// This native makes entities visible that are hidden by the native CREATE_MODEL_HIDE. \
    /// p5 should be false, true does nothing
    pub inline fn removeModelHide(vec: types.Vector3, radius: f32, model_hash: types.Hash, p_5: windows.BOOL) !void { try invoker.invoke(void, 0xD9E3006FB3CBD765, .{vec.x, vec.y, vec.z, radius, model_hash, p_5}); } // 0xD9E3006FB3CBD765 0x993DBC10 b323
    pub inline fn createForcedObject(vec: types.Vector3, p_3: types.Any, model_hash: types.Hash, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x150E808B375A385A, .{vec.x, vec.y, vec.z, p_3, model_hash, p_5}); } // 0x150E808B375A385A 0x335190A2 b323
    pub inline fn removeForcedObject(vec: types.Vector3, p_3: f32, model_hash: types.Hash) !void { try invoker.invoke(void, 0x61B6775E83C0DB6F, .{vec.x, vec.y, vec.z, p_3, model_hash}); } // 0x61B6775E83C0DB6F 0xAED73ADD b323
    /// Calling this function disables collision between two entities. \
    /// The importance of the order for entity1 and entity2 is unclear. \
    /// The third parameter, `thisFrame`, decides whether the collision is to be disabled until it is turned back on, or if it's just this frame.
    pub inline fn setEntityNoCollisionEntity(entity_1: types.Entity, entity_2: types.Entity, this_frame_only: windows.BOOL) !void { try invoker.invoke(void, 0xA53ED5520C07654A, .{entity_1, entity_2, this_frame_only}); } // 0xA53ED5520C07654A 0x1E11BFE9 b323
    pub inline fn setEntityNoCollisionWithNetworkedEntity_(entity_1: types.Entity, entity_2: types.Entity) !void { try invoker.invoke(void, 0x0A27A7827347B3B1, .{entity_1, entity_2}); } // 0x0A27A7827347B3B1  b3407
    pub inline fn setEntityMotionBlur(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x295D82A8559F9150, .{entity, toggle}); } // 0x295D82A8559F9150 0xE90005B8 b323
    /// p1 always false.
    pub inline fn setCanAutoVaultOnEntity(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE12ABE5E3A389A6C, .{entity, toggle}); } // 0xE12ABE5E3A389A6C 0x44767B31 b323
    /// p1 always false.
    pub inline fn setCanClimbOnEntity(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA80AE305E0A3044F, .{entity, toggle}); } // 0xA80AE305E0A3044F 0xE224A6A5 b323
    /// Only called within 1 script for x360. 'fm_mission_controller' and it used on an object. 
    /// 
    /// Ran after these 2 natives, \
    /// set_object_targettable(uParam0, 0); \
    /// set_entity_invincible(uParam0, 1);
    pub inline fn setWaitForCollisionsBeforeProbe(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDC6F8601FAF2E893, .{entity, toggle}); } // 0xDC6F8601FAF2E893 0xA0466A69 b323
    pub inline fn setEntityNoweapondecals(entity: types.Entity, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x2C2E3DC128F44309, .{entity, p_1}); } // 0x2C2E3DC128F44309  b323
    pub inline fn setEntityUseMaxDistanceForWaterReflection(entity: types.Entity, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x1A092BB0C3808B96, .{entity, p_1}); } // 0x1A092BB0C3808B96  b323
    /// Gets the world rotation of the specified bone of the specified entity.
    pub inline fn getEntityBoneRotation(entity: types.Entity, bone_index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xCE6294A232D03786, .{entity, bone_index}); } // 0xCE6294A232D03786  b791
    /// Gets the world position of the specified bone of the specified entity.
    pub inline fn getEntityBonePostion(entity: types.Entity, bone_index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x46F8696933A63C9B, .{entity, bone_index}); } // 0x46F8696933A63C9B  b877
    /// Gets the local rotation of the specified bone of the specified entity.
    pub inline fn getEntityBoneObjectRotation(entity: types.Entity, bone_index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xBD8D32550E5CEBFE, .{entity, bone_index}); } // 0xBD8D32550E5CEBFE  b1734
    pub inline fn getEntityBoneObjectPostion(entity: types.Entity, bone_index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xCF1247CC86961FD6, .{entity, bone_index}); } // 0xCF1247CC86961FD6  b2802
    pub inline fn getEntityBoneCount(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0xB328DCC3A3AA401B, .{entity}); } // 0xB328DCC3A3AA401B  b791
    pub inline fn enableEntityBulletCollision(entity: types.Entity) !void { try invoker.invoke(void, 0x6CE177D014502E8A, .{entity}); } // 0x6CE177D014502E8A  b877
    pub inline fn setEntityCanOnlyBeDamagedByEntity(entity_1: types.Entity, entity_2: types.Entity) !void { try invoker.invoke(void, 0xB17BC6453F6CF5AC, .{entity_1, entity_2}); } // 0xB17BC6453F6CF5AC  b944
    pub inline fn setEntityCantCauseCollisionDamagedEntity(entity_1: types.Entity, entity_2: types.Entity) !void { try invoker.invoke(void, 0x68B562E124CC0AEF, .{entity_1, entity_2}); } // 0x68B562E124CC0AEF  b1180
    /// p1 is always set to 1
    pub inline fn setAllowMigrateToSpectator(entity: types.Entity, p_1: types.Any) !void { try invoker.invoke(void, 0x36F32DE87082343E, .{entity, p_1}); } // 0x36F32DE87082343E  b1011
    /// Gets the handle of an entity with a specific model hash attached to another entity, such as an object attached to a ped. \
    ///  This native does not appear to have anything to do with pickups as in scripts it is used with objects.
    /// 
    /// Example from fm_mission_controller_2020.c:
    /// 
    /// iVar8 = ENTITY::GET_ENTITY_OF_TYPE_ATTACHED_TO_ENTITY(bParam0->f_9, joaat("p_cs_clipboard"));
    pub inline fn getEntityOfTypeAttachedToEntity(entity: types.Entity, model_hash: types.Hash) !types.Entity { return try invoker.invoke(types.Entity, 0x1F922734E259BD26, .{entity, model_hash}); } // 0x1F922734E259BD26  b1180
    pub inline fn setPickUpByCargobobDisabled(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD7B80E7C3BEFC396, .{entity, toggle}); } // 0xD7B80E7C3BEFC396  b1180
};

pub const Event = struct
{
    pub inline fn setDecisionMaker(ped: types.Ped, name: types.Hash) !void { try invoker.invoke(void, 0xB604A2942ADED0EE, .{ped, name}); } // 0xB604A2942ADED0EE 0x19CEAC9E b323
    /// eventType: https://alloc8or.re/gta5/doc/enums/eEventType.txt
    pub inline fn clearDecisionMakerEventResponse(name: types.Hash, event_type: c_int) !void { try invoker.invoke(void, 0x4FC9381A7AEE8968, .{name, event_type}); } // 0x4FC9381A7AEE8968 0x07ABD94D b323
    /// eventType: https://alloc8or.re/gta5/doc/enums/eEventType.txt
    /// 
    /// This is limited to 4 blocked events at a time.
    pub inline fn blockDecisionMakerEvent(name: types.Hash, event_type: c_int) !void { try invoker.invoke(void, 0xE42FCDFD0E4196F7, .{name, event_type}); } // 0xE42FCDFD0E4196F7 0x57506EA6 b323
    /// eventType: https://alloc8or.re/gta5/doc/enums/eEventType.txt
    pub inline fn unblockDecisionMakerEvent(name: types.Hash, event_type: c_int) !void { try invoker.invoke(void, 0xD7CD9CF34F2C99E8, .{name, event_type}); } // 0xD7CD9CF34F2C99E8 0x62A3161D b323
    /// eventType: https://alloc8or.re/gta5/doc/enums/eEventType.txt
    pub inline fn addShockingEventAtPosition(event_type: c_int, vec: types.Vector3, duration: f32) !c_int { return try invoker.invoke(c_int, 0xD9F8455409B525E9, .{event_type, vec.x, vec.y, vec.z, duration}); } // 0xD9F8455409B525E9 0x0B30F779 b323
    /// eventType: https://alloc8or.re/gta5/doc/enums/eEventType.txt
    pub inline fn addShockingEventForEntity(event_type: c_int, entity: types.Entity, duration: f32) !c_int { return try invoker.invoke(c_int, 0x7FD8F3BE76F89422, .{event_type, entity, duration}); } // 0x7FD8F3BE76F89422 0xA81B5B71 b323
    /// eventType: https://alloc8or.re/gta5/doc/enums/eEventType.txt
    pub inline fn isShockingEventInSphere(event_type: c_int, vec: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1374ABB7C15BAB92, .{event_type, vec.x, vec.y, vec.z, radius}); } // 0x1374ABB7C15BAB92 0x2F98823E b323
    pub inline fn removeShockingEvent(event: types.ScrHandle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2CDA538C44C6CCE5, .{event}); } // 0x2CDA538C44C6CCE5 0xF82D5A87 b323
    pub inline fn removeAllShockingEvents(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xEAABE8FDFA21274C, .{p_0}); } // 0xEAABE8FDFA21274C 0x64DF6282 b323
    pub inline fn removeShockingEventSpawnBlockingAreas() !void { try invoker.invoke(void, 0x340F1415B68AEADE, .{}); } // 0x340F1415B68AEADE 0xA0CE89C8 b323
    pub inline fn suppressShockingEventsNextFrame() !void { try invoker.invoke(void, 0x2F9A292AD0A3BD89, .{}); } // 0x2F9A292AD0A3BD89 0x4CC674B5 b323
    /// eventType: https://alloc8or.re/gta5/doc/enums/eEventType.txt
    pub inline fn suppressShockingEventTypeNextFrame(event_type: c_int) !void { try invoker.invoke(void, 0x3FD2EC8BF1F1CF30, .{event_type}); } // 0x3FD2EC8BF1F1CF30 0xA0FDCB82 b323
    pub inline fn suppressAgitationEventsNextFrame() !void { try invoker.invoke(void, 0x5F3B7749C112D552, .{}); } // 0x5F3B7749C112D552 0x80340396 b323
};

pub const Extrametadata = struct
{
    /// Character types: \
    /// 0 = Michael,  \
    /// 1 = Franklin,  \
    /// 2 = Trevor,  \
    /// 3 = MPMale,  \
    /// 4 = MPFemale
    pub inline fn getNumTattooShopDlcItems(character: c_int) !c_int { return try invoker.invoke(c_int, 0x278F76C3B0A8F109, .{character}); } // 0x278F76C3B0A8F109 0x71D0CF3E b323
    /// Character types: \
    /// 0 = Michael,  \
    /// 1 = Franklin,  \
    /// 2 = Trevor,  \
    /// 3 = MPMale,  \
    /// 4 = MPFemale
    /// 
    /// 
    /// enum TattooZoneData \
    /// {   \
    ///     ZONE_TORSO = 0,  
    ///     ZONE_HEAD = 1,  
    ///     ZONE_LEFT_ARM = 2,  
    ///     ZONE_RIGHT_ARM = 3,  
    ///     ZONE_LEFT_LEG = 4,  
    ///     ZONE_RIGHT_LEG = 5,  
    ///     ZONE_UNKNOWN = 6,
    ///     ZONE_NONE = 7,  
    /// }; \
    /// struct outComponent \
    /// { \
    ///     // these vars are suffixed with 4 bytes of padding each.
    ///     uint unk;
    ///     int unk2;
    ///     uint tattooCollectionHash;
    ///     uint tattooNameHash;
    ///     int unk3;
    ///     TattooZoneData zoneId;
    ///     uint unk4;
    ///     uint unk5;
    ///     // maybe more, not sure exactly, decompiled scripts are very vague around this part.
    /// }
    pub inline fn getTattooShopDlcItemData(character_type: c_int, decoration_index: c_int, out_component: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFF56381874F82086, .{character_type, decoration_index, out_component}); } // 0xFF56381874F82086 0x2E9D628C b323
    /// Returns some sort of index/offset for overlays/decorations.
    /// 
    /// Character types: \
    /// 0 = Michael,  \
    /// 1 = Franklin,  \
    /// 2 = Trevor,  \
    /// 3 = MPMale,  \
    /// 4 = MPFemale
    pub inline fn getTattooShopDlcItemIndex(overlay_hash: types.Hash, p_1: types.Any, character: c_int) !c_int { return try invoker.invoke(c_int, 0x10144267DD22866C, .{overlay_hash, p_1, character}); } // 0x10144267DD22866C  b2189
    pub inline fn initShopPedComponent(out_component: [*c]types.Any) !void { try invoker.invoke(void, 0x1E8C308FD312C036, .{out_component}); } // 0x1E8C308FD312C036 0xB818C7FC b323
    pub inline fn initShopPedProp(out_prop: [*c]types.Any) !void { try invoker.invoke(void, 0xEB0A2B758F7B850F, .{out_prop}); } // 0xEB0A2B758F7B850F 0xF5659E50 b323
    pub inline fn setupShopPedApparelQuery(p_0: c_int, p_1: c_int, p_2: c_int, p_3: c_int) !c_int { return try invoker.invoke(c_int, 0x50F457823CE6EB5F, .{p_0, p_1, p_2, p_3}); } // 0x50F457823CE6EB5F 0xC937FF3D b323
    /// character is 0 for Michael, 1 for Franklin, 2 for Trevor, 3 for freemode male, and 4 for freemode female.
    /// 
    /// componentId is between 0 and 11 and corresponds to the usual component slots.
    /// 
    /// p1 could be the outfit number; unsure.
    /// 
    /// p2 is usually -1; unknown function.
    /// 
    /// p3 appears to be for selecting between clothes and props; false is used with components/clothes, true is used with props.
    /// 
    /// p4 is usually -1; unknown function.
    /// 
    /// componentId is -1 when p3 is true in decompiled scripts.
    pub inline fn setupShopPedApparelQueryTu(character: c_int, p_1: c_int, p_2: c_int, p_3: windows.BOOL, p_4: c_int, component_id: c_int) !c_int { return try invoker.invoke(c_int, 0x9BDF59818B1E38C1, .{character, p_1, p_2, p_3, p_4, component_id}); } // 0x9BDF59818B1E38C1 0x594E862C b323
    /// See https://git.io/JtcRf for example and structs.
    pub inline fn getShopPedQueryComponent(component_id: c_int, out_component: [*c]types.Any) !void { try invoker.invoke(void, 0x249E310B2D920699, .{component_id, out_component}); } // 0x249E310B2D920699 0xC0718904 b323
    /// Returns some sort of index/offset for components. \
    /// Needs _GET_NUM_PROPS_FROM_OUTFIT to be called with p3 = false and componentId with the drawable's component slot first, returns -1 otherwise.
    pub inline fn getShopPedQueryComponentIndex(component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x96E2929292A4DB77, .{component_hash}); } // 0x96E2929292A4DB77  b2189
    /// More info here: https://gist.github.com/root-cause/3b80234367b0c856d60bf5cb4b826f86
    pub inline fn getShopPedComponent(component_hash: types.Hash, out_component: [*c]types.Any) !void { try invoker.invoke(void, 0x74C0E2A57EC66760, .{component_hash, out_component}); } // 0x74C0E2A57EC66760 0xB39677C5 b323
    /// See https://git.io/JtcRf for example and structs.
    pub inline fn getShopPedQueryProp(component_id: c_int, out_prop: [*c]types.Any) !void { try invoker.invoke(void, 0xDE44A00999B2837D, .{component_id, out_prop}); } // 0xDE44A00999B2837D 0x1D3C1466 b323
    /// Returns some sort of index/offset for props. \
    /// Needs _GET_NUM_PROPS_FROM_OUTFIT to be called with p3 = true and componentId = -1 first, returns -1 otherwise.
    pub inline fn getShopPedQueryPropIndex(component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x6CEBE002E58DEE97, .{component_hash}); } // 0x6CEBE002E58DEE97  b2189
    /// More info here: https://gist.github.com/root-cause/3b80234367b0c856d60bf5cb4b826f86
    pub inline fn getShopPedProp(component_hash: types.Hash, out_prop: [*c]types.Any) !void { try invoker.invoke(void, 0x5D5CAFF661DDF6FC, .{component_hash, out_prop}); } // 0x5D5CAFF661DDF6FC 0xDB0A7A58 b323
    pub inline fn getHashNameForComponent(entity: types.Entity, component_id: c_int, drawable_variant: c_int, texture_variant: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0x0368B3A838070348, .{entity, component_id, drawable_variant, texture_variant}); } // 0x0368B3A838070348 0xC8A4BF12 b323
    pub inline fn getHashNameForProp(entity: types.Entity, component_id: c_int, prop_index: c_int, prop_texture_index: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0x5D6160275CAEC8DD, .{entity, component_id, prop_index, prop_texture_index}); } // 0x5D6160275CAEC8DD 0x7D876DC0 b323
    pub inline fn getShopPedApparelVariantComponentCount(component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xC17AD0E5752BECDA, .{component_hash}); } // 0xC17AD0E5752BECDA 0x159751B4 b323
    /// `propHash`: Ped helmet prop hash? \
    /// This native returns 1 when the player helmet has a visor (there is another prop index for the same helmet with closed/opened visor variant) that can be toggled. 0 if there's no alternative version with a visor for this helmet prop.
    pub inline fn getShopPedApparelVariantPropCount(prop_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xD40AAC51E8E4C663, .{prop_hash}); } // 0xD40AAC51E8E4C663  b791
    pub inline fn getVariantComponent(component_hash: types.Hash, variant_component_index: c_int, name_hash: [*c]types.Hash, enum_value: [*c]c_int, component_type: [*c]c_int) !void { try invoker.invoke(void, 0x6E11F282F11863B6, .{component_hash, variant_component_index, name_hash, enum_value, component_type}); } // 0x6E11F282F11863B6 0xE4FF7103 b323
    pub inline fn getVariantProp(component_hash: types.Hash, variant_prop_index: c_int, name_hash: [*c]types.Hash, enum_value: [*c]c_int, anchor_point: [*c]c_int) !void { try invoker.invoke(void, 0xD81B7F27BC773E66, .{component_hash, variant_prop_index, name_hash, enum_value, anchor_point}); } // 0xD81B7F27BC773E66  b791
    /// Returns number of possible values of the forcedComponentIndex argument of GET_FORCED_COMPONENT.
    pub inline fn getShopPedApparelForcedComponentCount(component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xC6B9DB42C04DD8C3, .{component_hash}); } // 0xC6B9DB42C04DD8C3 0xCE70F183 b323
    /// Returns number of possible values of the forcedPropIndex argument of GET_FORCED_PROP.
    pub inline fn getShopPedApparelForcedPropCount(component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x017568A8182D98A6, .{component_hash}); } // 0x017568A8182D98A6 0xC560D7C0 b323
    pub inline fn getForcedComponent(component_hash: types.Hash, forced_component_index: c_int, name_hash: [*c]types.Hash, enum_value: [*c]c_int, component_type: [*c]c_int) !void { try invoker.invoke(void, 0x6C93ED8C2F74859B, .{component_hash, forced_component_index, name_hash, enum_value, component_type}); } // 0x6C93ED8C2F74859B 0x382C70BE b323
    pub inline fn getForcedProp(component_hash: types.Hash, forced_prop_index: c_int, name_hash: [*c]types.Hash, enum_value: [*c]c_int, anchor_point: [*c]c_int) !void { try invoker.invoke(void, 0xE1CA84EBF72E691D, .{component_hash, forced_prop_index, name_hash, enum_value, anchor_point}); } // 0xE1CA84EBF72E691D 0x22DAE257 b323
    /// Full list of restriction tags by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedApparelRestrictionTags.json
    /// 
    /// componentId/last parameter seems to be unused.
    pub inline fn doesShopPedApparelHaveRestrictionTag(component_hash: types.Hash, restriction_tag_hash: types.Hash, component_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x341DE7ED1D2A1BFD, .{component_hash, restriction_tag_hash, component_id}); } // 0x341DE7ED1D2A1BFD 0x8E2C7FD5 b323
    pub inline fn doesCurrentPedComponentHaveRestrictionTag(ped: types.Ped, component_id: c_int, restriction_tag_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7796B21B76221BC5, .{ped, component_id, restriction_tag_hash}); } // 0x7796B21B76221BC5  b2612
    pub inline fn doesCurrentPedPropHaveRestrictionTag(ped: types.Ped, component_id: c_int, restriction_tag_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD726BAB4554DA580, .{ped, component_id, restriction_tag_hash}); } // 0xD726BAB4554DA580  b2612
    /// characters
    /// 
    /// 0: Michael \
    /// 1: Franklin \
    /// 2: Trevor \
    /// 3: MPMale \
    /// 4: MPFemale
    pub inline fn setupShopPedOutfitQuery(character: c_int, p_1: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xF3FBE2D50A6A8C28, .{character, p_1}); } // 0xF3FBE2D50A6A8C28 0x1ECD23E7 b323
    /// outfitIndex: from 0 to SETUP_SHOP_PED_OUTFIT_QUERY(characterIndex, false) - 1. \
    /// See https://git.io/JtcB8 for example and outfit struct.
    pub inline fn getShopPedQueryOutfit(outfit_index: c_int, outfit: [*c]types.Any) !void { try invoker.invoke(void, 0x6D793F03A631FE56, .{outfit_index, outfit}); } // 0x6D793F03A631FE56 0x2F8013A1 b323
    pub inline fn getShopPedOutfit(p_0: types.Any, p_1: [*c]types.Any) !void { try invoker.invoke(void, 0xB7952076E444979D, .{p_0, p_1}); } // 0xB7952076E444979D 0xCAFE9209 b323
    pub inline fn getShopPedOutfitLocate(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x073CA26B079F956E, .{p_0}); } // 0x073CA26B079F956E 0x2798F56F b323
    /// See https://git.io/JtcBH for example and structs.
    pub inline fn getShopPedOutfitPropVariant(outfit_hash: types.Hash, variant_index: c_int, out_prop_variant: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA9F9C2E0FDE11CBB, .{outfit_hash, variant_index, out_prop_variant}); } // 0xA9F9C2E0FDE11CBB 0x6641A864 b323
    /// See https://git.io/JtcBH for example and structs.
    pub inline fn getShopPedOutfitComponentVariant(outfit_hash: types.Hash, variant_index: c_int, out_component_variant: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x19F2A026EDF0013F, .{outfit_hash, variant_index, out_component_variant}); } // 0x19F2A026EDF0013F 0x818534AC b323
    pub inline fn getNumDlcVehicles() !c_int { return try invoker.invoke(c_int, 0xA7A866D21CD2329B, .{}); } // 0xA7A866D21CD2329B 0x8EAF9CF6 b323
    /// dlcVehicleIndex is 0 to GET_NUM_DLC_VEHICLS() - 1
    pub inline fn getDlcVehicleModel(dlc_vehicle_index: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0xECC01B7C5763333C, .{dlc_vehicle_index}); } // 0xECC01B7C5763333C 0xA2201E09 b323
    /// dlcVehicleIndex takes a number from 0 - GET_NUM_DLC_VEHICLES() - 1. \
    /// outData is a struct of 3 8-byte items. \
    /// The Second item in the struct *(Hash *)(outData + 1) is the vehicle hash.
    pub inline fn getDlcVehicleData(dlc_vehicle_index: c_int, out_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x33468EDC08E371F6, .{dlc_vehicle_index, out_data}); } // 0x33468EDC08E371F6 0xCF428FA4 b323
    pub inline fn getDlcVehicleFlags(dlc_vehicle_index: c_int) !c_int { return try invoker.invoke(c_int, 0x5549EE11FA22FCF2, .{dlc_vehicle_index}); } // 0x5549EE11FA22FCF2 0xAB12738C b323
    /// Returns the total number of DLC weapons.
    pub inline fn getNumDlcWeapons() !c_int { return try invoker.invoke(c_int, 0xEE47635F352DA367, .{}); } // 0xEE47635F352DA367 0x2B757E6C b323
    /// Returns the total number of DLC weapons that are available in SP (availableInSP field in shop_weapon.meta).
    pub inline fn getNumDlcWeaponsSp() !c_int { return try invoker.invoke(c_int, 0x4160B65AE085B5A9, .{}); } // 0x4160B65AE085B5A9  b2060
    /// 
    /// dlcWeaponIndex takes a number from 0 - GET_NUM_DLC_WEAPONS() - 1. \
    /// struct DlcWeaponData \
    /// { \
    /// int emptyCheck; //use DLC1::IS_CONTENT_ITEM_LOCKED on this \
    /// int padding1; \
    /// int weaponHash; \
    /// int padding2; \
    /// int unk; \
    /// int padding3; \
    /// int weaponCost; \
    /// int padding4; \
    /// int ammoCost; \
    /// int padding5; \
    /// int ammoType; \
    /// int padding6; \
    /// int defaultClipSize; \
    /// int padding7; \
    /// char nameLabel[64]; \
    /// char descLabel[64]; \
    /// char desc2Label[64]; // usually "the" + name \
    /// char upperCaseNameLabel[64]; \
    /// };
    pub inline fn getDlcWeaponData(dlc_weapon_index: c_int, out_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x79923CD21BECE14E, .{dlc_weapon_index, out_data}); } // 0x79923CD21BECE14E 0xD88EC8EA b323
    /// Same as GET_DLC_WEAPON_DATA but only works for DLC weapons that are available in SP.
    pub inline fn getDlcWeaponDataSp(dlc_weapon_index: c_int, out_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x310836EE7129BA33, .{dlc_weapon_index, out_data}); } // 0x310836EE7129BA33  b2060
    /// Returns the total number of DLC weapon components.
    pub inline fn getNumDlcWeaponComponents(dlc_weapon_index: c_int) !c_int { return try invoker.invoke(c_int, 0x405425358A7D61FE, .{dlc_weapon_index}); } // 0x405425358A7D61FE 0x476B23A9 b323
    /// Returns the total number of DLC weapon components that are available in SP.
    pub inline fn getNumDlcWeaponComponentsSp(dlc_weapon_index: c_int) !c_int { return try invoker.invoke(c_int, 0xAD2A7A6DFF55841B, .{dlc_weapon_index}); } // 0xAD2A7A6DFF55841B  b2060
    /// p0 seems to be the weapon index \
    /// p1 seems to be the weapon component index \
    /// struct DlcComponentData{ \
    /// int attachBone; \
    /// int padding1; \
    /// int bActiveByDefault; \
    /// int padding2; \
    /// int unk; \
    /// int padding3; \
    /// int componentHash; \
    /// int padding4; \
    /// int unk2; \
    /// int padding5; \
    /// int componentCost; \
    /// int padding6; \
    /// char nameLabel[64]; \
    /// char descLabel[64]; \
    /// };
    /// 
    pub inline fn getDlcWeaponComponentData(dlc_weapon_index: c_int, dlc_weap_comp_index: c_int, _component_data_ptr: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6CF598A2957C2BF8, .{dlc_weapon_index, dlc_weap_comp_index, _component_data_ptr}); } // 0x6CF598A2957C2BF8 0x4B83FCAF b323
    /// Same as GET_DLC_WEAPON_COMPONENT_DATA but only works for DLC components that are available in SP.
    pub inline fn getDlcWeaponComponentDataSp(dlc_weapon_index: c_int, dlc_weap_comp_index: c_int, _component_data_ptr: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x31D5E073B6F93CDC, .{dlc_weapon_index, dlc_weap_comp_index, _component_data_ptr}); } // 0x31D5E073B6F93CDC  b2060
    pub inline fn isContentItemLocked(item_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD4D7B033C3AA243C, .{item_hash}); } // 0xD4D7B033C3AA243C 0x06396058 b323
    pub inline fn isDlcVehicleMod(hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0564B9FF9631B82C, .{hash}); } // 0x0564B9FF9631B82C 0x35BCA844 b323
    pub inline fn getDlcVehicleModLockHash(hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0xC098810437312FFF, .{hash}); } // 0xC098810437312FFF 0x59352658 b323
    /// From fm_deathmatch_creator and fm_race_creator:
    /// 
    /// FILES::REVERT_CONTENT_CHANGESET_GROUP_FOR_ALL(joaat("GROUP_MAP_SP")); \
    /// FILES::EXECUTE_CONTENT_CHANGESET_GROUP_FOR_ALL(joaat("GROUP_MAP"));
    pub inline fn executeContentChangesetGroupForAll(hash: types.Hash) !void { try invoker.invoke(void, 0x6BEDF5769AC2DC07, .{hash}); } // 0x6BEDF5769AC2DC07  b1604
    /// From fm_deathmatch_creator and fm_race_creator:
    /// 
    /// FILES::REVERT_CONTENT_CHANGESET_GROUP_FOR_ALL(joaat("GROUP_MAP_SP")); \
    /// FILES::EXECUTE_CONTENT_CHANGESET_GROUP_FOR_ALL(joaat("GROUP_MAP"));
    pub inline fn revertContentChangesetGroupForAll(hash: types.Hash) !void { try invoker.invoke(void, 0x3C1978285B036B25, .{hash}); } // 0x3C1978285B036B25  b1604
};

pub const Fire = struct
{
    /// Starts a fire:
    /// 
    /// xyz: Location of fire \
    /// maxChildren: The max amount of times a fire can spread to other objects. Must be 25 or less, or the function will do nothing. \
    /// isGasFire: Whether or not the fire is powered by gasoline.
    pub inline fn startScriptFire(vec: types.Vector3, max_children: c_int, is_gas_fire: windows.BOOL) !types.FireId { return try invoker.invoke(types.FireId, 0x6B83617E04503888, .{vec.x, vec.y, vec.z, max_children, is_gas_fire}); } // 0x6B83617E04503888 0xE7529357 b323
    pub inline fn removeScriptFire(fire_handle: types.FireId) !void { try invoker.invoke(void, 0x7FF548385680673F, .{fire_handle}); } // 0x7FF548385680673F 0x6B21FE26 b323
    pub inline fn startEntityFire(entity: types.Entity) !types.FireId { return try invoker.invoke(types.FireId, 0xF6A9D9708F6F23DF, .{entity}); } // 0xF6A9D9708F6F23DF 0x8928428E b323
    pub inline fn stopEntityFire(entity: types.Entity) !void { try invoker.invoke(void, 0x7F0DD2EBBB651AFF, .{entity}); } // 0x7F0DD2EBBB651AFF 0xCE8C9066 b323
    pub inline fn isEntityOnFire(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x28D3FED7190D3A0B, .{entity}); } // 0x28D3FED7190D3A0B 0x8C73E64F b323
    pub inline fn getNumberOfFiresInRange(vec: types.Vector3, radius: f32) !c_int { return try invoker.invoke(c_int, 0x50CAD495A460B305, .{vec.x, vec.y, vec.z, radius}); } // 0x50CAD495A460B305 0x654D93B7 b323
    pub inline fn setFlammabilityMultiplier(p_0: f32) !void { try invoker.invoke(void, 0x8F390AC4155099BA, .{p_0}); } // 0x8F390AC4155099BA  b1734
    pub inline fn stopFireInRange(vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0x056A8A219B8E829F, .{vec.x, vec.y, vec.z, radius}); } // 0x056A8A219B8E829F 0x725C7205 b323
    /// Returns TRUE if it found something. FALSE if not.
    pub inline fn getClosestFirePos(out_position: [*c]types.Vector3, vec: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x352A9F6BCF90081F, .{out_position, vec.x, vec.y, vec.z}); } // 0x352A9F6BCF90081F 0xC4977B47 b323
    /// BOOL isAudible = If explosion makes a sound. \
    /// BOOL isInvisible = If the explosion is invisible or not.
    /// 
    /// explosionType: https://alloc8or.re/gta5/doc/enums/eExplosionTag.txt
    pub inline fn addExplosion(vec: types.Vector3, explosion_type: c_int, damage_scale: f32, is_audible: windows.BOOL, is_invisible: windows.BOOL, camera_shake: f32, no_damage: windows.BOOL) !void { try invoker.invoke(void, 0xE3AD2BDBAEE269AC, .{vec.x, vec.y, vec.z, explosion_type, damage_scale, is_audible, is_invisible, camera_shake, no_damage}); } // 0xE3AD2BDBAEE269AC 0x10AF5258 b323
    /// isAudible: If explosion makes a sound. \
    /// isInvisible: If the explosion is invisible or not. \
    /// explosionType: See ADD_EXPLOSION.
    pub inline fn addOwnedExplosion(ped: types.Ped, vec: types.Vector3, explosion_type: c_int, damage_scale: f32, is_audible: windows.BOOL, is_invisible: windows.BOOL, camera_shake: f32) !void { try invoker.invoke(void, 0x172AA1B624FA1013, .{ped, vec.x, vec.y, vec.z, explosion_type, damage_scale, is_audible, is_invisible, camera_shake}); } // 0x172AA1B624FA1013 0x27EE0D67 b323
    /// isAudible: If explosion makes a sound. \
    /// isInvisible: If the explosion is invisible or not. \
    /// explosionType: See ADD_EXPLOSION.
    pub inline fn addExplosionWithUserVfx(vec: types.Vector3, explosion_type: c_int, explosion_fx: types.Hash, damage_scale: f32, is_audible: windows.BOOL, is_invisible: windows.BOOL, camera_shake: f32) !void { try invoker.invoke(void, 0x36DD3FE58B5E5212, .{vec.x, vec.y, vec.z, explosion_type, explosion_fx, damage_scale, is_audible, is_invisible, camera_shake}); } // 0x36DD3FE58B5E5212 0xCF358946 b323
    /// explosionType: See ADD_EXPLOSION.
    pub inline fn isExplosionInArea(explosion_type: c_int, vec_1__: types.Vector3, vec_2__: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E2EBA0EE7CED0E0, .{explosion_type, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x2E2EBA0EE7CED0E0 0xFB40075B b323
    /// explosionType: See ADD_EXPLOSION.
    pub inline fn isExplosionActiveInArea(explosion_type: c_int, vec_1__: types.Vector3, vec_2__: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6070104B699B2EF4, .{explosion_type, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x6070104B699B2EF4 0x37C388DB b323
    /// explosionType: See ADD_EXPLOSION.
    pub inline fn isExplosionInSphere(explosion_type: c_int, vec: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAB0F816885B0E483, .{explosion_type, vec.x, vec.y, vec.z, radius}); } // 0xAB0F816885B0E483 0xD455A7F3 b323
    /// explosionType: See ADD_EXPLOSION.
    pub inline fn getOwnerOfExplosionInSphere(explosion_type: c_int, vec: types.Vector3, radius: f32) !types.Entity { return try invoker.invoke(types.Entity, 0xB3CD51E3DB86F176, .{explosion_type, vec.x, vec.y, vec.z, radius}); } // 0xB3CD51E3DB86F176  b1290
    /// explosionType: See ADD_EXPLOSION, -1 for any explosion type
    /// 
    pub inline fn isExplosionInAngledArea(explosion_type: c_int, vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA079A6C51525DC4B, .{explosion_type, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width}); } // 0xA079A6C51525DC4B 0x0128FED9 b323
    /// Returns a handle to the first entity within the a circle spawned inside the 2 points from a radius.
    /// 
    /// explosionType: See ADD_EXPLOSION.
    pub inline fn getOwnerOfExplosionInAngledArea(explosion_type: c_int, vec_1__: types.Vector3, vec_2__: types.Vector3, radius: f32) !types.Entity { return try invoker.invoke(types.Entity, 0x14BA4BA137AF6CEC, .{explosion_type, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, radius}); } // 0x14BA4BA137AF6CEC 0xAEC0D176 b323
    pub inline fn networkExpectExplosionEventsForPlayer_(expect: windows.BOOL, player: types.Player) !void { try invoker.invoke(void, 0x5241DB47A8B8AD54, .{expect, player}); } // 0x5241DB47A8B8AD54  b3570
    pub inline fn getMaximumNumberOfWaterCannons_() !c_int { return try invoker.invoke(c_int, 0x56581E7E219D6263, .{}); } // 0x56581E7E219D6263  b3717
    pub inline fn getWaterCannonCoords_(index: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xE61CBD3ED80E7327, .{index}); } // 0xE61CBD3ED80E7327  b3717
};

pub const Graphics = struct
{
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn setDebugLinesAndSpheresDrawingActive(enabled: windows.BOOL) !void { try invoker.invoke(void, 0x175B6BFC15CDD0C5, .{enabled}); } // 0x175B6BFC15CDD0C5 0x1418CA37 b323
    pub inline fn drawDebugLine(vec_1__: types.Vector3, vec_2__: types.Vector3, r: c_int, g: c_int, b: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x7FDFADE676AA3CB0, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, r, g, b, alpha}); } // 0x7FDFADE676AA3CB0 0xABF783AB b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn drawDebugLineWithTwoColours(vec_1__: types.Vector3, vec_2__: types.Vector3, r_1: c_int, g_1: c_int, b_1: c_int, r_2: c_int, g_2: c_int, b_2: c_int, alpha_1: c_int, alpha_2: c_int) !void { try invoker.invoke(void, 0xD8B9A8AC5608FF94, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, r_1, g_1, b_1, r_2, g_2, b_2, alpha_1, alpha_2}); } // 0xD8B9A8AC5608FF94 0xE8BFF632 b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn drawDebugSphere(vec: types.Vector3, radius: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xAAD68E1AB39DA632, .{vec.x, vec.y, vec.z, radius, red, green, blue, alpha}); } // 0xAAD68E1AB39DA632 0x304D0EEF b323
    pub inline fn drawDebugBox(vec_1__: types.Vector3, vec_2__: types.Vector3, r: c_int, g: c_int, b: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x083A2CA4F2E573BD, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, r, g, b, alpha}); } // 0x083A2CA4F2E573BD 0x8524A848 b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn drawDebugCross(vec: types.Vector3, size: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x73B1189623049839, .{vec.x, vec.y, vec.z, size, red, green, blue, alpha}); } // 0x73B1189623049839 0xB6DF3709 b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn drawDebugText(text: [*c]const u8, vec: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x3903E216620488E8, .{text, vec.x, vec.y, vec.z, red, green, blue, alpha}); } // 0x3903E216620488E8 0x269B006F b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn drawDebugText2d(text: [*c]const u8, vec: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xA3BB2E9555C05A8F, .{text, vec.x, vec.y, vec.z, red, green, blue, alpha}); } // 0xA3BB2E9555C05A8F 0x528B973B b323
    /// Draws a depth-tested line from one point to another. \
    /// ---------------- \
    /// x1, y1, z1 : Coordinates for the first point \
    /// x2, y2, z2 : Coordinates for the second point \
    /// r, g, b, alpha : Color with RGBA-Values \
    /// I recommend using a predefined function to call this. \
    /// [VB.NET] \
    /// Public Sub DrawLine(from As Vector3, [to] As Vector3, col As Color) \
    ///     [Function].Call(Hash.DRAW_LINE, from.X, from.Y, from.Z, [to].X, [to].Y, [to].Z, col.R, col.G, col.B, col.A)
    /// End Sub
    /// 
    /// [C#] \
    /// public void DrawLine(Vector3 from, Vector3 to, Color col) \
    /// { \
    ///     Function.Call(Hash.DRAW_LINE, from.X, from.Y, from.Z, to.X, to.Y, to.Z, col.R, col.G, col.B, col.A);
    /// }
    pub inline fn drawLine(vec_1__: types.Vector3, vec_2__: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x6B7256074AE34680, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, red, green, blue, alpha}); } // 0x6B7256074AE34680 0xB3426BCC b323
    /// x/y/z - Location of a vertex (in world coords), presumably. \
    /// ---------------- \
    /// x1, y1, z1     : Coordinates for the first point \
    /// x2, y2, z2     : Coordinates for the second point \
    /// x3, y3, z3     : Coordinates for the third point \
    /// r, g, b, alpha : Color with RGBA-Values
    /// 
    /// Keep in mind that only one side of the drawn triangle is visible: It's the side, in which the vector-product of the vectors heads to: (b-a)x(c-a) Or (b-a)x(c-b). \
    /// But be aware: The function seems to work somehow differently. I have trouble having them drawn in rotated orientation. Try it yourself and if you somehow succeed, please edit this and post your solution. \
    /// I recommend using a predefined function to call this. \
    /// [VB.NET] \
    /// Public Sub DrawPoly(a As Vector3, b As Vector3, c As Vector3, col As Color) \
    ///     [Function].Call(Hash.DRAW_POLY, a.X, a.Y, a.Z, b.X, b.Y, b.Z, c.X, c.Y, c.Z, col.R, col.G, col.B, col.A)
    /// End Sub
    /// 
    /// [C#] \
    /// public void DrawPoly(Vector3 a, Vector3 b, Vector3 c, Color col) \
    /// { \
    ///     Function.Call(Hash.DRAW_POLY, a.X, a.Y, a.Z, b.X, b.Y, b.Z, c.X, c.Y, c.Z, col.R, col.G, col.B, col.A);
    /// } \
    /// BTW: Intersecting triangles are not supported: They overlap in the order they were called.
    pub inline fn drawPoly(vec_1__: types.Vector3, vec_2__: types.Vector3, vec_3__: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xAC26716048436851, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, vec_3__.x, vec_3__.y, vec_3__.z, red, green, blue, alpha}); } // 0xAC26716048436851 0xABD19253 b323
    /// Used for drawling Deadline trailing lights, see deadline.ytd
    /// 
    /// p15 through p23 are values that appear to be related to illiumation, scaling, and rotation; more testing required. \
    /// For UVW mapping (u,v,w parameters), reference your favourite internet resource for more details.
    pub inline fn drawTexturedPoly(vec_1__: types.Vector3, vec_2__: types.Vector3, vec_3__: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int, texture_dict: [*c]const u8, texture_name: [*c]const u8, u_1: f32, v_1: f32, w_1: f32, u_2: f32, v_2: f32, w_2: f32, u_3: f32, v_3: f32, w_3: f32) !void { try invoker.invoke(void, 0x29280002282F1928, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, vec_3__.x, vec_3__.y, vec_3__.z, red, green, blue, alpha, texture_dict, texture_name, u_1, v_1, w_1, u_2, v_2, w_2, u_3, v_3, w_3}); } // 0x29280002282F1928  b877
    /// Used for drawling Deadline trailing lights, see deadline.ytd
    /// 
    /// Each vertex has its own colour that is blended/illuminated on the texture. Additionally, the R, G, and B components are floats that are int-casted internally. \
    /// For UVW mapping (u,v,w parameters), reference your favourite internet resource for more details.
    pub inline fn drawTexturedPolyWithThreeColours(vec_1__: types.Vector3, vec_2__: types.Vector3, vec_3__: types.Vector3, red_1: f32, green_1: f32, blue_1: f32, alpha_1: c_int, red_2: f32, green_2: f32, blue_2: f32, alpha_2: c_int, red_3: f32, green_3: f32, blue_3: f32, alpha_3: c_int, texture_dict: [*c]const u8, texture_name: [*c]const u8, u_1: f32, v_1: f32, w_1: f32, u_2: f32, v_2: f32, w_2: f32, u_3: f32, v_3: f32, w_3: f32) !void { try invoker.invoke(void, 0x736D7AA1B750856B, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, vec_3__.x, vec_3__.y, vec_3__.z, red_1, green_1, blue_1, alpha_1, red_2, green_2, blue_2, alpha_2, red_3, green_3, blue_3, alpha_3, texture_dict, texture_name, u_1, v_1, w_1, u_2, v_2, w_2, u_3, v_3, w_3}); } // 0x736D7AA1B750856B  b877
    /// x,y,z = start pos \
    /// x2,y2,z2 = end pos
    /// 
    /// Draw's a 3D Box between the two x,y,z coords. \
    /// -------------- \
    /// Keep in mind that the edges of the box do only align to the worlds base-vectors. Therefore something like rotation cannot be applied. That means this function is pretty much useless, unless you want a static unicolor box somewhere. \
    /// I recommend using a predefined function to call this. \
    /// [VB.NET] \
    /// Public Sub DrawBox(a As Vector3, b As Vector3, col As Color) \
    ///     [Function].Call(Hash.DRAW_BOX,a.X, a.Y, a.Z,b.X, b.Y, b.Z,col.R, col.G, col.B, col.A)
    /// End Sub
    /// 
    /// [C#] \
    /// public void DrawBox(Vector3 a, Vector3 b, Color col) \
    /// { \
    ///     Function.Call(Hash.DRAW_BOX,a.X, a.Y, a.Z,b.X, b.Y, b.Z,col.R, col.G, col.B, col.A);
    /// }
    pub inline fn drawBox(vec_1__: types.Vector3, vec_2__: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xD3A9971CADAC7252, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, red, green, blue, alpha}); } // 0xD3A9971CADAC7252 0xCD4D9DD5 b323
    pub inline fn setBackfaceculling(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x23BA6B0C2AD7B0D3, .{toggle}); } // 0x23BA6B0C2AD7B0D3 0xC44C2F44 b323
    pub inline fn setDepthwriting(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC5C8F970D4EDFF71, .{toggle}); } // 0xC5C8F970D4EDFF71  b877
    pub inline fn beginTakeMissionCreatorPhoto() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1DD2139A9A20DCE8, .{}); } // 0x1DD2139A9A20DCE8 0xBA9AD458 b323
    pub inline fn getStatusOfTakeMissionCreatorPhoto() !c_int { return try invoker.invoke(c_int, 0x90A78ECAA4E78453, .{}); } // 0x90A78ECAA4E78453 0xADBBA287 b323
    pub inline fn freeMemoryForMissionCreatorPhoto() !void { try invoker.invoke(void, 0x0A46AF8A78DC5E0A, .{}); } // 0x0A46AF8A78DC5E0A 0x9E553002 b323
    pub inline fn loadMissionCreatorPhoto(p_0: [*c]types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4862437A486F91B0, .{p_0, p_1, p_2, p_3}); } // 0x4862437A486F91B0 0x56C1E488 b323
    pub inline fn getStatusOfLoadMissionCreatorPhoto(p_0: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0x1670F8D05056F257, .{p_0}); } // 0x1670F8D05056F257 0x226B08EA b323
    pub inline fn beginCreateMissionCreatorPhotoPreview() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7FA5D82B8F58EC06, .{}); } // 0x7FA5D82B8F58EC06 0x1F3CADB0 b323
    pub inline fn getStatusOfCreateMissionCreatorPhotoPreview() !c_int { return try invoker.invoke(c_int, 0x5B0316762AFD4A64, .{}); } // 0x5B0316762AFD4A64 0xA9DC8558 b323
    pub inline fn freeMemoryForMissionCreatorPhotoPreview() !void { try invoker.invoke(void, 0x346EF3ECAAAB149E, .{}); } // 0x346EF3ECAAAB149E 0x88EAF398 b323
    pub inline fn beginTakeHighQualityPhoto() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA67C35C56EB1BD9D, .{}); } // 0xA67C35C56EB1BD9D 0x47B0C137 b323
    pub inline fn getStatusOfTakeHighQualityPhoto() !c_int { return try invoker.invoke(c_int, 0x0D6CA79EEEBD8CA3, .{}); } // 0x0D6CA79EEEBD8CA3 0x65376C9B b323
    pub inline fn freeMemoryForHighQualityPhoto() !void { try invoker.invoke(void, 0xD801CC02177FA3F1, .{}); } // 0xD801CC02177FA3F1 0x9CBA682A b323
    pub inline fn setTakenPhotoIsMugshot(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1BBC135A4D25EDDE, .{toggle}); } // 0x1BBC135A4D25EDDE  b323
    pub inline fn setArenaThemeAndVariationForTakenPhoto(p_0: types.Any, p_1: c_int) !void { try invoker.invoke(void, 0xF3F776ADA161E47D, .{p_0, p_1}); } // 0xF3F776ADA161E47D  b1604
    pub inline fn setOnIslandXForTakenPhoto(p_0: types.Any) !void { try invoker.invoke(void, 0xADD6627C4D325458, .{p_0}); } // 0xADD6627C4D325458  b2189
    /// 1 match in 1 script. cellphone_controller. \
    /// p0 is -1 in scripts.
    pub inline fn saveHighQualityPhoto(unused: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3DEC726C25A11BAC, .{unused}); } // 0x3DEC726C25A11BAC 0x3B15D33C b323
    pub inline fn getStatusOfSaveHighQualityPhoto() !c_int { return try invoker.invoke(c_int, 0x0C0C4E81E1AC60A0, .{}); } // 0x0C0C4E81E1AC60A0 0xEC5D0317 b323
    pub inline fn beginCreateLowQualityCopyOfPhoto(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x759650634F07B6B4, .{p_0}); } // 0x759650634F07B6B4 0x25D569EB b323
    pub inline fn getStatusOfCreateLowQualityCopyOfPhoto(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0xCB82A0BF0E3E3265, .{p_0}); } // 0xCB82A0BF0E3E3265 0xCFCDC518 b323
    pub inline fn freeMemoryForLowQualityPhoto() !void { try invoker.invoke(void, 0x6A12D88881435DCA, .{}); } // 0x6A12D88881435DCA 0x108F36CC b323
    pub inline fn drawLowQualityPhotoToPhone(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x1072F115DAB0717E, .{p_0, p_1}); } // 0x1072F115DAB0717E 0xE9F2B68F b323
    /// This function is hard-coded to always return 0.
    pub inline fn getMaximumNumberOfPhotos() !c_int { return try invoker.invoke(c_int, 0x34D23450F028B0BF, .{}); } // 0x34D23450F028B0BF 0x727AA63F b323
    /// This function is hard-coded to always return 96.
    pub inline fn getMaximumNumberOfCloudPhotos() !c_int { return try invoker.invoke(c_int, 0xDC54A7AF8B3A14EF, .{}); } // 0xDC54A7AF8B3A14EF 0x239272BD b323
    pub inline fn getCurrentNumberOfCloudPhotos() !c_int { return try invoker.invoke(c_int, 0x473151EBC762C6DA, .{}); } // 0x473151EBC762C6DA 0x21DBF0C9 b323
    /// 2 matches across 2 scripts. Only showed in appcamera & appmedia. Both were 0.
    pub inline fn queueOperationToCreateSortedListOfPhotos(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2A893980E96B659A, .{p_0}); } // 0x2A893980E96B659A 0x199FABF0 b323
    /// 3 matches across 3 scripts. First 2 were 0, 3rd was 1. Possibly a bool. \
    /// appcamera, appmedia, and cellphone_controller.
    pub inline fn getStatusOfSortedListOperation(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0xF5BED327CEA362B1, .{p_0}); } // 0xF5BED327CEA362B1 0x596B900D b323
    pub inline fn clearStatusOfSortedListOperation() !void { try invoker.invoke(void, 0x4AF92ACD3141D96C, .{}); } // 0x4AF92ACD3141D96C 0xC9EF81ED b323
    /// This function is hard-coded to always return 0.
    pub inline fn doesThisPhotoSlotContainAValidPhoto(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE791DF1F73ED2C8B, .{p_0}); } // 0xE791DF1F73ED2C8B 0x9D84554C b323
    /// This function is hard-coded to always return 0.
    pub inline fn loadHighQualityPhoto(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEC72C258667BE5EA, .{p_0}); } // 0xEC72C258667BE5EA 0x9C106AD9 b323
    /// Hardcoded to always return 2.
    pub inline fn getLoadHighQualityPhotoStatus(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x40AFB081F8ADD4EE, .{p_0}); } // 0x40AFB081F8ADD4EE 0x762E5C5F b323
    pub inline fn drawLightWithRangeex(vec: types.Vector3, r: c_int, g: c_int, b: c_int, range: f32, intensity: f32, shadow: f32) !void { try invoker.invoke(void, 0xF49E9A9716A04595, .{vec.x, vec.y, vec.z, r, g, b, range, intensity, shadow}); } // 0xF49E9A9716A04595  b323
    pub inline fn drawLightWithRange(pos__: types.Vector3, color_r: c_int, color_g: c_int, color_b: c_int, range: f32, intensity: f32) !void { try invoker.invoke(void, 0xF2A1B2771A01DBD4, .{pos__.x, pos__.y, pos__.z, color_r, color_g, color_b, range, intensity}); } // 0xF2A1B2771A01DBD4 0x6A396E9A b323
    /// Parameters: \
    /// * pos - coordinate where the spotlight is located \
    /// * dir - the direction vector the spotlight should aim at from its current position \
    /// * r,g,b - color of the spotlight \
    /// * distance - the maximum distance the light can reach \
    /// * brightness - the brightness of the light \
    /// * roundness - "smoothness" of the circle edge \
    /// * radius - the radius size of the spotlight \
    /// * falloff - the falloff size of the light's edge (example: www.i.imgur.com/DemAWeO.jpg)
    /// 
    /// Example in C# (spotlight aims at the closest vehicle): \
    /// Vector3 myPos = Game.Player.Character.Position; \
    /// Vehicle nearest = World.GetClosestVehicle(myPos , 1000f); \
    /// Vector3 destinationCoords = nearest.Position; \
    /// Vector3 dirVector = destinationCoords - myPos; \
    /// dirVector.Normalize(); \
    /// Function.Call(Hash.DRAW_SPOT_LIGHT, pos.X, pos.Y, pos.Z, dirVector.X, dirVector.Y, dirVector.Z, 255, 255, 255, 100.0f, 1f, 0.0f, 13.0f, 1f);
    pub inline fn drawSpotLight(pos__: types.Vector3, dir__: types.Vector3, color_r: c_int, color_g: c_int, color_b: c_int, distance: f32, brightness: f32, hardness: f32, radius: f32, falloff: f32) !void { try invoker.invoke(void, 0xD0F64B265C8C8B33, .{pos__.x, pos__.y, pos__.z, dir__.x, dir__.y, dir__.z, color_r, color_g, color_b, distance, brightness, hardness, radius, falloff}); } // 0xD0F64B265C8C8B33 0xBDBC410C b323
    pub inline fn drawShadowedSpotLight(pos__: types.Vector3, dir__: types.Vector3, color_r: c_int, color_g: c_int, color_b: c_int, distance: f32, brightness: f32, roundness: f32, radius: f32, falloff: f32, shadow_id: c_int) !void { try invoker.invoke(void, 0x5BCA583A583194DB, .{pos__.x, pos__.y, pos__.z, dir__.x, dir__.y, dir__.z, color_r, color_g, color_b, distance, brightness, roundness, radius, falloff, shadow_id}); } // 0x5BCA583A583194DB 0x32BF9598 b323
    pub inline fn fadeUpPedLight(p_0: f32) !void { try invoker.invoke(void, 0xC9B18B4619F48F7B, .{p_0}); } // 0xC9B18B4619F48F7B 0x93628786 b323
    pub inline fn updateLightsOnEntity(entity: types.Entity) !void { try invoker.invoke(void, 0xDEADC0DEDEADC0DE, .{entity}); } // 0xDEADC0DEDEADC0DE 0xC12AC47A b323
    pub inline fn setLightOverrideMaxIntensityScale(p_0: types.Any) !void { try invoker.invoke(void, 0x9641588DAB93B4B5, .{p_0}); } // 0x9641588DAB93B4B5  b877
    pub inline fn getLightOverrideMaxIntensityScale() !f32 { return try invoker.invoke(f32, 0x393BD2275CEB7793, .{}); } // 0x393BD2275CEB7793  b1103
    /// enum MarkerTypes \
    /// { \
    ///     MarkerTypeUpsideDownCone = 0,
    ///  MarkerTypeVerticalCylinder = 1, \
    ///    MarkerTypeThickChevronUp = 2,
    ///  MarkerTypeThinChevronUp = 3, \
    ///   MarkerTypeCheckeredFlagRect = 4,
    ///   MarkerTypeCheckeredFlagCircle = 5,
    ///     MarkerTypeVerticleCircle = 6,
    ///  MarkerTypePlaneModel = 7, \
    ///  MarkerTypeLostMCDark = 8, \
    ///  MarkerTypeLostMCLight = 9, \
    ///     MarkerTypeNumber0 = 10,
    ///    MarkerTypeNumber1 = 11,
    ///    MarkerTypeNumber2 = 12,
    ///    MarkerTypeNumber3 = 13,
    ///    MarkerTypeNumber4 = 14,
    ///    MarkerTypeNumber5 = 15,
    ///    MarkerTypeNumber6 = 16,
    ///    MarkerTypeNumber7 = 17,
    ///    MarkerTypeNumber8 = 18,
    ///    MarkerTypeNumber9 = 19,
    ///    MarkerTypeChevronUpx1 = 20,
    ///    MarkerTypeChevronUpx2 = 21,
    ///    MarkerTypeChevronUpx3 = 22,
    ///    MarkerTypeHorizontalCircleFat = 23,
    ///    MarkerTypeReplayIcon = 24,
    ///     MarkerTypeHorizontalCircleSkinny = 25,
    ///     MarkerTypeHorizontalCircleSkinny_Arrow = 26,
    ///   MarkerTypeHorizontalSplitArrowCircle = 27,
    ///     MarkerTypeDebugSphere = 28,
    ///    MarkerTypeDallorSign = 29,
    ///     MarkerTypeHorizontalBars = 30,
    ///     MarkerTypeWolfHead = 31
    /// };
    /// 
    /// dirX/Y/Z represent a heading on each axis in which the marker should face, alternatively you can rotate each axis independently with rotX/Y/Z (and set dirX/Y/Z all to 0).
    /// 
    /// faceCamera - Rotates only the y-axis (the heading) towards the camera
    /// 
    /// p19 - no effect, default value in script is 2
    /// 
    /// rotate - Rotates only on the y-axis (the heading)
    /// 
    /// textureDict - Name of texture dictionary to load texture from (e.g. "GolfPutting")
    /// 
    /// textureName - Name of texture inside dictionary to load (e.g. "PuttingMarker")
    /// 
    /// drawOnEnts - Draws the marker onto any entities that intersect it
    /// 
    /// basically what he said, except textureDict and textureName are totally not const char*, or if so, then they are always set to 0/NULL/nullptr in every script I checked, eg:
    /// 
    /// bj.c: graphics::draw_marker(6, vParam0, 0f, 0f, 1f, 0f, 0f, 0f, 4f, 4f, 4f, 240, 200, 80, iVar1, 0, 0, 2, 0, 0, 0, false);
    /// 
    /// his is what I used to draw an amber downward pointing chevron "V", has to be redrawn every frame.  The 180 is for 180 degrees rotation around the Y axis, the 50 is alpha, assuming max is 100, but it will accept 255.
    /// 
    /// GRAPHICS::DRAW_MARKER(2, v.x, v.y, v.z + 2, 0, 0, 0, 0, 180, 0, 2, 2, 2, 255, 128, 0, 50, 0, 1, 1, 0, 0, 0, 0);
    /// 
    /// 
    pub inline fn drawMarker(@"type": c_int, pos__: types.Vector3, dir__: types.Vector3, rot__: types.Vector3, scale__: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int, bob_up_and_down: windows.BOOL, face_camera: windows.BOOL, p_1_9: c_int, rotate: windows.BOOL, texture_dict: [*c]const u8, texture_name: [*c]const u8, draw_on_ents: windows.BOOL) !void { try invoker.invoke(void, 0x28477EC23D892089, .{@"type", pos__.x, pos__.y, pos__.z, dir__.x, dir__.y, dir__.z, rot__.x, rot__.y, rot__.z, scale__.x, scale__.y, scale__.z, red, green, blue, alpha, bob_up_and_down, face_camera, p_1_9, rotate, texture_dict, texture_name, draw_on_ents}); } // 0x28477EC23D892089 0x48D84A02 b323
    pub inline fn drawMarkerEx(@"type": c_int, pos__: types.Vector3, dir__: types.Vector3, rot__: types.Vector3, scale__: types.Vector3, red: c_int, green: c_int, blue: c_int, alpha: c_int, bob_up_and_down: windows.BOOL, face_camera: windows.BOOL, p_1_9: types.Any, rotate: windows.BOOL, texture_dict: [*c]const u8, texture_name: [*c]const u8, draw_on_ents: windows.BOOL, p_2_4: windows.BOOL, p_2_5: windows.BOOL) !void { try invoker.invoke(void, 0xE82728F0DE75D13A, .{@"type", pos__.x, pos__.y, pos__.z, dir__.x, dir__.y, dir__.z, rot__.x, rot__.y, rot__.z, scale__.x, scale__.y, scale__.z, red, green, blue, alpha, bob_up_and_down, face_camera, p_1_9, rotate, texture_dict, texture_name, draw_on_ents, p_2_4, p_2_5}); } // 0xE82728F0DE75D13A  b573
    /// Draws a 3D sphere, typically seen in the GTA:O freemode event "Penned In". \
    /// Example https://imgur.com/nCbtS4H
    /// 
    /// alpha - The alpha for the sphere. Goes from 0.0 to 1.0.
    pub inline fn drawMarkerSphere(vec: types.Vector3, radius: f32, red: c_int, green: c_int, blue: c_int, alpha: f32) !void { try invoker.invoke(void, 0x799017F9E3B10112, .{vec.x, vec.y, vec.z, radius, red, green, blue, alpha}); } // 0x799017F9E3B10112  b463
    /// Creates a checkpoint. Returns the handle of the checkpoint.
    /// 
    /// 20/03/17 : Attention, checkpoints are already handled by the game itself, so you must not loop it like markers.
    /// 
    /// Parameters: \
    /// * type - The type of checkpoint to create. See below for a list of checkpoint types. \
    /// * pos1 - The position of the checkpoint. \
    /// * pos2 - The position of the next checkpoint to point to. \
    /// * radius - The radius of the checkpoint. \
    /// * color - The color of the checkpoint. \
    /// * reserved - Special parameter, see below for details. Usually set to 0 in the scripts.
    /// 
    /// Checkpoint types: \
    /// 0-4---------Cylinder: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker \
    /// 5-9---------Cylinder: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker \
    /// 10-14-------Ring: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker \
    /// 15-19-------1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker       \
    /// 20-24-------Cylinder: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker  \
    /// 25-29-------Cylinder: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker     \
    /// 30-34-------Cylinder: 1 arrow, 2 arrow, 3 arrows, CycleArrow, Checker  \
    /// 35-38-------Ring: Airplane Up, Left, Right, UpsideDown \
    /// 39----------? \
    /// 40----------Ring: just a ring \
    /// 41----------? \
    /// 42-44-------Cylinder w/ number (uses 'reserved' parameter) \
    /// 45-47-------Cylinder no arrow or number
    /// 
    /// If using type 42-44, reserved sets number / number and shape to display
    /// 
    /// 0-99------------Just numbers (0-99) \
    /// 100-109-----------------Arrow (0-9) \
    /// 110-119------------Two arrows (0-9) \
    /// 120-129----------Three arrows (0-9) \
    /// 130-139----------------Circle (0-9) \
    /// 140-149------------CycleArrow (0-9) \
    /// 150-159----------------Circle (0-9) \
    /// 160-169----Circle  w/ pointer (0-9) \
    /// 170-179-------Perforated ring (0-9) \
    /// 180-189----------------Sphere (0-9)
    pub inline fn createCheckpoint(@"type": c_int, pos_1__: types.Vector3, pos_2__: types.Vector3, diameter: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int, reserved: c_int) !c_int { return try invoker.invoke(c_int, 0x0134F0835AB6BFCB, .{@"type", pos_1__.x, pos_1__.y, pos_1__.z, pos_2__.x, pos_2__.y, pos_2__.z, diameter, red, green, blue, alpha, reserved}); } // 0x0134F0835AB6BFCB 0xF541B690 b323
    pub inline fn setCheckpointInsideCylinderHeightScale(checkpoint: c_int, scale: f32) !void { try invoker.invoke(void, 0x4B5B4DA5D79F1943, .{checkpoint, scale}); } // 0x4B5B4DA5D79F1943 0x80151CCF b323
    pub inline fn setCheckpointInsideCylinderScale(checkpoint: c_int, scale: f32) !void { try invoker.invoke(void, 0x44621483FF966526, .{checkpoint, scale}); } // 0x44621483FF966526  b877
    /// Sets the cylinder height of the checkpoint.
    /// 
    /// Parameters: \
    /// * nearHeight - The height of the checkpoint when inside of the radius. \
    /// * farHeight - The height of the checkpoint when outside of the radius. \
    /// * radius - The radius of the checkpoint.
    pub inline fn setCheckpointCylinderHeight(checkpoint: c_int, near_height: f32, far_height: f32, radius: f32) !void { try invoker.invoke(void, 0x2707AAE9D9297D89, .{checkpoint, near_height, far_height, radius}); } // 0x2707AAE9D9297D89 0xFF0F9B22 b323
    /// Sets the checkpoint color.
    pub inline fn setCheckpointRgba(checkpoint: c_int, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x7167371E8AD747F7, .{checkpoint, red, green, blue, alpha}); } // 0x7167371E8AD747F7 0xEF9C8CB3 b323
    /// Sets the checkpoint icon color.
    pub inline fn setCheckpointRgba2(checkpoint: c_int, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xB9EA40907C680580, .{checkpoint, red, green, blue, alpha}); } // 0xB9EA40907C680580 0xA5456DBB b323
    /// This does not move an existing checkpoint... so wtf.
    pub inline fn setCheckpointClipplaneWithPosNorm(checkpoint: c_int, pos__: types.Vector3, unk__: types.Vector3) !void { try invoker.invoke(void, 0xF51D36185993515D, .{checkpoint, pos__.x, pos__.y, pos__.z, unk__.x, unk__.y, unk__.z}); } // 0xF51D36185993515D 0x20EABD0F b323
    pub inline fn setCheckpointForceOldArrowPointing(checkpoint: c_int) !void { try invoker.invoke(void, 0xFCF6788FC4860CD4, .{checkpoint}); } // 0xFCF6788FC4860CD4  b1734
    /// Unknown. Called after creating a checkpoint (type: 51) in the creators.
    pub inline fn setCheckpointDecalRotAlignedToCameraRot(checkpoint: c_int) !void { try invoker.invoke(void, 0x615D3925E87A3B26, .{checkpoint}); } // 0x615D3925E87A3B26 0x1E3A3126 b323
    pub inline fn setCheckpointForceDirection(checkpoint: c_int) !void { try invoker.invoke(void, 0xDB1EA9411C8911EC, .{checkpoint}); } // 0xDB1EA9411C8911EC  b1180
    pub inline fn setCheckpointDirection(checkpoint: c_int, pos__: types.Vector3) !void { try invoker.invoke(void, 0x3C788E7F6438754D, .{checkpoint, pos__.x, pos__.y, pos__.z}); } // 0x3C788E7F6438754D  b1180
    pub inline fn deleteCheckpoint(checkpoint: c_int) !void { try invoker.invoke(void, 0xF5ED37F54CD4D52E, .{checkpoint}); } // 0xF5ED37F54CD4D52E 0xB66CF3CA b323
    pub inline fn dontRenderInGameUi(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x22A249A53034450A, .{p_0}); } // 0x22A249A53034450A 0x932FDB81 b323
    pub inline fn forceRenderInGameUi(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDC459CFA0CCE245B, .{toggle}); } // 0xDC459CFA0CCE245B 0x7E946E87 b323
    /// This function can requests texture dictonaries from following RPFs: \
    /// scaleform_generic.rpf \
    /// scaleform_minigames.rpf \
    /// scaleform_minimap.rpf \
    /// scaleform_web.rpf
    /// 
    /// last param isnt a toggle
    pub inline fn requestStreamedTextureDict(texture_dict: [*c]const u8, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xDFA2EF8E04127DD5, .{texture_dict, p_1}); } // 0xDFA2EF8E04127DD5 0x4C9B035F b323
    pub inline fn hasStreamedTextureDictLoaded(texture_dict: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0145F696AAAAD2E4, .{texture_dict}); } // 0x0145F696AAAAD2E4 0x3F436EEF b323
    pub inline fn setStreamedTextureDictAsNoLongerNeeded(texture_dict: [*c]const u8) !void { try invoker.invoke(void, 0xBE2CACCF5A8AA805, .{texture_dict}); } // 0xBE2CACCF5A8AA805 0xF07DDA38 b323
    /// Draws a rectangle on the screen.
    /// 
    /// -x: The relative X point of the center of the rectangle. (0.0-1.0, 0.0 is the left edge of the screen, 1.0 is the right edge of the screen)
    /// 
    /// -y: The relative Y point of the center of the rectangle. (0.0-1.0, 0.0 is the top edge of the screen, 1.0 is the bottom edge of the screen)
    /// 
    /// -width: The relative width of the rectangle. (0.0-1.0, 1.0 means the whole screen width)
    /// 
    /// -height: The relative height of the rectangle. (0.0-1.0, 1.0 means the whole screen height)
    /// 
    /// -R: Red part of the color. (0-255)
    /// 
    /// -G: Green part of the color. (0-255)
    /// 
    /// -B: Blue part of the color. (0-255)
    /// 
    /// -A: Alpha part of the color. (0-255, 0 means totally transparent, 255 means totally opaque)
    /// 
    /// The total number of rectangles to be drawn in one frame is apparently limited to 399.
    /// 
    pub inline fn drawRect(vec: types.Vector2, width: f32, height: f32, r: c_int, g: c_int, b: c_int, a: c_int, p_8: windows.BOOL) !void { try invoker.invoke(void, 0x3A618A217E5154F0, .{vec.x, vec.y, width, height, r, g, b, a, p_8}); } // 0x3A618A217E5154F0 0xDD2BFC77 b323
    /// Sets a flag defining whether or not script draw commands should continue being drawn behind the pause menu. This is usually used for TV channels and other draw commands that are used with a world render target.
    pub inline fn setScriptGfxDrawBehindPausemenu(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC6372ECD45D73BCD, .{toggle}); } // 0xC6372ECD45D73BCD 0xF8FBCC25 b323
    /// Sets the draw order for script draw commands.
    /// 
    /// Examples from decompiled scripts: \
    /// GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER(7); \
    /// GRAPHICS::DRAW_RECT(0.5, 0.5, 3.0, 3.0, v_4, v_5, v_6, a_0._f172, 0);
    /// 
    /// GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER(1); \
    /// GRAPHICS::DRAW_RECT(0.5, 0.5, 1.5, 1.5, 0, 0, 0, 255, 0);
    pub inline fn setScriptGfxDrawOrder(draw_order: c_int) !void { try invoker.invoke(void, 0x61BB1D9B3A95D802, .{draw_order}); } // 0x61BB1D9B3A95D802 0xADF81D24 b323
    /// horizontalAlign: The horizontal alignment. This can be 67 ('C'), 76 ('L'), or 82 ('R'). \
    /// verticalAlign: The vertical alignment. This can be 67 ('C'), 66 ('B'), or 84 ('T').
    /// 
    /// This function anchors script draws to a side of the safe zone. This needs to be called to make the interface independent of the player's safe zone configuration.
    /// 
    /// These values are equivalent to alignX and alignY in common:/data/ui/frontend.xml, which can be used as a baseline for default alignment.
    /// 
    /// Using any other value (including 0) will result in the safe zone not being taken into account for this draw. The canonical value for this is 'I' (73).
    /// 
    /// For example, you can use SET_SCRIPT_GFX_ALIGN(0, 84) to only scale on the Y axis (to the top), but not change the X axis.
    /// 
    /// To reset the value, use RESET_SCRIPT_GFX_ALIGN.
    pub inline fn setScriptGfxAlign(horizontal_align: c_int, vertical_align: c_int) !void { try invoker.invoke(void, 0xB8A850F20A067EB6, .{horizontal_align, vertical_align}); } // 0xB8A850F20A067EB6 0x228A2598 b323
    /// This function resets the alignment set using SET_SCRIPT_GFX_ALIGN and SET_SCRIPT_GFX_ALIGN_PARAMS to the default values ('I', 'I'; 0, 0, 0, 0). \
    /// This should be used after having used the aforementioned functions in order to not affect any other scripts attempting to draw.
    pub inline fn resetScriptGfxAlign() !void { try invoker.invoke(void, 0xE3A3DB414A373DAB, .{}); } // 0xE3A3DB414A373DAB 0x3FE33BD6 b323
    /// Sets the draw offset/calculated size for SET_SCRIPT_GFX_ALIGN. If using any alignment other than left/top, the game expects the width/height to be configured using this native in order to get a proper starting position for the draw command.
    pub inline fn setScriptGfxAlignParams(vec: types.Vector2, w: f32, h: f32) !void { try invoker.invoke(void, 0xF5A2C681787E579D, .{vec.x, vec.y, w, h}); } // 0xF5A2C681787E579D 0x76C641E4 b323
    /// Calculates the effective X/Y fractions when applying the values set by SET_SCRIPT_GFX_ALIGN and SET_SCRIPT_GFX_ALIGN_PARAMS
    pub inline fn getScriptGfxAlignPosition(vec: types.Vector2, calculated_x: [*c]f32, calculated_y: [*c]f32) !void { try invoker.invoke(void, 0x6DD8F5AA635EB4B2, .{vec.x, vec.y, calculated_x, calculated_y}); } // 0x6DD8F5AA635EB4B2  b323
    /// Gets the scale of safe zone. if the safe zone size scale is max, it will return 1.0.
    pub inline fn getSafeZoneSize() !f32 { return try invoker.invoke(f32, 0xBAF107B6BB2C97F0, .{}); } // 0xBAF107B6BB2C97F0 0x3F0D1A6F b323
    /// Draws a 2D sprite on the screen.
    /// 
    /// Parameters: \
    /// textureDict - Name of texture dictionary to load texture from (e.g. "CommonMenu", "MPWeaponsCommon", etc.)
    /// 
    /// textureName - Name of texture to load from texture dictionary (e.g. "last_team_standing_icon", "tennis_icon", etc.)
    /// 
    /// screenX/Y - Screen offset (0.5 = center) \
    /// scaleX/Y - Texture scaling. Negative values can be used to flip the texture on that axis. (0.5 = half)
    /// 
    /// heading - Texture rotation in degrees (default = 0.0) positive is clockwise, measured in degrees
    /// 
    /// red,green,blue - Sprite color (default = 255/255/255)
    /// 
    /// alpha - opacity level
    pub inline fn drawSprite(texture_dict: [*c]const u8, texture_name: [*c]const u8, screen__: types.Vector2, width: f32, height: f32, heading: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int, p_1_1: windows.BOOL, p_1_2: types.Any) !void { try invoker.invoke(void, 0xE7FFAE5EBF23D890, .{texture_dict, texture_name, screen__.x, screen__.y, width, height, heading, red, green, blue, alpha, p_1_1, p_1_2}); } // 0xE7FFAE5EBF23D890 0x1FEC16B0 b323
    /// Used in arcade games and Beam hack minigame in Doomsday Heist. I will most certainly dive into this to try replicate arcade games. \
    /// x position must be between 0.0 and 1.0 (1.0 being the most right side of the screen) \
    /// y position must be between 0.0 and 1.0 (1.0 being the most bottom side of the screen) \
    /// width 0.0 - 1.0 is the reasonable amount generally \
    /// height 0.0 - 1.0 is the reasonable amount generally \
    /// p6 almost always 0.0 \
    /// p11 seems to be unknown but almost always 0 int
    pub inline fn drawSpriteArx(texture_dict: [*c]const u8, texture_name: [*c]const u8, vec: types.Vector2, width: f32, height: f32, p_6: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int, p_1_1: types.Any, p_1_2: types.Any) !void { try invoker.invoke(void, 0x2D3B147AFAD49DE0, .{texture_dict, texture_name, vec.x, vec.y, width, height, p_6, red, green, blue, alpha, p_1_1, p_1_2}); } // 0x2D3B147AFAD49DE0  b1290
    /// Similar to _DRAW_SPRITE, but seems to be some kind of "interactive" sprite, at least used by render targets. \
    /// These seem to be the only dicts ever requested by this native:
    /// 
    /// prop_screen_biker_laptop \
    /// Prop_Screen_GR_Disruption \
    /// Prop_Screen_TaleOfUs \
    /// prop_screen_nightclub \
    /// Prop_Screen_IE_Adhawk \
    /// prop_screen_sm_free_trade_shipping \
    /// prop_screen_hacker_truck \
    /// MPDesktop \
    /// Prop_Screen_Nightclub \
    /// And a few others
    /// 
    pub inline fn drawSpriteNamedRendertarget(texture_dict: [*c]const u8, texture_name: [*c]const u8, screen__: types.Vector2, width: f32, height: f32, heading: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int, p_1_1: types.Any) !void { try invoker.invoke(void, 0x2BC54A8188768488, .{texture_dict, texture_name, screen__.x, screen__.y, width, height, heading, red, green, blue, alpha, p_1_1}); } // 0x2BC54A8188768488  b877
    /// Similar to DRAW_SPRITE, but allows to specify the texture coordinates used to draw the sprite.
    /// 
    /// u1, v1 - texture coordinates for the top-left corner \
    /// u2, v2 - texture coordinates for the bottom-right corner
    pub inline fn drawSpriteArxWithUv(texture_dict: [*c]const u8, texture_name: [*c]const u8, vec: types.Vector2, width: f32, height: f32, u_1: f32, v_1: f32, u_2: f32, v_2: f32, heading: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int, p_1_5: types.Any) !void { try invoker.invoke(void, 0x95812F9B26074726, .{texture_dict, texture_name, vec.x, vec.y, width, height, u_1, v_1, u_2, v_2, heading, red, green, blue, alpha, p_1_5}); } // 0x95812F9B26074726  b1868
    /// Example: \
    /// GRAPHICS::ADD_ENTITY_ICON(a_0, "MP_Arrow");
    /// 
    /// I tried this and nothing happened...
    pub inline fn addEntityIcon(entity: types.Entity, icon: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x9CD43EEE12BF4DD0, .{entity, icon}); } // 0x9CD43EEE12BF4DD0 0xF3027D21 b323
    pub inline fn setEntityIconVisibility(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE0E8BEECCA96BA31, .{entity, toggle}); } // 0xE0E8BEECCA96BA31 0xD1D2FD52 b323
    pub inline fn setEntityIconColor(entity: types.Entity, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x1D5F595CCAE2E238, .{entity, red, green, blue, alpha}); } // 0x1D5F595CCAE2E238 0x6EE1E946 b323
    /// Sets the on-screen drawing origin for draw-functions (which is normally x=0,y=0 in the upper left corner of the screen) to a world coordinate. \
    /// From now on, the screen coordinate which displays the given world coordinate on the screen is seen as x=0,y=0.
    /// 
    /// Example in C#: \
    /// Vector3 boneCoord = somePed.GetBoneCoord(Bone.SKEL_Head); \
    /// Function.Call(Hash.SET_DRAW_ORIGIN, boneCoord.X, boneCoord.Y, boneCoord.Z, 0); \
    /// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", -0.01, -0.015, 0.013, 0.013, 0.0, 255, 0, 0, 200); \
    /// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", 0.01, -0.015, 0.013, 0.013, 90.0, 255, 0, 0, 200); \
    /// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", -0.01, 0.015, 0.013, 0.013, 270.0, 255, 0, 0, 200); \
    /// Function.Call(Hash.DRAW_SPRITE, "helicopterhud", "hud_corner", 0.01, 0.015, 0.013, 0.013, 180.0, 255, 0, 0, 200); \
    /// Function.Call(Hash.CLEAR_DRAW_ORIGIN);
    /// 
    /// Result: www11.pic-upload.de/19.06.15/bkqohvil2uao.jpg \
    /// If the pedestrian starts walking around now, the sprites are always around her head, no matter where the head is displayed on the screen.
    /// 
    /// This function also effects the drawing of texts and other UI-elements. \
    /// The effect can be reset by calling GRAPHICS::CLEAR_DRAW_ORIGIN().
    pub inline fn setDrawOrigin(vec: types.Vector3, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xAA0008F3BBB8F416, .{vec.x, vec.y, vec.z, p_3}); } // 0xAA0008F3BBB8F416 0xE10198D5 b323
    /// Resets the screen's draw-origin which was changed by the function GRAPHICS::SET_DRAW_ORIGIN(...) back to x=0,y=0.
    /// 
    /// See GRAPHICS::SET_DRAW_ORIGIN(...) for further information.
    pub inline fn clearDrawOrigin() !void { try invoker.invoke(void, 0xFF0B610F6BE0D7AF, .{}); } // 0xFF0B610F6BE0D7AF 0xDD76B263 b323
    pub inline fn setBinkMovie(name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x338D9F609FD632DB, .{name}); } // 0x338D9F609FD632DB  b1290
    pub inline fn playBinkMovie(bink_movie: c_int) !void { try invoker.invoke(void, 0x70D2CC8A542A973C, .{bink_movie}); } // 0x70D2CC8A542A973C  b1290
    pub inline fn stopBinkMovie(bink_movie: c_int) !void { try invoker.invoke(void, 0x63606A61DE68898A, .{bink_movie}); } // 0x63606A61DE68898A  b1290
    pub inline fn releaseBinkMovie(bink_movie: c_int) !void { try invoker.invoke(void, 0x04D950EEFA4EED8C, .{bink_movie}); } // 0x04D950EEFA4EED8C  b1290
    pub inline fn drawBinkMovie(bink_movie: c_int, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, r: c_int, g: c_int, b: c_int, a: c_int) !void { try invoker.invoke(void, 0x7118E83EEB9F7238, .{bink_movie, p_1, p_2, p_3, p_4, p_5, r, g, b, a}); } // 0x7118E83EEB9F7238  b1290
    /// In percentage: 0.0 - 100.0
    pub inline fn setBinkMovieTime(bink_movie: c_int, progress: f32) !void { try invoker.invoke(void, 0x0CB6B3446855B57A, .{bink_movie, progress}); } // 0x0CB6B3446855B57A  b1290
    /// In percentage: 0.0 - 100.0
    pub inline fn getBinkMovieTime(bink_movie: c_int) !f32 { return try invoker.invoke(f32, 0x8E17DDD6B9D5BF29, .{bink_movie}); } // 0x8E17DDD6B9D5BF29  b1734
    /// binkMovie: Is return value from _SET_BINK_MOVIE. Has something to do with bink volume? (audRequestedSettings::SetVolumeCurveScale)
    pub inline fn setBinkMovieVolume(bink_movie: c_int, value: f32) !void { try invoker.invoke(void, 0xAFF33B1178172223, .{bink_movie, value}); } // 0xAFF33B1178172223  b1290
    pub inline fn attachTvAudioToEntity(entity: types.Entity) !void { try invoker.invoke(void, 0x845BAD77CC770633, .{entity}); } // 0x845BAD77CC770633 0x784944DB b323
    pub inline fn setBinkMovieAudioFrontend(bink_movie: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xF816F2933752322D, .{bink_movie, p_1}); } // 0xF816F2933752322D  b1868
    /// Probably changes tvs from being a 3d audio to being "global" audio
    pub inline fn setTvAudioFrontend(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x113D2C5DC57E1774, .{toggle}); } // 0x113D2C5DC57E1774 0x2E0DFA35 b323
    pub inline fn setBinkShouldSkip(bink_movie: c_int, b_should_skip: windows.BOOL) !void { try invoker.invoke(void, 0x6805D58CAA427B72, .{bink_movie, b_should_skip}); } // 0x6805D58CAA427B72  b1290
    pub inline fn loadMovieMeshSet(movie_mesh_set_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xB66064452270E8F1, .{movie_mesh_set_name}); } // 0xB66064452270E8F1 0x9627905C b323
    pub inline fn releaseMovieMeshSet(movie_mesh_set: c_int) !void { try invoker.invoke(void, 0xEB119AA014E89183, .{movie_mesh_set}); } // 0xEB119AA014E89183 0x4FA5501D b323
    pub inline fn queryMovieMeshSetState(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x9B6E70C5CEEF4EEB, .{p_0}); } // 0x9B6E70C5CEEF4EEB 0x9D5D9B38 b323
    /// int screenresx,screenresy; \
    /// GET_SCREEN_RESOLUTION(&screenresx,&screenresy);
    pub inline fn getScreenResolution(x: [*c]c_int, y: [*c]c_int) !void { try invoker.invoke(void, 0x888D57E407E63624, .{x, y}); } // 0x888D57E407E63624 0x29F3572F b323
    /// Returns current screen resolution.
    pub inline fn getActualScreenResolution(x: [*c]c_int, y: [*c]c_int) !void { try invoker.invoke(void, 0x873C9F3104101DD3, .{x, y}); } // 0x873C9F3104101DD3  b323
    pub inline fn getAspectRatio(b: windows.BOOL) !f32 { return try invoker.invoke(f32, 0xF1307EF624A80D87, .{b}); } // 0xF1307EF624A80D87  b323
    pub inline fn getScreenAspectRatio() !f32 { return try invoker.invoke(f32, 0xB2EBE8CBC58B90E9, .{}); } // 0xB2EBE8CBC58B90E9  b323
    /// Setting Aspect Ratio Manually in game will return:
    /// 
    /// false - for Narrow format Aspect Ratios (3:2, 4:3, 5:4, etc. ) \
    /// true - for Wide format Aspect Ratios (5:3, 16:9, 16:10, etc. )
    /// 
    /// Setting Aspect Ratio to "Auto" in game will return "false" or "true" based on the actual set Resolution Ratio.
    pub inline fn getIsWidescreen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x30CF4BDA4FCB1905, .{}); } // 0x30CF4BDA4FCB1905 0xEC717AEF b323
    /// false = Any resolution < 1280x720 \
    /// true = Any resolution >= 1280x720
    pub inline fn getIsHidef() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x84ED31191CC5D2C9, .{}); } // 0x84ED31191CC5D2C9 0x1C340359 b323
    pub inline fn adjustNextPosSizeAsNormalized169() !void { try invoker.invoke(void, 0xEFABC7722293DA7C, .{}); } // 0xEFABC7722293DA7C  b323
    /// Enables Night Vision.
    /// 
    /// Example: \
    /// C#: Function.Call(Hash.SET_NIGHTVISION, true); \
    /// C++: GRAPHICS::SET_NIGHTVISION(true);
    /// 
    /// BOOL toggle: \
    /// true = turns night vision on for your player. \
    /// false = turns night vision off for your player.
    pub inline fn setNightvision(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x18F621F7A5B1F85D, .{toggle}); } // 0x18F621F7A5B1F85D 0xD1E5565F b323
    pub inline fn getRequestingnightvision() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x35FB78DC42B7BD21, .{}); } // 0x35FB78DC42B7BD21 0xF3A6309E b323
    pub inline fn getUsingnightvision() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2202A3F42C8E5F79, .{}); } // 0x2202A3F42C8E5F79 0x62619061 b323
    pub inline fn setExposuretweak(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEF398BEEE4EF45F9, .{toggle}); } // 0xEF398BEEE4EF45F9  b323
    pub inline fn forceExposureReadback(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x814AF7DCAACC597B, .{toggle}); } // 0x814AF7DCAACC597B  b372
    pub inline fn overrideNightvisionLightRange(p_0: f32) !void { try invoker.invoke(void, 0x43FA7CBE20DAB219, .{p_0}); } // 0x43FA7CBE20DAB219  b1290
    pub inline fn setNoiseoveride(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE787BF1C5CF823C9, .{toggle}); } // 0xE787BF1C5CF823C9 0xD576F5DD b323
    pub inline fn setNoisinessoveride(value: f32) !void { try invoker.invoke(void, 0xCB6A7C3BB17A0C67, .{value}); } // 0xCB6A7C3BB17A0C67 0x046B62D9 b323
    /// Convert a world coordinate into its relative screen coordinate.  (WorldToScreen)
    /// 
    /// Returns a boolean; whether or not the operation was successful. It will return false if the coordinates given are not visible to the rendering camera.
    /// 
    /// 
    /// For .NET users...
    /// 
    /// VB: \
    /// Public Shared Function World3DToScreen2d(pos as vector3) As Vector2
    /// 
    ///         Dim x2dp, y2dp As New Native.OutputArgument
    /// 
    ///         Native.Function.Call(Of Boolean)(Native.Hash.GET_SCREEN_COORD_FROM_WORLD_COORD , pos.x, pos.y, pos.z, x2dp, y2dp)
    ///         Return New Vector2(x2dp.GetResult(Of Single), y2dp.GetResult(Of Single))
    ///       
    ///     End Function
    /// 
    /// C#: \
    /// Vector2 World3DToScreen2d(Vector3 pos) \
    ///     {
    ///         var x2dp = new OutputArgument();
    ///         var y2dp = new OutputArgument();
    /// 
    ///         Function.Call<bool>(Hash.GET_SCREEN_COORD_FROM_WORLD_COORD , pos.X, pos.Y, pos.Z, x2dp, y2dp);
    ///         return new Vector2(x2dp.GetResult<float>(), y2dp.GetResult<float>());
    ///     }
    /// //USE VERY SMALL VALUES FOR THE SCALE OF RECTS/TEXT because it is dramatically larger on screen than in 3D, e.g '0.05' small.
    /// 
    /// Used to be called _WORLD3D_TO_SCREEN2D
    /// 
    /// I thought we lost you from the scene forever. It does seem however that calling SET_DRAW_ORIGIN then your natives, then ending it. Seems to work better for certain things such as keeping boxes around people for a predator missile e.g.
    pub inline fn getScreenCoordFromWorldCoord(world__: types.Vector3, screen_x: [*c]f32, screen_y: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x34E82F05DF2974F5, .{world__.x, world__.y, world__.z, screen_x, screen_y}); } // 0x34E82F05DF2974F5 0x1F950E4B b323
    /// Returns the texture resolution of the passed texture dict+name.
    /// 
    /// Note: Most texture resolutions are doubled compared to the console version of the game.
    pub inline fn getTextureResolution(texture_dict: [*c]const u8, texture_name: [*c]const u8) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x35736EE65BD00C11, .{texture_dict, texture_name}); } // 0x35736EE65BD00C11 0x096DAA4D b323
    /// Overriding ped badge texture to a passed texture. It's synced between players (even custom textures!), don't forget to request used dict on *all* clients to make it sync properly. Can be removed by passing empty strings.
    pub inline fn overridePedCrewLogoTexture(ped: types.Ped, txd: [*c]const u8, txn: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x95EB5E34F821BABE, .{ped, txd, txn}); } // 0x95EB5E34F821BABE  b877
    pub inline fn setDistanceBlurStrengthOverride(p_0: f32) !void { try invoker.invoke(void, 0xE2892E7E55D7073A, .{p_0}); } // 0xE2892E7E55D7073A 0x455F1084 b323
    /// Purpose of p0 and p1 unknown.
    pub inline fn setFlash(p_0: f32, p_1: f32, fade_in: f32, duration: f32, fade_out: f32) !void { try invoker.invoke(void, 0x0AB84296FED9CFC6, .{p_0, p_1, fade_in, duration, fade_out}); } // 0x0AB84296FED9CFC6 0x7E55A1EE b323
    pub inline fn disableOcclusionThisFrame() !void { try invoker.invoke(void, 0x3669F1B198DCAA4F, .{}); } // 0x3669F1B198DCAA4F 0x0DCC0B8B b323
    /// Does not affect weapons, particles, fire/explosions, flashlights or the sun. \
    /// When set to true, all emissive textures (including ped components that have light effects), street lights, building lights, vehicle lights, etc will all be turned off.
    /// 
    /// Used in Humane Labs Heist for EMP.
    /// 
    /// state: True turns off all artificial light sources in the map: buildings, street lights, car lights, etc. False turns them back on.
    pub inline fn setArtificialLightsState(state: windows.BOOL) !void { try invoker.invoke(void, 0x1268615ACE24D504, .{state}); } // 0x1268615ACE24D504 0xAA2A0EAF b323
    /// If "blackout" is enabled, this native allows you to ignore "blackout" for vehicles.
    pub inline fn setArtificialVehicleLightsState(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE2B187C0939B3D32, .{toggle}); } // 0xE2B187C0939B3D32  b2060
    pub inline fn disableHdtexThisFrame() !void { try invoker.invoke(void, 0xC35A6D07C93802B2, .{}); } // 0xC35A6D07C93802B2  b323
    /// Creates a tracked point, useful for checking the visibility of a 3D point on screen.
    pub inline fn createTrackedPoint() !c_int { return try invoker.invoke(c_int, 0xE2C9439ED45DEA60, .{}); } // 0xE2C9439ED45DEA60 0x3129C31A b323
    pub inline fn setTrackedPointInfo(point: c_int, vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0x164ECBB3CF750CB0, .{point, vec.x, vec.y, vec.z, radius}); } // 0x164ECBB3CF750CB0 0x28689AA4 b323
    pub inline fn isTrackedPointVisible(point: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC45CCDAAC9221CA8, .{point}); } // 0xC45CCDAAC9221CA8 0x0BFC4F64 b323
    pub inline fn destroyTrackedPoint(point: c_int) !void { try invoker.invoke(void, 0xB25DC90BAD56CA42, .{point}); } // 0xB25DC90BAD56CA42 0x14AC675F b323
    /// This function is hard-coded to always return 0.
    pub inline fn setGrassCullSphere(p_0: f32, p_1: f32, p_2: f32, p_3: f32) !c_int { return try invoker.invoke(c_int, 0xBE197EAA669238F4, .{p_0, p_1, p_2, p_3}); } // 0xBE197EAA669238F4  b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn removeGrassCullSphere(handle: c_int) !void { try invoker.invoke(void, 0x61F95E5BB3E0A8C6, .{handle}); } // 0x61F95E5BB3E0A8C6  b323
    pub inline fn procgrassEnableCullsphere(handle: c_int, vec: types.Vector3, scale: f32) !void { try invoker.invoke(void, 0xAE51BC858F32BA66, .{handle, vec.x, vec.y, vec.z, scale}); } // 0xAE51BC858F32BA66  b323
    pub inline fn procgrassDisableCullsphere(handle: c_int) !void { try invoker.invoke(void, 0x649C97D52332341A, .{handle}); } // 0x649C97D52332341A  b323
    pub inline fn procgrassIsCullsphereEnabled(handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2C42340F916C5930, .{handle}); } // 0x2C42340F916C5930  b323
    pub inline fn procgrassEnableAmbscalescan() !void { try invoker.invoke(void, 0x14FC5833464340A8, .{}); } // 0x14FC5833464340A8  b323
    pub inline fn procgrassDisableAmbscalescan() !void { try invoker.invoke(void, 0x0218BA067D249DEA, .{}); } // 0x0218BA067D249DEA  b323
    pub inline fn disableProcobjCreation() !void { try invoker.invoke(void, 0x1612C45F9E3E0D44, .{}); } // 0x1612C45F9E3E0D44  b323
    pub inline fn enableProcobjCreation() !void { try invoker.invoke(void, 0x5DEBD9C4DC995692, .{}); } // 0x5DEBD9C4DC995692  b323
    pub inline fn grassbatchEnableFlatteningExtInSphere(vec: types.Vector3, p_3: types.Any, p_4: f32, p_5: f32, p_6: f32, scale: f32) !void { try invoker.invoke(void, 0xAAE9BE70EC7C69AB, .{vec.x, vec.y, vec.z, p_3, p_4, p_5, p_6, scale}); } // 0xAAE9BE70EC7C69AB  b1290
    /// Wraps 0xAAE9BE70EC7C69AB with FLT_MAX as p7
    pub inline fn grassbatchEnableFlatteningInSphere(vec: types.Vector3, radius: f32, p_4: f32, p_5: f32, p_6: f32) !void { try invoker.invoke(void, 0x6D955F6A9E0295B1, .{vec.x, vec.y, vec.z, radius, p_4, p_5, p_6}); } // 0x6D955F6A9E0295B1  b323
    pub inline fn grassbatchDisableFlattening() !void { try invoker.invoke(void, 0x302C91AB2D477F7E, .{}); } // 0x302C91AB2D477F7E  b323
    pub inline fn cascadeShadowsInitSession() !void { try invoker.invoke(void, 0x03FC694AE06C5A20, .{}); } // 0x03FC694AE06C5A20 0x48F16186 b323
    pub inline fn cascadeShadowsSetCascadeBounds(p_0: types.Any, p_1: windows.BOOL, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: windows.BOOL, p_7: f32) !void { try invoker.invoke(void, 0xD2936CAB8B58FCBD, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0xD2936CAB8B58FCBD 0x84F05943 b323
    pub inline fn cascadeShadowsSetCascadeBoundsScale(p_0: f32) !void { try invoker.invoke(void, 0x5F0F3F56635809EF, .{p_0}); } // 0x5F0F3F56635809EF 0x13D4ABC0 b323
    pub inline fn cascadeShadowsSetEntityTrackerScale(p_0: f32) !void { try invoker.invoke(void, 0x5E9DAF5A20F15908, .{p_0}); } // 0x5E9DAF5A20F15908 0xD2157428 b323
    pub inline fn cascadeShadowsSetSplitZExpWeight(p_0: f32) !void { try invoker.invoke(void, 0x36F6626459D91457, .{p_0}); } // 0x36F6626459D91457 0xC07C64C9 b323
    pub inline fn cascadeShadowsSetBoundPosition(p_0: types.Any) !void { try invoker.invoke(void, 0x259BA6D4E6F808F1, .{p_0}); } // 0x259BA6D4E6F808F1  b1011
    /// When this is set to ON, shadows only draw as you get nearer.
    /// 
    /// When OFF, they draw from a further distance.
    pub inline fn cascadeShadowsEnableEntityTracker(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x80ECBC0C856D3B0B, .{toggle}); } // 0x80ECBC0C856D3B0B 0xFE903D0F b323
    pub inline fn cascadeShadowsSetScreenSizeCheckEnabled(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x25FC3E33A31AD0C9, .{p_0}); } // 0x25FC3E33A31AD0C9  b323
    /// Possible values: \
    /// "CSM_ST_POINT" \
    /// "CSM_ST_LINEAR" \
    /// "CSM_ST_TWOTAP" \
    /// "CSM_ST_BOX3x3" \
    /// "CSM_ST_BOX4x4" \
    /// "CSM_ST_DITHER2_LINEAR" \
    /// "CSM_ST_CUBIC" \
    /// "CSM_ST_DITHER4" \
    /// "CSM_ST_DITHER16" \
    /// "CSM_ST_SOFT16" \
    /// "CSM_ST_DITHER16_RPDB" \
    /// "CSM_ST_POISSON16_RPDB_GNORM" \
    /// "CSM_ST_HIGHRES_BOX4x4" \
    /// "CSM_ST_CLOUDS_SIMPLE" \
    /// "CSM_ST_CLOUDS_LINEAR" \
    /// "CSM_ST_CLOUDS_TWOTAP" \
    /// "CSM_ST_CLOUDS_BOX3x3" \
    /// "CSM_ST_CLOUDS_BOX4x4" \
    /// "CSM_ST_CLOUDS_DITHER2_LINEAR" \
    /// "CSM_ST_CLOUDS_SOFT16" \
    /// "CSM_ST_CLOUDS_DITHER16_RPDB" \
    /// "CSM_ST_CLOUDS_POISSON16_RPDB_GNORM"
    pub inline fn cascadeShadowsSetShadowSampleType(@"type": [*c]const u8) !void { try invoker.invoke(void, 0xB11D94BC55F41932, .{@"type"}); } // 0xB11D94BC55F41932 0xDE10BA1F b323
    pub inline fn cascadeShadowsClearShadowSampleType() !void { try invoker.invoke(void, 0x27CB772218215325, .{}); } // 0x27CB772218215325  b323
    pub inline fn cascadeShadowsSetAircraftMode(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x6DDBF9DFFC4AC080, .{p_0}); } // 0x6DDBF9DFFC4AC080 0x9F470BE3 b323
    pub inline fn cascadeShadowsSetDynamicDepthMode(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xD39D13C9FEBF0511, .{p_0}); } // 0xD39D13C9FEBF0511 0x4A124267 b323
    pub inline fn cascadeShadowsSetDynamicDepthValue(p_0: f32) !void { try invoker.invoke(void, 0x02AC28F3A01FA04A, .{p_0}); } // 0x02AC28F3A01FA04A 0xB19B2764 b323
    pub inline fn cascadeShadowsEnableFreezer(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x0AE73D8DF3A762B2, .{p_0}); } // 0x0AE73D8DF3A762B2 0x342FA2B4 b323
    pub inline fn waterReflectionSetScriptObjectVisibility(p_0: types.Any) !void { try invoker.invoke(void, 0xCA465D9CC0D231BA, .{p_0}); } // 0xCA465D9CC0D231BA  b1011
    pub inline fn golfTrailSetEnabled(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA51C4B86B71652AE, .{toggle}); } // 0xA51C4B86B71652AE 0x5D3BFFC9 b323
    /// p8 seems to always be false.
    pub inline fn golfTrailSetPath(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: windows.BOOL) !void { try invoker.invoke(void, 0x312342E1A4874F3F, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0x312342E1A4874F3F 0xD9653728 b323
    pub inline fn golfTrailSetRadius(p_0: f32, p_1: f32, p_2: f32) !void { try invoker.invoke(void, 0x2485D34E50A22E84, .{p_0, p_1, p_2}); } // 0x2485D34E50A22E84 0x72BA8A14 b323
    pub inline fn golfTrailSetColour(p_0: c_int, p_1: c_int, p_2: c_int, p_3: c_int, p_4: c_int, p_5: c_int, p_6: c_int, p_7: c_int, p_8: c_int, p_9: c_int, p_1_0: c_int, p_1_1: c_int) !void { try invoker.invoke(void, 0x12995F2E53FFA601, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0, p_1_1}); } // 0x12995F2E53FFA601 0x804F444C b323
    pub inline fn golfTrailSetTessellation(p_0: c_int, p_1: c_int) !void { try invoker.invoke(void, 0xDBAA5EC848BA2D46, .{p_0, p_1}); } // 0xDBAA5EC848BA2D46 0xBB1A1294 b323
    pub inline fn golfTrailSetFixedControlPointEnable(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xC0416B061F2B7E5E, .{p_0}); } // 0xC0416B061F2B7E5E 0x1A1A72EF b323
    /// 12 matches across 4 scripts. All 4 scripts were job creators.
    /// 
    /// type ranged from 0 - 2. \
    /// p4 was always 0.2f. Likely scale. \
    /// assuming p5 - p8 is RGBA, the graphic is always yellow (255, 255, 0, 255).
    /// 
    /// Tested but noticed nothing.
    pub inline fn golfTrailSetFixedControlPoint(@"type": c_int, pos__: types.Vector3, p_4: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xB1BB03742917A5D6, .{@"type", pos__.x, pos__.y, pos__.z, p_4, red, green, blue, alpha}); } // 0xB1BB03742917A5D6 0x3BB12B75 b323
    /// Only appeared in Golf & Golf_mp. Parameters were all ptrs
    pub inline fn golfTrailSetShaderParams(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32) !void { try invoker.invoke(void, 0x9CFDD90B2B844BF7, .{p_0, p_1, p_2, p_3, p_4}); } // 0x9CFDD90B2B844BF7 0x4EA70FB4 b323
    pub inline fn golfTrailSetFacing(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x06F761EA47C1D3ED, .{p_0}); } // 0x06F761EA47C1D3ED 0x0D830DC7 b323
    pub inline fn golfTrailGetMaxHeight() !f32 { return try invoker.invoke(f32, 0xA4819F5E23E2FFAD, .{}); } // 0xA4819F5E23E2FFAD 0xA08B46AD b323
    pub inline fn golfTrailGetVisualControlPoint(p_0: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xA4664972A9B8F8BA, .{p_0}); } // 0xA4664972A9B8F8BA 0xECD470F0 b323
    /// Toggles Heatvision on/off.
    pub inline fn setSeethrough(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7E08924259E08CE0, .{toggle}); } // 0x7E08924259E08CE0 0x74D4995C b323
    pub inline fn getUsingseethrough() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x44B80ABAB9D80BD3, .{}); } // 0x44B80ABAB9D80BD3 0x1FE547F2 b323
    pub inline fn seethroughReset() !void { try invoker.invoke(void, 0x70A64C0234EF522C, .{}); } // 0x70A64C0234EF522C 0x310E9B67 b323
    pub inline fn seethroughSetFadeStartdistance(distance: f32) !void { try invoker.invoke(void, 0xA78DE25577300BA1, .{distance}); } // 0xA78DE25577300BA1  b573
    pub inline fn seethroughSetFadeEnddistance(distance: f32) !void { try invoker.invoke(void, 0x9D75795B9DC6EBBF, .{distance}); } // 0x9D75795B9DC6EBBF  b573
    pub inline fn seethroughGetMaxThickness() !f32 { return try invoker.invoke(f32, 0x43DBAE39626CE83F, .{}); } // 0x43DBAE39626CE83F  b1290
    /// 0.0 = you will not be able to see people behind the walls. 50.0 and more = you will see everyone through the walls. More value is "better" view. See https://gfycat.com/FirmFlippantGourami \
    /// min: 1.0 \
    /// max: 10000.0
    pub inline fn seethroughSetMaxThickness(thickness: f32) !void { try invoker.invoke(void, 0x0C8FAC83902A62DF, .{thickness}); } // 0x0C8FAC83902A62DF  b573
    pub inline fn seethroughSetNoiseMin(amount: f32) !void { try invoker.invoke(void, 0xFF5992E1C9E65D05, .{amount}); } // 0xFF5992E1C9E65D05  b573
    pub inline fn seethroughSetNoiseMax(amount: f32) !void { try invoker.invoke(void, 0xFEBFBFDFB66039DE, .{amount}); } // 0xFEBFBFDFB66039DE  b573
    pub inline fn seethroughSetHilightIntensity(intensity: f32) !void { try invoker.invoke(void, 0x19E50EB6E33E1D28, .{intensity}); } // 0x19E50EB6E33E1D28  b573
    pub inline fn seethroughSetHighlightNoise(noise: f32) !void { try invoker.invoke(void, 0x1636D7FC127B10D2, .{noise}); } // 0x1636D7FC127B10D2  b573
    /// min: 0.0 \
    /// max: 0.75
    pub inline fn seethroughSetHeatscale(index: c_int, heat_scale: f32) !void { try invoker.invoke(void, 0xD7D0B00177485411, .{index, heat_scale}); } // 0xD7D0B00177485411 0x654F0287 b323
    pub inline fn seethroughSetColorNear(red: c_int, green: c_int, blue: c_int) !void { try invoker.invoke(void, 0x1086127B3A63505E, .{red, green, blue}); } // 0x1086127B3A63505E 0x5B2A67A8 b573
    /// Setter for GET_MOTIONBLUR_MAX_VEL_SCALER
    pub inline fn setMotionblurMaxVelScaler(p_0: f32) !void { try invoker.invoke(void, 0xB3C641F3630BF6DA, .{p_0}); } // 0xB3C641F3630BF6DA 0xF6B837F0 b323
    /// Getter for SET_MOTIONBLUR_MAX_VEL_SCALER
    pub inline fn getMotionblurMaxVelScaler() !f32 { return try invoker.invoke(f32, 0xE59343E9E96529E7, .{}); } // 0xE59343E9E96529E7 0xD906A3A9 b323
    pub inline fn setForceMotionblur(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6A51F78772175A51, .{toggle}); } // 0x6A51F78772175A51  b1011
    pub inline fn togglePlayerDamageOverlay(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE63D7C6EECECB66B, .{toggle}); } // 0xE63D7C6EECECB66B 0xD34A6CBA b323
    /// Sets an value related to timecycles.
    pub inline fn resetAdaptation(p_0: c_int) !void { try invoker.invoke(void, 0xE3E2C1B4C59DBC77, .{p_0}); } // 0xE3E2C1B4C59DBC77 0xD8CC7221 b323
    /// time in ms to transition to fully blurred screen
    pub inline fn triggerScreenblurFadeIn(transition_time: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA328A24AAA6B7FDC, .{transition_time}); } // 0xA328A24AAA6B7FDC 0x5604B890 b323
    /// time in ms to transition from fully blurred to normal
    pub inline fn triggerScreenblurFadeOut(transition_time: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEFACC8AEF94430D5, .{transition_time}); } // 0xEFACC8AEF94430D5 0x46617502 b323
    pub inline fn disableScreenblurFade() !void { try invoker.invoke(void, 0xDE81239437E8C5A8, .{}); } // 0xDE81239437E8C5A8 0xDB7AECDA b323
    pub inline fn getScreenblurFadeCurrentTime() !f32 { return try invoker.invoke(f32, 0x5CCABFFCA31DDE33, .{}); } // 0x5CCABFFCA31DDE33 0xEA432A94 b323
    /// Returns whether screen transition to blur/from blur is running.
    pub inline fn isScreenblurFadeRunning() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7B226C785A52A0A9, .{}); } // 0x7B226C785A52A0A9 0x926B8734 b323
    pub inline fn togglePausedRenderphases(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDFC252D8A3E15AB7, .{toggle}); } // 0xDFC252D8A3E15AB7 0x30ADE541 b323
    pub inline fn getTogglePausedRenderphasesStatus() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEB3DAC2C86001E5E, .{}); } // 0xEB3DAC2C86001E5E 0xD4F5D07D b323
    pub inline fn resetPausedRenderphases() !void { try invoker.invoke(void, 0xE1C8709406F2C41C, .{}); } // 0xE1C8709406F2C41C 0x0113EAE4 b323
    pub inline fn grabPausemenuOwnership() !void { try invoker.invoke(void, 0x851CD923176EBA7C, .{}); } // 0x851CD923176EBA7C 0xDCBA251B b323
    pub inline fn setHidofOverride(p_0: windows.BOOL, p_1: windows.BOOL, nearplane_out: f32, nearplane_in: f32, farplane_out: f32, farplane_in: f32) !void { try invoker.invoke(void, 0xBA3D65906822BED5, .{p_0, p_1, nearplane_out, nearplane_in, farplane_out, farplane_in}); } // 0xBA3D65906822BED5 0x513D444B b323
    pub inline fn setLockAdaptiveDofDistance(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xB569F41F3E7E83A4, .{p_0}); } // 0xB569F41F3E7E83A4  b1103
    pub inline fn phonephotoeditorToggle(p_0: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7AC24EAB6D74118D, .{p_0}); } // 0x7AC24EAB6D74118D 0xB2410EAB b323
    pub inline fn phonephotoeditorIsActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBCEDB009461DA156, .{}); } // 0xBCEDB009461DA156 0x5AB94128 b323
    pub inline fn phonephotoeditorSetFrameTxd(texture_dict: [*c]const u8, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x27FEB5254759CDE3, .{texture_dict, p_1}); } // 0x27FEB5254759CDE3 0xD63FCB3E b323
    /// GRAPHICS::START_PARTICLE_FX_NON_LOOPED_AT_COORD("scr_paleto_roof_impact", -140.8576f, 6420.789f, 41.1391f, 0f, 0f, 267.3957f, 0x3F800000, 0, 0, 0);
    /// 
    /// Axis - Invert Axis Flags
    /// 
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    /// 
    /// 
    /// ------------------------------------------------------------------- \
    /// C#
    /// 
    /// Function.Call<int>(Hash.START_PARTICLE_FX_NON_LOOPED_AT_COORD, = you are calling this function.
    /// 
    /// char *effectname = This is an in-game effect name, for e.g. "scr_fbi4_trucks_crash" is used to give the effects when truck crashes etc
    /// 
    /// float x, y, z pos = this one is Simple, you just have to declare, where do you want this effect to take place at, so declare the ordinates
    /// 
    /// float xrot, yrot, zrot = Again simple? just mention the value in case if you want the effect to rotate.
    /// 
    /// float scale = is declare the scale of the effect, this may vary as per the effects for e.g 1.0f
    /// 
    /// bool xaxis, yaxis, zaxis = To bool the axis values.
    /// 
    /// example: \
    /// Function.Call<int>(Hash.START_PARTICLE_FX_NON_LOOPED_AT_COORD, "scr_fbi4_trucks_crash", GTA.Game.Player.Character.Position.X, GTA.Game.Player.Character.Position.Y, GTA.Game.Player.Character.Position.Z + 4f, 0, 0, 0, 5.5f, 0, 0, 0);
    pub inline fn startParticleFxNonLoopedAtCoord(effect_name: [*c]const u8, pos__: types.Vector3, rot__: types.Vector3, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x25129531F77B9ED3, .{effect_name, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, scale, x_axis, y_axis, z_axis}); } // 0x25129531F77B9ED3 0xDD79D679 b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startNetworkedParticleFxNonLoopedAtCoord(effect_name: [*c]const u8, pos__: types.Vector3, rot__: types.Vector3, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL, p_1_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF56B8137DF10135D, .{effect_name, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, scale, x_axis, y_axis, z_axis, p_1_1}); } // 0xF56B8137DF10135D 0x633F8C48 b323
    /// GRAPHICS::START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE("scr_sh_bong_smoke", PLAYER::PLAYER_PED_ID(), -0.025f, 0.13f, 0f, 0f, 0f, 0f, 31086, 0x3F800000, 0, 0, 0);
    /// 
    /// Axis - Invert Axis Flags
    /// 
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startParticleFxNonLoopedOnPedBone(effect_name: [*c]const u8, ped: types.Ped, offset__: types.Vector3, rot__: types.Vector3, bone_index: c_int, scale: f32, axis_x: windows.BOOL, axis_y: windows.BOOL, axis_z: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0E7E72961BA18619, .{effect_name, ped, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, bone_index, scale, axis_x, axis_y, axis_z}); } // 0x0E7E72961BA18619 0x53DAEF4E b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startNetworkedParticleFxNonLoopedOnPedBone(effect_name: [*c]const u8, ped: types.Ped, offset__: types.Vector3, rot__: types.Vector3, bone_index: c_int, scale: f32, axis_x: windows.BOOL, axis_y: windows.BOOL, axis_z: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA41B6A43642AC2CF, .{effect_name, ped, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, bone_index, scale, axis_x, axis_y, axis_z}); } // 0xA41B6A43642AC2CF 0x161780C1 b323
    /// Starts a particle effect on an entity for example your player.
    /// 
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    /// 
    /// Example: \
    /// C#: \
    /// Function.Call(Hash.REQUEST_NAMED_PTFX_ASSET, "scr_rcbarry2");                     Function.Call(Hash.USE_PARTICLE_FX_ASSET, "scr_rcbarry2");                             Function.Call(Hash.START_PARTICLE_FX_NON_LOOPED_ON_ENTITY, "scr_clown_appears", Game.Player.Character, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 1.0, false, false, false);
    /// 
    /// Internally this calls the same function as GRAPHICS::START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE \
    /// however it uses -1 for the specified bone index, so it should be possible to start a non looped fx on an entity bone using that native
    /// 
    /// -can confirm START_PARTICLE_FX_NON_LOOPED_ON_PED_BONE does NOT work on vehicle bones.
    pub inline fn startParticleFxNonLoopedOnEntity(effect_name: [*c]const u8, entity: types.Entity, offset__: types.Vector3, rot__: types.Vector3, scale: f32, axis_x: windows.BOOL, axis_y: windows.BOOL, axis_z: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0D53A3B8DA0809D2, .{effect_name, entity, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, scale, axis_x, axis_y, axis_z}); } // 0x0D53A3B8DA0809D2 0x9604DAD4 b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startNetworkedParticleFxNonLoopedOnEntity(effect_name: [*c]const u8, entity: types.Entity, offset__: types.Vector3, rot__: types.Vector3, scale: f32, axis_x: windows.BOOL, axis_y: windows.BOOL, axis_z: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC95EB1DB6E92113D, .{effect_name, entity, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, scale, axis_x, axis_y, axis_z}); } // 0xC95EB1DB6E92113D 0x469A2B4A b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startParticleFxNonLoopedOnEntityBone(effect_name: [*c]const u8, entity: types.Entity, offset__: types.Vector3, rot__: types.Vector3, bone_index: c_int, scale: f32, axis_x: windows.BOOL, axis_y: windows.BOOL, axis_z: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x02B1F2A72E0F5325, .{effect_name, entity, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, bone_index, scale, axis_x, axis_y, axis_z}); } // 0x02B1F2A72E0F5325  b2189
    /// only works on some fx's, not networked
    pub inline fn setParticleFxNonLoopedColour(r: f32, g: f32, b: f32) !void { try invoker.invoke(void, 0x26143A59EF48B262, .{r, g, b}); } // 0x26143A59EF48B262 0x7B689E20 b323
    /// Usage example for C#:
    /// 
    /// Function.Call(Hash.SET_PARTICLE_FX_NON_LOOPED_ALPHA, new InputArgument[] { 0.1f });
    /// 
    /// Note: the argument alpha ranges from 0.0f-1.0f !
    pub inline fn setParticleFxNonLoopedAlpha(alpha: f32) !void { try invoker.invoke(void, 0x77168D722C58B2FC, .{alpha}); } // 0x77168D722C58B2FC 0x497EAFF2 b323
    pub inline fn setParticleFxNonLoopedScale(scale: f32) !void { try invoker.invoke(void, 0xB7EF5850C39FABCA, .{scale}); } // 0xB7EF5850C39FABCA  b2802
    pub inline fn setParticleFxNonLoopedEmitterSize(p_0: f32, p_1: f32, scale: f32) !void { try invoker.invoke(void, 0x1E2E01C00837D26E, .{p_0, p_1, scale}); } // 0x1E2E01C00837D26E  b2699
    /// Used only once in the scripts (taxi_clowncar)
    pub inline fn setParticleFxForceVehicleInterior(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8CDE909A0370BB3A, .{toggle}); } // 0x8CDE909A0370BB3A  b323
    /// GRAPHICS::START_PARTICLE_FX_LOOPED_AT_COORD("scr_fbi_falling_debris", 93.7743f, -749.4572f, 70.86904f, 0f, 0f, 0f, 0x3F800000, 0, 0, 0, 0)
    /// 
    /// 
    /// p11 seems to be always 0
    /// 
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startParticleFxLoopedAtCoord(effect_name: [*c]const u8, vec: types.Vector3, rot__: types.Vector3, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL, p_1_1: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xE184F4F0DC5910E7, .{effect_name, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, scale, x_axis, y_axis, z_axis, p_1_1}); } // 0xE184F4F0DC5910E7 0xD348E3E6 b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startParticleFxLoopedOnPedBone(effect_name: [*c]const u8, ped: types.Ped, offset__: types.Vector3, rot__: types.Vector3, bone_index: c_int, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xF28DA9F38CD1787C, .{effect_name, ped, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, bone_index, scale, x_axis, y_axis, z_axis}); } // 0xF28DA9F38CD1787C 0xF8FC196F b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startParticleFxLoopedOnEntity(effect_name: [*c]const u8, entity: types.Entity, offset__: types.Vector3, rot__: types.Vector3, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x1AE42C1660FD6517, .{effect_name, entity, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, scale, x_axis, y_axis, z_axis}); } // 0x1AE42C1660FD6517 0x0D06FF62 b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startParticleFxLoopedOnEntityBone(effect_name: [*c]const u8, entity: types.Entity, offset__: types.Vector3, rot__: types.Vector3, bone_index: c_int, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xC6EB449E33977F0B, .{effect_name, entity, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, bone_index, scale, x_axis, y_axis, z_axis}); } // 0xC6EB449E33977F0B 0x23BF0F9B b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startNetworkedParticleFxLoopedOnEntity(effect_name: [*c]const u8, entity: types.Entity, offset__: types.Vector3, rot__: types.Vector3, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL, r: f32, g: f32, b: f32, a: f32) !c_int { return try invoker.invoke(c_int, 0x6F60E89A7B64EE1D, .{effect_name, entity, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, scale, x_axis, y_axis, z_axis, r, g, b, a}); } // 0x6F60E89A7B64EE1D 0x110752B2 b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn startNetworkedParticleFxLoopedOnEntityBone(effect_name: [*c]const u8, entity: types.Entity, offset__: types.Vector3, rot__: types.Vector3, bone_index: c_int, scale: f32, x_axis: windows.BOOL, y_axis: windows.BOOL, z_axis: windows.BOOL, r: f32, g: f32, b: f32, a: f32) !c_int { return try invoker.invoke(c_int, 0xDDE23F30CC5A0F03, .{effect_name, entity, offset__.x, offset__.y, offset__.z, rot__.x, rot__.y, rot__.z, bone_index, scale, x_axis, y_axis, z_axis, r, g, b, a}); } // 0xDDE23F30CC5A0F03 0xF478EFCF b323
    /// p1 is always 0 in the native scripts
    pub inline fn stopParticleFxLooped(ptfx_handle: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x8F75998877616996, .{ptfx_handle, p_1}); } // 0x8F75998877616996 0xD245455B b323
    pub inline fn removeParticleFx(ptfx_handle: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xC401503DFE8D53CF, .{ptfx_handle, p_1}); } // 0xC401503DFE8D53CF 0x6BA48C7E b323
    pub inline fn removeParticleFxFromEntity(entity: types.Entity) !void { try invoker.invoke(void, 0xB8FEAEEBCC127425, .{entity}); } // 0xB8FEAEEBCC127425 0xCEDE52E9 b323
    pub inline fn removeParticleFxInRange(vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0xDD19FA1C6D657305, .{vec.x, vec.y, vec.z, radius}); } // 0xDD19FA1C6D657305 0x7EB8F275 b323
    pub inline fn forceParticleFxInVehicleInterior(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xBA0127DA25FD54C9, .{p_0, p_1}); } // 0xBA0127DA25FD54C9  b372
    pub inline fn doesParticleFxLoopedExist(ptfx_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74AFEF0D2E1E409B, .{ptfx_handle}); } // 0x74AFEF0D2E1E409B 0xCBF91D2A b323
    pub inline fn setParticleFxLoopedOffsets(ptfx_handle: c_int, vec: types.Vector3, rot__: types.Vector3) !void { try invoker.invoke(void, 0xF7DDEBEC43483C43, .{ptfx_handle, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z}); } // 0xF7DDEBEC43483C43 0x641F7790 b323
    pub inline fn setParticleFxLoopedEvolution(ptfx_handle: c_int, property_name: [*c]const u8, amount: f32, no_network: windows.BOOL) !void { try invoker.invoke(void, 0x5F0C4B5B1C393BE2, .{ptfx_handle, property_name, amount, no_network}); } // 0x5F0C4B5B1C393BE2 0x1CBC1373 b323
    /// only works on some fx's
    /// 
    /// p4 = 0
    pub inline fn setParticleFxLoopedColour(ptfx_handle: c_int, r: f32, g: f32, b: f32, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x7F8F65877F88783B, .{ptfx_handle, r, g, b, p_4}); } // 0x7F8F65877F88783B 0x5219D530 b323
    pub inline fn setParticleFxLoopedAlpha(ptfx_handle: c_int, alpha: f32) !void { try invoker.invoke(void, 0x726845132380142E, .{ptfx_handle, alpha}); } // 0x726845132380142E 0x5ED49BE1 b323
    pub inline fn setParticleFxLoopedScale(ptfx_handle: c_int, scale: f32) !void { try invoker.invoke(void, 0xB44250AAA456492D, .{ptfx_handle, scale}); } // 0xB44250AAA456492D 0x099B8B49 b323
    pub inline fn setParticleFxLoopedFarClipDist(ptfx_handle: c_int, range: f32) !void { try invoker.invoke(void, 0xDCB194B85EF7B541, .{ptfx_handle, range}); } // 0xDCB194B85EF7B541 0x233DE879 b323
    pub inline fn setParticleFxLoopedCameraBias_(ptfx_handle: c_int, p_1: f32) !void { try invoker.invoke(void, 0x4100BF0346A8D2C3, .{ptfx_handle, p_1}); } // 0x4100BF0346A8D2C3  b3095
    pub inline fn setParticleFxCamInsideVehicle(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xEEC4047028426510, .{p_0}); } // 0xEEC4047028426510 0x19EC0001 b323
    pub inline fn setParticleFxCamInsideNonplayerVehicle(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xACEE6F360FC1F6B6, .{vehicle, p_1}); } // 0xACEE6F360FC1F6B6 0x6B125A02 b323
    pub inline fn setParticleFxShootoutBoat(p_0: types.Any) !void { try invoker.invoke(void, 0x96EF97DAEB89BEF5, .{p_0}); } // 0x96EF97DAEB89BEF5 0xD938DEE0 b323
    pub inline fn clearParticleFxShootoutBoat() !void { try invoker.invoke(void, 0x2A251AA48B2B46DB, .{}); } // 0x2A251AA48B2B46DB  b323
    pub inline fn setParticleFxBloodScale(p_0: types.Any) !void { try invoker.invoke(void, 0x908311265D42A820, .{p_0}); } // 0x908311265D42A820  b323
    pub inline fn disableInWaterPtfx(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCFD16F0DB5A3535C, .{toggle}); } // 0xCFD16F0DB5A3535C  b2060
    pub inline fn disableDownwashPtfx(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5F6DF3D92271E8A1, .{toggle}); } // 0x5F6DF3D92271E8A1  b323
    pub inline fn setParticleFxSlipstreamLodrangeScale(scale: f32) !void { try invoker.invoke(void, 0x2B40A97646381508, .{scale}); } // 0x2B40A97646381508  b1011
    /// Creates cartoon effect when Michel smokes the weed
    pub inline fn enableClownBloodVfx(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD821490579791273, .{toggle}); } // 0xD821490579791273 0xC61C75E9 b323
    /// Creates a motion-blur sort of effect, this native does not seem to work, however by using the `START_SCREEN_EFFECT` native with `DrugsMichaelAliensFight` as the effect parameter, you should be able to get the effect.
    pub inline fn enableAlienBloodVfx(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9DCE1F0F78260875, .{toggle}); } // 0x9DCE1F0F78260875 0xCE8B8748 b323
    pub inline fn setParticleFxBulletImpactScale(scale: f32) !void { try invoker.invoke(void, 0x27E32866E9A5C416, .{scale}); } // 0x27E32866E9A5C416 0xC1AD5DDF b323
    pub inline fn setParticleFxBulletImpactLodrangeScale(p_0: f32) !void { try invoker.invoke(void, 0xBB90E12CAC1DAB25, .{p_0}); } // 0xBB90E12CAC1DAB25 0x3968E915 b323
    pub inline fn setParticleFxBulletTraceNoAngleReject(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xCA4AE345A153D573, .{p_0}); } // 0xCA4AE345A153D573 0x64BA4648 b323
    pub inline fn setParticleFxBangScrapeLodrangeScale(p_0: f32) !void { try invoker.invoke(void, 0x54E22EA2C1956A8D, .{p_0}); } // 0x54E22EA2C1956A8D 0x8BE3D47F b323
    pub inline fn setParticleFxFootLodrangeScale(p_0: f32) !void { try invoker.invoke(void, 0x949F397A288B28B3, .{p_0}); } // 0x949F397A288B28B3 0xE3880F5A b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn setParticleFxFootOverrideName(p_0: [*c]const u8) !void { try invoker.invoke(void, 0xBA3D194057C79A7B, .{p_0}); } // 0xBA3D194057C79A7B  b877
    pub inline fn setSkidmarkRangeScale(scale: f32) !void { try invoker.invoke(void, 0x5DBF05DB5926D089, .{scale}); } // 0x5DBF05DB5926D089  b1011
    pub inline fn setPtfxForceVehicleInteriorFlag(p_0: types.Any) !void { try invoker.invoke(void, 0xC6730E0D14E50703, .{p_0}); } // 0xC6730E0D14E50703  b2545
    pub inline fn registerPostfxBulletImpact(weaponworldpos__: types.Vector3, intensity: f32) !void { try invoker.invoke(void, 0x170911F37F646F29, .{weaponworldpos__.x, weaponworldpos__.y, weaponworldpos__.z, intensity}); } // 0x170911F37F646F29  b2802
    pub inline fn forcePostfxBulletImpactsAfterHud(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x9B079E5221D984D3, .{p_0}); } // 0x9B079E5221D984D3  b323
    /// From the b678d decompiled scripts:
    /// 
    ///  GRAPHICS::USE_PARTICLE_FX_ASSET("FM_Mission_Controler"); \
    ///  GRAPHICS::USE_PARTICLE_FX_ASSET("scr_apartment_mp"); \
    ///  GRAPHICS::USE_PARTICLE_FX_ASSET("scr_indep_fireworks"); \
    ///  GRAPHICS::USE_PARTICLE_FX_ASSET("scr_mp_cig_plane"); \
    ///  GRAPHICS::USE_PARTICLE_FX_ASSET("scr_mp_creator"); \
    ///  GRAPHICS::USE_PARTICLE_FX_ASSET("scr_ornate_heist"); \
    ///  GRAPHICS::USE_PARTICLE_FX_ASSET("scr_prison_break_heist_station");
    /// 
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn useParticleFxAsset(name: [*c]const u8) !void { try invoker.invoke(void, 0x6C38AF3693A69A91, .{name}); } // 0x6C38AF3693A69A91 0x9C720B61 b323
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn setParticleFxOverride(old_asset: [*c]const u8, new_asset: [*c]const u8) !void { try invoker.invoke(void, 0xEA1E2D93F6F75ED9, .{old_asset, new_asset}); } // 0xEA1E2D93F6F75ED9 0xC92719A7 b323
    /// Resets the effect of SET_PARTICLE_FX_OVERRIDE
    /// 
    /// Full list of particle effect dictionaries and effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/particleEffectsCompact.json
    pub inline fn resetParticleFxOverride(name: [*c]const u8) !void { try invoker.invoke(void, 0x89C8553DD3274AAE, .{name}); } // 0x89C8553DD3274AAE 0x9E8D8B72 b323
    /// Returns ptfxHandle \
    /// effectName: scr_sv_drag_burnout
    pub inline fn startVehicleParticleFxLooped_(vehicle: types.Vehicle, effect_name: [*c]const u8, front_back: windows.BOOL, left_right: windows.BOOL, local_only: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xDF269BE2909E181A, .{vehicle, effect_name, front_back, left_right, local_only}); } // 0xDF269BE2909E181A  b3095
    pub inline fn setWeatherPtfxUseOverrideSettings(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xA46B73FAA3460AE1, .{p_0}); } // 0xA46B73FAA3460AE1  b323
    pub inline fn setWeatherPtfxOverrideCurrLevel(p_0: f32) !void { try invoker.invoke(void, 0xF78B803082D4386F, .{p_0}); } // 0xF78B803082D4386F  b323
    pub inline fn washDecalsInRange(vec: types.Vector3, range: f32, p_4: f32) !void { try invoker.invoke(void, 0x9C30613D50A6ADEF, .{vec.x, vec.y, vec.z, range, p_4}); } // 0x9C30613D50A6ADEF 0xDEECBC57 b323
    pub inline fn washDecalsFromVehicle(vehicle: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0x5B712761429DBC14, .{vehicle, p_1}); } // 0x5B712761429DBC14 0x2929F11A b323
    /// Fades nearby decals within the range specified
    pub inline fn fadeDecalsInRange(vec: types.Vector3, p_3: f32, p_4: f32) !void { try invoker.invoke(void, 0xD77EDADB0420E6E0, .{vec.x, vec.y, vec.z, p_3, p_4}); } // 0xD77EDADB0420E6E0 0xF81E884A b323
    /// Removes all decals in range from a position, it includes the bullet holes, blood pools, petrol...
    pub inline fn removeDecalsInRange(vec: types.Vector3, range: f32) !void { try invoker.invoke(void, 0x5D6B2D4830A67C62, .{vec.x, vec.y, vec.z, range}); } // 0x5D6B2D4830A67C62 0x06A619A0 b323
    pub inline fn removeDecalsFromObject(obj: types.Object) !void { try invoker.invoke(void, 0xCCF71CBDDF5B6CB9, .{obj}); } // 0xCCF71CBDDF5B6CB9 0x8B67DCA7 b323
    pub inline fn removeDecalsFromObjectFacing(obj: types.Object, vec: types.Vector3) !void { try invoker.invoke(void, 0xA6F6F70FDC6D144C, .{obj, vec.x, vec.y, vec.z}); } // 0xA6F6F70FDC6D144C 0xF4999A55 b323
    pub inline fn removeDecalsFromVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xE91F1B65F2B48D57, .{vehicle}); } // 0xE91F1B65F2B48D57 0x831D06CA b323
    /// decal types:
    /// 
    /// public enum DecalTypes \
    /// { \
    ///     splatters_blood = 1010,
    ///     splatters_blood_dir = 1015,
    ///     splatters_blood_mist = 1017,
    ///     splatters_mud = 1020,
    ///     splatters_paint = 1030,
    ///     splatters_water = 1040,
    ///     splatters_water_hydrant = 1050,
    ///     splatters_blood2 = 1110,
    ///     weapImpact_metal = 4010,
    ///     weapImpact_concrete = 4020,
    ///     weapImpact_mattress = 4030,
    ///     weapImpact_mud = 4032,
    ///     weapImpact_wood = 4050,
    ///     weapImpact_sand = 4053,
    ///     weapImpact_cardboard = 4040,
    ///     weapImpact_melee_glass = 4100,
    ///     weapImpact_glass_blood = 4102,
    ///     weapImpact_glass_blood2 = 4104,
    ///     weapImpact_shotgun_paper = 4200,
    ///     weapImpact_shotgun_mattress,
    ///     weapImpact_shotgun_metal,
    ///     weapImpact_shotgun_wood,
    ///     weapImpact_shotgun_dirt,
    ///     weapImpact_shotgun_tvscreen,
    ///     weapImpact_shotgun_tvscreen2,
    ///     weapImpact_shotgun_tvscreen3,
    ///     weapImpact_melee_concrete = 4310,
    ///     weapImpact_melee_wood = 4312,
    ///     weapImpact_melee_metal = 4314,
    ///     burn1 = 4421,
    ///     burn2,
    ///     burn3,
    ///     burn4,
    ///     burn5,
    ///     bang_concrete_bang = 5000,
    ///     bang_concrete_bang2,
    ///     bang_bullet_bang,
    ///     bang_bullet_bang2 = 5004,
    ///     bang_glass = 5031,
    ///     bang_glass2,
    ///     solidPool_water = 9000,
    ///     solidPool_blood,
    ///     solidPool_oil,
    ///     solidPool_petrol,
    ///     solidPool_mud,
    ///     porousPool_water,
    ///     porousPool_blood,
    ///     porousPool_oil,
    ///     porousPool_petrol,
    ///     porousPool_mud,
    ///     porousPool_water_ped_drip,
    ///     liquidTrail_water = 9050
    /// }
    pub inline fn addDecal(decal_type: c_int, pos__: types.Vector3, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: f32, p_9: f32, width: f32, height: f32, r_coef: f32, g_coef: f32, b_coef: f32, opacity: f32, timeout: f32, p_1_7: windows.BOOL, p_1_8: windows.BOOL, p_1_9: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xB302244A1839BDAD, .{decal_type, pos__.x, pos__.y, pos__.z, p_4, p_5, p_6, p_7, p_8, p_9, width, height, r_coef, g_coef, b_coef, opacity, timeout, p_1_7, p_1_8, p_1_9}); } // 0xB302244A1839BDAD 0xEAD0C412 b323
    pub inline fn addPetrolDecal(vec: types.Vector3, ground_lvl: f32, width: f32, transparency: f32) !c_int { return try invoker.invoke(c_int, 0x4F5212C7AD880DF8, .{vec.x, vec.y, vec.z, ground_lvl, width, transparency}); } // 0x4F5212C7AD880DF8 0x1259DF42 b323
    pub inline fn addOilDecal(vec: types.Vector3, ground_lvl: f32, width: f32, transparency: f32) !c_int { return try invoker.invoke(c_int, 0x126D7F89FE859A5E, .{vec.x, vec.y, vec.z, ground_lvl, width, transparency}); } // 0x126D7F89FE859A5E  b2699
    pub inline fn startPetrolTrailDecals(p_0: f32) !void { try invoker.invoke(void, 0x99AC7F0D8B9C893D, .{p_0}); } // 0x99AC7F0D8B9C893D 0xE3938B0B b323
    pub inline fn addPetrolTrailDecalInfo(vec: types.Vector3, p_3: f32) !void { try invoker.invoke(void, 0x967278682CB6967A, .{vec.x, vec.y, vec.z, p_3}); } // 0x967278682CB6967A 0xBAEC6ADD b323
    pub inline fn endPetrolTrailDecals() !void { try invoker.invoke(void, 0x0A123435A26C36CD, .{}); } // 0x0A123435A26C36CD 0xCCCA6855 b323
    pub inline fn removeDecal(decal: c_int) !void { try invoker.invoke(void, 0xED3F346429CCD659, .{decal}); } // 0xED3F346429CCD659 0xA4363188 b323
    pub inline fn isDecalAlive(decal: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC694D74949CAFD0C, .{decal}); } // 0xC694D74949CAFD0C 0xCDD4A61A b323
    pub inline fn getDecalWashLevel(decal: c_int) !f32 { return try invoker.invoke(f32, 0x323F647679A09103, .{decal}); } // 0x323F647679A09103 0x054448EF b323
    pub inline fn setDisablePetrolDecalsIgnitingThisFrame() !void { try invoker.invoke(void, 0xD9454B5752C857DC, .{}); } // 0xD9454B5752C857DC 0xEAB6417C b323
    pub inline fn setDisablePetrolDecalsRecyclingThisFrame() !void { try invoker.invoke(void, 0x27CFB1B1E078CB2D, .{}); } // 0x27CFB1B1E078CB2D 0xC2703B88 b323
    pub inline fn setDisableDecalRenderingThisFrame() !void { try invoker.invoke(void, 0x4B5CFC83122DF602, .{}); } // 0x4B5CFC83122DF602 0xA706E84D b323
    pub inline fn getIsPetrolDecalInRange(coord__: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2F09F7976C512404, .{coord__.x, coord__.y, coord__.z, radius}); } // 0x2F09F7976C512404 0x242C6A04 b323
    pub inline fn patchDecalDiffuseMap(decal_type: c_int, texture_dict: [*c]const u8, texture_name: [*c]const u8) !void { try invoker.invoke(void, 0x8A35C742130C6080, .{decal_type, texture_dict, texture_name}); } // 0x8A35C742130C6080 0x335695CF b323
    pub inline fn unpatchDecalDiffuseMap(decal_type: c_int) !void { try invoker.invoke(void, 0xB7ED70C49521A61D, .{decal_type}); } // 0xB7ED70C49521A61D 0x7B786555 b323
    pub inline fn moveVehicleDecals(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x84C8D7C2D30D3280, .{p_0, p_1}); } // 0x84C8D7C2D30D3280 0xCE9E6CF2 b323
    /// boneIndex is always chassis_dummy in the scripts. The x/y/z params are location relative to the chassis bone.
    pub inline fn addVehicleCrewEmblem(vehicle: types.Vehicle, ped: types.Ped, bone_index: c_int, x_1: f32, x_2: f32, x_3: f32, y_1: f32, y_2: f32, y_3: f32, z_1: f32, z_2: f32, z_3: f32, scale: f32, p_1_3: types.Any, alpha: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x428BDCB9DA58DA53, .{vehicle, ped, bone_index, x_1, x_2, x_3, y_1, y_2, y_3, z_1, z_2, z_3, scale, p_1_3, alpha}); } // 0x428BDCB9DA58DA53 0x12077738 b323
    pub inline fn abortVehicleCrewEmblemRequest(p_0: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x82ACC484FFA3B05F, .{p_0}); } // 0x82ACC484FFA3B05F  b372
    pub inline fn removeVehicleCrewEmblem(vehicle: types.Vehicle, p_1: c_int) !void { try invoker.invoke(void, 0xD2300034310557E4, .{vehicle, p_1}); } // 0xD2300034310557E4 0x667046A8 b323
    pub inline fn getVehicleCrewEmblemRequestState(vehicle: types.Vehicle, p_1: c_int) !c_int { return try invoker.invoke(c_int, 0xFE26117A5841B2FF, .{vehicle, p_1}); } // 0xFE26117A5841B2FF 0x4F4D76E8 b323
    pub inline fn doesVehicleHaveCrewEmblem(vehicle: types.Vehicle, p_1: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x060D935D3981A275, .{vehicle, p_1}); } // 0x060D935D3981A275 0x6D58F73B b323
    pub inline fn disableCompositeShotgunDecals(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0E4299C549F0D1F1, .{toggle}); } // 0x0E4299C549F0D1F1 0x9BABCBA4 b323
    pub inline fn disableScuffDecals(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x02369D5C8A51FDCF, .{toggle}); } // 0x02369D5C8A51FDCF 0xFDF6D8DA b323
    pub inline fn setDecalBulletImpactRangeScale(p_0: f32) !void { try invoker.invoke(void, 0x46D1A61A21F566FC, .{p_0}); } // 0x46D1A61A21F566FC 0x2056A015 b323
    pub inline fn overrideInteriorSmokeName(name: [*c]const u8) !void { try invoker.invoke(void, 0x2A2A52824DB96700, .{name}); } // 0x2A2A52824DB96700 0x0F486429 b323
    pub inline fn overrideInteriorSmokeLevel(level: f32) !void { try invoker.invoke(void, 0x1600FD8CF72EBC12, .{level}); } // 0x1600FD8CF72EBC12 0xD87CC710 b323
    pub inline fn overrideInteriorSmokeEnd() !void { try invoker.invoke(void, 0xEFB55E7C25D3B3BE, .{}); } // 0xEFB55E7C25D3B3BE 0xE29EE145 b323
    /// Used with 'NG_filmnoir_BW{01,02}' timecycles and the "NOIR_FILTER_SOUNDS" audioref.
    pub inline fn registerNoirLensEffect() !void { try invoker.invoke(void, 0xA44FF770DFBC5DAE, .{}); } // 0xA44FF770DFBC5DAE  b323
    pub inline fn disableVehicleDistantlights(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC9F98AC1884E73A2, .{toggle}); } // 0xC9F98AC1884E73A2 0x7CFAE36F b323
    pub inline fn renderShadowedLightsWithNoShadows(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x03300B57FCAC6DDB, .{p_0}); } // 0x03300B57FCAC6DDB 0x60F72371 b323
    pub inline fn requestEarlyLightCheck() !void { try invoker.invoke(void, 0x98EDF76A7271E4F2, .{}); } // 0x98EDF76A7271E4F2  b323
    /// Forces footstep tracks on all surfaces.
    pub inline fn useSnowFootVfxWhenUnsheltered(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAEEDAD1420C65CC0, .{toggle}); } // 0xAEEDAD1420C65CC0 0xC53576CA b323
    pub inline fn forceAllowSnowFootVfxOnIce_(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA342A3763B3AFB6C, .{toggle}); } // 0xA342A3763B3AFB6C  b3095
    /// Forces vehicle trails on all surfaces.
    pub inline fn useSnowWheelVfxWhenUnsheltered(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4CC7F0FEA5283FE0, .{toggle}); } // 0x4CC7F0FEA5283FE0 0x7158B1EA b323
    pub inline fn disableRegionVfx(p_0: types.Any) !void { try invoker.invoke(void, 0xEFD97FF47B745B8D, .{p_0}); } // 0xEFD97FF47B745B8D  b791
    pub inline fn forceGroundSnowPass_(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6E9EF3A33C8899F8, .{toggle}); } // 0x6E9EF3A33C8899F8  b3095
    /// Only one match in the scripts:
    /// 
    /// GRAPHICS::PRESET_INTERIOR_AMBIENT_CACHE("int_carrier_hanger");
    pub inline fn presetInteriorAmbientCache(timecycle_modifier_name: [*c]const u8) !void { try invoker.invoke(void, 0xD7021272EB0A451E, .{timecycle_modifier_name}); } // 0xD7021272EB0A451E 0x137E3E24 b323
    /// Loads the specified timecycle modifier. Modifiers are defined separately in another file (e.g. "timecycle_mods_1.xml")
    /// 
    /// Parameters: \
    /// modifierName - The modifier to load (e.g. "V_FIB_IT3", "scanline_cam", etc.)
    /// 
    /// Full list of timecycle modifiers by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/timecycleModifiers.json
    pub inline fn setTimecycleModifier(modifier_name: [*c]const u8) !void { try invoker.invoke(void, 0x2C933ABF17A1DF41, .{modifier_name}); } // 0x2C933ABF17A1DF41 0xA81F3638 b323
    pub inline fn setTimecycleModifierStrength(strength: f32) !void { try invoker.invoke(void, 0x82E7FFCD5B2326B3, .{strength}); } // 0x82E7FFCD5B2326B3 0x458F4F45 b323
    /// Full list of timecycle modifiers by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/timecycleModifiers.json
    pub inline fn setTransitionTimecycleModifier(modifier_name: [*c]const u8, transition: f32) !void { try invoker.invoke(void, 0x3BCF567485E1971C, .{modifier_name, transition}); } // 0x3BCF567485E1971C 0xBB2BA72A b323
    pub inline fn setTransitionOutOfTimecycleModifier(strength: f32) !void { try invoker.invoke(void, 0x1CBA05AE7BD7EE05, .{strength}); } // 0x1CBA05AE7BD7EE05 0x56345F6B b323
    pub inline fn clearTimecycleModifier() !void { try invoker.invoke(void, 0x0F07E7745A236711, .{}); } // 0x0F07E7745A236711 0x8D8DF8EE b323
    /// Only use for this in the PC scripts is:
    /// 
    /// if (GRAPHICS::GET_TIMECYCLE_MODIFIER_INDEX() != -1)
    pub inline fn getTimecycleModifierIndex() !c_int { return try invoker.invoke(c_int, 0xFDF3D97C674AFB66, .{}); } // 0xFDF3D97C674AFB66 0x594FEEC4 b323
    pub inline fn getTimecycleTransitionModifierIndex() !c_int { return try invoker.invoke(c_int, 0x459FD2C8D0AB78BC, .{}); } // 0x459FD2C8D0AB78BC 0x03C44E4B b323
    pub inline fn getIsTimecycleTransitioningOut() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x98D18905BF723B99, .{}); } // 0x98D18905BF723B99  b1493
    pub inline fn pushTimecycleModifier() !void { try invoker.invoke(void, 0x58F735290861E6B4, .{}); } // 0x58F735290861E6B4 0x7E082045 b323
    pub inline fn popTimecycleModifier() !void { try invoker.invoke(void, 0x3C8938D7D872211E, .{}); } // 0x3C8938D7D872211E 0x79D7D235 b323
    pub inline fn setCurrentPlayerTcmodifier(modifier_name: [*c]const u8) !void { try invoker.invoke(void, 0xBBF327DED94E4DEB, .{modifier_name}); } // 0xBBF327DED94E4DEB 0x85BA15A4 b323
    pub inline fn setPlayerTcmodifierTransition(value: f32) !void { try invoker.invoke(void, 0xBDEB86F4D5809204, .{value}); } // 0xBDEB86F4D5809204 0x9559BB38 b323
    pub inline fn setNextPlayerTcmodifier(modifier_name: [*c]const u8) !void { try invoker.invoke(void, 0xBF59707B3E5ED531, .{modifier_name}); } // 0xBF59707B3E5ED531 0x554BA16E b323
    pub inline fn addTcmodifierOverride(modifier_name_1: [*c]const u8, modifier_name_2: [*c]const u8) !void { try invoker.invoke(void, 0x1A8E2C8B9CF4549C, .{modifier_name_1, modifier_name_2}); } // 0x1A8E2C8B9CF4549C 0xE8F538B5 b323
    pub inline fn clearAllTcmodifierOverrides(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x15E33297C3E8DC60, .{p_0}); } // 0x15E33297C3E8DC60  b323
    /// Full list of timecycle modifiers by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/timecycleModifiers.json
    pub inline fn setExtraTcmodifier(modifier_name: [*c]const u8) !void { try invoker.invoke(void, 0x5096FD9CCB49056D, .{modifier_name}); } // 0x5096FD9CCB49056D  b323
    /// Clears the secondary timecycle modifier usually set with _SET_EXTRA_TIMECYCLE_MODIFIER
    pub inline fn clearExtraTcmodifier() !void { try invoker.invoke(void, 0x92CCC17A7A2285DA, .{}); } // 0x92CCC17A7A2285DA  b323
    /// See GET_TIMECYCLE_MODIFIER_INDEX for use, works the same just for the secondary timecycle modifier. \
    /// Returns an integer representing the Timecycle modifier
    pub inline fn getExtraTcmodifier() !c_int { return try invoker.invoke(c_int, 0xBB0527EC6341496D, .{}); } // 0xBB0527EC6341496D  b323
    /// The same as SET_TIMECYCLE_MODIFIER_STRENGTH but for the secondary timecycle modifier.
    pub inline fn enableMoonCycleOverride(strength: f32) !void { try invoker.invoke(void, 0x2C328AF17210F009, .{strength}); } // 0x2C328AF17210F009  b323
    /// Resets the extra timecycle modifier strength normally set with 0x2C328AF17210F009
    pub inline fn disableMoonCycleOverride() !void { try invoker.invoke(void, 0x2BF72AD5B41AA739, .{}); } // 0x2BF72AD5B41AA739  b323
    pub inline fn requestScaleformMovie(scaleform_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x11FE353CF9733E6F, .{scaleform_name}); } // 0x11FE353CF9733E6F 0xC67E3DCB b323
    /// Another REQUEST_SCALEFORM_MOVIE equivalent.
    pub inline fn requestScaleformMovieWithIgnoreSuperWidescreen(scaleform_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x65E7E78842E74CDB, .{scaleform_name}); } // 0x65E7E78842E74CDB  b372
    pub inline fn requestScaleformMovieInstance(scaleform_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xC514489CFB8AF806, .{scaleform_name}); } // 0xC514489CFB8AF806 0x7CC8057D b323
    /// Similar to REQUEST_SCALEFORM_MOVIE, but seems to be some kind of "interactive" scaleform movie?
    /// 
    /// These seem to be the only scaleforms ever requested by this native: \
    /// "breaking_news" \
    /// "desktop_pc" \
    /// "ECG_MONITOR" \
    /// "Hacking_PC" \
    /// "TEETH_PULLING"
    /// 
    /// Note: Unless this hash is out-of-order, this native is next-gen only.
    /// 
    pub inline fn requestScaleformMovieSkipRenderWhilePaused(scaleform_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xBD06C611BB9048C2, .{scaleform_name}); } // 0xBD06C611BB9048C2  b323
    pub inline fn hasScaleformMovieLoaded(scaleform_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x85F01B8D5B90570E, .{scaleform_handle}); } // 0x85F01B8D5B90570E 0xDDFB6448 b323
    pub inline fn hasScaleformMovieNamedLoaded_(scaleform_handle: [*c]c_int, scaleform_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9743BCCF7CD6E1F6, .{scaleform_handle, scaleform_name}); } // 0x9743BCCF7CD6E1F6  b3407
    /// val is 1-20 (0 will return false)
    pub inline fn isActiveScaleformMovieDeleting(val: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2FCB133CA50A49EB, .{val}); } // 0x2FCB133CA50A49EB  b1290
    /// val is 1-20. Return is related to INSTRUCTIONAL_BUTTONS, COLOUR_SWITCHER_02, etc?
    pub inline fn isScaleformMovieDeleting(val: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x86255B1FC929E33E, .{val}); } // 0x86255B1FC929E33E  b1290
    /// Only values used in the scripts are:
    /// 
    /// "heist_mp" \
    /// "heistmap_mp" \
    /// "instructional_buttons" \
    /// "heist_pre"
    pub inline fn hasScaleformMovieFilenameLoaded(scaleform_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0C1C5D756FB5F337, .{scaleform_name}); } // 0x0C1C5D756FB5F337 0x494A9E50 b323
    pub inline fn hasScaleformContainerMovieLoadedIntoParent(scaleform_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8217150E1217EBFD, .{scaleform_handle}); } // 0x8217150E1217EBFD 0x1DFE8D8A b323
    pub inline fn setScaleformMovieAsNoLongerNeeded(scaleform_handle: [*c]c_int) !void { try invoker.invoke(void, 0x1D132D614DD86811, .{scaleform_handle}); } // 0x1D132D614DD86811 0x5FED3BA1 b323
    pub inline fn setScaleformMovieNamedAsNoLongerNeeded_(scaleform_handle: c_int, scaleform_name: [*c]const u8) !void { try invoker.invoke(void, 0x2FDFB1B04C76E9C3, .{scaleform_handle, scaleform_name}); } // 0x2FDFB1B04C76E9C3  b3407
    pub inline fn setScaleformMovieToUseSystemTime(scaleform: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6D8EB211944DCE08, .{scaleform, toggle}); } // 0x6D8EB211944DCE08 0x18C9DE8D b323
    pub inline fn setScaleformMovieToUseLargeRt(scaleform_handle: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x32F34FF7F617643B, .{scaleform_handle, toggle}); } // 0x32F34FF7F617643B  b573
    /// This native is used in some casino scripts to fit the scaleform in the rendertarget.
    pub inline fn setScaleformMovieToUseSuperLargeRt(scaleform_handle: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE6A9F00D4240B519, .{scaleform_handle, toggle}); } // 0xE6A9F00D4240B519  b877
    pub inline fn drawScaleformMovie(scaleform_handle: c_int, vec: types.Vector2, width: f32, height: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int, p_9: c_int) !void { try invoker.invoke(void, 0x54972ADAF0294A93, .{scaleform_handle, vec.x, vec.y, width, height, red, green, blue, alpha, p_9}); } // 0x54972ADAF0294A93 0x48DA6A58 b323
    /// unk is not used so no need
    pub inline fn drawScaleformMovieFullscreen(scaleform: c_int, red: c_int, green: c_int, blue: c_int, alpha: c_int, p_5: c_int) !void { try invoker.invoke(void, 0x0DF606929C105BE1, .{scaleform, red, green, blue, alpha, p_5}); } // 0x0DF606929C105BE1 0x7B48E696 b323
    pub inline fn drawScaleformMovieFullscreenMasked(scaleform_1: c_int, scaleform_2: c_int, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xCF537FDE4FBD4CE5, .{scaleform_1, scaleform_2, red, green, blue, alpha}); } // 0xCF537FDE4FBD4CE5 0x9C59FC06 b323
    pub inline fn drawScaleformMovie3d(scaleform: c_int, pos__: types.Vector3, rot__: types.Vector3, p_7: f32, p_8: f32, p_9: f32, scale__: types.Vector3, rotation_order: c_int) !void { try invoker.invoke(void, 0x87D51D72255D4E78, .{scaleform, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, p_7, p_8, p_9, scale__.x, scale__.y, scale__.z, rotation_order}); } // 0x87D51D72255D4E78 0xC4F63A89 b323
    pub inline fn drawScaleformMovie3dSolid(scaleform: c_int, pos__: types.Vector3, rot__: types.Vector3, p_7: f32, p_8: f32, p_9: f32, scale__: types.Vector3, rotation_order: c_int) !void { try invoker.invoke(void, 0x1CE592FDC749D6F5, .{scaleform, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, p_7, p_8, p_9, scale__.x, scale__.y, scale__.z, rotation_order}); } // 0x1CE592FDC749D6F5 0x899933C8 b323
    /// Calls the Scaleform function.
    pub inline fn callScaleformMovieMethod(scaleform: c_int, method: [*c]const u8) !void { try invoker.invoke(void, 0xFBD96D87AC96D533, .{scaleform, method}); } // 0xFBD96D87AC96D533 0x7AB77B57 b323
    /// Calls the Scaleform function and passes the parameters as floats.
    /// 
    /// The number of parameters passed to the function varies, so the end of the parameter list is represented by -1.0.
    pub inline fn callScaleformMovieMethodWithNumber(scaleform: c_int, method_name: [*c]const u8, param_1: f32, param_2: f32, param_3: f32, param_4: f32, param_5: f32) !void { try invoker.invoke(void, 0xD0837058AE2E4BEE, .{scaleform, method_name, param_1, param_2, param_3, param_4, param_5}); } // 0xD0837058AE2E4BEE 0x557EDA1D b323
    /// Calls the Scaleform function and passes the parameters as strings.
    /// 
    /// The number of parameters passed to the function varies, so the end of the parameter list is represented by 0 (NULL).
    pub inline fn callScaleformMovieMethodWithString(scaleform: c_int, method_name: [*c]const u8, param_1: [*c]const u8, param_2: [*c]const u8, param_3: [*c]const u8, param_4: [*c]const u8, param_5: [*c]const u8) !void { try invoker.invoke(void, 0x51BC1ED3CC44E8F7, .{scaleform, method_name, param_1, param_2, param_3, param_4, param_5}); } // 0x51BC1ED3CC44E8F7 0x91A7FCEB b323
    /// Calls the Scaleform function and passes both float and string parameters (in their respective order).
    /// 
    /// The number of parameters passed to the function varies, so the end of the float parameters is represented by -1.0, and the end of the string parameters is represented by 0 (NULL).
    /// 
    /// NOTE: The order of parameters in the function prototype is important! All float parameters must come first, followed by the string parameters.
    /// 
    /// Examples: \
    /// // function MY_FUNCTION(floatParam1, floatParam2, stringParam) \
    /// GRAPHICS::CALL_SCALEFORM_MOVIE_METHOD_WITH_NUMBER_AND_STRING(scaleform, "MY_FUNCTION", 10.0, 20.0, -1.0, -1.0, -1.0, "String param", 0, 0, 0, 0);
    /// 
    /// // function MY_FUNCTION_2(floatParam, stringParam1, stringParam2) \
    /// GRAPHICS::CALL_SCALEFORM_MOVIE_METHOD_WITH_NUMBER_AND_STRING(scaleform, "MY_FUNCTION_2", 10.0, -1.0, -1.0, -1.0, -1.0, "String param #1", "String param #2", 0, 0, 0);
    pub inline fn callScaleformMovieMethodWithNumberAndString(scaleform: c_int, method_name: [*c]const u8, float_param_1: f32, float_param_2: f32, float_param_3: f32, float_param_4: f32, float_param_5: f32, string_param_1: [*c]const u8, string_param_2: [*c]const u8, string_param_3: [*c]const u8, string_param_4: [*c]const u8, string_param_5: [*c]const u8) !void { try invoker.invoke(void, 0xEF662D8D57E290B1, .{scaleform, method_name, float_param_1, float_param_2, float_param_3, float_param_4, float_param_5, string_param_1, string_param_2, string_param_3, string_param_4, string_param_5}); } // 0xEF662D8D57E290B1 0x6EAF56DE b323
    /// Pushes a function from the Hud component Scaleform onto the stack. Same behavior as GRAPHICS::BEGIN_SCALEFORM_MOVIE_METHOD, just a hud component id instead of a Scaleform.
    /// 
    /// Known components: \
    /// 19 - MP_RANK_BAR \
    /// 20 - HUD_DIRECTOR_MODE
    /// 
    /// This native requires more research - all information can be found inside of 'hud.gfx'. Using a decompiler, the different components are located under "scripts\__Packages\com\rockstargames\gtav\hud\hudComponents" and "scripts\__Packages\com\rockstargames\gtav\Multiplayer".
    pub inline fn beginScaleformScriptHudMovieMethod(hud_component: c_int, method_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x98C494FD5BDFBFD5, .{hud_component, method_name}); } // 0x98C494FD5BDFBFD5 0x5D66CE1E b323
    /// Push a function from the Scaleform onto the stack
    /// 
    pub inline fn beginScaleformMovieMethod(scaleform: c_int, method_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF6E48914C7A8694E, .{scaleform, method_name}); } // 0xF6E48914C7A8694E 0x215ABBE8 b323
    /// Starts frontend (pause menu) scaleform movie methods. \
    /// This can be used when you want to make custom frontend menus, and customize things like images or text in the menus etc. \
    /// Use `BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND_HEADER` for header scaleform functions.
    pub inline fn beginScaleformMovieMethodOnFrontend(method_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAB58C27C2E6123C6, .{method_name}); } // 0xAB58C27C2E6123C6 0xF6015178 b323
    /// Starts frontend (pause menu) scaleform movie methods for header options. \
    /// Use `BEGIN_SCALEFORM_MOVIE_METHOD_ON_FRONTEND` to customize the content inside the frontend menus.
    pub inline fn beginScaleformMovieMethodOnFrontendHeader(method_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB9449845F73F5E9C, .{method_name}); } // 0xB9449845F73F5E9C 0x5E219B67 b323
    /// Pops and calls the Scaleform function on the stack
    pub inline fn endScaleformMovieMethod() !void { try invoker.invoke(void, 0xC6796A8FFA375E53, .{}); } // 0xC6796A8FFA375E53 0x02DBF2D7 b323
    pub inline fn endScaleformMovieMethodReturnValue() !c_int { return try invoker.invoke(c_int, 0xC50AA39A577AF886, .{}); } // 0xC50AA39A577AF886 0x2F38B526 b323
    /// methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE \
    /// Returns true if the return value of a scaleform function is ready to be collected (using GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_STRING or GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_INT).
    pub inline fn isScaleformMovieMethodReturnValueReady(method_return: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x768FF8961BA904D6, .{method_return}); } // 0x768FF8961BA904D6 0x5CD7C3C0 b323
    /// methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE \
    /// Used to get a return value from a scaleform function. Returns an int in the same way GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_STRING returns a string.
    pub inline fn getScaleformMovieMethodReturnValueInt(method_return: c_int) !c_int { return try invoker.invoke(c_int, 0x2DE7EFA66B906036, .{method_return}); } // 0x2DE7EFA66B906036 0x2CFB0E6D b323
    /// methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE
    pub inline fn getScaleformMovieMethodReturnValueBool(method_return: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD80A80346A45D761, .{method_return}); } // 0xD80A80346A45D761  b757
    /// methodReturn: The return value of this native: END_SCALEFORM_MOVIE_METHOD_RETURN_VALUE \
    /// Used to get a return value from a scaleform function. Returns a string in the same way GET_SCALEFORM_MOVIE_METHOD_RETURN_VALUE_INT returns an int.
    pub inline fn getScaleformMovieMethodReturnValueString(method_return: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xE1E258829A885245, .{method_return}); } // 0xE1E258829A885245 0x516862EB b323
    /// Pushes an integer for the Scaleform function onto the stack.
    pub inline fn scaleformMovieMethodAddParamInt(value: c_int) !void { try invoker.invoke(void, 0xC3D0841A0CC546A6, .{value}); } // 0xC3D0841A0CC546A6 0x716777CB b323
    /// Pushes a float for the Scaleform function onto the stack.
    pub inline fn scaleformMovieMethodAddParamFloat(value: f32) !void { try invoker.invoke(void, 0xD69736AAE04DB51A, .{value}); } // 0xD69736AAE04DB51A 0x9A01FFDA b323
    /// Pushes a boolean for the Scaleform function onto the stack.
    pub inline fn scaleformMovieMethodAddParamBool(value: windows.BOOL) !void { try invoker.invoke(void, 0xC58424BA936EB458, .{value}); } // 0xC58424BA936EB458 0x0D4AE8CB b323
    /// Called prior to adding a text component to the UI. After doing so, GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING is called.
    /// 
    /// Examples: \
    /// GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING("NUMBER"); \
    /// HUD::ADD_TEXT_COMPONENT_INTEGER(MISC::ABSI(a_1)); \
    /// GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING();
    /// 
    /// GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING("STRING"); \
    /// HUD::ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(a_2); \
    /// GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING();
    /// 
    /// GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING("STRTNM2"); \
    /// HUD::ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL_HASH_KEY(v_3); \
    /// HUD::ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL_HASH_KEY(v_4); \
    /// GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING();
    /// 
    /// GRAPHICS::BEGIN_TEXT_COMMAND_SCALEFORM_STRING("STRTNM1"); \
    /// HUD::ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL_HASH_KEY(v_3); \
    /// GRAPHICS::END_TEXT_COMMAND_SCALEFORM_STRING();
    pub inline fn beginTextCommandScaleformString(component_type: [*c]const u8) !void { try invoker.invoke(void, 0x80338406F3475E55, .{component_type}); } // 0x80338406F3475E55 0x3AC9CB55 b323
    pub inline fn endTextCommandScaleformString() !void { try invoker.invoke(void, 0x362E2D3FE93A9959, .{}); } // 0x362E2D3FE93A9959 0x386CE0B8 b323
    /// Same as END_TEXT_COMMAND_SCALEFORM_STRING but does not perform HTML conversion for text tokens.
    pub inline fn endTextCommandUnparsedScaleformString() !void { try invoker.invoke(void, 0xAE4E8157D9ECF087, .{}); } // 0xAE4E8157D9ECF087 0x2E80DB52 b323
    /// Same as SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING \
    /// Both SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING / _SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING_2 works, but _SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING_2 is usually used for "name" (organisation, players..).
    pub inline fn scaleformMovieMethodAddParamLiteralString(string: [*c]const u8) !void { try invoker.invoke(void, 0x77FE3402004CD1B0, .{string}); } // 0x77FE3402004CD1B0  b573
    pub inline fn scaleformMovieMethodAddParamTextureNameString(string: [*c]const u8) !void { try invoker.invoke(void, 0xBA7148484BD90365, .{string}); } // 0xBA7148484BD90365 0x4DAAD55B b323
    pub inline fn scaleformMovieMethodAddParamPlayerNameString(string: [*c]const u8) !void { try invoker.invoke(void, 0xE83A3E3557A56640, .{string}); } // 0xE83A3E3557A56640 0xCCBF0334 b323
    pub inline fn doesLatestBriefStringExist(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5E657EF1099EDD65, .{p_0}); } // 0x5E657EF1099EDD65 0x91A081A1 b323
    pub inline fn scaleformMovieMethodAddParamLatestBriefString(value: c_int) !void { try invoker.invoke(void, 0xEC52C631A1831C03, .{value}); } // 0xEC52C631A1831C03 0x83A9811D b323
    pub inline fn requestScaleformScriptHudMovie(hud_component: c_int) !void { try invoker.invoke(void, 0x9304881D6F6537EA, .{hud_component}); } // 0x9304881D6F6537EA 0x7AF85862 b323
    pub inline fn hasScaleformScriptHudMovieLoaded(hud_component: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDF6E5987D2B4D140, .{hud_component}); } // 0xDF6E5987D2B4D140 0x79B43255 b323
    pub inline fn removeScaleformScriptHudMovie(hud_component: c_int) !void { try invoker.invoke(void, 0xF44A5456AC3F4F97, .{hud_component}); } // 0xF44A5456AC3F4F97 0x03D87600 b323
    pub inline fn passKeyboardInputToScaleform(scaleform_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD1C7CB175E012964, .{scaleform_handle}); } // 0xD1C7CB175E012964 0xE9183D3A b323
    pub inline fn setTvChannel(channel: c_int) !void { try invoker.invoke(void, 0xBAABBB23EB6E484E, .{channel}); } // 0xBAABBB23EB6E484E 0x41A8A627 b323
    pub inline fn getTvChannel() !c_int { return try invoker.invoke(c_int, 0xFC1E275A90D39995, .{}); } // 0xFC1E275A90D39995 0x6B96145A b323
    pub inline fn setTvVolume(volume: f32) !void { try invoker.invoke(void, 0x2982BF73F66E9DDC, .{volume}); } // 0x2982BF73F66E9DDC 0xF3504F4D b323
    pub inline fn getTvVolume() !f32 { return try invoker.invoke(f32, 0x2170813D3DD8661B, .{}); } // 0x2170813D3DD8661B 0x39555CF0 b323
    /// All calls to this native are preceded by calls to GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER and GRAPHICS::SET_SCRIPT_GFX_DRAW_BEHIND_PAUSEMENU, respectively.
    /// 
    /// "act_cinema.ysc", line 1483: \
    /// HUD::SET_HUD_COMPONENT_POSITION(15, 0.0, -0.0375); \
    /// HUD::SET_TEXT_RENDER_ID(l_AE); \
    /// GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER(4); \
    /// GRAPHICS::SET_SCRIPT_GFX_DRAW_BEHIND_PAUSEMENU(1); \
    /// if (GRAPHICS::IS_TVSHOW_CURRENTLY_PLAYING(${movie_arthouse})) { \
    ///     GRAPHICS::DRAW_TV_CHANNEL(0.5, 0.5, 0.7375, 1.0, 0.0, 255, 255, 255, 255);
    /// } else {  \
    ///     GRAPHICS::DRAW_TV_CHANNEL(0.5, 0.5, 1.0, 1.0, 0.0, 255, 255, 255, 255);
    /// }
    /// 
    /// "am_mp_property_int.ysc", line 102545: \
    /// if (ENTITY::DOES_ENTITY_EXIST(a_2._f3)) { \
    ///     if (HUD::IS_NAMED_RENDERTARGET_LINKED(ENTITY::GET_ENTITY_MODEL(a_2._f3))) {
    ///         HUD::SET_TEXT_RENDER_ID(a_2._f1);
    ///         GRAPHICS::SET_SCRIPT_GFX_DRAW_ORDER(4);
    ///         GRAPHICS::SET_SCRIPT_GFX_DRAW_BEHIND_PAUSEMENU(1);
    ///         GRAPHICS::DRAW_TV_CHANNEL(0.5, 0.5, 1.0, 1.0, 0.0, 255, 255, 255, 255);
    ///         if (GRAPHICS::GET_TV_CHANNEL() == -1) {
    ///             sub_a8fa5(a_2, 1);
    ///         } else { 
    ///             sub_a8fa5(a_2, 1);
    ///             GRAPHICS::ATTACH_TV_AUDIO_TO_ENTITY(a_2._f3);
    ///         }
    ///         HUD::SET_TEXT_RENDER_ID(HUD::GET_DEFAULT_SCRIPT_RENDERTARGET_RENDER_ID());
    ///     }
    /// }
    /// 
    pub inline fn drawTvChannel(pos__: types.Vector2, scale__: types.Vector2, rotation: f32, red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xFDDC2B4ED3C69DF0, .{pos__.x, pos__.y, scale__.x, scale__.y, rotation, red, green, blue, alpha}); } // 0xFDDC2B4ED3C69DF0 0x8129EF89 b323
    /// Loads specified video sequence into the TV Channel \
    /// TV_Channel ranges from 0-2 \
    /// VideoSequence can be any of the following: \
    /// "PL_STD_CNT" CNT Standard Channel \
    /// "PL_STD_WZL" Weazel Standard Channel \
    /// "PL_LO_CNT" \
    /// "PL_LO_WZL" \
    /// "PL_SP_WORKOUT" \
    /// "PL_SP_INV" - Jay Norris Assassination Mission Fail \
    /// "PL_SP_INV_EXP" - Jay Norris Assassination Mission Success \
    /// "PL_LO_RS" - Righteous Slaughter Ad \
    /// "PL_LO_RS_CUTSCENE" - Righteous Slaughter Cut-scene \
    /// "PL_SP_PLSH1_INTRO" \
    /// "PL_LES1_FAME_OR_SHAME" \
    /// "PL_STD_WZL_FOS_EP2" \
    /// "PL_MP_WEAZEL" - Weazel Logo on loop \
    /// "PL_MP_CCTV" - Generic CCTV loop
    /// 
    /// Restart: \
    /// 0=video sequence continues as normal \
    /// 1=sequence restarts from beginning every time that channel is selected
    /// 
    /// 
    /// The above playlists work as intended, and are commonly used, but there are many more playlists, as seen in `tvplaylists.xml`. A pastebin below outlines all playlists, they will be surronded by the name tag I.E. (<Name>PL_STD_CNT</Name> = PL_STD_CNT). \
    /// https://pastebin.com/zUzGB6h7
    pub inline fn setTvChannelPlaylist(tv_channel: c_int, playlist_name: [*c]const u8, restart: windows.BOOL) !void { try invoker.invoke(void, 0xF7B38B8305F1FE8B, .{tv_channel, playlist_name, restart}); } // 0xF7B38B8305F1FE8B 0xB262DE67 b323
    pub inline fn setTvChannelPlaylistAtHour(tv_channel: c_int, playlist_name: [*c]const u8, hour: c_int) !void { try invoker.invoke(void, 0x2201C576FACAEBE8, .{tv_channel, playlist_name, hour}); } // 0x2201C576FACAEBE8 0x78C4DCBE b323
    /// Does not actually return anything.
    pub inline fn setTvChannelPlaylistDirty_(tv_channel: c_int, p_1: windows.BOOL) !types.Any { return try invoker.invoke(types.Any, 0xEE831F15A8D0D94A, .{tv_channel, p_1}); } // 0xEE831F15A8D0D94A  b3095
    pub inline fn clearTvChannelPlaylist(tv_channel: c_int) !void { try invoker.invoke(void, 0xBEB3D46BB7F043C0, .{tv_channel}); } // 0xBEB3D46BB7F043C0 0xCBE7068F b323
    pub inline fn isPlaylistOnChannel(tv_channel: c_int, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1F710BFF7DAE6261, .{tv_channel, p_1}); } // 0x1F710BFF7DAE6261  b1604
    pub inline fn isTvshowCurrentlyPlaying(video_cliphash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0AD973CA1E077B60, .{video_cliphash}); } // 0x0AD973CA1E077B60 0x4D1EB0FB b323
    pub inline fn enableMovieKeyframeWait(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x74C180030FDE4B69, .{toggle}); } // 0x74C180030FDE4B69 0x796DE696 b323
    pub inline fn setTvPlayerWatchingThisFrame(p_0: types.Any) !void { try invoker.invoke(void, 0xD1C55B110E4DF534, .{p_0}); } // 0xD1C55B110E4DF534 0xD99EC000 b323
    pub inline fn getCurrentTvClipNamehash() !types.Hash { return try invoker.invoke(types.Hash, 0x30432A0118736E00, .{}); } // 0x30432A0118736E00  b1493
    pub inline fn enableMovieSubtitles(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x873FA65C778AD970, .{toggle}); } // 0x873FA65C778AD970 0xC2DEBA3D b323
    pub inline fn ui3dsceneIsAvailable() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD3A10FC7FD8D98CD, .{}); } // 0xD3A10FC7FD8D98CD 0xE40A0F1A b323
    /// All presets can be found in common\data\ui\uiscenes.meta
    pub inline fn ui3dscenePushPreset(preset_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF1CEA8A4198D8E9A, .{preset_name}); } // 0xF1CEA8A4198D8E9A 0x2E7D9B98 b323
    /// It's called after UI3DSCENE_IS_AVAILABLE and UI3DSCENE_PUSH_PRESET
    /// 
    /// presetName was always "CELEBRATION_WINNER" \
    /// All presets can be found in common\data\ui\uiscenes.meta
    pub inline fn ui3dsceneAssignPedToSlot(preset_name: [*c]const u8, ped: types.Ped, slot: c_int, pos__: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x98C4FE6EC34154CA, .{preset_name, ped, slot, pos__.x, pos__.y, pos__.z}); } // 0x98C4FE6EC34154CA 0x9A0E3BFE b323
    pub inline fn ui3dsceneClearPatchedData() !void { try invoker.invoke(void, 0x7A42B2E236E71415, .{}); } // 0x7A42B2E236E71415 0x431AA036 b323
    pub inline fn ui3dsceneMakePushedPresetPersistent(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x108BE26959A9D9BB, .{toggle}); } // 0x108BE26959A9D9BB 0x24A7A7F6 b323
    /// This native enables/disables the gold putting grid display (https://i.imgur.com/TC6cku6.png). \
    /// This requires these two natives to be called as well to configure the grid: `TERRAINGRID_SET_PARAMS` and `TERRAINGRID_SET_COLOURS`.
    pub inline fn terraingridActivate(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA356990E161C9E65, .{toggle}); } // 0xA356990E161C9E65 0xA1CB6C94 b323
    /// This native is used along with these two natives: `TERRAINGRID_ACTIVATE` and `TERRAINGRID_SET_COLOURS`. \
    /// This native configures the location, size, rotation, normal height, and the difference ratio between min, normal and max.
    /// 
    /// All those natives combined they will output something like this: https://i.imgur.com/TC6cku6.png
    /// 
    /// This native renders a box at the given position, with a special shader that renders a grid on world geometry behind it. This box does not have backface culling. \
    /// The forward args here are a direction vector, something similar to what's returned by GET_ENTITY_FORWARD_VECTOR. \
    /// normalHeight and heightDiff are used for positioning the color gradient of the grid, colors specified via TERRAINGRID_SET_COLOURS.
    /// 
    /// Example with box superimposed on the image to demonstrate: https://i.imgur.com/wdqskxd.jpg
    pub inline fn terraingridSetParams(vec: types.Vector3, forward__: types.Vector3, size__: types.Vector3, grid_scale: f32, glow_intensity: f32, normal_height: f32, height_diff: f32) !void { try invoker.invoke(void, 0x1C4FC5752BCD8E48, .{vec.x, vec.y, vec.z, forward__.x, forward__.y, forward__.z, size__.x, size__.y, size__.z, grid_scale, glow_intensity, normal_height, height_diff}); } // 0x1C4FC5752BCD8E48 0x3B637AA7 b323
    /// This native is used along with these two natives: `TERRAINGRID_ACTIVATE` and `TERRAINGRID_SET_PARAMS`. \
    /// This native sets the colors for the golf putting grid. the 'min...' values are for the lower areas that the grid covers, the 'max...' values are for the higher areas that the grid covers, all remaining values are for the 'normal' ground height. \
    /// All those natives combined they will output something like this: https://i.imgur.com/TC6cku6.png
    pub inline fn terraingridSetColours(low_r: c_int, low_g: c_int, low_b: c_int, low_alpha: c_int, r: c_int, g: c_int, b: c_int, alpha: c_int, high_r: c_int, high_g: c_int, high_b: c_int, high_alpha: c_int) !void { try invoker.invoke(void, 0x5CE62918F8D703C7, .{low_r, low_g, low_b, low_alpha, r, g, b, alpha, high_r, high_g, high_b, high_alpha}); } // 0x5CE62918F8D703C7 0xDF552973 b323
    /// duration - is how long to play the effect for in milliseconds. If 0, it plays the default length \
    /// if loop is true, the effect won't stop until you call ANIMPOSTFX_STOP on it. (only loopable effects)
    /// 
    /// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
    pub inline fn animpostfxPlay(effect_name: [*c]const u8, duration: c_int, looped: windows.BOOL) !void { try invoker.invoke(void, 0x2206BF9A37B7F724, .{effect_name, duration, looped}); } // 0x2206BF9A37B7F724 0x1D980479 b323
    /// See ANIMPOSTFX_PLAY
    /// 
    /// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
    pub inline fn animpostfxStop(effect_name: [*c]const u8) !void { try invoker.invoke(void, 0x068E835A1D0DC0E3, .{effect_name}); } // 0x068E835A1D0DC0E3 0x06BB5CDA b323
    /// See ANIMPOSTFX_PLAY
    /// 
    /// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
    pub inline fn animpostfxGetCurrentTime(effect_name: [*c]const u8) !f32 { return try invoker.invoke(f32, 0xE35B38A27E8E7179, .{effect_name}); } // 0xE35B38A27E8E7179  b877
    /// Returns whether the specified effect is active. \
    /// See ANIMPOSTFX_PLAY
    /// 
    /// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
    pub inline fn animpostfxIsRunning(effect_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x36AD3E690DA5ACEB, .{effect_name}); } // 0x36AD3E690DA5ACEB 0x089D5921 b323
    /// Stops ALL currently playing effects.
    pub inline fn animpostfxStopAll() !void { try invoker.invoke(void, 0xB4EDDC19532BFB85, .{}); } // 0xB4EDDC19532BFB85 0x4E6D875B b323
    /// Stops the effect and sets a value (bool) in its data (+0x199) to false. \
    /// See ANIMPOSTFX_PLAY
    /// 
    /// Full list of animpostFX / screen effects by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animPostFxNamesCompact.json
    pub inline fn animpostfxStopAndFlushRequests(effect_name: [*c]const u8) !void { try invoker.invoke(void, 0xD2209BE128B5418C, .{effect_name}); } // 0xD2209BE128B5418C  b323
};

pub const Hud = struct
{
    /// Initializes the text entry for the the text next to a loading prompt. All natives for building UI texts can be used here
    /// 
    /// 
    /// e.g \
    /// void StartLoadingMessage(char *text, int spinnerType = 3) \
    ///   {
    ///      BEGIN_TEXT_COMMAND_BUSYSPINNER_ON("STRING");
    ///        ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
    ///        END_TEXT_COMMAND_BUSYSPINNER_ON(spinnerType);
    ///     }
    /// /*OR*/ \
    ///  void ShowLoadingMessage(char *text, int spinnerType = 3, int timeMs = 10000) \
    ///   {
    ///      BEGIN_TEXT_COMMAND_BUSYSPINNER_ON("STRING");
    ///        ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
    ///        END_TEXT_COMMAND_BUSYSPINNER_ON(spinnerType);
    ///         WAIT(timeMs);
    ///      BUSYSPINNER_OFF();
    ///  }
    /// 
    /// 
    /// These are some localized strings used in the loading spinner. \
    /// "PM_WAIT"                   = Please Wait \
    /// "CELEB_WPLYRS"              = Waiting For Players. \
    /// "CELL_SPINNER2"             = Scanning storage. \
    /// "ERROR_CHECKYACHTNAME" = Registering your yacht's name. Please wait. \
    /// "ERROR_CHECKPROFANITY"   = Checking your text for profanity. Please wait. \
    /// "FM_COR_AUTOD"                        = Just spinner no text \
    /// "FM_IHELP_WAT2"                        = Waiting for other players \
    /// "FM_JIP_WAITO"                            = Game options are being set \
    /// "FMMC_DOWNLOAD"                    = Downloading \
    /// "FMMC_PLYLOAD"                         = Loading \
    /// "FMMC_STARTTRAN"                    = Launching session \
    /// "HUD_QUITTING"                           =  Quiting session \
    /// "KILL_STRIP_IDM"                         = Waiting for to accept \
    /// "MP_SPINLOADING"                      = Loading
    pub inline fn beginTextCommandBusyspinnerOn(string: [*c]const u8) !void { try invoker.invoke(void, 0xABA17D7CE615ADBF, .{string}); } // 0xABA17D7CE615ADBF 0xCB7C8994 b323
    /// enum eBusySpinnerType \
    /// { \
    ///     BUSY_SPINNER_LEFT,
    ///     BUSY_SPINNER_LEFT_2,
    ///     BUSY_SPINNER_LEFT_3,
    ///     BUSY_SPINNER_SAVE,
    ///     BUSY_SPINNER_RIGHT,
    /// };
    pub inline fn endTextCommandBusyspinnerOn(busy_spinner_type: c_int) !void { try invoker.invoke(void, 0xBD12F8228410D9B4, .{busy_spinner_type}); } // 0xBD12F8228410D9B4 0x903F5EE4 b323
    /// Removes the loading prompt at the bottom right of the screen.
    pub inline fn busyspinnerOff() !void { try invoker.invoke(void, 0x10D373323E5B9C0D, .{}); } // 0x10D373323E5B9C0D 0x94119534 b323
    pub inline fn preloadBusyspinner() !void { try invoker.invoke(void, 0xC65AB383CD91DF98, .{}); } // 0xC65AB383CD91DF98 0x71077FBD b323
    pub inline fn busyspinnerIsOn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD422FCC5F239A915, .{}); } // 0xD422FCC5F239A915 0xB8B3A5D0 b323
    pub inline fn busyspinnerIsDisplaying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB2A592B04648A9CB, .{}); } // 0xB2A592B04648A9CB 0x3AF34DEF b323
    pub inline fn disablePausemenuSpinner(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x9245E81072704B8A, .{p_0}); } // 0x9245E81072704B8A  b323
    /// Shows the cursor on screen for one frame.
    pub inline fn setMouseCursorThisFrame() !void { try invoker.invoke(void, 0xAAE7CE1D63167423, .{}); } // 0xAAE7CE1D63167423  b323
    /// Changes the mouse cursor's sprite.  \
    /// 1 = Normal \
    /// 6 = Left Arrow \
    /// 7 = Right Arrow
    pub inline fn setMouseCursorStyle(sprite_id: c_int) !void { try invoker.invoke(void, 0x8DB8CFFD58B62552, .{sprite_id}); } // 0x8DB8CFFD58B62552  b323
    /// Shows/hides the frontend cursor on the pause menu or similar menus. \
    /// Clicking off and then on the game window will show it again.
    pub inline fn setMouseCursorVisible(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x98215325A695E78A, .{toggle}); } // 0x98215325A695E78A  b323
    /// Returns TRUE if mouse is hovering above instructional buttons. Works with all buttons gfx, such as popup_warning, pause_menu_instructional_buttons, instructional_buttons, etc. Note: You have to call TOGGLE_MOUSE_BUTTONS on the scaleform if you want this native to work.
    pub inline fn isMouseRolledOverInstructionalButtons() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3D9ACB1EB139E702, .{}); } // 0x3D9ACB1EB139E702  b323
    pub inline fn getMouseEvent(scaleform_handle: c_int, p_1: [*c]types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x632B2940C67F4EA9, .{scaleform_handle, p_1, p_2, p_3}); } // 0x632B2940C67F4EA9  b323
    pub inline fn thefeedOnlyShowTooltips(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6F1554B0CC2089FA, .{toggle}); } // 0x6F1554B0CC2089FA 0xA7C8594B b323
    pub inline fn thefeedSetScriptedMenuHeight(pos: f32) !void { try invoker.invoke(void, 0x55598D21339CB998, .{pos}); } // 0x55598D21339CB998 0x1DA7E41A b323
    /// Stops loading screen tips shown by invoking `THEFEED_SHOW`
    pub inline fn thefeedHide() !void { try invoker.invoke(void, 0x32888337579A5970, .{}); } // 0x32888337579A5970  b463
    /// Once called each frame hides all above radar notifications.
    pub inline fn thefeedHideThisFrame() !void { try invoker.invoke(void, 0x25F87B30C382FCA7, .{}); } // 0x25F87B30C382FCA7 0x1E63088A b323
    /// Displays loading screen tips, requires `THEFEED_AUTO_POST_GAMETIPS_ON` to be called beforehand.
    pub inline fn thefeedShow() !void { try invoker.invoke(void, 0x15CFA549788D35EF, .{}); } // 0x15CFA549788D35EF  b463
    pub inline fn thefeedFlushQueue() !void { try invoker.invoke(void, 0xA8FDB297A8D25FBA, .{}); } // 0xA8FDB297A8D25FBA 0x5205C6F5 b323
    /// Removes a notification instantly instead of waiting for it to disappear
    pub inline fn thefeedRemoveItem(notification_id: c_int) !void { try invoker.invoke(void, 0xBE4390CB40B3E627, .{notification_id}); } // 0xBE4390CB40B3E627 0xECA8ACB9 b323
    pub inline fn thefeedForceRenderOn() !void { try invoker.invoke(void, 0xA13C11E1B5C06BFC, .{}); } // 0xA13C11E1B5C06BFC 0x520FCB6D b323
    /// Enables loading screen tips to be be shown (`THEFEED_SHOW`), blocks other kinds of notifications from being displayed (at least from current script). Call `0xADED7F5748ACAFE6` to display those again.
    pub inline fn thefeedForceRenderOff() !void { try invoker.invoke(void, 0x583049884A2EEE3C, .{}); } // 0x583049884A2EEE3C 0xC8BAB2F2 b323
    pub inline fn thefeedPause() !void { try invoker.invoke(void, 0xFDB423997FA30340, .{}); } // 0xFDB423997FA30340 0x4D0449C6 b323
    pub inline fn thefeedResume() !void { try invoker.invoke(void, 0xE1CD1E48E025E661, .{}); } // 0xE1CD1E48E025E661 0xD3F40140 b323
    pub inline fn thefeedIsPaused() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA9CBFD40B3FA3010, .{}); } // 0xA9CBFD40B3FA3010 0xC5223796 b323
    pub inline fn thefeedReportLogoOn() !void { try invoker.invoke(void, 0xD4438C0564490E63, .{}); } // 0xD4438C0564490E63 0x709B4BCB b323
    pub inline fn thefeedReportLogoOff() !void { try invoker.invoke(void, 0xB695E2CD0A2DA9EE, .{}); } // 0xB695E2CD0A2DA9EE 0x4A4A40A4 b323
    /// Returns the handle for the notification currently displayed on the screen. Name may be a hash collision, but describes the function accurately.
    pub inline fn thefeedGetLastShownPhoneActivatableFeedId() !c_int { return try invoker.invoke(c_int, 0x82352748437638CA, .{}); } // 0x82352748437638CA 0x294405D4 b323
    /// Enables loading screen tips to be be shown (`THEFEED_SHOW`), blocks other kinds of notifications from being displayed (at least from current script). Call `THEFEED_AUTO_POST_GAMETIPS_OFF` to display those again.
    pub inline fn thefeedAutoPostGametipsOn() !void { try invoker.invoke(void, 0x56C8B608CFD49854, .{}); } // 0x56C8B608CFD49854 0xF881AB87 b323
    /// Displays "normal" notifications again after calling `THEFEED_AUTO_POST_GAMETIPS_ON` (those that were drawn before calling this native too), though those will have a weird offset and stay on screen forever (tested with notifications created from same script).
    pub inline fn thefeedAutoPostGametipsOff() !void { try invoker.invoke(void, 0xADED7F5748ACAFE6, .{}); } // 0xADED7F5748ACAFE6 0x1D6859CA b323
    /// From the decompiled scripts: \
    /// HUD::THEFEED_SET_BACKGROUND_COLOR_FOR_NEXT_POST(6); \
    /// HUD::THEFEED_SET_BACKGROUND_COLOR_FOR_NEXT_POST(184); \
    /// HUD::THEFEED_SET_BACKGROUND_COLOR_FOR_NEXT_POST(190);
    /// 
    /// sets background color for the next notification \
    /// 6 = red \
    /// 184 = green \
    /// 190 = yellow
    /// 
    /// Here is a list of some colors that can be used: https://gyazo.com/68bd384455fceb0a85a8729e48216e15
    pub inline fn thefeedSetBackgroundColorForNextPost(hud_color_index: c_int) !void { try invoker.invoke(void, 0x92F0DA1E27DB96DC, .{hud_color_index}); } // 0x92F0DA1E27DB96DC 0x07CE2EA4 b323
    pub inline fn thefeedSetRgbaParameterForNextMessage(red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0x17430B918701C342, .{red, green, blue, alpha}); } // 0x17430B918701C342 0xCF14D7F2 b323
    /// Related to notification color flashing, setting count to 0 invalidates a `THEFEED_SET_RGBA_PARAMETER_FOR_NEXT_MESSAGE` call for the target notification.
    pub inline fn thefeedSetFlashDurationParameterForNextMessage(count: c_int) !void { try invoker.invoke(void, 0x17AD8C9706BDD88A, .{count}); } // 0x17AD8C9706BDD88A 0x24A97AF8 b323
    pub inline fn thefeedSetVibrateParameterForNextMessage(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4A0C7C9BB10ABB36, .{toggle}); } // 0x4A0C7C9BB10ABB36 0x44018EDB b323
    pub inline fn thefeedResetAllParameters() !void { try invoker.invoke(void, 0xFDD85225B2DEA55E, .{}); } // 0xFDD85225B2DEA55E 0xA4524B23 b323
    /// Requires manual management of game stream handles (i.e., 0xBE4390CB40B3E627).
    pub inline fn thefeedFreezeNextPost() !void { try invoker.invoke(void, 0xFDEC055AB549E328, .{}); } // 0xFDEC055AB549E328 0xAFA1148B b323
    pub inline fn thefeedClearFrozenPost() !void { try invoker.invoke(void, 0x80FE4F3AB4E1B62A, .{}); } // 0x80FE4F3AB4E1B62A 0x3CD4307C b323
    pub inline fn thefeedSetSnapFeedItemPositions(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xBAE4F9B97CD43B30, .{p_0}); } // 0xBAE4F9B97CD43B30  b323
    /// Used in the native scripts to reference "GET_PEDHEADSHOT_TXD_STRING" and "CHAR_DEFAULT".
    pub inline fn thefeedUpdateItemTexture(txd_string_1: [*c]const u8, txn_string_1: [*c]const u8, txd_string_2: [*c]const u8, txn_string_2: [*c]const u8) !void { try invoker.invoke(void, 0x317EBA71D7543F52, .{txd_string_1, txn_string_1, txd_string_2, txn_string_2}); } // 0x317EBA71D7543F52 0x6A3F747D b323
    /// Declares the entry type of a notification, for example "STRING".
    /// 
    /// int ShowNotification(char *text) \
    /// { \
    ///     BEGIN_TEXT_COMMAND_THEFEED_POST("STRING");
    ///     ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
    ///     return END_TEXT_COMMAND_THEFEED_POST_TICKER(1, 1);
    /// }
    pub inline fn beginTextCommandThefeedPost(text: [*c]const u8) !void { try invoker.invoke(void, 0x202709F4C58A0424, .{text}); } // 0x202709F4C58A0424 0x574EE85C b323
    /// List of picture names: https://pastebin.com/XdpJVbHz \
    /// Example result: https://i.imgur.com/SdEZ22m.png
    pub inline fn endTextCommandThefeedPostStats(stat_title: [*c]const u8, icon_enum: c_int, step_val: windows.BOOL, bar_value: c_int, is_important: windows.BOOL, picture_texture_dict: [*c]const u8, picture_texture_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x2B7E9A4EAAA93C89, .{stat_title, icon_enum, step_val, bar_value, is_important, picture_texture_dict, picture_texture_name}); } // 0x2B7E9A4EAAA93C89 0xED130FA1 b323
    /// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
    /// 
    /// List of picNames: https://pastebin.com/XdpJVbHz
    /// 
    /// 
    /// flash is a bool for fading in. \
    /// iconTypes: \
    /// 1 : Chat Box \
    /// 2 : Email \
    /// 3 : Add Friend Request \
    /// 4 : Nothing \
    /// 5 : Nothing \
    /// 6 : Nothing \
    /// 7 : Right Jumping Arrow \
    /// 8 : RP Icon \
    /// 9 : $ Icon
    /// 
    /// "sender" is the very top header. This can be any old string. \
    /// "subject" is the header under the sender.
    pub inline fn endTextCommandThefeedPostMessagetext(txd_name: [*c]const u8, texture_name: [*c]const u8, flash: windows.BOOL, icon_type: c_int, sender: [*c]const u8, subject: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x1CCD9A37359072CF, .{txd_name, texture_name, flash, icon_type, sender, subject}); } // 0x1CCD9A37359072CF 0xE7E3C98B b323
    /// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
    /// 
    /// Needs more research.
    /// 
    /// Only one type of usage in the scripts:
    /// 
    /// HUD::END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_SUBTITLE_LABEL("CHAR_ACTING_UP", "CHAR_ACTING_UP", 0, 0, "DI_FEED_CHAR", a_0);
    pub inline fn endTextCommandThefeedPostMessagetextSubtitleLabel(txd_name: [*c]const u8, texture_name: [*c]const u8, flash: windows.BOOL, icon_type: c_int, sender: [*c]const u8, subject: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xC6F580E4C94926AC, .{txd_name, texture_name, flash, icon_type, sender, subject}); } // 0xC6F580E4C94926AC  b323
    /// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
    /// 
    /// NOTE: 'duration' is a multiplier, so 1.0 is normal, 2.0 is twice as long (very slow), and 0.5 is half as long.
    /// 
    /// Example, only occurrence in the scripts: \
    /// v_8 = HUD::END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT_TU("CHAR_SOCIAL_CLUB", "CHAR_SOCIAL_CLUB", 0, 0, &v_9, "", a_5);
    pub inline fn endTextCommandThefeedPostMessagetextTu(txd_name: [*c]const u8, texture_name: [*c]const u8, flash: windows.BOOL, icon_type: c_int, sender: [*c]const u8, subject: [*c]const u8, duration: f32) !c_int { return try invoker.invoke(c_int, 0x1E6611149DB3DB6B, .{txd_name, texture_name, flash, icon_type, sender, subject, duration}); } // 0x1E6611149DB3DB6B 0x0EB382B7 b323
    /// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
    /// 
    /// List of picNames https://pastebin.com/XdpJVbHz
    /// 
    /// flash is a bool for fading in. \
    /// iconTypes: \
    /// 1 : Chat Box \
    /// 2 : Email \
    /// 3 : Add Friend Request \
    /// 4 : Nothing \
    /// 5 : Nothing \
    /// 6 : Nothing \
    /// 7 : Right Jumping Arrow \
    /// 8 : RP Icon \
    /// 9 : $ Icon
    /// 
    /// "sender" is the very top header. This can be any old string. \
    /// "subject" is the header under the sender. \
    /// "duration" is a multiplier, so 1.0 is normal, 2.0 is twice as long (very slow), and 0.5 is half as long. \
    /// "clanTag" shows a crew tag in the "sender" header, after the text. You need to use 3 underscores as padding. Maximum length of this field seems to be 7. (e.g. "MK" becomes "___MK", "ACE" becomes "___ACE", etc.)
    pub inline fn endTextCommandThefeedPostMessagetextWithCrewTag(txd_name: [*c]const u8, texture_name: [*c]const u8, flash: windows.BOOL, icon_type: c_int, sender: [*c]const u8, subject: [*c]const u8, duration: f32, clan_tag: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x5CBF7BADE20DB93E, .{txd_name, texture_name, flash, icon_type, sender, subject, duration, clan_tag}); } // 0x5CBF7BADE20DB93E 0x3E807FE3 b323
    /// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
    /// 
    /// List of picNames:  https://pastebin.com/XdpJVbHz
    /// 
    /// flash is a bool for fading in. \
    /// iconTypes: \
    /// 1 : Chat Box \
    /// 2 : Email \
    /// 3 : Add Friend Request \
    /// 4 : Nothing \
    /// 5 : Nothing \
    /// 6 : Nothing \
    /// 7 : Right Jumping Arrow \
    /// 8 : RP Icon \
    /// 9 : $ Icon
    /// 
    /// "sender" is the very top header. This can be any old string. \
    /// "subject" is the header under the sender. \
    /// "duration" is a multiplier, so 1.0 is normal, 2.0 is twice as long (very slow), and 0.5 is half as long. \
    /// "clanTag" shows a crew tag in the "sender" header, after the text. You need to use 3 underscores as padding. Maximum length of this field seems to be 7. (e.g. "MK" becomes "___MK", "ACE" becomes "___ACE", etc.) \
    /// iconType2 is a mirror of iconType. It shows in the "subject" line, right under the original iconType.
    /// 
    /// 
    /// int IconNotification(char *text, char *text2, char *Subject) \
    /// { \
    ///     BEGIN_TEXT_COMMAND_THEFEED_POST("STRING");
    ///  ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text); \
    ///    _SET_NOTIFICATION_MESSAGE_CLAN_TAG_2("CHAR_SOCIAL_CLUB", "CHAR_SOCIAL_CLUB", 1, 7, text2, Subject, 1.0f, "__EXAMPLE", 7);
    ///    return END_TEXT_COMMAND_THEFEED_POST_TICKER(1, 1);
    /// }
    pub inline fn endTextCommandThefeedPostMessagetextWithCrewTagAndAdditionalIcon(txd_name: [*c]const u8, texture_name: [*c]const u8, flash: windows.BOOL, icon_type_1: c_int, sender: [*c]const u8, subject: [*c]const u8, duration: f32, clan_tag: [*c]const u8, icon_type_2: c_int, p_9: c_int) !c_int { return try invoker.invoke(c_int, 0x531B84E7DA981FB6, .{txd_name, texture_name, flash, icon_type_1, sender, subject, duration, clan_tag, icon_type_2, p_9}); } // 0x531B84E7DA981FB6 0xDEB491C8 b323
    pub inline fn endTextCommandThefeedPostTicker(blink: windows.BOOL, p_1: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x2ED7843F8F801023, .{blink, p_1}); } // 0x2ED7843F8F801023 0x08F7AF78 b323
    pub inline fn endTextCommandThefeedPostTickerForced(blink: windows.BOOL, p_1: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x44FA03975424A0EE, .{blink, p_1}); } // 0x44FA03975424A0EE 0x57B8D0D4 b323
    pub inline fn endTextCommandThefeedPostTickerWithTokens(blink: windows.BOOL, p_1: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x378E809BF61EC840, .{blink, p_1}); } // 0x378E809BF61EC840 0x02BCAF9B b323
    /// Shows an "award" notification above the minimap, example: https://i.imgur.com/e2DNaKX.png \
    /// Example:
    /// 
    /// HUD::BEGIN_TEXT_COMMAND_THEFEED_POST("HUNT"); \
    /// HUD::END_TEXT_COMMAND_THEFEED_POST_AWARD("Hunting", "Hunting_Gold_128", 0, 109, "HUD_MED_UNLKED");
    pub inline fn endTextCommandThefeedPostAward(texture_dict: [*c]const u8, texture_name: [*c]const u8, rp_bonus: c_int, color_overlay: c_int, title_label: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xAA295B6F28BD587D, .{texture_dict, texture_name, rp_bonus, color_overlay, title_label}); } // 0xAA295B6F28BD587D 0x02DED2B8 b323
    pub inline fn endTextCommandThefeedPostCrewtag(p_0: windows.BOOL, p_1: windows.BOOL, p_2: [*c]c_int, p_3: c_int, is_leader: windows.BOOL, unk_0: windows.BOOL, clan_desc: c_int, _r: c_int, _g: c_int, _b: c_int) !c_int { return try invoker.invoke(c_int, 0x97C9E4E7024A8F2C, .{p_0, p_1, p_2, p_3, is_leader, unk_0, clan_desc, _r, _g, _b}); } // 0x97C9E4E7024A8F2C 0xA9CCEF66 b323
    pub inline fn endTextCommandThefeedPostCrewtagWithGameName(p_0: windows.BOOL, p_1: windows.BOOL, p_2: [*c]c_int, p_3: c_int, is_leader: windows.BOOL, unk_0: windows.BOOL, clan_desc: c_int, player_name: [*c]const u8, _r: c_int, _g: c_int, _b: c_int) !c_int { return try invoker.invoke(c_int, 0x137BC35589E34E1E, .{p_0, p_1, p_2, p_3, is_leader, unk_0, clan_desc, player_name, _r, _g, _b}); } // 0x137BC35589E34E1E 0x88B9B909 b323
    pub inline fn endTextCommandThefeedPostUnlock(gxt_label_1: [*c]const u8, p_1: c_int, gxt_label_2: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x33EE12743CCD6343, .{gxt_label_1, p_1, gxt_label_2}); } // 0x33EE12743CCD6343 0xE05E7052 b323
    pub inline fn endTextCommandThefeedPostUnlockTu(gxt_label_1: [*c]const u8, p_1: c_int, gxt_label_2: [*c]const u8, p_3: c_int) !c_int { return try invoker.invoke(c_int, 0xC8F3AAF93D0600BF, .{gxt_label_1, p_1, gxt_label_2, p_3}); } // 0xC8F3AAF93D0600BF 0x4FA43BA4 b323
    pub inline fn endTextCommandThefeedPostUnlockTuWithColor(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !c_int { return try invoker.invoke(c_int, 0x7AE0589093A2E088, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x7AE0589093A2E088 0x8C90D22F b323
    pub inline fn endTextCommandThefeedPostMpticker(blink: windows.BOOL, p_1: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xF020C96915705B3A, .{blink, p_1}); } // 0xF020C96915705B3A 0x8E319AB8 b323
    pub inline fn endTextCommandThefeedPostCrewRankupWithLiteralFlag(p_0: [*c]const u8, p_1: [*c]const u8, p_2: [*c]const u8, p_3: windows.BOOL, p_4: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x8EFCCF6EC66D85E4, .{p_0, p_1, p_2, p_3, p_4}); } // 0x8EFCCF6EC66D85E4  b323
    /// This function can show pictures of every texture that can be requested by REQUEST_STREAMED_TEXTURE_DICT.
    /// 
    /// List of picNames: https://pastebin.com/XdpJVbHz \
    /// HUD colors and their values: https://pastebin.com/d9aHPbXN
    /// 
    /// Shows a deathmatch score above the minimap, example: https://i.imgur.com/YmoMklG.png
    pub inline fn endTextCommandThefeedPostVersusTu(txd_name_1: [*c]const u8, texture_name_1: [*c]const u8, count_1: c_int, txd_name_2: [*c]const u8, texture_name_2: [*c]const u8, count_2: c_int, hud_color_1: c_int, hud_color_2: c_int) !c_int { return try invoker.invoke(c_int, 0xB6871B0555B02996, .{txd_name_1, texture_name_1, count_1, txd_name_2, texture_name_2, count_2, hud_color_1, hud_color_2}); } // 0xB6871B0555B02996 0x5E93FBFA b323
    /// returns a notification handle, prints out a notification like below: \
    /// type range: 0 - 2 \
    /// if you set type to 1, image goes from 0 - 39 - Xbox you can add text to
    /// 
    /// example:  \
    /// HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT(1, 20, "Who you trynna get crazy with, ese? Don't you know I'm LOCO?!"); \
    /// - https://imgur.com/lGBPCz3
    pub inline fn endTextCommandThefeedPostReplay(@"type": c_int, image: c_int, text: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xD202B92CBF1D816F, .{@"type", image, text}); } // 0xD202B92CBF1D816F  b323
    /// returns a notification handle, prints out a notification like below: \
    /// type range: 0 - 2 \
    /// if you set type to 1, button accepts "~INPUT_SOMETHING~"
    /// 
    /// example: \
    /// HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT(1, "~INPUT_TALK~", "Who you trynna get crazy with, ese? Don't you know I'm LOCO?!"); \
    /// - https://imgur.com/UPy0Ial
    /// 
    /// 
    /// Examples from the scripts: \
    /// l_D1[1/*1*/]=HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT(1,"~INPUT_REPLAY_START_STOP_RECORDING~",""); \
    /// l_D1[2/*1*/]=HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT(1,"~INPUT_SAVE_REPLAY_CLIP~",""); \
    /// l_D1[1/*1*/]=HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT(1,"~INPUT_REPLAY_START_STOP_RECORDING~",""); \
    /// l_D1[2/*1*/]=HUD::END_TEXT_COMMAND_THEFEED_POST_REPLAY_INPUT(1,"~INPUT_REPLAY_START_STOP_RECORDING_SECONDARY~","");
    /// 
    pub inline fn endTextCommandThefeedPostReplayInput(@"type": c_int, button: [*c]const u8, text: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xDD6CB2CCE7C2735C, .{@"type", button, text}); } // 0xDD6CB2CCE7C2735C  b323
    /// void ShowSubtitle(const char *text) \
    /// { \
    ///   BEGIN_TEXT_COMMAND_PRINT("STRING");
    ///  ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text); \
    ///    END_TEXT_COMMAND_PRINT(2000, true);
    /// }
    pub inline fn beginTextCommandPrint(_gxt_entry: [*c]const u8) !void { try invoker.invoke(void, 0xB87A37EEB7FAA67D, .{_gxt_entry}); } // 0xB87A37EEB7FAA67D 0xF42C43C7 b323
    /// Draws the subtitle at middle center of the screen.
    /// 
    /// int duration = time in milliseconds to show text on screen before disappearing
    /// 
    /// drawImmediately = If true, the text will be drawn immediately, if false, the text will be drawn after the previous subtitle has finished
    /// 
    /// Used to be known as _DRAW_SUBTITLE_TIMED
    pub inline fn endTextCommandPrint(duration: c_int, draw_immediately: windows.BOOL) !void { try invoker.invoke(void, 0x9D77056A530643F6, .{duration, draw_immediately}); } // 0x9D77056A530643F6 0x38F82261 b323
    /// nothin doin. 
    /// 
    /// BOOL Message(const char* text) \
    ///    {
    ///      BEGIN_TEXT_COMMAND_IS_MESSAGE_DISPLAYED("STRING");
    ///       ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
    ///        return END_TEXT_COMMAND_IS_MESSAGE_DISPLAYED();
    ///    }
    pub inline fn beginTextCommandIsMessageDisplayed(text: [*c]const u8) !void { try invoker.invoke(void, 0x853648FD1063A213, .{text}); } // 0x853648FD1063A213 0xDD524A11 b323
    pub inline fn endTextCommandIsMessageDisplayed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8A9BA1AB3E237613, .{}); } // 0x8A9BA1AB3E237613 0x672EFB45 b323
    /// The following were found in the decompiled script files: \
    /// STRING, TWOSTRINGS, NUMBER, PERCENTAGE, FO_TWO_NUM, ESMINDOLLA, ESDOLLA, MTPHPER_XPNO, AHD_DIST, CMOD_STAT_0, CMOD_STAT_1, CMOD_STAT_2, CMOD_STAT_3, DFLT_MNU_OPT, F3A_TRAFDEST, ES_HELP_SOC3
    /// 
    /// ESDOLLA - cash \
    /// ESMINDOLLA - cash (negative)
    /// 
    /// Used to be known as _SET_TEXT_ENTRY
    pub inline fn beginTextCommandDisplayText(text: [*c]const u8) !void { try invoker.invoke(void, 0x25FBB336DF1804CB, .{text}); } // 0x25FBB336DF1804CB 0x3E35563E b323
    /// After applying the properties to the text (See HUD::SET_TEXT_), this will draw the text in the applied position. Also 0.0f < x, y < 1.0f, percentage of the axis.
    /// 
    /// Used to be known as _DRAW_TEXT
    pub inline fn endTextCommandDisplayText(vec: types.Vector2, p_2: c_int) !void { try invoker.invoke(void, 0xCD015E5BB0D96A57, .{vec.x, vec.y, p_2}); } // 0xCD015E5BB0D96A57 0x6F8350CE b323
    pub inline fn beginTextCommandGetScreenWidthOfDisplayText(text: [*c]const u8) !void { try invoker.invoke(void, 0x54CE8AC98E120CAB, .{text}); } // 0x54CE8AC98E120CAB 0x51E7A037 b323
    pub inline fn endTextCommandGetScreenWidthOfDisplayText(p_0: windows.BOOL) !f32 { return try invoker.invoke(f32, 0x85F061DA64ED2F67, .{p_0}); } // 0x85F061DA64ED2F67 0xD12A643A b323
    /// int GetLineCount(char *text, float x, float y) \
    ///     {
    ///      BEGIN_TEXT_COMMAND_GET_NUMBER_OF_LINES_FOR_STRING("STRING");
    ///                 ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
    ///       return BEGIN_TEXT_COMMAND_GET_NUMBER_OF_LINES_FOR_STRING(x, y);
    ///     }
    pub inline fn beginTextCommandGetNumberOfLinesForString(entry: [*c]const u8) !void { try invoker.invoke(void, 0x521FB041D93DD0E4, .{entry}); } // 0x521FB041D93DD0E4 0x94B82066 b323
    /// Determines how many lines the text string will use when drawn on screen.  \
    /// Must use 0x521FB041D93DD0E4 for setting up
    pub inline fn endTextCommandGetNumberOfLinesForString(vec: types.Vector2) !c_int { return try invoker.invoke(c_int, 0x9040DFB09BE75706, .{vec.x, vec.y}); } // 0x9040DFB09BE75706 0xAA318785 b323
    /// Used to be known as _SET_TEXT_COMPONENT_FORMAT
    pub inline fn beginTextCommandDisplayHelp(input_type: [*c]const u8) !void { try invoker.invoke(void, 0x8509B634FBE7DA11, .{input_type}); } // 0x8509B634FBE7DA11 0xB245FC10 b323
    /// shape goes from -1 to 50 (may be more). \
    /// p0 is always 0.
    /// 
    /// Example: \
    /// void FloatingHelpText(const char* text) \
    /// { \
    ///     BEGIN_TEXT_COMMAND_DISPLAY_HELP("STRING");
    ///   ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(text);
    ///    END_TEXT_COMMAND_DISPLAY_HELP (0, 0, 1, -1);
    /// }
    /// 
    /// Image: \
    /// - imgbin.org/images/26209.jpg
    /// 
    /// more inputs/icons: \
    /// - https://pastebin.com/nqNYWMSB
    /// 
    /// Used to be known as _DISPLAY_HELP_TEXT_FROM_STRING_LABEL
    pub inline fn endTextCommandDisplayHelp(p_0: c_int, loop: windows.BOOL, beep: windows.BOOL, shape: c_int) !void { try invoker.invoke(void, 0x238FFE5C7B0498A6, .{p_0, loop, beep, shape}); } // 0x238FFE5C7B0498A6 0xB59B530D b323
    /// BOOL IsContextActive(char *ctx) \
    ///     {
    ///      BEGIN_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED(ctx);
    ///      return END_TEXT_COMMAND_IS_THIS_HELP_MESSAGE_BEING_DISPLAYED(0);
    ///   }
    pub inline fn beginTextCommandIsThisHelpMessageBeingDisplayed(label_name: [*c]const u8) !void { try invoker.invoke(void, 0x0A24DA3A41B718F5, .{label_name}); } // 0x0A24DA3A41B718F5 0x00E20F2D b323
    pub inline fn endTextCommandIsThisHelpMessageBeingDisplayed(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x10BDDBFC529428DD, .{p_0}); } // 0x10BDDBFC529428DD 0xF63A13EC b323
    /// Starts a text command to change the name of a blip displayed in the pause menu. \
    /// This should be paired with `END_TEXT_COMMAND_SET_BLIP_NAME`, once adding all required text components. \
    /// Example:
    /// 
    /// HUD::BEGIN_TEXT_COMMAND_SET_BLIP_NAME("STRING"); \
    /// HUD::ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME("Name"); \
    /// HUD::END_TEXT_COMMAND_SET_BLIP_NAME(blip);
    pub inline fn beginTextCommandSetBlipName(text_label: [*c]const u8) !void { try invoker.invoke(void, 0xF9113A30DE5C6670, .{text_label}); } // 0xF9113A30DE5C6670 0xF4C211F6 b323
    /// Finalizes a text command started with BEGIN_TEXT_COMMAND_SET_BLIP_NAME, setting the name of the specified blip.
    pub inline fn endTextCommandSetBlipName(blip: types.Blip) !void { try invoker.invoke(void, 0xBC38B49BCB83BC9B, .{blip}); } // 0xBC38B49BCB83BC9B 0xE8E59820 b323
    pub inline fn beginTextCommandAddDirectlyToPreviousBriefs(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x23D69E0465570028, .{p_0}); } // 0x23D69E0465570028 0x0E103475 b323
    pub inline fn endTextCommandAddDirectlyToPreviousBriefs(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xCFDBDF5AE59BA0F4, .{p_0}); } // 0xCFDBDF5AE59BA0F4 0x2944A6C5 b323
    /// clears a print text command with this text
    pub inline fn beginTextCommandClearPrint(text: [*c]const u8) !void { try invoker.invoke(void, 0xE124FA80A759019C, .{text}); } // 0xE124FA80A759019C 0x550665AE b323
    pub inline fn endTextCommandClearPrint() !void { try invoker.invoke(void, 0xFCC75460ABA29378, .{}); } // 0xFCC75460ABA29378 0x67785AF2 b323
    pub inline fn beginTextCommandOverrideButtonText(gxt_entry: [*c]const u8) !void { try invoker.invoke(void, 0x8F9EE5687F8EECCD, .{gxt_entry}); } // 0x8F9EE5687F8EECCD 0xBF855650 b323
    pub inline fn endTextCommandOverrideButtonText(p_0: c_int) !void { try invoker.invoke(void, 0xA86911979638106F, .{p_0}); } // 0xA86911979638106F 0x6E7FDA1C b323
    pub inline fn addTextComponentInteger(value: c_int) !void { try invoker.invoke(void, 0x03B504CF259931BC, .{value}); } // 0x03B504CF259931BC 0xFE272A57 b323
    pub inline fn addTextComponentFloat(value: f32, decimal_places: c_int) !void { try invoker.invoke(void, 0xE7DCB5B874BCD96E, .{value, decimal_places}); } // 0xE7DCB5B874BCD96E 0x24D78013 b323
    pub inline fn addTextComponentSubstringTextLabel(label_name: [*c]const u8) !void { try invoker.invoke(void, 0xC63CD5D2920ACBE7, .{label_name}); } // 0xC63CD5D2920ACBE7 0xDCE05406 b323
    /// It adds the localized text of the specified GXT entry name. Eg. if the argument is GET_HASH_KEY("ES_HELP"), adds "Continue". Just uses a text labels hash key
    pub inline fn addTextComponentSubstringTextLabelHashKey(gxt_entry_hash: types.Hash) !void { try invoker.invoke(void, 0x17299B63C7683A2B, .{gxt_entry_hash}); } // 0x17299B63C7683A2B 0x150E03B6 b323
    pub inline fn addTextComponentSubstringBlipName(blip: types.Blip) !void { try invoker.invoke(void, 0x80EAD8E2E1D5D52E, .{blip}); } // 0x80EAD8E2E1D5D52E 0x5DE98F0A b323
    pub inline fn addTextComponentSubstringPlayerName(text: [*c]const u8) !void { try invoker.invoke(void, 0x6C188BE134E074AA, .{text}); } // 0x6C188BE134E074AA 0x27A244D8 b323
    /// Adds a timer (e.g. "00:00:00:000"). The appearance of the timer depends on the flags, which needs more research.
    pub inline fn addTextComponentSubstringTime(timestamp: c_int, flags: c_int) !void { try invoker.invoke(void, 0x1115F16B8AB9E8BF, .{timestamp, flags}); } // 0x1115F16B8AB9E8BF 0x135B3CD0 b323
    pub inline fn addTextComponentFormattedInteger(value: c_int, comma_separated: windows.BOOL) !void { try invoker.invoke(void, 0x0E4C749FF9DE9CC4, .{value, comma_separated}); } // 0x0E4C749FF9DE9CC4 0x12929BDF b323
    /// p1 was always -1
    pub inline fn addTextComponentSubstringPhoneNumber(p_0: [*c]const u8, p_1: c_int) !void { try invoker.invoke(void, 0x761B77454205A61D, .{p_0, p_1}); } // 0x761B77454205A61D 0x65E1D404 b323
    /// This native (along with ADD_TEXT_COMPONENT_SUBSTRING_KEYBOARD_DISPLAY and ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME) do not actually filter anything. They simply add the provided text (as of 944)
    pub inline fn addTextComponentSubstringWebsite(website: [*c]const u8) !void { try invoker.invoke(void, 0x94CF4AC034C9C986, .{website}); } // 0x94CF4AC034C9C986 0xC736999E b323
    pub inline fn addTextComponentSubstringKeyboardDisplay(string: [*c]const u8) !void { try invoker.invoke(void, 0x5F68520888E69014, .{string}); } // 0x5F68520888E69014 0x0829A799 b323
    pub inline fn setColourOfNextTextComponent(hud_color: c_int) !void { try invoker.invoke(void, 0x39BBF623FC803EAC, .{hud_color}); } // 0x39BBF623FC803EAC 0x6F1A1901 b323
    /// Returns a substring of a specified length starting at a specified position.
    /// 
    /// Example: \
    /// // Get "STRING" text from "MY_STRING" \
    /// subStr = HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME("MY_STRING", 3, 6);
    pub inline fn getCharacterFromAudioConversationFilename(text: [*c]const u8, position: c_int, length: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x169BD9382084C8C0, .{text, position, length}); } // 0x169BD9382084C8C0 0x34A396EE b323
    /// Returns a substring of a specified length starting at a specified position. The result is guaranteed not to exceed the specified max length.
    /// 
    /// NOTE: The 'maxLength' parameter might actually be the size of the buffer that is returned. More research is needed. -CL69
    /// 
    /// Example: \
    /// // Condensed example of how Rockstar uses this function \
    /// strLen = HUD::GET_LENGTH_OF_LITERAL_STRING(MISC::GET_ONSCREEN_KEYBOARD_RESULT()); \
    /// subStr = HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_WITH_BYTE_LIMIT(MISC::GET_ONSCREEN_KEYBOARD_RESULT(), 0, strLen, 63);
    /// 
    /// --
    /// 
    /// "fm_race_creator.ysc", line 85115: \
    /// // parameters modified for clarity \
    /// BOOL sub_8e5aa(char *text, int length) { \
    ///     for (i = 0; i <= (length - 2); i += 1) {
    ///         if (!MISC::ARE_STRINGS_EQUAL(HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_WITH_BYTE_LIMIT(text, i, i + 1, 1), " ")) {
    ///             return FALSE;
    ///         }
    ///     }
    ///     return TRUE;
    /// }
    pub inline fn getCharacterFromAudioConversationFilenameWithByteLimit(text: [*c]const u8, position: c_int, length: c_int, max_length: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xB2798643312205C5, .{text, position, length, max_length}); } // 0xB2798643312205C5 0x0183A66C b323
    /// Returns a substring that is between two specified positions. The length of the string will be calculated using (endPosition - startPosition).
    /// 
    /// Example: \
    /// // Get "STRING" text from "MY_STRING" \
    /// subStr = HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_BYTES("MY_STRING", 3, 9); \
    /// // Overflows are possibly replaced with underscores (needs verification) \
    /// subStr = HUD::GET_CHARACTER_FROM_AUDIO_CONVERSATION_FILENAME_BYTES("MY_STRING", 3, 10); // "STRING_"?
    pub inline fn getCharacterFromAudioConversationFilenameBytes(text: [*c]const u8, start_position: c_int, end_position: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xCE94AEBA5D82908A, .{text, start_position, end_position}); } // 0xCE94AEBA5D82908A 0xFA6373BB b323
    /// Gets a localized string literal from a label name. Can be used for output of e.g. VEHICLE::GET_LIVERY_NAME. To check if a GXT label can be localized with this, HUD::DOES_TEXT_LABEL_EXIST can be used.
    pub inline fn getFilenameForAudioConversation(label_name: [*c]const u8) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x7B5280EBA9840C72, .{label_name}); } // 0x7B5280EBA9840C72 0x95C4B5AD b323
    pub inline fn clearPrints() !void { try invoker.invoke(void, 0xCC33FA791322B9D9, .{}); } // 0xCC33FA791322B9D9 0x216CB1C5 b323
    pub inline fn clearBrief() !void { try invoker.invoke(void, 0x9D292F73ADBD9313, .{}); } // 0x9D292F73ADBD9313 0x9F75A929 b323
    pub inline fn clearAllHelpMessages() !void { try invoker.invoke(void, 0x6178F68A87A4D3A0, .{}); } // 0x6178F68A87A4D3A0 0x9E5D9198 b323
    /// p0: found arguments in the b617d scripts: https://pastebin.com/X5akCN7z
    pub inline fn clearThisPrint(p_0: [*c]const u8) !void { try invoker.invoke(void, 0xCF708001E1E536DD, .{p_0}); } // 0xCF708001E1E536DD 0x06878327 b323
    pub inline fn clearSmallPrints() !void { try invoker.invoke(void, 0x2CEA2839313C09AC, .{}); } // 0x2CEA2839313C09AC 0xA869A238 b323
    pub inline fn doesTextBlockExist(gxt: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1C7302E725259789, .{gxt}); } // 0x1C7302E725259789 0x96F74838 b323
    /// Request a gxt into the passed slot.
    pub inline fn requestAdditionalText(gxt: [*c]const u8, slot: c_int) !void { try invoker.invoke(void, 0x71A78003C8E71424, .{gxt, slot}); } // 0x71A78003C8E71424 0x9FA9175B b323
    pub inline fn requestAdditionalTextForDlc(gxt: [*c]const u8, slot: c_int) !void { try invoker.invoke(void, 0x6009F9F1AE90D8A6, .{gxt, slot}); } // 0x6009F9F1AE90D8A6 0xF4D27EBE b323
    pub inline fn hasAdditionalTextLoaded(slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x02245FE4BED318B8, .{slot}); } // 0x02245FE4BED318B8 0xB0E56045 b323
    pub inline fn clearAdditionalText(p_0: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x2A179DF17CCF04CD, .{p_0, p_1}); } // 0x2A179DF17CCF04CD 0x518141E0 b323
    pub inline fn isStreamingAdditionalText(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8B6817B71B85EBF0, .{p_0}); } // 0x8B6817B71B85EBF0 0xF079E4EB b323
    /// Checks if the specified gxt has loaded into the passed slot.
    pub inline fn hasThisAdditionalTextLoaded(gxt: [*c]const u8, slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xADBF060E2B30C5BC, .{gxt, slot}); } // 0xADBF060E2B30C5BC 0x80A52040 b323
    pub inline fn isMessageBeingDisplayed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7984C03AA5CC2F41, .{}); } // 0x7984C03AA5CC2F41 0x6A77FE8D b323
    /// Checks if the passed gxt name exists in the game files.
    pub inline fn doesTextLabelExist(gxt: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAC09CA973C564252, .{gxt}); } // 0xAC09CA973C564252 0x6ECAE560 b323
    pub inline fn getFirstNCharactersOfLiteralString(string: [*c]const u8, length: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x98C3CF913D895111, .{string, length}); } // 0x98C3CF913D895111  b505
    /// Returns the string length of the string from the gxt string .
    pub inline fn getLengthOfStringWithThisTextLabel(gxt: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x801BD273D3A23F74, .{gxt}); } // 0x801BD273D3A23F74 0xA4CA7BE5 b323
    /// Returns the length of the string passed (much like strlen).
    pub inline fn getLengthOfLiteralString(string: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xF030907CCBB8A9FD, .{string}); } // 0xF030907CCBB8A9FD 0x99379D55 b323
    pub inline fn getLengthOfLiteralStringInBytes(string: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x43E4111189E54F0E, .{string}); } // 0x43E4111189E54F0E 0x7DBC0764 b323
    /// This functions converts the hash of a street name into a readable string.
    /// 
    /// For how to get the hashes, see PATHFIND::GET_STREET_NAME_AT_COORD.
    pub inline fn getStreetNameFromHashKey(hash: types.Hash) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xD0EF8A959B8A4CB9, .{hash}); } // 0xD0EF8A959B8A4CB9 0x1E8E310C b323
    pub inline fn isHudPreferenceSwitchedOn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1930DFA731813EC4, .{}); } // 0x1930DFA731813EC4 0xC3BC1B4F b323
    pub inline fn isRadarPreferenceSwitchedOn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9EB6522EA68F22FE, .{}); } // 0x9EB6522EA68F22FE 0x14AEAA28 b323
    pub inline fn isSubtitlePreferenceSwitchedOn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAD6DACA4BA53E0A4, .{}); } // 0xAD6DACA4BA53E0A4 0x63BA19F5 b323
    /// If Hud should be displayed
    pub inline fn displayHud(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA6294919E56FF02A, .{toggle}); } // 0xA6294919E56FF02A 0xD10E4E31 b323
    /// Enables drawing some hud components, such as help labels, this frame, when the player is dead.
    pub inline fn displayHudWhenNotInStateOfPlayThisFrame() !void { try invoker.invoke(void, 0x7669F9E39DC17063, .{}); } // 0x7669F9E39DC17063 0xC380AC85 b323
    pub inline fn displayHudWhenPausedThisFrame() !void { try invoker.invoke(void, 0x402F9ED62087E898, .{}); } // 0x402F9ED62087E898 0xC47AB1B0 b323
    /// If Minimap / Radar should be displayed.
    pub inline fn displayRadar(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA0EBB943C300E693, .{toggle}); } // 0xA0EBB943C300E693 0x52816BD4 b323
    /// Setter for GET_FAKE_SPECTATOR_MODE
    pub inline fn setFakeSpectatorMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCD74233600C4EA6B, .{toggle}); } // 0xCD74233600C4EA6B  b505
    /// Getter for SET_FAKE_SPECTATOR_MODE
    pub inline fn getFakeSpectatorMode() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC2D2AD9EAAE265B8, .{}); } // 0xC2D2AD9EAAE265B8  b505
    pub inline fn isHudHidden() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA86478C6958735C5, .{}); } // 0xA86478C6958735C5 0x40BADA1D b323
    pub inline fn isRadarHidden() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x157F93B036700462, .{}); } // 0x157F93B036700462 0x1AB3B954 b323
    pub inline fn isMinimapRendering() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAF754F20EB5CD51A, .{}); } // 0xAF754F20EB5CD51A 0x9CD18314 b323
    pub inline fn useVehicleTargetingReticule(p_0: types.Any) !void { try invoker.invoke(void, 0x0C698D8F099174C7, .{p_0}); } // 0x0C698D8F099174C7  b1180
    pub inline fn useVehicleTargetingReticuleOnVehicles_(enable: windows.BOOL) !void { try invoker.invoke(void, 0x1BC0EA2912708625, .{enable}); } // 0x1BC0EA2912708625  b3095
    pub inline fn addValidVehicleHitHash(p_0: types.Any) !void { try invoker.invoke(void, 0xE4C3B169876D33D7, .{p_0}); } // 0xE4C3B169876D33D7  b1290
    pub inline fn clearValidVehicleHitHashes() !void { try invoker.invoke(void, 0xEB81A3DADD503187, .{}); } // 0xEB81A3DADD503187  b1290
    /// Enable / disable showing route for the Blip-object.
    pub inline fn setBlipRoute(blip: types.Blip, enabled: windows.BOOL) !void { try invoker.invoke(void, 0x4F7D8A9BFB0B43E9, .{blip, enabled}); } // 0x4F7D8A9BFB0B43E9 0x3E160C90 b323
    pub inline fn clearAllBlipRoutes() !void { try invoker.invoke(void, 0xD12882D3FF82BF11, .{}); } // 0xD12882D3FF82BF11  b877
    pub inline fn setBlipRouteColour(blip: types.Blip, colour: c_int) !void { try invoker.invoke(void, 0x837155CD2F63DA09, .{blip, colour}); } // 0x837155CD2F63DA09 0xDDE7C65C b323
    pub inline fn setForceShowGps(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2790F4B17D098E26, .{toggle}); } // 0x2790F4B17D098E26  b573
    pub inline fn setUseSetDestinationInPauseMap(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6CDD58146A436083, .{toggle}); } // 0x6CDD58146A436083  b573
    pub inline fn setBlockWantedFlash(disabled: windows.BOOL) !void { try invoker.invoke(void, 0xD1942374085C8469, .{disabled}); } // 0xD1942374085C8469  b505
    pub inline fn addNextMessageToPreviousBriefs(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x60296AF4BA14ABC5, .{p_0}); } // 0x60296AF4BA14ABC5 0xB58B25BD b323
    pub inline fn forceNextMessageToPreviousBriefsList(p_0: c_int) !void { try invoker.invoke(void, 0x57D760D55F54E071, .{p_0}); } // 0x57D760D55F54E071 0x9854485F b323
    /// zoom ranges from 0 to 90f in R* Scripts
    pub inline fn setRadarZoomPrecise(zoom: f32) !void { try invoker.invoke(void, 0xBD12C5EEE184C337, .{zoom}); } // 0xBD12C5EEE184C337 0xDCA3F423 b323
    /// zoomLevel ranges from 0 to 1400 in R* Scripts
    pub inline fn setRadarZoom(zoom_level: c_int) !void { try invoker.invoke(void, 0x096EF57A0C999BBA, .{zoom_level}); } // 0x096EF57A0C999BBA 0x2A50D1A6 b323
    pub inline fn setRadarZoomToBlip(blip: types.Blip, zoom: f32) !void { try invoker.invoke(void, 0xF98E4B3E56AFC7B1, .{blip, zoom}); } // 0xF98E4B3E56AFC7B1 0x25EC28C0 b323
    pub inline fn setRadarZoomToDistance(zoom: f32) !void { try invoker.invoke(void, 0xCB7CC0D58405AD41, .{zoom}); } // 0xCB7CC0D58405AD41 0x09CF1CE5 b323
    /// Does nothing (it's a nullsub).
    pub inline fn updateRadarZoomToBlip() !void { try invoker.invoke(void, 0xD2049635DEB9C375, .{}); } // 0xD2049635DEB9C375 0xE8D3A910 b323
    pub inline fn getHudColour(hud_color_index: c_int, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int, a: [*c]c_int) !void { try invoker.invoke(void, 0x7C9C91AB74A0360F, .{hud_color_index, r, g, b, a}); } // 0x7C9C91AB74A0360F 0x63F66A0B b323
    /// Sets the color of HUD_COLOUR_SCRIPT_VARIABLE
    pub inline fn setScriptVariableHudColour(r: c_int, g: c_int, b: c_int, a: c_int) !void { try invoker.invoke(void, 0xD68A5FF8A3A89874, .{r, g, b, a}); } // 0xD68A5FF8A3A89874 0x0E41E45C b323
    /// Sets the color of HUD_COLOUR_SCRIPT_VARIABLE_2
    pub inline fn setSecondScriptVariableHudColour(r: c_int, g: c_int, b: c_int, a: c_int) !void { try invoker.invoke(void, 0x16A304E6CB2BFAB9, .{r, g, b, a}); } // 0x16A304E6CB2BFAB9 0x6BE3ACA8 b323
    /// makes hudColorIndex2 color into hudColorIndex color
    pub inline fn replaceHudColour(hud_color_index: c_int, hud_color_index_2: c_int) !void { try invoker.invoke(void, 0x1CCC708F0F850613, .{hud_color_index, hud_color_index_2}); } // 0x1CCC708F0F850613 0x3B216749 b323
    pub inline fn replaceHudColourWithRgba(hud_color_index: c_int, r: c_int, g: c_int, b: c_int, a: c_int) !void { try invoker.invoke(void, 0xF314CF4F0211894E, .{hud_color_index, r, g, b, a}); } // 0xF314CF4F0211894E 0xF6E7E92B b323
    pub inline fn setAbilityBarVisibility(visible: windows.BOOL) !void { try invoker.invoke(void, 0x1DFEDD15019315A9, .{visible}); } // 0x1DFEDD15019315A9  b1493
    pub inline fn setAllowAbilityBar(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x889329C80FE5963C, .{toggle}); } // 0x889329C80FE5963C  b1868
    pub inline fn flashAbilityBar(milliseconds_to_flash: c_int) !void { try invoker.invoke(void, 0x02CFBA0C9E9275CE, .{milliseconds_to_flash}); } // 0x02CFBA0C9E9275CE 0x3648960D b323
    pub inline fn setAbilityBarValue(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0x9969599CCFF5D85E, .{p_0, p_1}); } // 0x9969599CCFF5D85E 0x24E53FD8 b323
    pub inline fn flashWantedDisplay(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xA18AFB39081B6A1F, .{p_0}); } // 0xA18AFB39081B6A1F 0x629F866B b323
    pub inline fn forceOffWantedStarFlash(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBA8D65C1C65702E5, .{toggle}); } // 0xBA8D65C1C65702E5 0x58612465 b323
    pub inline fn setCustomMpHudColor(hud_color_id: c_int) !void { try invoker.invoke(void, 0x2ACCB195F3CCD9DE, .{hud_color_id}); } // 0x2ACCB195F3CCD9DE  b2545
    /// This gets the height of the FONT and not the total text. You need to get the number of lines your text uses, and get the height of a newline (I'm using a smaller value) to get the total text height.
    pub inline fn getRenderedCharacterHeight(size: f32, font: c_int) !f32 { return try invoker.invoke(f32, 0xDB88A37483346780, .{size, font}); } // 0xDB88A37483346780 0x3330175B b323
    /// Size range : 0F to 1.0F \
    /// p0 is unknown and doesn't seem to have an effect, yet in the game scripts it changes to 1.0F sometimes.
    pub inline fn setTextScale(scale: f32, size: f32) !void { try invoker.invoke(void, 0x07C837F9A01C34C9, .{scale, size}); } // 0x07C837F9A01C34C9 0xB6E15B23 b323
    /// colors you input not same as you think? \
    /// A: for some reason its R B G A
    pub inline fn setTextColour(red: c_int, green: c_int, blue: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xBE6B23FFA53FB442, .{red, green, blue, alpha}); } // 0xBE6B23FFA53FB442 0xE54DD2C8 b323
    pub inline fn setTextCentre(@"align": windows.BOOL) !void { try invoker.invoke(void, 0xC02F4DBFB51D988B, .{@"align"}); } // 0xC02F4DBFB51D988B 0xE26D39A1 b323
    pub inline fn setTextRightJustify(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6B3C4650BC8BEE47, .{toggle}); } // 0x6B3C4650BC8BEE47 0x45B60520 b323
    /// Types - \
    /// 0: Center-Justify \
    /// 1: Left-Justify \
    /// 2: Right-Justify
    /// 
    /// Right-Justify requires SET_TEXT_WRAP, otherwise it will draw to the far right of the screen
    pub inline fn setTextJustification(justify_type: c_int) !void { try invoker.invoke(void, 0x4E096588B13FFECA, .{justify_type}); } // 0x4E096588B13FFECA 0x68CDFA60 b323
    pub inline fn setTextLineHeightMult(line_height_mult: f32) !void { try invoker.invoke(void, 0x9F4624F76E6953D1, .{line_height_mult}); } // 0x9F4624F76E6953D1  b3095
    /// It sets the text in a specified box and wraps the text if it exceeds the boundries. Both values are for X axis. Useful when positioning text set to center or aligned to the right.
    /// 
    /// start - left boundry on screen position (0.0 - 1.0) \
    /// end - right boundry on screen position (0.0 - 1.0)
    pub inline fn setTextWrap(start: f32, end: f32) !void { try invoker.invoke(void, 0x63145D9C883A1A70, .{start, end}); } // 0x63145D9C883A1A70 0x6F60AB54 b323
    pub inline fn setTextLeading(p_0: c_int) !void { try invoker.invoke(void, 0xA50ABC31E3CDFAFF, .{p_0}); } // 0xA50ABC31E3CDFAFF 0x98CE21D4 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn setTextProportional(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x038C1F517D7FDCF8, .{p_0}); } // 0x038C1F517D7FDCF8 0xF49D8A08 b323
    /// fonts that mess up your text where made for number values/misc stuff
    pub inline fn setTextFont(font_type: c_int) !void { try invoker.invoke(void, 0x66E0276CC5F6B9DA, .{font_type}); } // 0x66E0276CC5F6B9DA 0x80BC530D b323
    pub inline fn setTextDropShadow() !void { try invoker.invoke(void, 0x1CA3E9EAC9D93E5E, .{}); } // 0x1CA3E9EAC9D93E5E 0xE2A11511 b323
    /// distance - shadow distance in pixels, both horizontal and vertical \
    /// r, g, b, a - color
    pub inline fn setTextDropshadow(distance: c_int, r: c_int, g: c_int, b: c_int, a: c_int) !void { try invoker.invoke(void, 0x465C84BC39F1C351, .{distance, r, g, b, a}); } // 0x465C84BC39F1C351 0xE6587517 b323
    pub inline fn setTextOutline() !void { try invoker.invoke(void, 0x2513DFB0FB8400FE, .{}); } // 0x2513DFB0FB8400FE 0xC753412F b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn setTextEdge(p_0: c_int, r: c_int, g: c_int, b: c_int, a: c_int) !void { try invoker.invoke(void, 0x441603240D202FA6, .{p_0, r, g, b, a}); } // 0x441603240D202FA6 0x3F1A5DAB b323
    pub inline fn setTextRenderId(render_id: c_int) !void { try invoker.invoke(void, 0x5F15302936E07111, .{render_id}); } // 0x5F15302936E07111 0xC5C3B7F3 b323
    /// This function is hard-coded to always return 1.
    pub inline fn getDefaultScriptRendertargetRenderId() !c_int { return try invoker.invoke(c_int, 0x52F0982D7FD156B6, .{}); } // 0x52F0982D7FD156B6 0x8188935F b323
    pub inline fn registerNamedRendertarget(name: [*c]const u8, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57D9C12635E25CE3, .{name, p_1}); } // 0x57D9C12635E25CE3 0xFAE5D6F0 b323
    pub inline fn isNamedRendertargetRegistered(name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x78DCDC15C9F116B4, .{name}); } // 0x78DCDC15C9F116B4 0x284057F5 b323
    pub inline fn releaseNamedRendertarget(name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE9F6FFE837354DD4, .{name}); } // 0xE9F6FFE837354DD4 0xD3F6C892 b323
    pub inline fn linkNamedRendertarget(model_hash: types.Hash) !void { try invoker.invoke(void, 0xF6C09E276AEB3F2D, .{model_hash}); } // 0xF6C09E276AEB3F2D 0x6844C4B9 b323
    pub inline fn getNamedRendertargetRenderId(name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x1A6478B61C6BDC3B, .{name}); } // 0x1A6478B61C6BDC3B 0xF9D7A401 b323
    pub inline fn isNamedRendertargetLinked(model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x113750538FA31298, .{model_hash}); } // 0x113750538FA31298 0x8B52601F b323
    pub inline fn clearHelp(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8DFCED7A656F8802, .{toggle}); } // 0x8DFCED7A656F8802 0xE6D85741 b323
    pub inline fn isHelpMessageOnScreen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDAD37F45428801AE, .{}); } // 0xDAD37F45428801AE 0x4B3C9CA9 b323
    pub inline fn hasScriptHiddenHelpThisFrame() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x214CD562A939246A, .{}); } // 0x214CD562A939246A 0x812CBE0E b323
    pub inline fn isHelpMessageBeingDisplayed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4D79439A6B55AC67, .{}); } // 0x4D79439A6B55AC67 0xA65F262A b323
    pub inline fn isHelpMessageFadingOut() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x327EDEEEAC55C369, .{}); } // 0x327EDEEEAC55C369 0x3E50AE92 b323
    pub inline fn setHelpMessageStyle(style: c_int, hud_color: c_int, alpha: c_int, p_3: c_int, p_4: c_int) !void { try invoker.invoke(void, 0xB9C362BABECDDC7A, .{style, hud_color, alpha, p_3, p_4}); } // 0xB9C362BABECDDC7A  b463
    pub inline fn getStandardBlipEnumId() !c_int { return try invoker.invoke(c_int, 0x4A9923385BDB9DAD, .{}); } // 0x4A9923385BDB9DAD 0x87871CE0 b323
    pub inline fn getWaypointBlipEnumId() !c_int { return try invoker.invoke(c_int, 0x186E5D252FA50E7D, .{}); } // 0x186E5D252FA50E7D 0xB9827942 b323
    pub inline fn getNumberOfActiveBlips() !c_int { return try invoker.invoke(c_int, 0x9A3FF3DE163034E8, .{}); } // 0x9A3FF3DE163034E8 0x144020FA b323
    pub inline fn getNextBlipInfoId(blip_sprite: c_int) !types.Blip { return try invoker.invoke(types.Blip, 0x14F96AA50D6FBEA7, .{blip_sprite}); } // 0x14F96AA50D6FBEA7 0x9356E92F b323
    pub inline fn getFirstBlipInfoId(blip_sprite: c_int) !types.Blip { return try invoker.invoke(types.Blip, 0x1BEDE233E6CD2A1F, .{blip_sprite}); } // 0x1BEDE233E6CD2A1F 0x64C0273D b323
    pub inline fn getClosestBlipInfoId(blip_sprite: c_int) !types.Blip { return try invoker.invoke(types.Blip, 0xD484BF71050CA1EE, .{blip_sprite}); } // 0xD484BF71050CA1EE  b1180
    pub inline fn getBlipInfoIdCoord(blip: types.Blip) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xFA7C7F0AADF25D09, .{blip}); } // 0xFA7C7F0AADF25D09 0xB7374A66 b323
    pub inline fn getBlipInfoIdDisplay(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0x1E314167F701DC3B, .{blip}); } // 0x1E314167F701DC3B 0xD0FC19F4 b323
    /// Returns a value based on what the blip is attached to \
    /// 1 - Vehicle \
    /// 2 - Ped \
    /// 3 - Object \
    /// 4 - Coord \
    /// 5 - unk \
    /// 6 - Pickup \
    /// 7 - Radius
    pub inline fn getBlipInfoIdType(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0xBE9B0959FFD0779B, .{blip}); } // 0xBE9B0959FFD0779B 0x501D7B4E b323
    pub inline fn getBlipInfoIdEntityIndex(blip: types.Blip) !types.Entity { return try invoker.invoke(types.Entity, 0x4BA4E2553AFEDC2C, .{blip}); } // 0x4BA4E2553AFEDC2C 0xA068C40B b323
    /// This function is hard-coded to always return 0.
    pub inline fn getBlipInfoIdPickupIndex(blip: types.Blip) !types.Pickup { return try invoker.invoke(types.Pickup, 0x9B6786E4C03DD382, .{blip}); } // 0x9B6786E4C03DD382 0x86913D37 b323
    /// Returns the Blip handle of given Entity.
    pub inline fn getBlipFromEntity(entity: types.Entity) !types.Blip { return try invoker.invoke(types.Blip, 0xBC8DBDCA2436F7E8, .{entity}); } // 0xBC8DBDCA2436F7E8 0x005A2A47 b323
    pub inline fn addBlipForRadius(pos__: types.Vector3, radius: f32) !types.Blip { return try invoker.invoke(types.Blip, 0x46818D79B1F7499A, .{pos__.x, pos__.y, pos__.z, radius}); } // 0x46818D79B1F7499A 0x4626756C b323
    /// Adds a rectangular blip for the specified coordinates/area.
    /// 
    /// It is recommended to use SET_BLIP_ROTATION and SET_BLIP_COLOUR to make the blip not rotate along with the camera.
    /// 
    /// By default, the blip will show as a _regular_ blip with the specified color/sprite if it is outside of the minimap view.
    /// 
    /// Example image: \
    /// minimap https://w.wew.wtf/pdcjig.png \
    /// big map https://w.wew.wtf/zgcjcm.png
    /// 
    /// (Native name is _likely_ to actually be ADD_BLIP_FOR_AREA, but due to the usual reasons this can't be confirmed)
    pub inline fn addBlipForArea(vec: types.Vector3, width: f32, height: f32) !types.Blip { return try invoker.invoke(types.Blip, 0xCE5D0E5E315DB238, .{vec.x, vec.y, vec.z, width, height}); } // 0xCE5D0E5E315DB238  b463
    /// Returns red ( default ) blip attached to entity.
    /// 
    /// Example: \
    /// Blip blip; //Put this outside your case or option \
    /// blip = HUD::ADD_BLIP_FOR_ENTITY(YourPedOrBodyguardName); \
    /// HUD::SET_BLIP_AS_FRIENDLY(blip, true);
    pub inline fn addBlipForEntity(entity: types.Entity) !types.Blip { return try invoker.invoke(types.Blip, 0x5CDE92C702A8FCE7, .{entity}); } // 0x5CDE92C702A8FCE7 0x30822554 b323
    pub inline fn addBlipForPickup(pickup: types.Pickup) !types.Blip { return try invoker.invoke(types.Blip, 0xBE339365C863BD36, .{pickup}); } // 0xBE339365C863BD36 0x16693C3A b323
    /// Creates an orange ( default ) Blip-object. Returns a Blip-object which can then be modified.
    pub inline fn addBlipForCoord(vec: types.Vector3) !types.Blip { return try invoker.invoke(types.Blip, 0x5A039BB0BCA604B6, .{vec.x, vec.y, vec.z}); } // 0x5A039BB0BCA604B6 0xC6F43D0E b323
    pub inline fn triggerSonarBlip(pos__: types.Vector3, radius: f32, p_4: c_int) !void { try invoker.invoke(void, 0x72DD432F3CDFC0EE, .{pos__.x, pos__.y, pos__.z, radius, p_4}); } // 0x72DD432F3CDFC0EE 0xBF25E7B2 b323
    pub inline fn allowSonarBlips(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x60734CC207C9833C, .{toggle}); } // 0x60734CC207C9833C 0xE7E1E32B b323
    pub inline fn setBlipCoords(blip: types.Blip, pos__: types.Vector3) !void { try invoker.invoke(void, 0xAE2AF67E9D9AF65D, .{blip, pos__.x, pos__.y, pos__.z}); } // 0xAE2AF67E9D9AF65D 0x680A34D4 b323
    pub inline fn getBlipCoords(blip: types.Blip) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x586AFE3FF72D996E, .{blip}); } // 0x586AFE3FF72D996E 0xEF6FF47B b323
    /// Sets the displayed sprite for a specific blip..
    /// 
    /// You may have your own list, but since dev-c didn't show it I was bored and started looking through scripts and functions to get a presumable almost positive list of a majority of blip IDs \
    /// https://pastebin.com/Bpj9Sfft
    /// 
    /// Blips Images + IDs: \
    /// https://gtaxscripting.blogspot.com/2016/05/gta-v-blips-id-and-image.html
    pub inline fn setBlipSprite(blip: types.Blip, sprite_id: c_int) !void { try invoker.invoke(void, 0xDF735600A4696DAF, .{blip, sprite_id}); } // 0xDF735600A4696DAF 0x8DBBB0B9 b323
    /// Blips Images + IDs: \
    /// gtaxscripting.blogspot.com/2016/05/gta-v-blips-id-and-image.html
    pub inline fn getBlipSprite(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0x1FC877464A04FC4F, .{blip}); } // 0x1FC877464A04FC4F 0x72FF2E73 b323
    pub inline fn setCopBlipSprite(p_0: c_int, p_1: f32) !void { try invoker.invoke(void, 0x9FCB3CBFB3EAD69A, .{p_0, p_1}); } // 0x9FCB3CBFB3EAD69A  b1734
    pub inline fn setCopBlipSpriteAsStandard() !void { try invoker.invoke(void, 0xB7B873520C84C118, .{}); } // 0xB7B873520C84C118  b1734
    /// Doesn't work if the label text of gxtEntry is >= 80.
    pub inline fn setBlipNameFromTextFile(blip: types.Blip, gxt_entry: [*c]const u8) !void { try invoker.invoke(void, 0xEAA0FFE120D92784, .{blip, gxt_entry}); } // 0xEAA0FFE120D92784 0xAC8A5461 b323
    pub inline fn setBlipNameToPlayerName(blip: types.Blip, player: types.Player) !void { try invoker.invoke(void, 0x127DE7B20C60A6A3, .{blip, player}); } // 0x127DE7B20C60A6A3 0x03A0B8F9 b323
    /// Sets alpha-channel for blip color.
    /// 
    /// Example:
    /// 
    /// Blip blip = HUD::ADD_BLIP_FOR_ENTITY(entity); \
    /// HUD::SET_BLIP_COLOUR(blip , 3); \
    /// HUD::SET_BLIP_ALPHA(blip , 64);
    /// 
    pub inline fn setBlipAlpha(blip: types.Blip, alpha: c_int) !void { try invoker.invoke(void, 0x45FF974EEE1C8734, .{blip, alpha}); } // 0x45FF974EEE1C8734 0xA791FCCD b323
    pub inline fn getBlipAlpha(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0x970F608F0EE6C885, .{blip}); } // 0x970F608F0EE6C885 0x297AF6C8 b323
    pub inline fn setBlipFade(blip: types.Blip, opacity: c_int, duration: c_int) !void { try invoker.invoke(void, 0x2AEE8F8390D2298C, .{blip, opacity, duration}); } // 0x2AEE8F8390D2298C 0xA5999031 b323
    /// Returns -1, 0, +1, depending on if the blip is fading out, doing nothing, or fading in respectively.
    pub inline fn getBlipFadeDirection(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0x2C173AE2BDB9385E, .{blip}); } // 0x2C173AE2BDB9385E  b463
    /// After some testing, looks like you need to use CEIL() on the rotation (vehicle/ped heading) before using it there.
    pub inline fn setBlipRotation(blip: types.Blip, rotation: c_int) !void { try invoker.invoke(void, 0xF87683CDF73C3F6E, .{blip, rotation}); } // 0xF87683CDF73C3F6E 0x6B8F44FE b323
    /// Does not require whole number/integer rotations.
    pub inline fn setBlipRotationWithFloat(blip: types.Blip, heading: f32) !void { try invoker.invoke(void, 0xA8B6AFDAC320AC87, .{blip, heading}); } // 0xA8B6AFDAC320AC87  b877
    pub inline fn getBlipRotation(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0x003E92BA477F9D7F, .{blip}); } // 0x003E92BA477F9D7F  b2060
    /// Adds up after viewing multiple R* scripts. I believe that the duration is in miliseconds.
    pub inline fn setBlipFlashTimer(blip: types.Blip, duration: c_int) !void { try invoker.invoke(void, 0xD3CD6FD297AE87CC, .{blip, duration}); } // 0xD3CD6FD297AE87CC 0x8D5DF611 b323
    pub inline fn setBlipFlashInterval(blip: types.Blip, p_1: types.Any) !void { try invoker.invoke(void, 0xAA51DB313C010A7E, .{blip, p_1}); } // 0xAA51DB313C010A7E 0xEAF67377 b323
    /// https://gtaforums.com/topic/864881-all-blip-color-ids-pictured/
    pub inline fn setBlipColour(blip: types.Blip, color: c_int) !void { try invoker.invoke(void, 0x03D7FB09E75D6B7E, .{blip, color}); } // 0x03D7FB09E75D6B7E 0xBB3C5A41 b323
    /// Can be used to give blips any RGB colour with SET_BLIP_COLOUR(blip, 84).
    pub inline fn setBlipSecondaryColour(blip: types.Blip, r: c_int, g: c_int, b: c_int) !void { try invoker.invoke(void, 0x14892474891E09EB, .{blip, r, g, b}); } // 0x14892474891E09EB 0xC6384D32 b323
    pub inline fn getBlipColour(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0xDF729E8D20CF7327, .{blip}); } // 0xDF729E8D20CF7327 0xDD6A1E54 b323
    pub inline fn getBlipHudColour(blip: types.Blip) !c_int { return try invoker.invoke(c_int, 0x729B5F1EFBC0AAEE, .{blip}); } // 0x729B5F1EFBC0AAEE 0xE88B4BC2 b323
    pub inline fn isBlipShortRange(blip: types.Blip) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDA5F8727EB75B926, .{blip}); } // 0xDA5F8727EB75B926 0x1226765A b323
    pub inline fn isBlipOnMinimap(blip: types.Blip) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE41CA53051197A27, .{blip}); } // 0xE41CA53051197A27 0x258CBA3A b323
    pub inline fn doesBlipHaveGpsRoute(blip: types.Blip) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDD2238F57B977751, .{blip}); } // 0xDD2238F57B977751 0x3E47F357 b323
    pub inline fn setBlipHiddenOnLegend(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x54318C915D27E4CE, .{blip, toggle}); } // 0x54318C915D27E4CE 0x43996428 b323
    pub inline fn setBlipHighDetail(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE2590BC29220CEBB, .{blip, toggle}); } // 0xE2590BC29220CEBB 0xD5842BFF b323
    pub inline fn setBlipAsMissionCreatorBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x24AC0137444F9FD5, .{blip, toggle}); } // 0x24AC0137444F9FD5 0x802FB686 b323
    pub inline fn isMissionCreatorBlip(blip: types.Blip) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x26F49BF3381D933D, .{blip}); } // 0x26F49BF3381D933D 0x24ACC4E9 b323
    pub inline fn getNewSelectedMissionCreatorBlip() !types.Blip { return try invoker.invoke(types.Blip, 0x5C90988E7C8E1AF4, .{}); } // 0x5C90988E7C8E1AF4 0xFFD7476C b323
    pub inline fn isHoveringOverMissionCreatorBlip() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4167EFE0527D706E, .{}); } // 0x4167EFE0527D706E 0xC5EB849A b323
    pub inline fn showStartMissionInstructionalButton(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF1A6C18B35BCADE6, .{toggle}); } // 0xF1A6C18B35BCADE6 0xA2CAAB4F b323
    pub inline fn showContactInstructionalButton(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC772A904CDE1186F, .{toggle}); } // 0xC772A904CDE1186F  b2545
    pub inline fn showPurchaseInstructionalButton_(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF6865E26067B708C, .{toggle}); } // 0xF6865E26067B708C  b3407
    pub inline fn reloadMapMenu() !void { try invoker.invoke(void, 0x2916A928514C9827, .{}); } // 0x2916A928514C9827  b573
    pub inline fn setBlipMarkerLongDistance(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xB552929B85FC27EC, .{p_0, p_1}); } // 0xB552929B85FC27EC  b573
    pub inline fn setBlipFlashes(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB14552383D39CE3E, .{blip, toggle}); } // 0xB14552383D39CE3E 0xC0047F15 b323
    pub inline fn setBlipFlashesAlternate(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2E8D9498C56DD0D1, .{blip, toggle}); } // 0x2E8D9498C56DD0D1 0x1A81202B b323
    pub inline fn isBlipFlashing(blip: types.Blip) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA5E41FD83AD6CEF0, .{blip}); } // 0xA5E41FD83AD6CEF0 0x52E111D7 b323
    /// Sets whether or not the specified blip should only be displayed when nearby, or on the minimap.
    pub inline fn setBlipAsShortRange(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBE8BE4FE60E27B72, .{blip, toggle}); } // 0xBE8BE4FE60E27B72 0x5C67725E b323
    pub inline fn setBlipScale(blip: types.Blip, scale: f32) !void { try invoker.invoke(void, 0xD38744167B2FA257, .{blip, scale}); } // 0xD38744167B2FA257 0x1E6EC434 b323
    /// See https://imgur.com/a/lLkEsMN
    pub inline fn setBlipScale2d(blip: types.Blip, scale__: types.Vector2) !void { try invoker.invoke(void, 0xCD6524439909C979, .{blip, scale__.x, scale__.y}); } // 0xCD6524439909C979  b1734
    /// See this topic for more details : gtaforums.com/topic/717612-v-scriptnative-documentation-and-research/page-35?p=1069477935
    pub inline fn setBlipPriority(blip: types.Blip, priority: c_int) !void { try invoker.invoke(void, 0xAE9FC9EF6A9FAC79, .{blip, priority}); } // 0xAE9FC9EF6A9FAC79 0xCE87DA6F b323
    /// Display Id behaviours: \
    /// 0 = Doesn't show up, ever, anywhere. \
    /// 1 = Doesn't show up, ever, anywhere. \
    /// 2 = Shows on both main map and minimap. (Selectable on map) \
    /// 3 = Shows on main map only. (Selectable on map) \
    /// 4 = Shows on main map only. (Selectable on map) \
    /// 5 = Shows on minimap only. \
    /// 6 = Shows on both main map and minimap. (Selectable on map) \
    /// 7 = Doesn't show up, ever, anywhere. \
    /// 8 = Shows on both main map and minimap. (Not selectable on map) \
    /// 9 = Shows on minimap only. \
    /// 10 = Shows on both main map and minimap. (Not selectable on map)
    /// 
    /// Anything higher than 10 seems to be exactly the same as 10.
    pub inline fn setBlipDisplay(blip: types.Blip, display_id: c_int) !void { try invoker.invoke(void, 0x9029B2F3DA924928, .{blip, display_id}); } // 0x9029B2F3DA924928 0x2B521F91 b323
    /// Example: https://i.imgur.com/skY6vAJ.png
    /// 
    /// Index: \
    /// 1 = No distance shown in legend \
    /// 2 = Distance shown in legend \
    /// 7 = "Other Players" category, also shows distance in legend \
    /// 10 = "Property" category \
    /// 11 = "Owned Property" category
    /// 
    /// Any other value behaves like index = 1, index wraps around after 255 \
    /// Blips with categories 7, 10 or 11 will all show under the specific categories listing in the map legend, regardless of sprite or name. \
    /// Legend entries: \
    /// 7 = Other Players (BLIP_OTHPLYR) \
    /// 10 = Property (BLIP_PROPCAT) \
    /// 11 = Owned Property (BLIP_APARTCAT)
    /// 
    /// Category needs to be `7` in order for blip names to show on the expanded minimap when using DISPLAY_PLAYER_NAME_TAGS_ON_BLIPS.
    pub inline fn setBlipCategory(blip: types.Blip, index: c_int) !void { try invoker.invoke(void, 0x234CDD44D996FD9A, .{blip, index}); } // 0x234CDD44D996FD9A 0xEF72F533 b323
    /// In the C++ SDK, this seems not to work-- the blip isn't removed immediately. I use it for saving cars.
    /// 
    /// E.g.:
    /// 
    /// Ped pped = PLAYER::PLAYER_PED_ID(); \
    /// Vehicle v = PED::GET_VEHICLE_PED_IS_USING(pped); \
    /// Blip b = HUD::ADD_BLIP_FOR_ENTITY(v);
    /// 
    /// works fine. \
    /// But later attempting to delete it with:
    /// 
    /// Blip b = HUD::GET_BLIP_FROM_ENTITY(v); \
    /// if (HUD::DOES_BLIP_EXIST(b)) HUD::REMOVE_BLIP(&b);
    /// 
    /// doesn't work. And yes, doesn't work without the DOES_BLIP_EXIST check either. Also, if you attach multiple blips to the same thing (say, a vehicle), and that thing disappears, the blips randomly attach to other things (in my case, a vehicle).
    /// 
    /// Thus for me, HUD::REMOVE_BLIP(&b) only works if there's one blip, (in my case) the vehicle is marked as no longer needed, you drive away from it and it eventually despawns, AND there is only one blip attached to it. I never intentionally attach multiple blips but if the user saves the car, this adds a blip. Then if they delete it, it is supposed to remove the blip, but it doesn't. Then they can immediately save it again, causing another blip to re-appear. \
    /// -------------
    /// 
    /// Passing the address of the variable instead of the value works for me. \
    /// e.g. \
    /// int blip = HUD::ADD_BLIP_FOR_ENTITY(ped); \
    /// HUD::REMOVE_BLIP(&blip);
    /// 
    /// 
    /// Remove blip will currently crash your game, just artificially remove the blip by setting the sprite to a id that is 'invisible'.
    pub inline fn removeBlip(blip: [*c]types.Blip) !void { try invoker.invoke(void, 0x86A652570E5F25DD, .{blip}); } // 0x86A652570E5F25DD 0xD8C3C1CD b323
    /// false for enemy \
    /// true for friendly
    pub inline fn setBlipAsFriendly(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6F6F290102C02AB4, .{blip, toggle}); } // 0x6F6F290102C02AB4 0xF290CFD8 b323
    pub inline fn pulseBlip(blip: types.Blip) !void { try invoker.invoke(void, 0x742D6FD43115AF73, .{blip}); } // 0x742D6FD43115AF73 0x44253855 b323
    pub inline fn showNumberOnBlip(blip: types.Blip, number: c_int) !void { try invoker.invoke(void, 0xA3C0B359DCB848B6, .{blip, number}); } // 0xA3C0B359DCB848B6 0x7BFC66C6 b323
    pub inline fn hideNumberOnBlip(blip: types.Blip) !void { try invoker.invoke(void, 0x532CFF637EF80148, .{blip}); } // 0x532CFF637EF80148 0x0B6D610D b323
    pub inline fn showHeightOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x75A16C3DA34F1245, .{blip, toggle}); } // 0x75A16C3DA34F1245 0x1D99F676 b323
    /// Adds a green checkmark on top of a blip.
    pub inline fn showTickOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x74513EA3E505181E, .{blip, toggle}); } // 0x74513EA3E505181E 0x3DCF0092 b323
    /// Adds a orange checkmark on top of a given blip handle: https://imgur.com/a/aw5OTMF \
    /// _SHOW_FRIEND_INDICATOR_ON_BLIP* - _SHOW_HEADING_INDICATOR_ON_BLIP*
    pub inline fn showGoldTickOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCAC2031EBF79B1A8, .{blip, toggle}); } // 0xCAC2031EBF79B1A8  b2699
    pub inline fn showForSaleIconOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x19BD6E3C0E16A8FA, .{blip, toggle}); } // 0x19BD6E3C0E16A8FA  b2802
    /// Adds the GTA: Online player heading indicator to a blip.
    pub inline fn showHeadingIndicatorOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5FBCA48327B914DF, .{blip, toggle}); } // 0x5FBCA48327B914DF 0xD1C3D71B b323
    /// Highlights a blip by a cyan color circle.
    /// 
    /// Color can be changed with SET_BLIP_SECONDARY_COLOUR
    pub inline fn showOutlineIndicatorOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB81656BC81FE24D1, .{blip, toggle}); } // 0xB81656BC81FE24D1 0x8DE82C15 b323
    /// Highlights a blip by a half cyan circle on the right side of the blip. https://i.imgur.com/FrV9M4e.png \
    /// .Indicating that that player is a friend (in GTA:O). This color can not be changed. \
    /// To toggle the left side (crew member indicator) of the half circle around the blip, use: `SHOW_CREW_INDICATOR_ON_BLIP`
    pub inline fn showFriendIndicatorOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x23C3EB807312F01A, .{blip, toggle}); } // 0x23C3EB807312F01A 0x4C8F02B4 b323
    /// Enables or disables the blue half circle https://i.imgur.com/iZes9Ec.png around the specified blip on the left side of the blip. This is used to indicate that the player is in your crew in GTA:O. Color is changeable by using `SET_BLIP_SECONDARY_COLOUR`.
    pub inline fn showCrewIndicatorOnBlip(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDCFB5D4DB8BF367E, .{blip, toggle}); } // 0xDCFB5D4DB8BF367E 0xABBE1E45 b323
    /// Must be toggled before being queued for animation
    pub inline fn setBlipExtendedHeightThreshold(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC4278F70131BAA6D, .{blip, toggle}); } // 0xC4278F70131BAA6D 0x6AA6A1CC b323
    pub inline fn setBlipShortHeightThreshold(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x4B5B620C9B59ED34, .{p_0, p_1}); } // 0x4B5B620C9B59ED34  b678
    pub inline fn setBlipUseHeightIndicatorOnEdge(blip: types.Blip, p_1: types.Any) !void { try invoker.invoke(void, 0x2C9F302398E13141, .{blip, p_1}); } // 0x2C9F302398E13141 0xCA95C487 b1103
    /// Makes a blip go small when off the minimap.
    pub inline fn setBlipAsMinimalOnEdge(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2B6D467DAB714E8D, .{blip, toggle}); } // 0x2B6D467DAB714E8D 0xC575F0BC b323
    /// Enabling this on a radius blip will make it outline only. See https://cdn.discordapp.com/attachments/553235301632573459/575132227935928330/unknown.png
    pub inline fn setRadiusBlipEdge(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x25615540D894B814, .{blip, toggle}); } // 0x25615540D894B814 0x40E25DB8 b323
    pub inline fn doesBlipExist(blip: types.Blip) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA6DB27D19ECBB7DA, .{blip}); } // 0xA6DB27D19ECBB7DA 0xAE92DD96 b323
    /// This native removes the current waypoint from the map.
    /// 
    /// Example: \
    /// C#: \
    /// Function.Call(Hash.SET_WAYPOINT_OFF);
    /// 
    /// C++: \
    /// HUD::SET_WAYPOINT_OFF();
    pub inline fn setWaypointOff() !void { try invoker.invoke(void, 0xA7E4E2D361C2627F, .{}); } // 0xA7E4E2D361C2627F 0xB3496E1B b323
    pub inline fn deleteWaypointsFromThisPlayer() !void { try invoker.invoke(void, 0xD8E694757BCEA8E9, .{}); } // 0xD8E694757BCEA8E9 0x62BABF2C b323
    pub inline fn refreshWaypoint() !void { try invoker.invoke(void, 0x81FA173F170560D1, .{}); } // 0x81FA173F170560D1 0xB395D753 b323
    pub inline fn isWaypointActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1DD1F58F493F1DA5, .{}); } // 0x1DD1F58F493F1DA5 0x5E4DF47B b323
    pub inline fn setNewWaypoint(vec: types.Vector2) !void { try invoker.invoke(void, 0xFE43368D2AA4F2FC, .{vec.x, vec.y}); } // 0xFE43368D2AA4F2FC 0x8444E1F0 b323
    pub inline fn getWaypointClearOnArrivalMode() !c_int { return try invoker.invoke(c_int, 0xF46851AB8B02EF40, .{}); } // 0xF46851AB8B02EF40  b3717
    pub inline fn setWaypointClearOnArrivalMode(mode: c_int) !void { try invoker.invoke(void, 0x3FFC556B62146F75, .{mode}); } // 0x3FFC556B62146F75  b3717
    pub inline fn setBlipBright(blip: types.Blip, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB203913733F27884, .{blip, toggle}); } // 0xB203913733F27884 0x72BEE6DF b323
    /// As of b2189, the third parameter sets the color of the cone (before b2189 it was ignored). Note that it uses HUD colors, not blip colors.
    pub inline fn setBlipShowCone(blip: types.Blip, toggle: windows.BOOL, hud_color_index: c_int) !void { try invoker.invoke(void, 0x13127EC3665E8EE1, .{blip, toggle, hud_color_index}); } // 0x13127EC3665E8EE1 0xFF545AD8 b323
    /// Interesting fact: A hash collision for this is RESET_JETPACK_MODEL_SETTINGS
    pub inline fn removeCopBlipFromPed(ped: types.Ped) !void { try invoker.invoke(void, 0xC594B315EDF2D4AF, .{ped}); } // 0xC594B315EDF2D4AF 0x41B0D022 b323
    pub inline fn setupFakeConeData(blip: types.Blip, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: types.Any, p_8: c_int) !void { try invoker.invoke(void, 0xF83D0FEBE75E62C9, .{blip, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0xF83D0FEBE75E62C9  b1290
    pub inline fn removeFakeConeData(blip: types.Blip) !void { try invoker.invoke(void, 0x35A3CD97B2C0A6D2, .{blip}); } // 0x35A3CD97B2C0A6D2  b1290
    pub inline fn clearFakeConeArray() !void { try invoker.invoke(void, 0x8410C5E0CD847B9D, .{}); } // 0x8410C5E0CD847B9D  b1290
    /// Applies to new eBlipParams _BLIP_CHANGE_46* and _BLIP_CHANGE_47*
    pub inline fn setBlipGpsRouteDisplayDistance_(blip: types.Blip, blip_change_param_4_6: c_int, blip_change_param_4_7: windows.BOOL) !void { try invoker.invoke(void, 0x25D984CFB64ED6DE, .{blip, blip_change_param_4_6, blip_change_param_4_7}); } // 0x25D984CFB64ED6DE  b3095
    /// This native is used to colorize certain map components like the army base at the top of the map. \
    /// p2 appears to be always -1. If p2 is -1 then native wouldn't change the color. See https://gfycat.com/SkinnyPinkChupacabra
    pub inline fn setMinimapComponent(component_id: c_int, toggle: windows.BOOL, override_color: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x75A9A10948D1DEA6, .{component_id, toggle, override_color}); } // 0x75A9A10948D1DEA6 0x419DCDC4 b323
    pub inline fn setMinimapSonarSweep(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6B50FC8749632EC1, .{toggle}); } // 0x6B50FC8749632EC1  b2189
    pub inline fn showAccountPicker() !void { try invoker.invoke(void, 0x60E892BA4F5BDCA4, .{}); } // 0x60E892BA4F5BDCA4  b323
    pub inline fn getMainPlayerBlipId() !types.Blip { return try invoker.invoke(types.Blip, 0xDCD4EC3F419D02FA, .{}); } // 0xDCD4EC3F419D02FA 0xAB93F020 b323
    pub inline fn setPmWarningscreenActive(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x41350B4FC28E3941, .{p_0}); } // 0x41350B4FC28E3941  b323
    pub inline fn hideLoadingOnFadeThisFrame() !void { try invoker.invoke(void, 0x4B0311D3CDC4648F, .{}); } // 0x4B0311D3CDC4648F 0x35087963 b323
    /// List of interior hashes: https://pastebin.com/1FUyXNqY \
    /// Not for every interior zoom > 0 available.
    pub inline fn setRadarAsInteriorThisFrame(interior: types.Hash, vec: types.Vector2, z: c_int, zoom: c_int) !void { try invoker.invoke(void, 0x59E727A1C9D3E31A, .{interior, vec.x, vec.y, z, zoom}); } // 0x59E727A1C9D3E31A 0x6F2626E1 b323
    pub inline fn setInsideVerySmallInterior(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x504DFE62A1692296, .{toggle}); } // 0x504DFE62A1692296  b1493
    pub inline fn setInsideVeryLargeInterior(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7EC8ABA5E74B3D7A, .{toggle}); } // 0x7EC8ABA5E74B3D7A  b2372
    pub inline fn setRadarAsExteriorThisFrame() !void { try invoker.invoke(void, 0xE81B7D2A3DAB2D81, .{}); } // 0xE81B7D2A3DAB2D81 0x39ABB10E b323
    /// Sets the position of the arrow icon representing the player on both the minimap and world map.
    /// 
    /// Too bad this wouldn't work over the network (obviously not). Could spoof where we would be.
    pub inline fn setFakePausemapPlayerPositionThisFrame(vec: types.Vector2) !void { try invoker.invoke(void, 0x77E2DD177910E1CF, .{vec.x, vec.y}); } // 0x77E2DD177910E1CF 0x54E75C7D b323
    pub inline fn setFakeGpsPlayerPositionThisFrame(vec: types.Vector3) !void { try invoker.invoke(void, 0xA17784FCA9548D15, .{vec.x, vec.y, vec.z}); } // 0xA17784FCA9548D15  b877
    pub inline fn isPausemapInInteriorMode() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9049FE339D5F6F6F, .{}); } // 0x9049FE339D5F6F6F 0x199DED14 b323
    pub inline fn hideMinimapExteriorMapThisFrame() !void { try invoker.invoke(void, 0x5FBAE526203990C9, .{}); } // 0x5FBAE526203990C9 0x1A4318F7 b323
    pub inline fn hideMinimapInteriorMapThisFrame() !void { try invoker.invoke(void, 0x20FE7FDFEEAD38C0, .{}); } // 0x20FE7FDFEEAD38C0 0xCE36E3FE b323
    /// Toggles the Cayo Perico map.
    pub inline fn setUseIslandMap(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5E1460624D194A38, .{toggle}); } // 0x5E1460624D194A38  b2189
    pub inline fn setPauseExteriorRenderingWhileInInterior_() !void { try invoker.invoke(void, 0x35CCE12EAECB4A51, .{}); } // 0x35CCE12EAECB4A51  b2944
    /// When calling this, the current frame will have the players "arrow icon" be focused on the dead center of the radar.
    pub inline fn dontTiltMinimapThisFrame() !void { try invoker.invoke(void, 0x6D14BFDC33B34F55, .{}); } // 0x6D14BFDC33B34F55 0x334EFD46 b323
    pub inline fn dontZoomMinimapWhenRunningThisFrame() !void { try invoker.invoke(void, 0x89DA85D949CE57A0, .{}); } // 0x89DA85D949CE57A0  b2802
    pub inline fn dontZoomMinimapWhenSnipingThisFrame() !void { try invoker.invoke(void, 0x55F5A5F07134DE60, .{}); } // 0x55F5A5F07134DE60 0x7A569F78 b1180
    pub inline fn setWidescreenFormat(p_0: types.Any) !void { try invoker.invoke(void, 0xC3B07BA00A83B0F1, .{p_0}); } // 0xC3B07BA00A83B0F1 0xF016E08F b323
    pub inline fn displayAreaName(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x276B6CE369C33678, .{toggle}); } // 0x276B6CE369C33678 0x489FDD41 b323
    /// "DISPLAY_CASH(false);" makes the cash amount render on the screen when appropriate \
    /// "DISPLAY_CASH(true);" disables cash amount rendering
    pub inline fn displayCash(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x96DEC8D5430208B7, .{toggle}); } // 0x96DEC8D5430208B7 0x0049DF83 b323
    /// Related to displaying cash on the HUD \
    /// Always called before HUD::CHANGE_FAKE_MP_CASH in decompiled scripts
    pub inline fn useFakeMpCash(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x170F541E1CADD1DE, .{toggle}); } // 0x170F541E1CADD1DE 0x6253B9D7 b323
    /// Displays cash change notifications on HUD.
    pub inline fn changeFakeMpCash(cash: c_int, bank: c_int) !void { try invoker.invoke(void, 0x0772DF77852C2E30, .{cash, bank}); } // 0x0772DF77852C2E30 0xE319F90B b323
    pub inline fn displayAmmoThisFrame(display: windows.BOOL) !void { try invoker.invoke(void, 0xA5E78BA2B1331C55, .{display}); } // 0xA5E78BA2B1331C55 0x60693CEE b323
    /// Displays the crosshair for this frame.
    pub inline fn displaySniperScopeThisFrame() !void { try invoker.invoke(void, 0x73115226F4814E62, .{}); } // 0x73115226F4814E62 0xBC6C73CB b323
    /// Hides HUD and radar this frame and prohibits switching to other weapons (or accessing the weapon wheel)
    pub inline fn hideHudAndRadarThisFrame() !void { try invoker.invoke(void, 0x719FF505F097FD20, .{}); } // 0x719FF505F097FD20 0xB75D4AD2 b323
    /// Controls whether to display 'Cash'/'Bank' next to the money balance HUD in Multiplayer (https://i.imgur.com/MiYUtNl.png)
    pub inline fn allowDisplayOfMultiplayerCashText(allow: windows.BOOL) !void { try invoker.invoke(void, 0xE67C6DFD386EA5E7, .{allow}); } // 0xE67C6DFD386EA5E7 0x5476B9FD b323
    pub inline fn setMultiplayerWalletCash() !void { try invoker.invoke(void, 0xC2D15BEF167E27BC, .{}); } // 0xC2D15BEF167E27BC 0xF4F3C796 b323
    pub inline fn removeMultiplayerWalletCash() !void { try invoker.invoke(void, 0x95CF81BD06EE1887, .{}); } // 0x95CF81BD06EE1887 0x7BFFE82F b323
    pub inline fn setMultiplayerBankCash() !void { try invoker.invoke(void, 0xDD21B55DF695CD0A, .{}); } // 0xDD21B55DF695CD0A 0x2C842D03 b323
    pub inline fn removeMultiplayerBankCash() !void { try invoker.invoke(void, 0xC7C6789AA1CFEDD0, .{}); } // 0xC7C6789AA1CFEDD0 0x728B4EF4 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn setMultiplayerHudCash(p_0: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xFD1D220394BCB824, .{p_0, p_1}); } // 0xFD1D220394BCB824 0xA8DB435E b323
    /// Removes multiplayer cash hud each frame
    pub inline fn removeMultiplayerHudCash() !void { try invoker.invoke(void, 0x968F270E39141ECA, .{}); } // 0x968F270E39141ECA 0x07BF4A7D b323
    pub inline fn hideHelpTextThisFrame() !void { try invoker.invoke(void, 0xD46923FC481CA285, .{}); } // 0xD46923FC481CA285 0xF3807BED b323
    pub inline fn isImeInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x801879A9B4F4B2FB, .{}); } // 0x801879A9B4F4B2FB  b372
    /// The messages are localized strings. \
    /// Examples: \
    /// "No_bus_money" \
    /// "Enter_bus" \
    /// "Tour_help" \
    /// "LETTERS_HELP2" \
    /// "Dummy"
    /// 
    /// **The bool appears to always be false (if it even is a bool, as it's represented by a zero)** \
    /// -------- \
    /// p1 doesn't seem to make a difference, regardless of the state it's in. 
    /// 
    /// 
    /// picture of where on the screen this is displayed? 
    pub inline fn displayHelpTextThisFrame(message: [*c]const u8, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x960C9FF8F616E41C, .{message, p_1}); } // 0x960C9FF8F616E41C 0x18E3360A b323
    /// Forces the weapon wheel to show/hide.
    pub inline fn hudForceWeaponWheel(show: windows.BOOL) !void { try invoker.invoke(void, 0xEB354E5376BC81A7, .{show}); } // 0xEB354E5376BC81A7 0x1EFFB02A b323
    /// Displays "blazer_wheels_up" and "blazer_wheels_down" "weapon" icons when switching between jetski and quadbike modes. Works only on vehicles using "VEHICLE_TYPE_AMPHIBIOUS_QUADBIKE" vehicle type. Needs to be called every time prior to switching modes, otherwise the icon will only appear when switching modes once.
    pub inline fn hudForceSpecialVehicleWeaponWheel() !void { try invoker.invoke(void, 0x488043841BBE156F, .{}); } // 0x488043841BBE156F  b1011
    /// Calling this each frame, stops the player from receiving a weapon via the weapon wheel.
    pub inline fn hudSuppressWeaponWheelResultsThisFrame() !void { try invoker.invoke(void, 0x0AFC4AF510774B47, .{}); } // 0x0AFC4AF510774B47 0xB26FED2B b323
    /// Returns the weapon hash to the selected/highlighted weapon in the wheel
    pub inline fn hudGetWeaponWheelCurrentlyHighlighted() !types.Hash { return try invoker.invoke(types.Hash, 0xA48931185F0536FE, .{}); } // 0xA48931185F0536FE 0x22E9F555 b323
    /// Set the active slotIndex in the wheel weapon to the slot associated with the provided Weapon hash
    pub inline fn hudSetWeaponWheelTopSlot(weapon_hash: types.Hash) !void { try invoker.invoke(void, 0x72C1056D678BB7D8, .{weapon_hash}); } // 0x72C1056D678BB7D8 0x83B608A0 b323
    /// Returns the weapon hash active in a specific weapon wheel slotList
    pub inline fn hudGetWeaponWheelTopSlot(weapon_type_index: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0xA13E93403F26C812, .{weapon_type_index}); } // 0xA13E93403F26C812  b323
    /// Sets a global that disables many weapon input tasks (shooting, aiming, etc.). Does not work with vehicle weapons, only used in selector.ysc
    pub inline fn hudShowingCharacterSwitchSelection(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x14C9FDCC41F81F63, .{toggle}); } // 0x14C9FDCC41F81F63 0xE70D1F43 b323
    /// Only the script that originally called SET_GPS_FLAGS can set them again. Another script cannot set the flags, until the first script that called it has called CLEAR_GPS_FLAGS.
    /// 
    /// Doesn't seem like the flags are actually read by the game at all.
    pub inline fn setGpsFlags(p_0: c_int, p_1: f32) !void { try invoker.invoke(void, 0x5B440763A4C8D15B, .{p_0, p_1}); } // 0x5B440763A4C8D15B 0x60539BAB b323
    /// Clears the GPS flags. Only the script that originally called SET_GPS_FLAGS can clear them.
    /// 
    /// Doesn't seem like the flags are actually read by the game at all.
    pub inline fn clearGpsFlags() !void { try invoker.invoke(void, 0x21986729D6A3A830, .{}); } // 0x21986729D6A3A830 0x056AFCE6 b323
    pub inline fn setRaceTrackRender(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1EAC5F91BCBC5073, .{toggle}); } // 0x1EAC5F91BCBC5073 0xFB9BABF5 b323
    /// Does the same as SET_RACE_TRACK_RENDER(false);
    pub inline fn clearGpsRaceTrack() !void { try invoker.invoke(void, 0x7AA5B4CE533C858B, .{}); } // 0x7AA5B4CE533C858B 0x40C59829 b323
    /// Starts a new GPS custom-route, allowing you to plot lines on the map. \
    /// Lines are drawn directly between points. \
    /// The GPS custom route works like the GPS multi route, except it does not follow roads. \
    /// Example result: https://i.imgur.com/BDm5pzt.png \
    /// hudColor: The HUD color of the GPS path. \
    /// displayOnFoot: Draws the path regardless if the player is in a vehicle or not. \
    /// followPlayer: Draw the path partially between the previous and next point based on the players position between them. When false, the GPS appears to not disappear after the last leg is completed.
    pub inline fn startGpsCustomRoute(hud_color: c_int, display_on_foot: windows.BOOL, follow_player: windows.BOOL) !void { try invoker.invoke(void, 0xDB34E8D56FC13B08, .{hud_color, display_on_foot, follow_player}); } // 0xDB34E8D56FC13B08 0x7F93799B b323
    pub inline fn addPointToGpsCustomRoute(vec: types.Vector3) !void { try invoker.invoke(void, 0x311438A071DD9B1A, .{vec.x, vec.y, vec.z}); } // 0x311438A071DD9B1A 0xEEBDFE55 b323
    /// radarThickness: The width of the GPS route on the radar \
    /// mapThickness: The width of the GPS route on the map
    pub inline fn setGpsCustomRouteRender(toggle: windows.BOOL, radar_thickness: c_int, map_thickness: c_int) !void { try invoker.invoke(void, 0x900086F371220B6F, .{toggle, radar_thickness, map_thickness}); } // 0x900086F371220B6F 0xDA0AF00E b323
    pub inline fn clearGpsCustomRoute() !void { try invoker.invoke(void, 0xE6DE0561D9232A64, .{}); } // 0xE6DE0561D9232A64 0xCF2E3E24 b323
    /// Starts a new GPS multi-route, allowing you to create custom GPS paths. \
    /// GPS functions like the waypoint, except it can contain multiple points it's forced to go through. \
    /// Once the player has passed a point, the GPS will no longer force its path through it.
    /// 
    /// Works independently from the player-placed waypoint and blip routes. \
    /// Example result: https://i.imgur.com/ZZHQatX.png \
    /// hudColor: The HUD color of the GPS path. \
    /// routeFromPlayer: Makes the GPS draw a path from the player to the next point, rather than the original path from the previous point. \
    /// displayOnFoot: Draws the GPS path regardless if the player is in a vehicle or not.
    pub inline fn startGpsMultiRoute(hud_color: c_int, route_from_player: windows.BOOL, display_on_foot: windows.BOOL) !void { try invoker.invoke(void, 0x3D3D15AF7BCAAF83, .{hud_color, route_from_player, display_on_foot}); } // 0x3D3D15AF7BCAAF83 0xC3DCBEDB b323
    pub inline fn addPointToGpsMultiRoute(vec: types.Vector3) !void { try invoker.invoke(void, 0xA905192A6781C41B, .{vec.x, vec.y, vec.z}); } // 0xA905192A6781C41B 0xFE485135 b323
    pub inline fn setGpsMultiRouteRender(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3DDA37128DD1ACA8, .{toggle}); } // 0x3DDA37128DD1ACA8 0xE87CBE4C b323
    /// Does the same as SET_GPS_MULTI_ROUTE_RENDER(false);
    pub inline fn clearGpsMultiRoute() !void { try invoker.invoke(void, 0x67EEDEA1B9BAFD94, .{}); } // 0x67EEDEA1B9BAFD94 0x0D9969E4 b323
    pub inline fn clearGpsPlayerWaypoint() !void { try invoker.invoke(void, 0xFF4FB7C8CDFA3DA7, .{}); } // 0xFF4FB7C8CDFA3DA7 0x0B9C7FC2 b323
    pub inline fn setGpsFlashes(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x320D0E0D936A0E9B, .{toggle}); } // 0x320D0E0D936A0E9B 0xE991F733 b323
    pub inline fn setPlayerIconColour(color: c_int) !void { try invoker.invoke(void, 0x7B21E0BB01E8224A, .{color}); } // 0x7B21E0BB01E8224A  b323
    /// adds a short flash to the Radar/Minimap \
    /// Usage: UI.FLASH_MINIMAP_DISPLAY
    pub inline fn flashMinimapDisplay() !void { try invoker.invoke(void, 0xF2DD778C22B15BDA, .{}); } // 0xF2DD778C22B15BDA 0xB8359952 b323
    pub inline fn flashMinimapDisplayWithColor(hud_color_index: c_int) !void { try invoker.invoke(void, 0x6B1DE27EE78E6A19, .{hud_color_index}); } // 0x6B1DE27EE78E6A19 0x79A6CAF6 b323
    pub inline fn toggleStealthRadar(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6AFDFB93754950C7, .{toggle}); } // 0x6AFDFB93754950C7 0xC68D47C4 b323
    pub inline fn setMinimapInSpectatorMode(toggle: windows.BOOL, ped: types.Ped) !void { try invoker.invoke(void, 0x1A5CD7752DD28CD3, .{toggle, ped}); } // 0x1A5CD7752DD28CD3 0xD5BFCADB b323
    pub inline fn setMissionName(p_0: windows.BOOL, name: [*c]const u8) !void { try invoker.invoke(void, 0x5F28ECF5FC84772F, .{p_0, name}); } // 0x5F28ECF5FC84772F 0x68DCAE10 b323
    pub inline fn setMissionNameForUgcMission(p_0: windows.BOOL, name: [*c]const u8) !void { try invoker.invoke(void, 0xE45087D85F468BC2, .{p_0, name}); } // 0xE45087D85F468BC2 0x8D9A1734 b323
    pub inline fn setDescriptionForUgcMissionEightStrings(p_0: windows.BOOL, p_1: [*c]const u8, p_2: [*c]const u8, p_3: [*c]const u8, p_4: [*c]const u8, p_5: [*c]const u8, p_6: [*c]const u8, p_7: [*c]const u8, p_8: [*c]const u8) !void { try invoker.invoke(void, 0x817B86108EB94E51, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0x817B86108EB94E51 0xD2161E77 b323
    pub inline fn setMinimapBlockWaypoint(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x58FADDED207897DC, .{toggle}); } // 0x58FADDED207897DC 0xA41C3B62 b323
    /// Toggles the North Yankton map
    pub inline fn setMinimapInPrologue(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9133955F1A2DA957, .{toggle}); } // 0x9133955F1A2DA957 0x02F5F1D1 b323
    /// This native does absolutely nothing on PC master builds, just a nullsub.
    pub inline fn setMinimapBackgroundHidden(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB09D42557C45EBA1, .{toggle}); } // 0xB09D42557C45EBA1  b3258
    /// If true, the entire map will be revealed.
    /// 
    /// FOW = Fog of War
    pub inline fn setMinimapHideFow(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF8DEE0A5600CBB93, .{toggle}); } // 0xF8DEE0A5600CBB93 0xD8D77733 b323
    pub inline fn getMinimapFowDiscoveryRatio() !f32 { return try invoker.invoke(f32, 0xE0130B41D3CF4574, .{}); } // 0xE0130B41D3CF4574 0xA4098ACC b323
    pub inline fn getMinimapFowCoordinateIsRevealed(vec: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6E31B91145873922, .{vec.x, vec.y, vec.z}); } // 0x6E31B91145873922 0x65B705F6 b323
    pub inline fn setMinimapFowDoNotUpdate(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x62E849B7EB28E770, .{p_0}); } // 0x62E849B7EB28E770  b323
    /// Up to eight coordinates may be revealed per frame
    pub inline fn setMinimapFowRevealCoordinate(vec: types.Vector3) !void { try invoker.invoke(void, 0x0923DBF87DFF735E, .{vec.x, vec.y, vec.z}); } // 0x0923DBF87DFF735E 0xE010F081 b323
    /// Not much is known so far on what it does _exactly_. \
    /// All I know for sure is that it draws the specified hole ID on the pause menu map as well as on the mini-map/radar. This native also seems to change some other things related to the pause menu map's behaviour, for example: you can no longer set waypoints, the pause menu map starts up in a 'zoomed in' state. This native does not need to be executed every tick. \
    /// You need to center the minimap manually as well as change/lock it's zoom and angle in order for it to appear correctly on the minimap. \
    /// You'll also need to use the `GOLF` scaleform in order to get the correct minmap border to show up. \
    /// Use `0x35edd5b2e3ff01c0` to reset the map when you no longer want to display any golf holes (you still need to unlock zoom, position and angle of the radar manually after calling this).
    pub inline fn setMinimapGolfCourse(hole: c_int) !void { try invoker.invoke(void, 0x71BDB63DBAF8DA59, .{hole}); } // 0x71BDB63DBAF8DA59 0x5133A750 b323
    pub inline fn setMinimapGolfCourseOff() !void { try invoker.invoke(void, 0x35EDD5B2E3FF01C0, .{}); } // 0x35EDD5B2E3FF01C0 0x20FD3E87 b323
    /// Locks the minimap to the specified angle in integer degrees.
    /// 
    /// angle: The angle in whole degrees. If less than 0 or greater than 360, unlocks the angle.
    pub inline fn lockMinimapAngle(angle: c_int) !void { try invoker.invoke(void, 0x299FAEBB108AE05B, .{angle}); } // 0x299FAEBB108AE05B 0xDEC733E4 b323
    pub inline fn unlockMinimapAngle() !void { try invoker.invoke(void, 0x8183455E16C42E3A, .{}); } // 0x8183455E16C42E3A 0x742043F9 b323
    /// Locks the minimap to the specified world position.
    pub inline fn lockMinimapPosition(vec: types.Vector2) !void { try invoker.invoke(void, 0x1279E861A329E73F, .{vec.x, vec.y}); } // 0x1279E861A329E73F 0xB9632A91 b323
    pub inline fn unlockMinimapPosition() !void { try invoker.invoke(void, 0x3E93E06DB8EF1F30, .{}); } // 0x3E93E06DB8EF1F30 0x5E8E6F54 b323
    /// Argument must be 0.0f or above 38.0f, or it will be ignored.
    pub inline fn setFakeMinimapMaxAltimeterHeight(altitude: f32, p_1: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0xD201F3FF917A506D, .{altitude, p_1, p_2}); } // 0xD201F3FF917A506D 0x0308EDF6 b323
    pub inline fn setHealthHudDisplayValues(health: c_int, capacity: c_int, was_added: windows.BOOL) !void { try invoker.invoke(void, 0x3F5CC444DCAAA8F2, .{health, capacity, was_added}); } // 0x3F5CC444DCAAA8F2 0x7FB6FB2A b323
    pub inline fn setMaxHealthHudDisplay(maximum_value: c_int) !void { try invoker.invoke(void, 0x975D66A0BC17064C, .{maximum_value}); } // 0x975D66A0BC17064C 0xF07D8CEF b323
    pub inline fn setMaxArmourHudDisplay(maximum_value: c_int) !void { try invoker.invoke(void, 0x06A320535F5F0248, .{maximum_value}); } // 0x06A320535F5F0248 0x827F14DE b323
    /// Toggles the big minimap state like in GTA:Online.
    pub inline fn setBigmapActive(toggle_big_map: windows.BOOL, show_full_map: windows.BOOL) !void { try invoker.invoke(void, 0x231C8F89D0539D8F, .{toggle_big_map, show_full_map}); } // 0x231C8F89D0539D8F 0x08EB83D2 b323
    /// Full list of components below
    /// 
    /// HUD = 0; \
    /// HUD_WANTED_STARS = 1; \
    /// HUD_WEAPON_ICON = 2; \
    /// HUD_CASH = 3; \
    /// HUD_MP_CASH = 4; \
    /// HUD_MP_MESSAGE = 5; \
    /// HUD_VEHICLE_NAME = 6; \
    /// HUD_AREA_NAME = 7; \
    /// HUD_VEHICLE_CLASS = 8; \
    /// HUD_STREET_NAME = 9; \
    /// HUD_HELP_TEXT = 10; \
    /// HUD_FLOATING_HELP_TEXT_1 = 11; \
    /// HUD_FLOATING_HELP_TEXT_2 = 12; \
    /// HUD_CASH_CHANGE = 13; \
    /// HUD_RETICLE = 14; \
    /// HUD_SUBTITLE_TEXT = 15; \
    /// HUD_RADIO_STATIONS = 16; \
    /// HUD_SAVING_GAME = 17; \
    /// HUD_GAME_STREAM = 18; \
    /// HUD_WEAPON_WHEEL = 19; \
    /// HUD_WEAPON_WHEEL_STATS = 20; \
    /// MAX_HUD_COMPONENTS = 21; \
    /// MAX_HUD_WEAPONS = 22; \
    /// MAX_SCRIPTED_HUD_COMPONENTS = 141;
    pub inline fn isHudComponentActive(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC4C9EA5391ECC0D, .{id}); } // 0xBC4C9EA5391ECC0D 0x6214631F b323
    pub inline fn isScriptedHudComponentActive(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDD100EB17A94FF65, .{id}); } // 0xDD100EB17A94FF65 0x2B86F382 b323
    pub inline fn hideScriptedHudComponentThisFrame(id: c_int) !void { try invoker.invoke(void, 0xE374C498D8BADC14, .{id}); } // 0xE374C498D8BADC14 0x31ABA127 b323
    pub inline fn showScriptedHudComponentThisFrame(id: c_int) !void { try invoker.invoke(void, 0x4F38DCA127DAAEA2, .{id}); } // 0x4F38DCA127DAAEA2  b1734
    pub inline fn isScriptedHudComponentHiddenThisFrame(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x09C0403ED9A751C2, .{id}); } // 0x09C0403ED9A751C2 0xE8C8E535 b323
    /// This function hides various HUD (Heads-up Display) components. \
    /// Listed below are the integers and the corresponding HUD component. \
    /// - 1 : WANTED_STARS \
    /// - 2 : WEAPON_ICON \
    /// - 3 : CASH \
    /// - 4 : MP_CASH \
    /// - 5 : MP_MESSAGE \
    /// - 6 : VEHICLE_NAME \
    /// - 7 : AREA_NAME \
    /// - 8 : VEHICLE_CLASS \
    /// - 9 : STREET_NAME \
    /// - 10 : HELP_TEXT \
    /// - 11 : FLOATING_HELP_TEXT_1 \
    /// - 12 : FLOATING_HELP_TEXT_2 \
    /// - 13 : CASH_CHANGE \
    /// - 14 : RETICLE \
    /// - 15 : SUBTITLE_TEXT \
    /// - 16 : RADIO_STATIONS \
    /// - 17 : SAVING_GAME \
    /// - 18 : GAME_STREAM \
    /// - 19 : WEAPON_WHEEL \
    /// - 20 : WEAPON_WHEEL_STATS \
    /// - 21 : HUD_COMPONENTS \
    /// - 22 : HUD_WEAPONS
    /// 
    /// These integers also work for the `SHOW_HUD_COMPONENT_THIS_FRAME` native, but instead shows the HUD Component.
    pub inline fn hideHudComponentThisFrame(id: c_int) !void { try invoker.invoke(void, 0x6806C51AD12B83B8, .{id}); } // 0x6806C51AD12B83B8 0xDB2D0762 b323
    pub inline fn isHudComponentHiddenThisFrame(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8EDC335C943465C8, .{id}); } // 0x8EDC335C943465C8  b3717
    /// This function hides various HUD (Heads-up Display) components. \
    /// Listed below are the integers and the corresponding HUD component. \
    /// - 1 : WANTED_STARS \
    /// - 2 : WEAPON_ICON \
    /// - 3 : CASH \
    /// - 4 : MP_CASH \
    /// - 5 : MP_MESSAGE \
    /// - 6 : VEHICLE_NAME \
    /// - 7 : AREA_NAME \
    /// - 8 : VEHICLE_CLASS \
    /// - 9 : STREET_NAME \
    /// - 10 : HELP_TEXT \
    /// - 11 : FLOATING_HELP_TEXT_1 \
    /// - 12 : FLOATING_HELP_TEXT_2 \
    /// - 13 : CASH_CHANGE \
    /// - 14 : RETICLE \
    /// - 15 : SUBTITLE_TEXT \
    /// - 16 : RADIO_STATIONS \
    /// - 17 : SAVING_GAME \
    /// - 18 : GAME_STREAM \
    /// - 19 : WEAPON_WHEEL \
    /// - 20 : WEAPON_WHEEL_STATS \
    /// - 21 : HUD_COMPONENTS \
    /// - 22 : HUD_WEAPONS
    /// 
    /// These integers also work for the `HIDE_HUD_COMPONENT_THIS_FRAME` native, but instead hides the HUD Component.
    pub inline fn showHudComponentThisFrame(id: c_int) !void { try invoker.invoke(void, 0x0B4DF1FA60C0E664, .{id}); } // 0x0B4DF1FA60C0E664 0x95E1546E b323
    /// Hides area and vehicle name HUD components for one frame.
    pub inline fn hideStreetAndCarNamesThisFrame() !void { try invoker.invoke(void, 0xA4DEDE28B1814289, .{}); } // 0xA4DEDE28B1814289 0x52746FE1 b323
    pub inline fn resetReticuleValues() !void { try invoker.invoke(void, 0x12782CE0A636E9F0, .{}); } // 0x12782CE0A636E9F0 0xBE27AA3F b323
    pub inline fn resetHudComponentValues(id: c_int) !void { try invoker.invoke(void, 0x450930E616475D0D, .{id}); } // 0x450930E616475D0D 0xD15B46DA b323
    pub inline fn setHudComponentPosition(id: c_int, vec: types.Vector2) !void { try invoker.invoke(void, 0xAABB1F56E2A17CED, .{id, vec.x, vec.y}); } // 0xAABB1F56E2A17CED 0x2F3A0D15 b323
    pub inline fn getHudComponentPosition(id: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x223CA69A8C4417FD, .{id}); } // 0x223CA69A8C4417FD 0x080DCED6 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn clearReminderMessage() !void { try invoker.invoke(void, 0xB57D8DD645CFA2CF, .{}); } // 0xB57D8DD645CFA2CF 0x5BBCC934 b323
    /// World to relative screen coords, this world to screen will keep the text on screen. Was named _GET_SCREEN_COORD_FROM_WORLD_COORD, but this conflicts with 0x34E82F05DF2974F5. As that hash actually matches GET_SCREEN_COORD_FROM_WORLD_COORD that one supercedes and this one was renamed to _GET_2D_COORD_FROM_3D_COORD
    pub inline fn getHudScreenPositionFromWorldPosition(world__: types.Vector3, screen_x: [*c]f32, screen_y: [*c]f32) !c_int { return try invoker.invoke(c_int, 0xF9904D11F1ACBEC3, .{world__.x, world__.y, world__.z, screen_x, screen_y}); } // 0xF9904D11F1ACBEC3 0xFE9A39F8 b323
    /// Shows a menu for reporting UGC content.
    pub inline fn openReportugcMenu() !void { try invoker.invoke(void, 0x523A590C1A3CC0D3, .{}); } // 0x523A590C1A3CC0D3 0x10DE5150 b323
    pub inline fn forceCloseReportugcMenu() !void { try invoker.invoke(void, 0xEE4C0E6DBC6F2C6F, .{}); } // 0xEE4C0E6DBC6F2C6F 0x67649EE0 b323
    pub inline fn isReportugcMenuOpen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9135584D09A3437E, .{}); } // 0x9135584D09A3437E 0x9D2C94FA b323
    pub inline fn isFloatingHelpTextOnScreen(hud_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2432784ACA090DA4, .{hud_index}); } // 0x2432784ACA090DA4 0x45472FD5 b323
    pub inline fn setFloatingHelpTextScreenPosition(hud_index: c_int, vec: types.Vector2) !void { try invoker.invoke(void, 0x7679CC1BCEBE3D4C, .{hud_index, vec.x, vec.y}); } // 0x7679CC1BCEBE3D4C 0x198F32D7 b323
    pub inline fn setFloatingHelpTextWorldPosition(hud_index: c_int, vec: types.Vector3) !void { try invoker.invoke(void, 0x784BA7E0ECEB4178, .{hud_index, vec.x, vec.y, vec.z}); } // 0x784BA7E0ECEB4178 0x93045157 b323
    pub inline fn setFloatingHelpTextToEntity(hud_index: c_int, entity: types.Entity, offset__: types.Vector2) !void { try invoker.invoke(void, 0xB094BC1DB4018240, .{hud_index, entity, offset__.x, offset__.y}); } // 0xB094BC1DB4018240 0x18B012B7 b323
    pub inline fn setFloatingHelpTextStyle(hud_index: c_int, p_1: c_int, p_2: c_int, p_3: c_int, p_4: c_int, p_5: c_int) !void { try invoker.invoke(void, 0x788E7FD431BD67F1, .{hud_index, p_1, p_2, p_3, p_4, p_5}); } // 0x788E7FD431BD67F1 0x97852A82 b323
    pub inline fn clearFloatingHelp(hud_index: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x50085246ABD3FEFA, .{hud_index, p_1}); } // 0x50085246ABD3FEFA 0xB181F88F b323
    /// clanFlag: takes a number 0-5
    pub inline fn createMpGamerTagWithCrewColor(player: types.Player, username: [*c]const u8, pointed_clan_tag: windows.BOOL, is_rockstar_clan: windows.BOOL, clan_tag: [*c]const u8, clan_flag: c_int, r: c_int, g: c_int, b: c_int) !void { try invoker.invoke(void, 0x6DD05E9D83EFA4C9, .{player, username, pointed_clan_tag, is_rockstar_clan, clan_tag, clan_flag, r, g, b}); } // 0x6DD05E9D83EFA4C9 0xC969F2D0 b323
    pub inline fn isMpGamerTagMovieActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6E0EB3EB47C8D7AA, .{}); } // 0x6E0EB3EB47C8D7AA 0xEFD2564A b323
    /// clanFlag: takes a number 0-5
    pub inline fn createFakeMpGamerTag(ped: types.Ped, username: [*c]const u8, pointed_clan_tag: windows.BOOL, is_rockstar_clan: windows.BOOL, clan_tag: [*c]const u8, clan_flag: c_int) !c_int { return try invoker.invoke(c_int, 0xBFEFE3321A3F5015, .{ped, username, pointed_clan_tag, is_rockstar_clan, clan_tag, clan_flag}); } // 0xBFEFE3321A3F5015 0xF5CD2AA4 b323
    pub inline fn removeMpGamerTag(gamer_tag_id: c_int) !void { try invoker.invoke(void, 0x31698AA80E0223F8, .{gamer_tag_id}); } // 0x31698AA80E0223F8 0x3D081FE4 b323
    pub inline fn isMpGamerTagActive(gamer_tag_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4E929E7A5796FD26, .{gamer_tag_id}); } // 0x4E929E7A5796FD26 0x60118951 b323
    pub inline fn isMpGamerTagFree(gamer_tag_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x595B5178E412E199, .{gamer_tag_id}); } // 0x595B5178E412E199 0x63959059 b323
    /// enum eMpGamerTagComponent \
    /// { \
    ///     MP_TAG_GAMER_NAME,
    ///     MP_TAG_CREW_TAG,
    ///     MP_TAG_HEALTH_ARMOUR,
    ///     MP_TAG_BIG_TEXT,
    ///     MP_TAG_AUDIO_ICON,
    ///     MP_TAG_USING_MENU,
    ///     MP_TAG_PASSIVE_MODE,
    ///     MP_TAG_WANTED_STARS,
    ///     MP_TAG_DRIVER,
    ///     MP_TAG_CO_DRIVER,
    ///     MP_TAG_TAGGED,
    ///     MP_TAG_GAMER_NAME_NEARBY,
    ///     MP_TAG_ARROW,
    ///     MP_TAG_PACKAGES,
    ///     MP_TAG_INV_IF_PED_FOLLOWING,
    ///     MP_TAG_RANK_TEXT,
    ///     MP_TAG_TYPING,
    ///     MP_TAG_BAG_LARGE,
    ///     MP_TAG_ARROW,
    ///     MP_TAG_GANG_CEO,
    ///     MP_TAG_GANG_BIKER,
    ///     MP_TAG_BIKER_ARROW,
    ///     MP_TAG_MC_ROLE_PRESIDENT,
    ///     MP_TAG_MC_ROLE_VICE_PRESIDENT,
    ///     MP_TAG_MC_ROLE_ROAD_CAPTAIN,
    ///     MP_TAG_MC_ROLE_SARGEANT,
    ///     MP_TAG_MC_ROLE_ENFORCER,
    ///     MP_TAG_MC_ROLE_PROSPECT,
    ///     MP_TAG_TRANSMITTER,
    ///     MP_TAG_BOMB
    /// };
    pub inline fn setMpGamerTagVisibility(gamer_tag_id: c_int, component: c_int, toggle: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x63BB75ABEDC1F6A0, .{gamer_tag_id, component, toggle, p_3}); } // 0x63BB75ABEDC1F6A0 0xD41DF479 b323
    pub inline fn setAllMpGamerTagsVisibility(gamer_tag_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEE76FF7E6A0166B0, .{gamer_tag_id, toggle}); } // 0xEE76FF7E6A0166B0 0x767DED29 b323
    /// Displays a bunch of icons above the players name, and level, and their name twice
    pub inline fn setMpGamerTagsShouldUseVehicleHealth(gamer_tag_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA67F9C46D612B6F1, .{gamer_tag_id, toggle}); } // 0xA67F9C46D612B6F1 0xB01A5434 b323
    pub inline fn setMpGamerTagsShouldUsePointsHealth(gamer_tag_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD29EC58C2F6B5014, .{gamer_tag_id, toggle}); } // 0xD29EC58C2F6B5014  b1365
    pub inline fn setMpGamerTagsPointHealth(gamer_tag_id: c_int, value: c_int, maximum_value: c_int) !void { try invoker.invoke(void, 0x1563FE35E9928E67, .{gamer_tag_id, value, maximum_value}); } // 0x1563FE35E9928E67  b1365
    /// Sets a gamer tag's component colour
    /// 
    /// gamerTagId is obtained using for example CREATE_FAKE_MP_GAMER_TAG \
    /// Ranges from 0 to 255. 0 is grey health bar, ~50 yellow, 200 purple.
    pub inline fn setMpGamerTagColour(gamer_tag_id: c_int, component: c_int, hud_color_index: c_int) !void { try invoker.invoke(void, 0x613ED644950626AE, .{gamer_tag_id, component, hud_color_index}); } // 0x613ED644950626AE 0x7E3AA40A b323
    /// Ranges from 0 to 255. 0 is grey health bar, ~50 yellow, 200 purple. \
    /// Should be enabled as flag (2). Has 0 opacity by default.
    /// 
    /// - This was _SET_MP_GAMER_TAG_HEALTH_BAR_COLOR, \
    /// -> Rockstar use the EU spelling of 'color' so I hashed the same name with COLOUR and it came back as the correct hash, so it has been corrected above.
    pub inline fn setMpGamerTagHealthBarColour(gamer_tag_id: c_int, hud_color_index: c_int) !void { try invoker.invoke(void, 0x3158C77A7E888AB4, .{gamer_tag_id, hud_color_index}); } // 0x3158C77A7E888AB4 0x5777EC77 b323
    /// Sets flag's sprite transparency. 0-255.
    pub inline fn setMpGamerTagAlpha(gamer_tag_id: c_int, component: c_int, alpha: c_int) !void { try invoker.invoke(void, 0xD48FE545CD46F857, .{gamer_tag_id, component, alpha}); } // 0xD48FE545CD46F857 0xF4418611 b323
    /// displays wanted star above head
    pub inline fn setMpGamerTagWantedLevel(gamer_tag_id: c_int, wantedlvl: c_int) !void { try invoker.invoke(void, 0xCF228E2AA03099C3, .{gamer_tag_id, wantedlvl}); } // 0xCF228E2AA03099C3 0x0EBB003F b323
    pub inline fn setMpGamerTagNumPackages(gamer_tag_id: c_int, p_1: c_int) !void { try invoker.invoke(void, 0x9C16459B2324B2CF, .{gamer_tag_id, p_1}); } // 0x9C16459B2324B2CF  b877
    pub inline fn setMpGamerTagName(gamer_tag_id: c_int, string: [*c]const u8) !void { try invoker.invoke(void, 0xDEA2B8283BAA3944, .{gamer_tag_id, string}); } // 0xDEA2B8283BAA3944 0x627A559B b323
    pub inline fn isUpdatingMpGamerTagNameAndCrewDetails(gamer_tag_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEB709A36958ABE0D, .{gamer_tag_id}); } // 0xEB709A36958ABE0D 0xF11414C4 b323
    pub inline fn setMpGamerTagBigText(gamer_tag_id: c_int, string: [*c]const u8) !void { try invoker.invoke(void, 0x7B7723747CCB55B6, .{gamer_tag_id, string}); } // 0x7B7723747CCB55B6 0x939218AB b323
    pub inline fn getCurrentWebpageId() !c_int { return try invoker.invoke(c_int, 0x01A358D9128B7A86, .{}); } // 0x01A358D9128B7A86 0xAB5B7C18 b323
    pub inline fn getCurrentWebsiteId() !c_int { return try invoker.invoke(c_int, 0x97D47996FC48CBAD, .{}); } // 0x97D47996FC48CBAD 0x42A55B14 b323
    /// Returns the ActionScript flagValue. \
    /// ActionScript flags are global flags that scaleforms use \
    /// Flags found during testing \
    /// 0: Returns 1 if the web_browser keyboard is open, otherwise 0 \
    /// 1: Returns 1 if the player has clicked back twice on the opening page, otherwise 0 (web_browser) \
    /// 2: Returns how many links the player has clicked in the web_browser scaleform, returns 0 when the browser gets closed \
    /// 9: Returns the current selection on the mobile phone scaleform
    /// 
    /// There are 20 flags in total.
    pub inline fn getGlobalActionscriptFlag(flag_index: c_int) !c_int { return try invoker.invoke(c_int, 0xE3B05614DCE1D014, .{flag_index}); } // 0xE3B05614DCE1D014 0xD217EE7E b323
    pub inline fn resetGlobalActionscriptFlag(flag_index: c_int) !void { try invoker.invoke(void, 0xB99C4E4D9499DF29, .{flag_index}); } // 0xB99C4E4D9499DF29 0x4C4C10CF b323
    pub inline fn isWarningMessageReadyForControl() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAF42195A42C63BBA, .{}); } // 0xAF42195A42C63BBA  b323
    /// You can only use text entries. No custom text.
    /// 
    /// Example: SET_WARNING_MESSAGE("t20", 3, "adder", false, -1, 0, 0, true); \
    /// errorCode: shows an error code at the bottom left if nonzero
    pub inline fn setWarningMessage(title_msg: [*c]const u8, flags: c_int, prompt_msg: [*c]const u8, p_3: windows.BOOL, p_4: c_int, p_5: [*c]const u8, p_6: [*c]const u8, show_background: windows.BOOL, error_code: c_int) !void { try invoker.invoke(void, 0x7B1776B3B53F8D74, .{title_msg, flags, prompt_msg, p_3, p_4, p_5, p_6, show_background, error_code}); } // 0x7B1776B3B53F8D74 0xBE699BDE b323
    /// Shows a warning message on screen with a header. \
    /// Note: You can only use text entries. No custom text. You can recreate this easily with scaleforms. \
    /// Example: https://i.imgur.com/ITJt8bJ.png
    pub inline fn setWarningMessageWithHeader(entry_header: [*c]const u8, entry_line_1: [*c]const u8, instructional_key: c_int, entry_line_2: [*c]const u8, p_4: windows.BOOL, p_5: types.Any, show_background: [*c]types.Any, p_7: [*c]types.Any, p_8: windows.BOOL, p_9: types.Any) !void { try invoker.invoke(void, 0xDC38CC1E35B6A5D7, .{entry_header, entry_line_1, instructional_key, entry_line_2, p_4, p_5, show_background, p_7, p_8, p_9}); } // 0xDC38CC1E35B6A5D7 0x2DB9EAB5 b323
    /// You can use this native for custom input, without having to use any scaleform-related natives. \
    /// The native must be called on tick. \
    /// The entryHeader must be a valid label. \
    /// For Single lines use JL_INVITE_N as entryLine1, JL_INVITE_ND for multiple. \
    /// Notes: \
    /// - additionalIntInfo: replaces first occurrence of ~1~ in provided label with an integer \
    /// - additionalTextInfoLine1: replaces first occurrence of ~a~ in provided label, with your custom text \
    /// - additionalTextInfoLine2: replaces second occurrence of ~a~ in provided label, with your custom text \
    /// - showBackground: shows black background of the warning screen \
    /// - errorCode: shows an error code at the bottom left if nonzero \
    /// Example of usage: \
    /// SET_WARNING_MESSAGE_WITH_HEADER_AND_SUBSTRING_FLAGS("ALERT", "JL_INVITE_ND", 66, "", true, -1, -1, "Testing line 1", "Testing line 2", true, 0); \
    /// Screenshot: \
    /// https://imgur.com/a/IYA7vJ8
    pub inline fn setWarningMessageWithHeaderAndSubstringFlags(entry_header: [*c]const u8, entry_line_1: [*c]const u8, instructional_key: c_int, entry_line_2: [*c]const u8, p_4: windows.BOOL, p_5: types.Any, additional_int_info: types.Any, additional_text_info_line_1: [*c]const u8, additional_text_info_line_2: [*c]const u8, show_background: windows.BOOL, error_code: c_int) !void { try invoker.invoke(void, 0x701919482C74B5AB, .{entry_header, entry_line_1, instructional_key, entry_line_2, p_4, p_5, additional_int_info, additional_text_info_line_1, additional_text_info_line_2, show_background, error_code}); } // 0x701919482C74B5AB 0x749929D3 b323
    pub inline fn setWarningMessageWithHeaderExtended(entry_header: [*c]const u8, entry_line_1: [*c]const u8, flags: c_int, entry_line_2: [*c]const u8, p_4: windows.BOOL, p_5: types.Any, p_6: [*c]types.Any, p_7: [*c]types.Any, show_bg: windows.BOOL, p_9: types.Any, p_1_0: types.Any) !void { try invoker.invoke(void, 0x38B55259C2E078ED, .{entry_header, entry_line_1, flags, entry_line_2, p_4, p_5, p_6, p_7, show_bg, p_9, p_1_0}); } // 0x38B55259C2E078ED  b1493
    /// labelTitle: Label of the alert's title. \
    /// labelMsg: Label of the alert's message. \
    /// p2: This is an enum, check the description for a list. \
    /// p3: This is an enum, check the description for a list. \
    /// labelMsg2: Label of another message line \
    /// p5: usually 0 \
    /// p6: usually -1 \
    /// p7: usually 0 \
    /// p8: unknown label \
    /// p9: unknown label \
    /// background: Set to anything other than 0 or false (even any string) and it will draw a background. Setting it to 0 or false will draw no background. \
    /// errorCode: Error code, shown at the bottom left if set to value other than 0.
    /// 
    /// instructionalKey enum list: \
    /// Buttons = { \
    ///       Empty = 0,
    ///       Select = 1, -- (RETURN)
    ///       Ok = 2, -- (RETURN)
    ///       Yes = 4, -- (RETURN)
    ///       Back = 8, -- (ESC)
    ///       Cancel = 16, -- (ESC)
    ///       No = 32, -- (ESC)
    ///       RetrySpace = 64, -- (SPACE)
    ///       Restart = 128, -- (SPACE)
    ///       Skip = 256, -- (SPACE)
    ///       Quit = 512, -- (ESC)
    ///       Adjust = 1024, -- (ARROWS)
    ///       SpaceKey = 2048, -- (SPACE)
    ///       Share = 4096, -- (SPACE)
    ///       SignIn = 8192, -- (SPACE)
    ///       Continue = 16384, -- (RETURN)
    ///       AdjustLeftRight = 32768, -- (SCROLL L/R)
    ///       AdjustUpDown = 65536, -- (SCROLL U/D)
    ///       Overwrite = 131072, -- (SPACE)
    ///       SocialClubSignup = 262144, -- (RETURN)
    ///       Confirm = 524288, -- (RETURN)
    ///       Queue = 1048576, -- (RETURN)
    ///       RetryReturn = 2097152, -- (RETURN)
    ///       BackEsc = 4194304, -- (ESC)
    ///       SocialClub = 8388608, -- (RETURN)
    ///       Spectate = 16777216, -- (SPACE)
    ///       OkEsc = 33554432, -- (ESC)
    ///       CancelTransfer = 67108864, -- (ESC)
    ///       LoadingSpinner = 134217728,
    ///       NoReturnToGTA = 268435456, -- (ESC)
    ///       CancelEsc = 536870912, -- (ESC)
    /// }
    /// 
    /// Alt = { \
    ///       Empty = 0,
    ///       No = 1, -- (SPACE)
    ///       Host = 2, -- (ESC)
    ///       SearchForJob = 4, -- (RETURN)
    ///       ReturnKey = 8, -- (TURN)
    ///       Freemode = 16, -- (ESC)
    /// }
    /// 
    /// Example: https://i.imgur.com/TvmNF4k.png
    pub inline fn setWarningMessageWithHeaderAndSubstringFlagsExtended(label_title: [*c]const u8, label_message: [*c]const u8, p_2: c_int, p_3: c_int, label_message_2: [*c]const u8, p_5: windows.BOOL, p_6: c_int, p_7: c_int, p_8: [*c]const u8, p_9: [*c]const u8, background: windows.BOOL, error_code: c_int) !void { try invoker.invoke(void, 0x15803FEC3B9A872B, .{label_title, label_message, p_2, p_3, label_message_2, p_5, p_6, p_7, p_8, p_9, background, error_code}); } // 0x15803FEC3B9A872B  b573
    /// Has to do with the confirmation overlay (E.g. confirm exit)
    pub inline fn getWarningScreenMessageHash() !types.Hash { return try invoker.invoke(types.Hash, 0x81DF9ABA6C83DFF9, .{}); } // 0x81DF9ABA6C83DFF9  b1290
    /// Some sort of list displayed in a warning message. Yet unknown how to prevent repeating. \
    /// Param names copied from the corresponding scaleform function "SET_LIST_ROW". \
    /// Example: https://i.imgur.com/arKvOYx.png
    pub inline fn setWarningMessageOptionItems(index: c_int, name: [*c]const u8, cash: c_int, rp: c_int, lvl: c_int, colour: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0C5A80A9E096D529, .{index, name, cash, rp, lvl, colour}); } // 0x0C5A80A9E096D529  b323
    pub inline fn setWarningMessageOptionHighlight(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDAF87174BE7454FF, .{p_0}); } // 0xDAF87174BE7454FF  b323
    pub inline fn removeWarningMessageOptionItems() !void { try invoker.invoke(void, 0x6EF54AB721DC6242, .{}); } // 0x6EF54AB721DC6242  b323
    pub inline fn isWarningMessageActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE18B138FABC53103, .{}); } // 0xE18B138FABC53103 0x94C834AD b323
    pub inline fn clearDynamicPauseMenuErrorMessage() !void { try invoker.invoke(void, 0x7792424AA0EAC32E, .{}); } // 0x7792424AA0EAC32E 0x2F9A309C b323
    /// If toggle is true, the map is shown in full screen \
    /// If toggle is false, the map is shown in normal mode
    pub inline fn customMinimapSetActive(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5354C5BA2EA868A4, .{toggle}); } // 0x5354C5BA2EA868A4 0xE4FD20D8 b323
    /// Sets the sprite of the next BLIP_GALLERY blip, values used in the native scripts: 143 (ObjectiveBlue), 144 (ObjectiveGreen), 145 (ObjectiveRed), 146 (ObjectiveYellow).
    pub inline fn customMinimapSetBlipObject(sprite_id: c_int) !void { try invoker.invoke(void, 0x1EAE6DD17B7A5EFA, .{sprite_id}); } // 0x1EAE6DD17B7A5EFA 0x13E7A5A9 b323
    /// Add a BLIP_GALLERY at the specific coordinate. Used in fm_maintain_transition_players to display race track points.
    pub inline fn customMinimapCreateBlip(vec: types.Vector3) !c_int { return try invoker.invoke(c_int, 0x551DF99658DB6EE8, .{vec.x, vec.y, vec.z}); } // 0x551DF99658DB6EE8 0x786CA0A2 b323
    pub inline fn customMinimapClearBlips() !void { try invoker.invoke(void, 0x2708FC083123F9FF, .{}); } // 0x2708FC083123F9FF 0xCBEC9369 b323
    /// Doesn't actually return anything.
    pub inline fn forceSonarBlipsThisFrame() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1121BFA1A1A522A8, .{}); } // 0x1121BFA1A1A522A8 0x3F4AFB13 b323
    pub inline fn getNorthBlidIndex() !types.Blip { return try invoker.invoke(types.Blip, 0x3F0CF9CB7E589B88, .{}); } // 0x3F0CF9CB7E589B88  b463
    /// Toggles whether or not name labels are shown on the expanded minimap next to player blips, like in GTA:O. \
    /// Doesn't need to be called every frame. \
    /// Preview: https://i.imgur.com/DfqKWfJ.png
    /// 
    /// Make sure to call SET_BLIP_CATEGORY with index 7 for this to work on the desired blip.
    pub inline fn displayPlayerNameTagsOnBlips(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x82CEDC33687E1F50, .{toggle}); } // 0x82CEDC33687E1F50 0x2F28F0A6 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn drawFrontendBackgroundThisFrame() !void { try invoker.invoke(void, 0x211C4EF450086857, .{}); } // 0x211C4EF450086857 0x801D0D86 b323
    pub inline fn drawHudOverFadeThisFrame() !void { try invoker.invoke(void, 0xBF4F34A85CA2970C, .{}); } // 0xBF4F34A85CA2970C 0x317775DF b323
    /// Does stuff like this: \
    /// gyazo.com/7fcb78ea3520e3dbc5b2c0c0f3712617
    /// 
    /// Example: \
    /// int GetHash = GET_HASH_KEY("fe_menu_version_corona_lobby"); \
    /// ACTIVATE_FRONTEND_MENU(GetHash, 0, -1);
    /// 
    /// BOOL p1 is a toggle to define the game in pause. \
    /// int p2 is unknown but -1 always works, not sure why though.
    /// 
    /// [30/03/2017] ins1de :
    /// 
    /// the int p2 is actually a component variable. When the pause menu is visible, it opens the tab related to it.
    /// 
    /// Example : Function.Call(Hash.ACTIVATE_FRONTEND_MENU,-1171018317, 0, 42); \
    /// Result : Opens the "Online" tab without pausing the menu, with -1 it opens the map.Below is a list of all known Frontend Menu Hashes. \
    /// - FE_MENU_VERSION_SP_PAUSE \
    /// - FE_MENU_VERSION_MP_PAUSE \
    /// - FE_MENU_VERSION_CREATOR_PAUSE \
    /// - FE_MENU_VERSION_CUTSCENE_PAUSE \
    /// - FE_MENU_VERSION_SAVEGAME \
    /// - FE_MENU_VERSION_PRE_LOBBY \
    /// - FE_MENU_VERSION_LOBBY \
    /// - FE_MENU_VERSION_MP_CHARACTER_SELECT \
    /// - FE_MENU_VERSION_MP_CHARACTER_CREATION \
    /// - FE_MENU_VERSION_EMPTY \
    /// - FE_MENU_VERSION_EMPTY_NO_BACKGROUND \
    /// - FE_MENU_VERSION_TEXT_SELECTION \
    /// - FE_MENU_VERSION_CORONA \
    /// - FE_MENU_VERSION_CORONA_LOBBY \
    /// - FE_MENU_VERSION_CORONA_JOINED_PLAYERS \
    /// - FE_MENU_VERSION_CORONA_INVITE_PLAYERS \
    /// - FE_MENU_VERSION_CORONA_INVITE_FRIENDS \
    /// - FE_MENU_VERSION_CORONA_INVITE_CREWS \
    /// - FE_MENU_VERSION_CORONA_INVITE_MATCHED_PLAYERS \
    /// - FE_MENU_VERSION_CORONA_INVITE_LAST_JOB_PLAYERS \
    /// - FE_MENU_VERSION_CORONA_RACE \
    /// - FE_MENU_VERSION_CORONA_BETTING \
    /// - FE_MENU_VERSION_JOINING_SCREEN \
    /// - FE_MENU_VERSION_LANDING_MENU \
    /// - FE_MENU_VERSION_LANDING_KEYMAPPING_MENU
    pub inline fn activateFrontendMenu(menuhash: types.Hash, toggle_pause: windows.BOOL, component: c_int) !void { try invoker.invoke(void, 0xEF01D36B9C9D0C7B, .{menuhash, toggle_pause, component}); } // 0xEF01D36B9C9D0C7B 0x01D83872 b323
    /// Before using this native click the native above and look at the decription.
    /// 
    /// Example: \
    /// int GetHash = Function.Call<int>(Hash.GET_HASH_KEY, "fe_menu_version_corona_lobby"); \
    /// Function.Call(Hash.ACTIVATE_FRONTEND_MENU, GetHash, 0, -1); \
    /// Function.Call(Hash.RESTART_FRONTEND_MENU(GetHash, -1);
    /// 
    /// This native refreshes the frontend menu.
    /// 
    /// p1 = Hash of Menu \
    /// p2 = Unknown but always works with -1.
    pub inline fn restartFrontendMenu(menu_hash: types.Hash, p_1: c_int) !void { try invoker.invoke(void, 0x10706DC6AD2D49C0, .{menu_hash, p_1}); } // 0x10706DC6AD2D49C0 0xB07DAF98 b323
    /// if (HUD::GET_CURRENT_FRONTEND_MENU_VERSION() == joaat("fe_menu_version_empty_no_background"))
    pub inline fn getCurrentFrontendMenuVersion() !types.Hash { return try invoker.invoke(types.Hash, 0x2309595AD6145265, .{}); } // 0x2309595AD6145265 0x33D6868F b323
    pub inline fn setPauseMenuActive(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDF47FC56C71569CF, .{toggle}); } // 0xDF47FC56C71569CF 0x1DCD878E b323
    pub inline fn disableFrontendThisFrame() !void { try invoker.invoke(void, 0x6D3465A73092F0E6, .{}); } // 0x6D3465A73092F0E6 0xD86A029E b323
    pub inline fn suppressFrontendRenderingThisFrame() !void { try invoker.invoke(void, 0xBA751764F0821256, .{}); } // 0xBA751764F0821256 0x7F349900 b323
    /// Allows opening the pause menu this frame, when the player is dead.
    pub inline fn allowPauseWhenNotInStateOfPlayThisFrame() !void { try invoker.invoke(void, 0xCC3FDDED67BCFC63, .{}); } // 0xCC3FDDED67BCFC63 0x630CD8EE b323
    pub inline fn setFrontendActive(active: windows.BOOL) !void { try invoker.invoke(void, 0x745711A75AB09277, .{active}); } // 0x745711A75AB09277 0x81E1AD32 b323
    pub inline fn isPauseMenuActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB0034A223497FFCB, .{}); } // 0xB0034A223497FFCB 0xD3600591 b323
    pub inline fn isStorePendingNetworkShutdownToOpen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2F057596F2BD0061, .{}); } // 0x2F057596F2BD0061 0xC85C4487 b323
    /// Returns:
    /// 
    /// 0 \
    /// 5 \
    /// 10 \
    /// 15 \
    /// 20 \
    /// 25 \
    /// 30 \
    /// 35
    /// 
    pub inline fn getPauseMenuState() !c_int { return try invoker.invoke(c_int, 0x272ACD84970869C5, .{}); } // 0x272ACD84970869C5 0x92F50134 b323
    pub inline fn getPauseMenuPosition() !types.Vector3 { return try invoker.invoke(types.Vector3, 0x5BFF36D6ED83E0AE, .{}); } // 0x5BFF36D6ED83E0AE  b323
    pub inline fn isPauseMenuRestarting() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1C491717107431C7, .{}); } // 0x1C491717107431C7 0x3C4CF4D9 b323
    /// Not present in retail version of the game, actual definiton seems to be \
    /// _LOG_DEBUG_INFO(const char* category, const char* debugText);
    pub inline fn forceScriptedGfxWhenFrontendActive(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x2162C446DFDF38FD, .{p_0}); } // 0x2162C446DFDF38FD 0x2DFD35C7 b323
    pub inline fn pauseMenuceptionGoDeeper(page: c_int) !void { try invoker.invoke(void, 0x77F16B447824DA6C, .{page}); } // 0x77F16B447824DA6C 0x0A89336C b323
    pub inline fn pauseMenuceptionTheKick() !void { try invoker.invoke(void, 0xCDCA26E80FAECB8F, .{}); } // 0xCDCA26E80FAECB8F 0xC84BE309 b323
    pub inline fn pauseToggleFullscreenMap(p_0: types.Any) !void { try invoker.invoke(void, 0x2DE6C5E2E996F178, .{p_0}); } // 0x2DE6C5E2E996F178  b372
    /// Activates the specified frontend menu context. \
    /// pausemenu.xml defines some specific menu options using 'context'. Context is basically a 'condition'.  \
    /// The `*ALL*` part of the context means that whatever is being defined, will be active when any or all of those conditions after `*ALL*` are met. \
    /// The `*NONE*` part of the context section means that whatever is being defined, will NOT be active if any or all of the conditions after `*NONE*` are met. \
    /// This basically allows you to hide certain menu sections, or things like instructional buttons.
    pub inline fn pauseMenuActivateContext(context_hash: types.Hash) !void { try invoker.invoke(void, 0xDD564BDD0472C936, .{context_hash}); } // 0xDD564BDD0472C936 0x9FE8FD5E b323
    pub inline fn pauseMenuDeactivateContext(context_hash: types.Hash) !void { try invoker.invoke(void, 0x444D8CF241EC25C5, .{context_hash}); } // 0x444D8CF241EC25C5 0x0029046E b323
    pub inline fn pauseMenuIsContextActive(context_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x84698AB38D0C6636, .{context_hash}); } // 0x84698AB38D0C6636 0xC51BC42F b323
    pub inline fn pauseMenuIsContextMenuActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2A25ADC48F87841F, .{}); } // 0x2A25ADC48F87841F 0x016D7AF9 b323
    pub inline fn pauseMenuGetHairColourIndex() !c_int { return try invoker.invoke(c_int, 0xDE03620F8703A9DF, .{}); } // 0xDE03620F8703A9DF  b323
    pub inline fn pauseMenuGetMouseHoverIndex() !c_int { return try invoker.invoke(c_int, 0x359AF31A4B52F5ED, .{}); } // 0x359AF31A4B52F5ED  b323
    pub inline fn pauseMenuGetMouseHoverUniqueId() !c_int { return try invoker.invoke(c_int, 0x13C4B962653A5280, .{}); } // 0x13C4B962653A5280  b323
    pub inline fn pauseMenuGetMouseClickEvent(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC8E1071177A23BE5, .{p_0, p_1, p_2}); } // 0xC8E1071177A23BE5  b323
    pub inline fn pauseMenuRedrawInstructionalButtons(p_0: c_int) !void { try invoker.invoke(void, 0x4895BDEA16E7C080, .{p_0}); } // 0x4895BDEA16E7C080 0x15B24768 b323
    pub inline fn pauseMenuSetBusySpinner(p_0: windows.BOOL, position: c_int, spinner_index: c_int) !void { try invoker.invoke(void, 0xC78E239AC5B2DDB9, .{p_0, position, spinner_index}); } // 0xC78E239AC5B2DDB9 0x6C67131A b323
    pub inline fn pauseMenuSetWarnOnTabChange(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xF06EBB91A81E09E3, .{p_0}); } // 0xF06EBB91A81E09E3 0x11D09737 b323
    pub inline fn isFrontendReadyForControl() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3BAB9A4E4F2FF5C7, .{}); } // 0x3BAB9A4E4F2FF5C7 0xD3BF3ABD b323
    /// Disables frontend (works in custom frontends, not sure about regular pause menu) navigation keys on keyboard. Not sure about controller. Does not disable mouse controls. No need to call this every tick.
    /// 
    /// To enable the keys again, use `0x14621BB1DF14E2B2`.
    pub inline fn takeControlOfFrontend() !void { try invoker.invoke(void, 0xEC9264727EEC0F28, .{}); } // 0xEC9264727EEC0F28 0xC06B763D b323
    /// Enables frontend (works in custom frontends, not sure about regular pause menu) navigation keys on keyboard if they were disabled using the native below. \
    /// To disable the keys, use `0xEC9264727EEC0F28`
    pub inline fn releaseControlOfFrontend() !void { try invoker.invoke(void, 0x14621BB1DF14E2B2, .{}); } // 0x14621BB1DF14E2B2 0xB9392CE7 b323
    pub inline fn codeWantsScriptToTakeControl() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x66E7CB63C97B7D20, .{}); } // 0x66E7CB63C97B7D20 0x92DAFA78 b323
    pub inline fn getScreenCodeWantsScriptToControl() !c_int { return try invoker.invoke(c_int, 0x593FEAE1F73392D4, .{}); } // 0x593FEAE1F73392D4 0x22CA9F2A b323
    pub inline fn isNavigatingMenuContent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4E3CD0EF8A489541, .{}); } // 0x4E3CD0EF8A489541 0xDA7951A2 b323
    pub inline fn hasMenuTriggerEventOccurred() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF284AC67940C6812, .{}); } // 0xF284AC67940C6812 0x7D95AFFF b323
    pub inline fn hasMenuLayoutChangedEventOccurred() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E22FEFA0100275E, .{}); } // 0x2E22FEFA0100275E 0x96863460 b323
    pub inline fn setSavegameListUniqueId(p_0: types.Any) !void { try invoker.invoke(void, 0x0CF54F20DE43879C, .{p_0}); } // 0x0CF54F20DE43879C  b323
    pub inline fn getMenuTriggerEventDetails(last_item_menu_id: [*c]c_int, selected_item_unique_id: [*c]c_int) !void { try invoker.invoke(void, 0x36C1451A88A09630, .{last_item_menu_id, selected_item_unique_id}); } // 0x36C1451A88A09630 0x8543AAC8 b323
    /// lastItemMenuId: this is the menuID of the last selected item minus 1000 (lastItem.menuID - 1000) \
    /// selectedItemMenuId: same as lastItemMenuId except for the currently selected menu item \
    /// selectedItemUniqueId: this is uniqueID of the currently selected menu item
    /// 
    /// when the pausemenu is closed: \
    /// lastItemMenuId = -1 \
    /// selectedItemMenuId = -1 \
    /// selectedItemUniqueId = 0
    /// 
    /// when the header gains focus: \
    /// lastItemMenuId updates as normal or 0 if the pausemenu was just opened \
    /// selectedItemMenuId becomes a unique id for the pausemenu page that focus was taken from (?) or 0 if the pausemenu was just opened \
    /// selectedItemUniqueId = -1
    /// 
    /// when focus is moved from the header to a pausemenu page: \
    /// lastItemMenuId becomes a unique id for the pausemenu page that focus was moved to (?) \
    /// selectedItemMenuId = -1 \
    /// selectedItemUniqueId updates as normal
    pub inline fn getMenuLayoutChangedEventDetails(last_item_menu_id: [*c]c_int, selected_item_menu_id: [*c]c_int, selected_item_unique_id: [*c]c_int) !void { try invoker.invoke(void, 0x7E17BE53E1AAABAF, .{last_item_menu_id, selected_item_menu_id, selected_item_unique_id}); } // 0x7E17BE53E1AAABAF 0x6025AA2F b323
    pub inline fn getPmPlayerCrewColor(r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA238192F33110615, .{r, g, b}); } // 0xA238192F33110615 0x46794EB2 b323
    pub inline fn getMenuPedIntStat(p_0: types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEF4CED81CEBEDC6D, .{p_0, p_1}); } // 0xEF4CED81CEBEDC6D 0x4370999E b323
    pub inline fn getCharacterMenuPedIntStat(p_0: types.Any, p_1: [*c]types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCA6B2F7CE32AB653, .{p_0, p_1, p_2}); } // 0xCA6B2F7CE32AB653  b323
    pub inline fn getMenuPedMaskedIntStat(stat_hash: types.Hash, out_value: [*c]c_int, mask: c_int, p_3: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x90A6526CF0381030, .{stat_hash, out_value, mask, p_3}); } // 0x90A6526CF0381030 0xD6CC4766 b323
    pub inline fn getCharacterMenuPedMaskedIntStat(stat_hash: types.Hash, out_value: [*c]types.Any, p_2: c_int, mask: c_int, p_4: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x24A49BEAF468DC90, .{stat_hash, out_value, p_2, mask, p_4}); } // 0x24A49BEAF468DC90  b323
    pub inline fn getMenuPedFloatStat(stat_hash: types.Hash, out_value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5FBD7095FE7AE57F, .{stat_hash, out_value}); } // 0x5FBD7095FE7AE57F 0x51972B04 b323
    pub inline fn getCharacterMenuPedFloatStat(stat_hash: f32, out_value: [*c]f32, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8F08017F9D7C47BD, .{stat_hash, out_value, p_2}); } // 0x8F08017F9D7C47BD  b323
    /// p0 was always 0xAE2602A3.
    pub inline fn getMenuPedBoolStat(stat_hash: types.Hash, out_value: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x052991E59076E4E4, .{stat_hash, out_value}); } // 0x052991E59076E4E4 0xD43BB56D b323
    pub inline fn clearPedInPauseMenu() !void { try invoker.invoke(void, 0x5E62BE5DC58E9E06, .{}); } // 0x5E62BE5DC58E9E06 0x28058ACF b323
    /// p1 is either 1 or 2 in the PC scripts.
    pub inline fn givePedToPauseMenu(ped: types.Ped, p_1: c_int) !void { try invoker.invoke(void, 0xAC0BFBDC3BE00E14, .{ped, p_1}); } // 0xAC0BFBDC3BE00E14 0x2AD2C9CE b323
    /// Toggles the light state for the pause menu ped in frontend menus.
    /// 
    /// This is used by R* in combination with `SET_PAUSE_MENU_PED_SLEEP_STATE` to toggle the "offline" or "online" state in the "friends" tab of the pause menu in GTA Online.
    /// 
    /// 
    /// Example: \
    /// Lights On: https://vespura.com/hi/i/2019-04-01_16-09_540ee_1015.png \
    /// Lights Off: https://vespura.com/hi/i/2019-04-01_16-10_8b5e7_1016.png
    pub inline fn setPauseMenuPedLighting(state: windows.BOOL) !void { try invoker.invoke(void, 0x3CA6050692BC61B0, .{state}); } // 0x3CA6050692BC61B0 0x127310EB b323
    /// Toggles the pause menu ped sleep state for frontend menus.
    /// 
    /// Example: https://vespura.com/hi/i/2019-04-01_15-51_8ed38_1014.gif
    /// 
    /// `state` 0 will make the ped slowly fall asleep, 1 will slowly wake the ped up.
    pub inline fn setPauseMenuPedSleepState(state: windows.BOOL) !void { try invoker.invoke(void, 0xECF128344E9FF9F1, .{state}); } // 0xECF128344E9FF9F1 0x8F45D327 b323
    pub inline fn openOnlinePoliciesMenu() !void { try invoker.invoke(void, 0x805D7CBB36FD6C4C, .{}); } // 0x805D7CBB36FD6C4C 0x19FCBBB2 b323
    pub inline fn areOnlinePoliciesUpToDate() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF13FE2A80C05C561, .{}); } // 0xF13FE2A80C05C561 0x850690FF b323
    /// Returns the same as IS_SOCIAL_CLUB_ACTIVE
    pub inline fn isOnlinePoliciesMenuActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6F72CD94F7B5B68C, .{}); } // 0x6F72CD94F7B5B68C 0x9D4934F4 b323
    /// Uses the `SOCIAL_CLUB2` scaleform. \
    /// menu: GALLERY, MISSIONS, CREWS, MIGRATE, PLAYLISTS, JOBS
    pub inline fn openSocialClubMenu(menu: types.Hash) !void { try invoker.invoke(void, 0x75D3691713C3B05A, .{menu}); } // 0x75D3691713C3B05A 0x57218529 b323
    pub inline fn closeSocialClubMenu() !void { try invoker.invoke(void, 0xD2B32BE3FC1626C6, .{}); } // 0xD2B32BE3FC1626C6 0x5F86AA39 b323
    /// HUD::SET_SOCIAL_CLUB_TOUR("Gallery"); \
    /// HUD::SET_SOCIAL_CLUB_TOUR("Missions"); \
    /// HUD::SET_SOCIAL_CLUB_TOUR("General"); \
    /// HUD::SET_SOCIAL_CLUB_TOUR("Playlists");
    pub inline fn setSocialClubTour(name: [*c]const u8) !void { try invoker.invoke(void, 0x9E778248D6685FE0, .{name}); } // 0x9E778248D6685FE0 0x7AD67C95 b323
    pub inline fn isSocialClubActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC406BE343FC4B9AF, .{}); } // 0xC406BE343FC4B9AF 0xD4DA14EF b323
    pub inline fn setTextInputBoxEnabled(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x1185A8087587322C, .{p_0}); } // 0x1185A8087587322C  b323
    pub inline fn forceCloseTextInputBox() !void { try invoker.invoke(void, 0x8817605C2BA76200, .{}); } // 0x8817605C2BA76200  b323
    pub inline fn setAllowCommaOnTextInput(p_0: types.Any) !void { try invoker.invoke(void, 0x577599CCED639CA2, .{p_0}); } // 0x577599CCED639CA2  b505
    pub inline fn overrideMpTextChatTeamString(gxt_entry_hash: types.Hash) !void { try invoker.invoke(void, 0x6A1738B4323FE2D9, .{gxt_entry_hash}); } // 0x6A1738B4323FE2D9  b573
    /// Returns whether or not the text chat (MULTIPLAYER_CHAT Scaleform component) is active.
    pub inline fn isMpTextChatTyping() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB118AF58B5F332A1, .{}); } // 0xB118AF58B5F332A1  b323
    pub inline fn closeMpTextChat() !void { try invoker.invoke(void, 0x1AC8F4AD40E22127, .{}); } // 0x1AC8F4AD40E22127  b323
    pub inline fn mpTextChatIsTeamJob(p_0: types.Any) !void { try invoker.invoke(void, 0x7C226D5346D4D10A, .{p_0}); } // 0x7C226D5346D4D10A  b372
    pub inline fn overrideMpTextChatColor(p_0: c_int, hud_color: c_int) !void { try invoker.invoke(void, 0xF47E567B3630DD12, .{p_0, hud_color}); } // 0xF47E567B3630DD12  b678
    /// Hides the chat history, closes the input box and makes it unable to be opened unless called again with FALSE.
    pub inline fn mpTextChatDisable(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1DB21A44B09E8BA3, .{toggle}); } // 0x1DB21A44B09E8BA3  b323
    pub inline fn flagPlayerContextInTournament(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCEF214315D276FD1, .{toggle}); } // 0xCEF214315D276FD1 0xFF06772A b323
    /// This native turns on the AI blip on the specified ped. It also disappears automatically when the ped is too far or if the ped is dead. You don't need to control it with other natives.
    /// 
    /// See gtaforums.com/topic/884370-native-research-ai-blips for further information.
    pub inline fn setPedHasAiBlip(ped: types.Ped, has_cone: windows.BOOL) !void { try invoker.invoke(void, 0xD30C50DF888D58B5, .{ped, has_cone}); } // 0xD30C50DF888D58B5 0x96C4C4DD b323
    /// color: see SET_BLIP_COLOUR
    pub inline fn setPedHasAiBlipWithColour(ped: types.Ped, has_cone: windows.BOOL, color: c_int) !void { try invoker.invoke(void, 0xB13DCB4C6FAAD238, .{ped, has_cone, color}); } // 0xB13DCB4C6FAAD238  b505
    pub inline fn doesPedHaveAiBlip(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x15B8ECF844EE67ED, .{ped}); } // 0x15B8ECF844EE67ED 0x3BE1257F b323
    pub inline fn setPedAiBlipGangId(ped: types.Ped, gang_id: c_int) !void { try invoker.invoke(void, 0xE52B8E7F85D39A08, .{ped, gang_id}); } // 0xE52B8E7F85D39A08 0xD8E31B1A b323
    pub inline fn setPedAiBlipHasCone(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3EED80DFF7325CAA, .{ped, toggle}); } // 0x3EED80DFF7325CAA 0x872C2CFB b323
    pub inline fn setPedAiBlipForcedOn(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0C4BBF625CA98C4E, .{ped, toggle}); } // 0x0C4BBF625CA98C4E 0xFFDF46F0 b323
    pub inline fn setPedAiBlipNoticeRange(ped: types.Ped, range: f32) !void { try invoker.invoke(void, 0x97C65887D4B37FA9, .{ped, range}); } // 0x97C65887D4B37FA9 0xF9DC2AF7 b323
    pub inline fn setPedAiBlipSprite(ped: types.Ped, sprite_id: c_int) !void { try invoker.invoke(void, 0xFCFACD0DB9D7A57D, .{ped, sprite_id}); } // 0xFCFACD0DB9D7A57D  b877
    pub inline fn getAiPedPedBlipIndex(ped: types.Ped) !types.Blip { return try invoker.invoke(types.Blip, 0x7CD934010E115C2C, .{ped}); } // 0x7CD934010E115C2C 0x06349065 b323
    /// Returns the current AI BLIP for the specified ped
    pub inline fn getAiPedVehicleBlipIndex(ped: types.Ped) !types.Blip { return try invoker.invoke(types.Blip, 0x56176892826A4FE8, .{ped}); } // 0x56176892826A4FE8 0xCA52CF43 b323
    pub inline fn hasDirectorModeBeenLaunchedByCode() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA277800A9EAE340E, .{}); } // 0xA277800A9EAE340E  b323
    pub inline fn setDirectorModeLaunchedByScript() !void { try invoker.invoke(void, 0x2632482FD6B9AB87, .{}); } // 0x2632482FD6B9AB87  b323
    /// If toggle is true, hides special ability bar / character name in the pause menu \
    /// If toggle is false, shows special ability bar / character name in the pause menu
    pub inline fn setPlayerIsInDirectorMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x808519373FD336A3, .{toggle}); } // 0x808519373FD336A3  b323
    pub inline fn setDirectorModeAvailable(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x04655F9D075D0AE5, .{toggle}); } // 0x04655F9D075D0AE5  b323
    pub inline fn hideHudmarkersThisFrame() !void { try invoker.invoke(void, 0x243296A510B562B6, .{}); } // 0x243296A510B562B6  b2060
};

pub const Interior = struct
{
    pub inline fn getInteriorHeading(interior: types.Interior) !f32 { return try invoker.invoke(f32, 0xF49B58631D9E22D9, .{interior}); } // 0xF49B58631D9E22D9  b1493
    pub inline fn getInteriorLocationAndNamehash(interior: types.Interior, position: [*c]types.Vector3, name_hash: [*c]types.Hash) !void { try invoker.invoke(void, 0x252BDC06B73FA6EA, .{interior, position, name_hash}); } // 0x252BDC06B73FA6EA 0x75885CB3 b1290
    /// Returns the group ID of the specified interior. \
    /// 0 = default \
    /// 1 = subway station, subway tracks, sewers \
    /// 3 = train tunnel under mirror park \
    /// 5 = tunnel near del perro \
    /// 6 = train tunnel near chilliad \
    /// 7 = train tunnel near josiah \
    /// 8 = train tunnel in sandy shores \
    /// 9 = braddock tunnel (near chilliad) \
    /// 12 = tunnel under fort zancudo \
    /// 14 = train tunnel under cypress flats \
    /// 18 = rockford plaza parking garage \
    /// 19 = arcadius parking garage \
    /// 20 = union depository parking garage \
    /// 21 = fib parking garage
    pub inline fn getInteriorGroupId(interior: types.Interior) !c_int { return try invoker.invoke(c_int, 0xE4A84ABF135EF91A, .{interior}); } // 0xE4A84ABF135EF91A 0x09D6376F b323
    pub inline fn getOffsetFromInteriorInWorldCoords(interior: types.Interior, vec: types.Vector3) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x9E3B3E6D66F6E22F, .{interior, vec.x, vec.y, vec.z}); } // 0x9E3B3E6D66F6E22F 0x7D8F26A1 b323
    pub inline fn isInteriorScene() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC72B5D7A1CBD54D, .{}); } // 0xBC72B5D7A1CBD54D 0x55226C13 b323
    pub inline fn isValidInterior(interior: types.Interior) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x26B0E73D7EAAF4D3, .{interior}); } // 0x26B0E73D7EAAF4D3 0x39C0B635 b323
    pub inline fn clearRoomForEntity(entity: types.Entity) !void { try invoker.invoke(void, 0xB365FC0C4E27FFA7, .{entity}); } // 0xB365FC0C4E27FFA7 0x7DDADB92 b323
    pub inline fn forceRoomForEntity(entity: types.Entity, interior: types.Interior, room_hash_key: types.Hash) !void { try invoker.invoke(void, 0x52923C4710DD9907, .{entity, interior, room_hash_key}); } // 0x52923C4710DD9907 0x10BD4435 b323
    /// Gets the room hash key from the room that the specified entity is in. Each room in every interior has a unique key. Returns 0 if the entity is outside.
    pub inline fn getRoomKeyFromEntity(entity: types.Entity) !types.Hash { return try invoker.invoke(types.Hash, 0x47C2A06D4F5F424B, .{entity}); } // 0x47C2A06D4F5F424B 0xE4ACF8C3 b323
    /// Seems to do the exact same as INTERIOR::GET_ROOM_KEY_FROM_ENTITY
    pub inline fn getKeyForEntityInRoom(entity: types.Entity) !types.Hash { return try invoker.invoke(types.Hash, 0x399685DB942336BC, .{entity}); } // 0x399685DB942336BC 0x91EA80EF b323
    /// Returns the handle of the interior that the entity is in. Returns 0 if outside.
    pub inline fn getInteriorFromEntity(entity: types.Entity) !types.Interior { return try invoker.invoke(types.Interior, 0x2107BA504071A6BB, .{entity}); } // 0x2107BA504071A6BB 0x5C644614 b323
    pub inline fn retainEntityInInterior(entity: types.Entity, interior: types.Interior) !void { try invoker.invoke(void, 0x82EBB79E258FA2B7, .{entity, interior}); } // 0x82EBB79E258FA2B7 0xE645E162 b323
    /// Immediately removes entity from an interior. Like sets entity to `limbo` room.
    pub inline fn clearInteriorStateOfEntity(entity: types.Entity) !void { try invoker.invoke(void, 0x85D5422B2039A70D, .{entity}); } // 0x85D5422B2039A70D  b2189
    pub inline fn forceActivatingTrackingOnEntity(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x38C1CB1CB119A016, .{p_0, p_1}); } // 0x38C1CB1CB119A016  b1493
    pub inline fn forceRoomForGameViewport(interior_i_d: c_int, room_hash_key: types.Hash) !void { try invoker.invoke(void, 0x920D853F3E17F1DA, .{interior_i_d, room_hash_key}); } // 0x920D853F3E17F1DA 0xD79803B5 b323
    /// Example of use (carmod_shop) \
    /// INTERIOR::SET_ROOM_FOR_GAME_VIEWPORT_BY_NAME("V_CarModRoom");
    pub inline fn setRoomForGameViewportByName(room_name: [*c]const u8) !void { try invoker.invoke(void, 0xAF348AFCB575A441, .{room_name}); } // 0xAF348AFCB575A441 0x1F6B4B13 b323
    /// Usage: INTERIOR::SET_ROOM_FOR_GAME_VIEWPORT_BY_KEY(INTERIOR::GET_KEY_FOR_ENTITY_IN_ROOM(PLAYER::PLAYER_PED_ID()));
    pub inline fn setRoomForGameViewportByKey(room_hash_key: types.Hash) !void { try invoker.invoke(void, 0x405DC2AEF6AF95B9, .{room_hash_key}); } // 0x405DC2AEF6AF95B9 0x0E9529CC b323
    pub inline fn getRoomKeyForGameViewport() !types.Hash { return try invoker.invoke(types.Hash, 0xA6575914D2A0B450, .{}); } // 0xA6575914D2A0B450 0x4FF3D3F5 b323
    pub inline fn clearRoomForGameViewport() !void { try invoker.invoke(void, 0x23B59D8912F94246, .{}); } // 0x23B59D8912F94246 0x617DC75D b323
    /// Returns the current interior id from gameplay camera
    pub inline fn getInteriorFromPrimaryView() !types.Interior { return try invoker.invoke(types.Interior, 0xE7D267EC6CA966C3, .{}); } // 0xE7D267EC6CA966C3 0xA83C3D15 b1604
    /// Returns interior ID from specified coordinates. If coordinates are outside, then it returns 0.
    /// 
    /// Example for VB.NET \
    /// Dim interiorID As Integer = Native.Function.Call(Of Integer)(Hash.GET_INTERIOR_AT_COORDS, X, Y, Z)
    pub inline fn getInteriorAtCoords(vec: types.Vector3) !types.Interior { return try invoker.invoke(types.Interior, 0xB0F7F8663821D9C3, .{vec.x, vec.y, vec.z}); } // 0xB0F7F8663821D9C3 0xA17FBF37 b323
    pub inline fn addPickupToInteriorRoomByName(pickup: types.Pickup, room_name: [*c]const u8) !void { try invoker.invoke(void, 0x3F6167F351168730, .{pickup, room_name}); } // 0x3F6167F351168730 0xA2A73564 b323
    pub inline fn pinInteriorInMemory(interior: types.Interior) !void { try invoker.invoke(void, 0x2CA429C029CCF247, .{interior}); } // 0x2CA429C029CCF247 0x3ADA414E b323
    /// Does something similar to INTERIOR::DISABLE_INTERIOR.
    /// 
    /// You don't fall through the floor but everything is invisible inside and looks the same as when INTERIOR::DISABLE_INTERIOR is used. Peds behaves normally inside. 
    pub inline fn unpinInterior(interior: types.Interior) !void { try invoker.invoke(void, 0x261CCE7EED010641, .{interior}); } // 0x261CCE7EED010641 0xFCFF792A b323
    pub inline fn isInteriorReady(interior: types.Interior) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6726BDCCC1932F0E, .{interior}); } // 0x6726BDCCC1932F0E 0xE1EF6450 b323
    /// Only used once in the entire game scripts. \
    /// Does not actually return anything.
    pub inline fn setInteriorInUse(interior: types.Interior) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C2330E61D3DEB56, .{interior}); } // 0x4C2330E61D3DEB56  b323
    /// Returns the interior ID representing the requested interior at that location (if found?). The supplied interior string is not the same as the one used to load the interior.
    /// 
    /// Use: INTERIOR::UNPIN_INTERIOR(INTERIOR::GET_INTERIOR_AT_COORDS_WITH_TYPE(x, y, z, interior))
    /// 
    /// Interior types include: "V_Michael", "V_Franklins", "V_Franklinshouse", etc.. you can find them in the scripts.
    /// 
    /// Not a very useful native as you could just use GET_INTERIOR_AT_COORDS instead and get the same result, without even having to specify the interior type.
    pub inline fn getInteriorAtCoordsWithType(vec: types.Vector3, interior_type: [*c]const u8) !types.Interior { return try invoker.invoke(types.Interior, 0x05B7A89BD78797FC, .{vec.x, vec.y, vec.z, interior_type}); } // 0x05B7A89BD78797FC 0x96525B06 b323
    /// Hashed version of GET_INTERIOR_AT_COORDS_WITH_TYPE
    pub inline fn getInteriorAtCoordsWithTypehash(vec: types.Vector3, type_hash: types.Hash) !types.Interior { return try invoker.invoke(types.Interior, 0xF0F77ADB9F67E79D, .{vec.x, vec.y, vec.z, type_hash}); } // 0xF0F77ADB9F67E79D 0x11718507 b323
    pub inline fn activateInteriorGroupsUsingCamera() !void { try invoker.invoke(void, 0x483ACA1176CA93F1, .{}); } // 0x483ACA1176CA93F1  b1103
    /// Returns true if the collision at the specified coords is marked as being outside (false if there's an interior)
    pub inline fn isCollisionMarkedOutside(vec: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEEA5AC2EDA7C33E8, .{vec.x, vec.y, vec.z}); } // 0xEEA5AC2EDA7C33E8 0x7762249C b323
    pub inline fn getInteriorFromCollision(vec: types.Vector3) !types.Interior { return try invoker.invoke(types.Interior, 0xEC4CF9FCB29A4424, .{vec.x, vec.y, vec.z}); } // 0xEC4CF9FCB29A4424 0x7ED33DC1 b323
    pub inline fn enableStadiumProbesThisFrame(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7ECDF98587E92DEC, .{toggle}); } // 0x7ECDF98587E92DEC  b1604
    /// More info: http://gtaforums.com/topic/836367-adding-props-to-interiors/
    /// 
    /// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
    pub inline fn activateInteriorEntitySet(interior: types.Interior, entity_set_name: [*c]const u8) !void { try invoker.invoke(void, 0x55E86AF2712B36A1, .{interior, entity_set_name}); } // 0x55E86AF2712B36A1 0xC80A5DDF b323
    /// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
    pub inline fn deactivateInteriorEntitySet(interior: types.Interior, entity_set_name: [*c]const u8) !void { try invoker.invoke(void, 0x420BD37289EEE162, .{interior, entity_set_name}); } // 0x420BD37289EEE162 0xDBA768A1 b323
    /// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
    pub inline fn isInteriorEntitySetActive(interior: types.Interior, entity_set_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x35F7DD45E8C0A16D, .{interior, entity_set_name}); } // 0x35F7DD45E8C0A16D 0x39A3CC6F b323
    /// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
    pub inline fn setInteriorEntitySetTintIndex(interior: types.Interior, entity_set_name: [*c]const u8, color: c_int) !void { try invoker.invoke(void, 0xC1F1920BAF281317, .{interior, entity_set_name, color}); } // 0xC1F1920BAF281317  b877
    pub inline fn refreshInterior(interior: types.Interior) !void { try invoker.invoke(void, 0x41F37C3427C75AE0, .{interior}); } // 0x41F37C3427C75AE0 0x9A29ACE6 b323
    /// This is the native that is used to hide the exterior of GTA Online apartment buildings when you are inside an apartment.
    /// 
    /// More info: http://gtaforums.com/topic/836301-hiding-gta-online-apartment-exteriors/
    pub inline fn enableExteriorCullModelThisFrame(map_object_hash: types.Hash) !void { try invoker.invoke(void, 0xA97F257D0151A6AB, .{map_object_hash}); } // 0xA97F257D0151A6AB 0x1F375B4C b323
    pub inline fn enableShadowCullModelThisFrame(map_object_hash: types.Hash) !void { try invoker.invoke(void, 0x50C375537449F369, .{map_object_hash}); } // 0x50C375537449F369  b757
    /// Example:  \
    /// This removes the interior from the strip club and when trying to walk inside the player just falls:
    /// 
    /// INTERIOR::DISABLE_INTERIOR(118018, true);
    pub inline fn disableInterior(interior: types.Interior, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6170941419D7D8EC, .{interior, toggle}); } // 0x6170941419D7D8EC 0x093ADEA5 b323
    pub inline fn isInteriorDisabled(interior: types.Interior) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC5115A5A939DD15, .{interior}); } // 0xBC5115A5A939DD15 0x81F34C71 b323
    /// Does something similar to INTERIOR::DISABLE_INTERIOR
    pub inline fn capInterior(interior: types.Interior, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD9175F941610DB54, .{interior, toggle}); } // 0xD9175F941610DB54 0x34E735A6 b323
    pub inline fn isInteriorCapped(interior: types.Interior) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x92BAC8ACF88CEC26, .{interior}); } // 0x92BAC8ACF88CEC26 0x18B17C80 b323
    pub inline fn disableMetroSystem(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9E6542F0CE8E70A3, .{toggle}); } // 0x9E6542F0CE8E70A3 0x5EF9C5C2 b323
    /// Jenkins hash _might_ be 0xFC227584.
    pub inline fn setIsExteriorOnly(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7241CCB7D020DB69, .{entity, toggle}); } // 0x7241CCB7D020DB69  b791
};

pub const Itemset = struct
{
    pub inline fn createItemset(p_0: windows.BOOL) !types.ScrHandle { return try invoker.invoke(types.ScrHandle, 0x35AD299F50D91B24, .{p_0}); } // 0x35AD299F50D91B24 0x0A113B2C b323
    pub inline fn destroyItemset(itemset: types.ScrHandle) !void { try invoker.invoke(void, 0xDE18220B1C183EDA, .{itemset}); } // 0xDE18220B1C183EDA 0x83CE1A4C b323
    pub inline fn isItemsetValid(itemset: types.ScrHandle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB1B1EA596344DFAB, .{itemset}); } // 0xB1B1EA596344DFAB 0xD201FC29 b323
    pub inline fn addToItemset(item: types.ScrHandle, itemset: types.ScrHandle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE3945201F14637DD, .{item, itemset}); } // 0xE3945201F14637DD 0x6B0FE61B b323
    pub inline fn removeFromItemset(item: types.ScrHandle, itemset: types.ScrHandle) !void { try invoker.invoke(void, 0x25E68244B0177686, .{item, itemset}); } // 0x25E68244B0177686 0xA9565228 b323
    pub inline fn getItemsetSize(itemset: types.ScrHandle) !c_int { return try invoker.invoke(c_int, 0xD9127E83ABF7C631, .{itemset}); } // 0xD9127E83ABF7C631 0x2B31F41A b323
    pub inline fn getIndexedItemInItemset(index: c_int, itemset: types.ScrHandle) !types.ScrHandle { return try invoker.invoke(types.ScrHandle, 0x7A197E2521EE2BAB, .{index, itemset}); } // 0x7A197E2521EE2BAB 0x3F712874 b323
    pub inline fn isInItemset(item: types.ScrHandle, itemset: types.ScrHandle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2D0FC594D1E9C107, .{item, itemset}); } // 0x2D0FC594D1E9C107 0x0D4B9730 b323
    pub inline fn cleanItemset(itemset: types.ScrHandle) !void { try invoker.invoke(void, 0x41BC0D722FC04221, .{itemset}); } // 0x41BC0D722FC04221 0x919A4858 b323
};

pub const Lobby = struct
{
    /// This function is hard-coded to always return 0.
    pub inline fn lobbyAutoMultiplayerMenu() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF2CA003F167E21D2, .{}); } // 0xF2CA003F167E21D2 0x106C8317 b323
    pub inline fn lobbyAutoMultiplayerFreemode() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEF7D17BC6C85264C, .{}); } // 0xEF7D17BC6C85264C 0xD87F3A9E b323
    pub inline fn lobbySetAutoMultiplayer(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB0C56BD3D808D863, .{toggle}); } // 0xB0C56BD3D808D863 0xC0B971EA b323
    pub inline fn lobbyAutoMultiplayerEvent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8AA464D4E0F6ACCD, .{}); } // 0x8AA464D4E0F6ACCD 0x94BCAC7C b323
    pub inline fn lobbySetAutoMultiplayerEvent(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFC309E94546FCDB5, .{toggle}); } // 0xFC309E94546FCDB5 0x7D90EEE5 b323
    pub inline fn lobbyAutoMultiplayerRandomJob() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC6DC823253FBB366, .{}); } // 0xC6DC823253FBB366 0x734CFEDA b323
    pub inline fn lobbySetAutoMpRandomJob(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC7E7181C09F33B69, .{toggle}); } // 0xC7E7181C09F33B69 0x8C227332 b323
    pub inline fn shutdownSessionClearsAutoMultiplayer(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFA1E0E893D915215, .{toggle}); } // 0xFA1E0E893D915215 0x5C350D78 b323
};

pub const Localization = struct
{
    /// Same return values as GET_CURRENT_LANGUAGE
    pub inline fn localizationGetSystemLanguage() !c_int { return try invoker.invoke(c_int, 0x497420E022796B3F, .{}); } // 0x497420E022796B3F  b877
    /// 0 = american (en-US) \
    /// 1 = french (fr-FR) \
    /// 2 = german (de-DE) \
    /// 3 = italian (it-IT) \
    /// 4 = spanish (es-ES) \
    /// 5 = brazilian (pt-BR) \
    /// 6 = polish (pl-PL) \
    /// 7 = russian (ru-RU) \
    /// 8 = korean (ko-KR) \
    /// 9 = chinesetrad (zh-TW) \
    /// 10 = japanese (ja-JP) \
    /// 11 = mexican (es-MX) \
    /// 12 = chinesesimp (zh-CN)
    pub inline fn getCurrentLanguage() !c_int { return try invoker.invoke(c_int, 0x2BDD44CC428A7EAE, .{}); } // 0x2BDD44CC428A7EAE 0x761BE00B b323
    /// Possible return values: 0, 1, 2
    pub inline fn localizationGetSystemDateType() !c_int { return try invoker.invoke(c_int, 0xA8AE43AEC1A61314, .{}); } // 0xA8AE43AEC1A61314  b323
};

pub const Misc = struct
{
    pub inline fn getAllocatedStackSize() !c_int { return try invoker.invoke(c_int, 0x8B3CA62B1EF19B62, .{}); } // 0x8B3CA62B1EF19B62 0x4E9CA30A b323
    pub inline fn getNumberOfFreeStacksOfThisSize(stack_size: c_int) !c_int { return try invoker.invoke(c_int, 0xFEAD16FC8F9DFC0F, .{stack_size}); } // 0xFEAD16FC8F9DFC0F 0x11A178B8 b323
    pub inline fn setRandomSeed(seed: c_int) !void { try invoker.invoke(void, 0x444D98F98C11F3EC, .{seed}); } // 0x444D98F98C11F3EC 0xDB3FEB5C b323
    /// Maximum value is 1. \
    /// At a value of 0 the game will still run at a minimum time scale.
    /// 
    /// Slow Motion 1: 0.6 \
    /// Slow Motion 2: 0.4 \
    /// Slow Motion 3: 0.2
    pub inline fn setTimeScale(time_scale: f32) !void { try invoker.invoke(void, 0x1D408577D440E81E, .{time_scale}); } // 0x1D408577D440E81E 0xA7F84694 b323
    /// If true, the player can't save the game. 
    /// 
    /// 
    /// If the parameter is true, sets the mission flag to true, if the parameter is false, the function does nothing at all.
    /// 
    /// ^ also, if the mission flag is already set, the function does nothing at all
    pub inline fn setMissionFlag(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC4301E5121A0ED73, .{toggle}); } // 0xC4301E5121A0ED73 0x57592D52 b323
    pub inline fn getMissionFlag() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA33CDCCDA663159E, .{}); } // 0xA33CDCCDA663159E 0x95115F97 b323
    /// If the parameter is true, sets the random event flag to true, if the parameter is false, the function does nothing at all. \
    /// Does nothing if the mission flag is set.
    pub inline fn setRandomEventFlag(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x971927086CFD2158, .{toggle}); } // 0x971927086CFD2158 0xA77F31E8 b323
    pub inline fn getRandomEventFlag() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD2D57F1D764117B1, .{}); } // 0xD2D57F1D764117B1 0x794CC92C b323
    /// Returns pointer to an empty string.
    pub inline fn getContentToLoad() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x24DA7D7667FD7B09, .{}); } // 0x24DA7D7667FD7B09  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedCreate(p_0: [*c]const u8, p_1: [*c]const u8) !void { try invoker.invoke(void, 0x4DCDF92BF64236CD, .{p_0, p_1}); } // 0x4DCDF92BF64236CD  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedAddSubstringToCaption(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x31125FD509D9043F, .{p_0}); } // 0x31125FD509D9043F  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedAddLiteralSubstringToCaption(p_0: [*c]const u8) !void { try invoker.invoke(void, 0xEBD3205A207939ED, .{p_0}); } // 0xEBD3205A207939ED  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedAddIntToCaption(p_0: types.Any) !void { try invoker.invoke(void, 0x97E7E2C04245115B, .{p_0}); } // 0x97E7E2C04245115B  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedLargeImageUrl(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x916CA67D26FD1E37, .{p_0}); } // 0x916CA67D26FD1E37  b2060
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedActionStartWithCommandLine(p_0: [*c]const u8, p_1: [*c]const u8) !void { try invoker.invoke(void, 0xEB078CA2B5E82ADD, .{p_0, p_1}); } // 0xEB078CA2B5E82ADD  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedActionStartWithCommandLineAdd(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x703CC7F60CBB2B57, .{p_0}); } // 0x703CC7F60CBB2B57  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    pub inline fn activityFeedPost() !void { try invoker.invoke(void, 0x8951EB9C6906D3C8, .{}); } // 0x8951EB9C6906D3C8  b323
    /// Does nothing (it's a nullsub). Seems to be PS4 specific.
    /// 
    /// Used only once in the scripts (ingamehud) with p0 = "AF_GAMEMODE"
    pub inline fn activityFeedOnlinePlayedWithPost(p_0: [*c]const u8) !void { try invoker.invoke(void, 0xBA4B8D83BDC75551, .{p_0}); } // 0xBA4B8D83BDC75551  b323
    /// Hardcoded to return false.
    pub inline fn hasResumedFromSuspend() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE8B9C0EC9E183F35, .{}); } // 0xE8B9C0EC9E183F35  b323
    /// Sets GtaThread+0x14A
    pub inline fn setScriptHighPrio(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x65D2EBB47E1CEC21, .{toggle}); } // 0x65D2EBB47E1CEC21  b323
    /// Sets bit 3 in GtaThread+0x150
    pub inline fn setThisIsATriggerScript(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6F2135B6129620C1, .{toggle}); } // 0x6F2135B6129620C1 0x8B2DE971 b323
    pub inline fn informCodeOfContentIdOfCurrentUgcMission(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x8D74E26F54B4E5C3, .{p_0}); } // 0x8D74E26F54B4E5C3 0xE77199F7 b323
    pub inline fn getBaseElementLocationFromMetadataBlock(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: types.Any, p_3: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB335F761606DB47C, .{p_0, p_1, p_2, p_3}); } // 0xB335F761606DB47C  b323
    /// Returns current weather name hash
    pub inline fn getPrevWeatherTypeHashName() !types.Hash { return try invoker.invoke(types.Hash, 0x564B884A05EC45A3, .{}); } // 0x564B884A05EC45A3 0xA8171E9E b323
    /// Returns weather name hash
    pub inline fn getNextWeatherTypeHashName() !types.Hash { return try invoker.invoke(types.Hash, 0x711327CD09C8F162, .{}); } // 0x711327CD09C8F162 0x353E8056 b323
    pub inline fn isPrevWeatherType(weather_type: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x44F28F86433B10A9, .{weather_type}); } // 0x44F28F86433B10A9 0x250ADA61 b323
    pub inline fn isNextWeatherType(weather_type: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2FAA3A30BEC0F25D, .{weather_type}); } // 0x2FAA3A30BEC0F25D 0x99CB167F b323
    /// The following weatherTypes are used in the scripts: \
    /// "CLEAR" \
    /// "EXTRASUNNY" \
    /// "CLOUDS" \
    /// "OVERCAST" \
    /// "RAIN" \
    /// "CLEARING" \
    /// "THUNDER" \
    /// "SMOG" \
    /// "FOGGY" \
    /// "XMAS" \
    /// "SNOW" \
    /// "SNOWLIGHT" \
    /// "BLIZZARD" \
    /// "HALLOWEEN" \
    /// "NEUTRAL"
    pub inline fn setWeatherTypePersist(weather_type: [*c]const u8) !void { try invoker.invoke(void, 0x704983DF373B198F, .{weather_type}); } // 0x704983DF373B198F 0xC6C04C75 b323
    /// The following weatherTypes are used in the scripts: \
    /// "CLEAR" \
    /// "EXTRASUNNY" \
    /// "CLOUDS" \
    /// "OVERCAST" \
    /// "RAIN" \
    /// "CLEARING" \
    /// "THUNDER" \
    /// "SMOG" \
    /// "FOGGY" \
    /// "XMAS" \
    /// "SNOW" \
    /// "SNOWLIGHT" \
    /// "BLIZZARD" \
    /// "HALLOWEEN" \
    /// "NEUTRAL"
    pub inline fn setWeatherTypeNowPersist(weather_type: [*c]const u8) !void { try invoker.invoke(void, 0xED712CA327900C8A, .{weather_type}); } // 0xED712CA327900C8A 0xC869FE97 b323
    /// The following weatherTypes are used in the scripts: \
    /// "CLEAR" \
    /// "EXTRASUNNY" \
    /// "CLOUDS" \
    /// "OVERCAST" \
    /// "RAIN" \
    /// "CLEARING" \
    /// "THUNDER" \
    /// "SMOG" \
    /// "FOGGY" \
    /// "XMAS" \
    /// "SNOW" \
    /// "SNOWLIGHT" \
    /// "BLIZZARD" \
    /// "HALLOWEEN" \
    /// "NEUTRAL"
    pub inline fn setWeatherTypeNow(weather_type: [*c]const u8) !void { try invoker.invoke(void, 0x29B487C359E19889, .{weather_type}); } // 0x29B487C359E19889 0x361E9EAC b323
    pub inline fn setWeatherTypeOvertimePersist(weather_type: [*c]const u8, time: f32) !void { try invoker.invoke(void, 0xFB5045B7C42B75BF, .{weather_type, time}); } // 0xFB5045B7C42B75BF 0x386F0D25 b323
    pub inline fn setRandomWeatherType() !void { try invoker.invoke(void, 0x8B05F884CF7E8020, .{}); } // 0x8B05F884CF7E8020 0xE7AA1BC9 b323
    pub inline fn clearWeatherTypePersist() !void { try invoker.invoke(void, 0xCCC39339BEF76CF5, .{}); } // 0xCCC39339BEF76CF5 0x6AB757D8 b323
    pub inline fn clearWeatherTypeNowPersistNetwork(milliseconds: c_int) !void { try invoker.invoke(void, 0x0CF97F497FE7D048, .{milliseconds}); } // 0x0CF97F497FE7D048  b1103
    pub inline fn getCurrWeatherState(weather_type_1: [*c]types.Hash, weather_type_2: [*c]types.Hash, percent_weather_2: [*c]f32) !void { try invoker.invoke(void, 0xF3BBE884A14BB413, .{weather_type_1, weather_type_2, percent_weather_2}); } // 0xF3BBE884A14BB413 0x9A5C1D56 b323
    /// Mixes two weather types. If percentWeather2 is set to 0.0f, then the weather will be entirely of weatherType1, if it is set to 1.0f it will be entirely of weatherType2. If it's set somewhere in between, there will be a mixture of weather behaviors. To test, try this in the RPH console, and change the float to different values between 0 and 1:
    /// 
    /// execute "NativeFunction.Natives.x578C752848ECFA0C(Game.GetHashKey(""RAIN""), Game.GetHashKey(""SMOG""), 0.50f);
    /// 
    /// Note that unlike most of the other weather natives, this native takes the hash of the weather name, not the plain string. These are the weather names and their hashes:
    /// 
    /// CLEAR  0x36A83D84 \
    /// EXTRASUNNY  0x97AA0A79 \
    /// CLOUDS  0x30FDAF5C \
    /// OVERCAST    0xBB898D2D \
    /// RAIN    0x54A69840 \
    /// CLEARING    0x6DB1A50D \
    /// THUNDER 0xB677829F \
    /// SMOG    0x10DCF4B5 \
    /// FOGGY   0xAE737644 \
    /// XMAS    0xAAC9C895 \
    /// SNOWLIGHT   0x23FB812B \
    /// BLIZZARD    0x27EA2814
    /// 
    /// 
    /// 
    /// 
    /// 
    /// /* OLD INVALID INFO BELOW */ \
    /// Not tested. Based purely on disassembly. Instantly sets the weather to sourceWeather, then transitions to targetWeather over the specified transitionTime in seconds.
    /// 
    /// If an invalid hash is specified for sourceWeather, the current weather type will be used. \
    /// If an invalid hash is specified for targetWeather, the next weather type will be used. \
    /// If an invalid hash is specified for both sourceWeather and targetWeather, the function just changes the transition time of the current transition.
    pub inline fn setCurrWeatherState(weather_type_1: types.Hash, weather_type_2: types.Hash, percent_weather_2: f32) !void { try invoker.invoke(void, 0x578C752848ECFA0C, .{weather_type_1, weather_type_2, percent_weather_2}); } // 0x578C752848ECFA0C 0x5CA74040 b323
    /// Appears to have an optional bool parameter that is unused in the scripts.
    /// 
    /// If you pass true, something will be set to zero.
    pub inline fn setOverrideWeather(weather_type: [*c]const u8) !void { try invoker.invoke(void, 0xA43D5C6FE51ADBEF, .{weather_type}); } // 0xA43D5C6FE51ADBEF 0xD9082BB5 b323
    /// Identical to SET_OVERRIDE_WEATHER but has an additional BOOL param that sets some weather var to 0 if true
    pub inline fn setOverrideWeatherex(weather_type: [*c]const u8, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x1178E104409FE58C, .{weather_type, p_1}); } // 0x1178E104409FE58C  b2189
    pub inline fn clearOverrideWeather() !void { try invoker.invoke(void, 0x338D2E3477711050, .{}); } // 0x338D2E3477711050 0x7740EA4E b323
    pub inline fn waterOverrideSetShorewaveamplitude(amplitude: f32) !void { try invoker.invoke(void, 0xB8F87EAD7533B176, .{amplitude}); } // 0xB8F87EAD7533B176 0x625181DC b323
    pub inline fn waterOverrideSetShorewaveminamplitude(min_amplitude: f32) !void { try invoker.invoke(void, 0xC3EAD29AB273ECE8, .{min_amplitude}); } // 0xC3EAD29AB273ECE8 0xBEBBFDC8 b323
    pub inline fn waterOverrideSetShorewavemaxamplitude(max_amplitude: f32) !void { try invoker.invoke(void, 0xA7A1127490312C36, .{max_amplitude}); } // 0xA7A1127490312C36 0x6926AB03 b323
    pub inline fn waterOverrideSetOceannoiseminamplitude(min_amplitude: f32) !void { try invoker.invoke(void, 0x31727907B2C43C55, .{min_amplitude}); } // 0x31727907B2C43C55 0xD447439D b323
    pub inline fn waterOverrideSetOceanwaveamplitude(amplitude: f32) !void { try invoker.invoke(void, 0x405591EC8FD9096D, .{amplitude}); } // 0x405591EC8FD9096D 0x584E9C59 b323
    pub inline fn waterOverrideSetOceanwaveminamplitude(min_amplitude: f32) !void { try invoker.invoke(void, 0xF751B16FB32ABC1D, .{min_amplitude}); } // 0xF751B16FB32ABC1D 0x5656D578 b323
    pub inline fn waterOverrideSetOceanwavemaxamplitude(max_amplitude: f32) !void { try invoker.invoke(void, 0xB3E6360DDE733E82, .{max_amplitude}); } // 0xB3E6360DDE733E82 0x0DE40C28 b323
    pub inline fn waterOverrideSetRipplebumpiness(bumpiness: f32) !void { try invoker.invoke(void, 0x7C9C0B1EEB1F9072, .{bumpiness}); } // 0x7C9C0B1EEB1F9072 0x98C9138B b323
    pub inline fn waterOverrideSetRippleminbumpiness(min_bumpiness: f32) !void { try invoker.invoke(void, 0x6216B116083A7CB4, .{min_bumpiness}); } // 0x6216B116083A7CB4 0xFB1A9CDE b323
    pub inline fn waterOverrideSetRipplemaxbumpiness(max_bumpiness: f32) !void { try invoker.invoke(void, 0x9F5E6BB6B34540DA, .{max_bumpiness}); } // 0x9F5E6BB6B34540DA 0x1C0CAE89 b323
    pub inline fn waterOverrideSetRippledisturb(disturb: f32) !void { try invoker.invoke(void, 0xB9854DFDE0D833D6, .{disturb}); } // 0xB9854DFDE0D833D6 0x4671AC2E b323
    /// This seems to edit the water wave, intensity around your current location.
    /// 
    /// 0.0f = Normal \
    /// 1.0f = So Calm and Smooth, a boat will stay still. \
    /// 3.0f = Really Intense.
    pub inline fn waterOverrideSetStrength(strength: f32) !void { try invoker.invoke(void, 0xC54A08C85AE4D410, .{strength}); } // 0xC54A08C85AE4D410 0xDA02F415 b323
    pub inline fn waterOverrideFadeIn(p_0: f32) !void { try invoker.invoke(void, 0xA8434F1DFF41D6E7, .{p_0}); } // 0xA8434F1DFF41D6E7 0x5F3DDEC0 b323
    pub inline fn waterOverrideFadeOut(p_0: f32) !void { try invoker.invoke(void, 0xC3C221ADDDE31A11, .{p_0}); } // 0xC3C221ADDDE31A11 0x63A89684 b323
    /// Sets the the normalized wind speed value. The wind speed clamps always at 12.0, SET_WIND sets the wind in a percentage, 0.0 is 0 and 1.0 is 12.0. Setting this value to a negative number resumes the random wind speed changes provided by the game.
    pub inline fn setWind(speed: f32) !void { try invoker.invoke(void, 0xAC3A74E8384A9919, .{speed}); } // 0xAC3A74E8384A9919 0xC6294698 b323
    /// Using this native will set the absolute wind speed value. The wind speed clamps to a range of 0.0- 12.0. Setting this value to a negative number resumes the random wind speed changes provided by the game.
    pub inline fn setWindSpeed(speed: f32) !void { try invoker.invoke(void, 0xEE09ECEDBABE47FC, .{speed}); } // 0xEE09ECEDBABE47FC 0x45705F94 b323
    pub inline fn getWindSpeed() !f32 { return try invoker.invoke(f32, 0xA8CF1CC0AFCD3F12, .{}); } // 0xA8CF1CC0AFCD3F12 0x098F0F3C b323
    /// The wind direction in radians \
    /// 180 degrees (PI), wind will blow from the south. Setting this value to a negative number resumes the random wind direction changes provided by the game.
    pub inline fn setWindDirection(direction: f32) !void { try invoker.invoke(void, 0xEB0F4468467B4528, .{direction}); } // 0xEB0F4468467B4528 0x381AEEE9 b323
    pub inline fn getWindDirection() !types.Vector3 { return try invoker.invoke(types.Vector3, 0x1F400FEF721170DA, .{}); } // 0x1F400FEF721170DA 0x89499A0D b323
    /// With an `intensity` higher than `0.5f`, only the creation of puddles gets faster, rain and rain sound won't increase after that. \
    /// With an `intensity` of `0.0f` rain and rain sounds are disabled and there won't be any new puddles. \
    /// To use the rain intensity of the current weather, call this native with `-1f` as `intensity`.
    pub inline fn setRain(intensity: f32) !void { try invoker.invoke(void, 0x643E26EA6E024D92, .{intensity}); } // 0x643E26EA6E024D92  b323
    pub inline fn getRainLevel() !f32 { return try invoker.invoke(f32, 0x96695E368AD855F3, .{}); } // 0x96695E368AD855F3 0xC9F67F28 b323
    pub inline fn setSnow(level: f32) !void { try invoker.invoke(void, 0x7F06937B0CDCBC1A, .{level}); } // 0x7F06937B0CDCBC1A  b1868
    pub inline fn getSnowLevel() !f32 { return try invoker.invoke(f32, 0xC5868A966E5BE3AE, .{}); } // 0xC5868A966E5BE3AE 0x1B09184F b323
    /// creates single lightning+thunder at random position
    pub inline fn forceLightningFlash() !void { try invoker.invoke(void, 0xF6062E089251C898, .{}); } // 0xF6062E089251C898 0xDF38165E b323
    pub inline fn setCloudSettingsOverride(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x02DEAAC8F8EA7FE7, .{p_0}); } // 0x02DEAAC8F8EA7FE7  b323
    pub inline fn preloadCloudHat(name: [*c]const u8) !void { try invoker.invoke(void, 0x11B56FBBF7224868, .{name}); } // 0x11B56FBBF7224868 0x8727A4C5 b323
    /// The following cloudhats are useable: \
    /// altostratus \
    /// Cirrus \
    /// cirrocumulus \
    /// Clear 01 \
    /// Cloudy 01 \
    /// Contrails \
    /// Horizon \
    /// horizonband1 \
    /// horizonband2 \
    /// horizonband3 \
    /// horsey \
    /// Nimbus \
    /// Puffs \
    /// RAIN \
    /// Snowy 01 \
    /// Stormy 01 \
    /// stratoscumulus \
    /// Stripey \
    /// shower \
    /// Wispy
    /// 
    pub inline fn loadCloudHat(name: [*c]const u8, transition_time: f32) !void { try invoker.invoke(void, 0xFC4842A34657BFCB, .{name, transition_time}); } // 0xFC4842A34657BFCB 0xED88FC61 b323
    pub inline fn unloadCloudHat(name: [*c]const u8, p_1: f32) !void { try invoker.invoke(void, 0xA74802FB8D0B7814, .{name, p_1}); } // 0xA74802FB8D0B7814 0xC9FA6E07 b323
    pub inline fn unloadAllCloudHats() !void { try invoker.invoke(void, 0x957E790EA1727B64, .{}); } // 0x957E790EA1727B64 0x2D7787BC b323
    pub inline fn setCloudsAlpha(opacity: f32) !void { try invoker.invoke(void, 0xF36199225D6D8C86, .{opacity}); } // 0xF36199225D6D8C86  b323
    pub inline fn getCloudsAlpha() !f32 { return try invoker.invoke(f32, 0x20AC25E781AE4A84, .{}); } // 0x20AC25E781AE4A84  b323
    pub inline fn getGameTimer() !c_int { return try invoker.invoke(c_int, 0x9CD27B0045628463, .{}); } // 0x9CD27B0045628463 0xA4EA0691 b323
    pub inline fn getFrameTime() !f32 { return try invoker.invoke(f32, 0x15C40837039FFAF7, .{}); } // 0x15C40837039FFAF7 0x96374262 b323
    pub inline fn getSystemTimeStep() !f32 { return try invoker.invoke(f32, 0xE599A503B3837E1B, .{}); } // 0xE599A503B3837E1B  b323
    pub inline fn getFrameCount() !c_int { return try invoker.invoke(c_int, 0xFC8202EFC642E6F2, .{}); } // 0xFC8202EFC642E6F2 0xB477A015 b323
    pub inline fn getRandomFloatInRange(start_range: f32, end_range: f32) !f32 { return try invoker.invoke(f32, 0x313CE5879CEB6FCD, .{start_range, end_range}); } // 0x313CE5879CEB6FCD 0x0562C4D0 b323
    pub inline fn getRandomIntInRange(start_range: c_int, end_range: c_int) !c_int { return try invoker.invoke(c_int, 0xD53343AA4FB7DD28, .{start_range, end_range}); } // 0xD53343AA4FB7DD28 0x4051115B b323
    pub inline fn getRandomMwcIntInRange(start_range: c_int, end_range: c_int) !c_int { return try invoker.invoke(c_int, 0xF2D49816A804D134, .{start_range, end_range}); } // 0xF2D49816A804D134  b1734
    /// Gets the ground elevation at the specified position. Note that if the specified position is below ground level, the function will output zero!
    /// 
    /// x: Position on the X-axis to get ground elevation at. \
    /// y: Position on the Y-axis to get ground elevation at. \
    /// z: Position on the Z-axis to get ground elevation at. \
    /// groundZ: The ground elevation at the specified position. \
    /// ignoreWater: Nearly always 0, very rarely 1 in the scripts: https://gfycat.com/NiftyTatteredCricket
    /// 
    /// Bear in mind this native can only calculate the elevation when the coordinates are within the client's render distance.
    pub inline fn getGroundZFor3dCoord(vec: types.Vector3, ground_z: [*c]f32, ignore_water: windows.BOOL, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC906A7DAB05C8D2B, .{vec.x, vec.y, vec.z, ground_z, ignore_water, p_5}); } // 0xC906A7DAB05C8D2B 0xA1BFD5E0 b323
    pub inline fn getGroundZAndNormalFor3dCoord(vec: types.Vector3, ground_z: [*c]f32, normal: [*c]types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8BDC7BFC57A81E76, .{vec.x, vec.y, vec.z, ground_z, normal}); } // 0x8BDC7BFC57A81E76 0x64D91CED b323
    pub inline fn getGroundZExcludingObjectsFor3dCoord(vec: types.Vector3, ground_z: [*c]f32, p_4: windows.BOOL, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9E82F0F362881B29, .{vec.x, vec.y, vec.z, ground_z, p_4, p_5}); } // 0x9E82F0F362881B29  b505
    pub inline fn asin(p_0: f32) !f32 { return try invoker.invoke(f32, 0xC843060B5765DCE7, .{p_0}); } // 0xC843060B5765DCE7 0x998E5CAD b323
    pub inline fn acos(p_0: f32) !f32 { return try invoker.invoke(f32, 0x1D08B970013C34B6, .{p_0}); } // 0x1D08B970013C34B6 0xF4038776 b323
    pub inline fn tan(p_0: f32) !f32 { return try invoker.invoke(f32, 0x632106CC96E82E91, .{p_0}); } // 0x632106CC96E82E91 0xD320CE5E b323
    pub inline fn atan(p_0: f32) !f32 { return try invoker.invoke(f32, 0xA9D1795CD5043663, .{p_0}); } // 0xA9D1795CD5043663 0x7A03CC8E b323
    pub inline fn atan2(p_0: f32, p_1: f32) !f32 { return try invoker.invoke(f32, 0x8927CBF9D22261A4, .{p_0, p_1}); } // 0x8927CBF9D22261A4 0x2508AC81 b323
    /// Returns the distance between two three-dimensional points, optionally ignoring the Z values. \
    /// If useZ is false, only the 2D plane (X-Y) will be considered for calculating the distance.
    /// 
    /// Consider using this faster native instead: SYSTEM::VDIST - DVIST always takes in consideration the 3D coordinates.
    pub inline fn getDistanceBetweenCoords(vec_1__: types.Vector3, vec_2__: types.Vector3, use_z: windows.BOOL) !f32 { return try invoker.invoke(f32, 0xF1B760881820C952, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, use_z}); } // 0xF1B760881820C952 0xF698765E b323
    pub inline fn getAngleBetween2dVectors(vec_1__: types.Vector2, vec_2__: types.Vector2) !f32 { return try invoker.invoke(f32, 0x186FC4BE848E1C92, .{vec_1__.x, vec_1__.y, vec_2__.x, vec_2__.y}); } // 0x186FC4BE848E1C92 0xDBF75E58 b323
    /// dx = x1 - x2 \
    /// dy = y1 - y2
    pub inline fn getHeadingFromVector2d(dx: f32, dy: f32) !f32 { return try invoker.invoke(f32, 0x2FFB6B224F4B2926, .{dx, dy}); } // 0x2FFB6B224F4B2926 0xD209D52B b323
    /// returns a float between 0.0 and 1.0, clamp: sets whether the product should be clamped between the given coordinates
    pub inline fn getRatioOfClosestPointOnLine(vec_1__: types.Vector3, vec_2__: types.Vector3, vec_3__: types.Vector3, clamp: windows.BOOL) !f32 { return try invoker.invoke(f32, 0x7F8F6405F4777AF6, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, vec_3__.x, vec_3__.y, vec_3__.z, clamp}); } // 0x7F8F6405F4777AF6 0x89459F0A b323
    /// clamp: sets whether the product should be clamped between the given coordinates
    pub inline fn getClosestPointOnLine(vec_1__: types.Vector3, vec_2__: types.Vector3, vec_3__: types.Vector3, clamp: windows.BOOL) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x21C235BC64831E5A, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, vec_3__.x, vec_3__.y, vec_3__.z, clamp}); } // 0x21C235BC64831E5A 0xCAECF37E b323
    pub inline fn getLinePlaneIntersection(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: f32, p_9: f32, p_1_0: f32, p_1_1: f32, p_1_2: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF56DFB7B61BE7276, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2}); } // 0xF56DFB7B61BE7276 0xC6CC812C b323
    pub inline fn getPointAreaOverlap(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: types.Any, p_1_0: types.Any, p_1_1: types.Any, p_1_2: types.Any, p_1_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0AD167E4B39D9A2, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2, p_1_3}); } // 0xA0AD167E4B39D9A2  b2189
    /// This sets bit [offset] of [address] to on.
    /// 
    /// The offsets used are different bits to be toggled on and off, typically there is only one address used in a script.
    /// 
    /// Example: \
    /// MISC::SET_BIT(&bitAddress, 1);
    /// 
    /// To check if this bit has been enabled: \
    /// MISC::IS_BIT_SET(bitAddress, 1); // will return 1 afterwards
    /// 
    /// Please note, this method may assign a value to [address] when used.
    pub inline fn setBit(address: [*c]c_int, offset: c_int) !void { try invoker.invoke(void, 0x933D6A9EEC1BACD0, .{address, offset}); } // 0x933D6A9EEC1BACD0 0x4EFE7E6B b323
    /// This sets bit [offset] of [address] to off.
    /// 
    /// Example: \
    /// MISC::CLEAR_BIT(&bitAddress, 1);
    /// 
    /// To check if this bit has been enabled: \
    /// MISC::IS_BIT_SET(bitAddress, 1); // will return 0 afterwards
    pub inline fn clearBit(address: [*c]c_int, offset: c_int) !void { try invoker.invoke(void, 0xE80492A9AC099A93, .{address, offset}); } // 0xE80492A9AC099A93 0x8BC9E618 b323
    /// This native converts its past string to hash. It is hashed using jenkins one at a time method.
    pub inline fn getHashKey(string: [*c]const u8) !types.Hash { return try invoker.invoke(types.Hash, 0xD24D37CC275948CC, .{string}); } // 0xD24D37CC275948CC 0x98EFF6F1 b323
    /// This native always come right before SET_ENTITY_QUATERNION where its final 4 parameters are SLERP_NEAR_QUATERNION p9 to p12
    pub inline fn slerpNearQuaternion(t: f32, vec: types.Vector4, vec_1__: types.Vector4, out_x: [*c]f32, out_y: [*c]f32, out_z: [*c]f32, out_w: [*c]f32) !void { try invoker.invoke(void, 0xF2F6A2FA49278625, .{t, vec.x, vec.y, vec.z, vec.w, vec_1__.x, vec_1__.y, vec_1__.z, vec_1__.w, out_x, out_y, out_z, out_w}); } // 0xF2F6A2FA49278625 0x87B92190 b323
    pub inline fn isAreaOccupied(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: windows.BOOL, p_7: windows.BOOL, p_8: windows.BOOL, p_9: windows.BOOL, p_1_0: windows.BOOL, p_1_1: types.Any, p_1_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA61B4DF533DCB56E, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2}); } // 0xA61B4DF533DCB56E 0xC013972F b323
    pub inline fn isAreaOccupiedSlow(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: types.Any, p_1_0: types.Any, p_1_1: types.Any, p_1_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x39455BF4F4F55186, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2}); } // 0x39455BF4F4F55186  b1868
    /// `range`: The range, seems to not be very accurate during testing. \
    /// `p4`: Unknown, when set to true it seems to always return true no matter what I try. \
    /// `checkVehicle`: Check for any vehicles in that area. \
    /// `checkPeds`: Check for any peds in that area. \
    /// `ignoreEntity`: This entity will be ignored if it's in the area. Set to 0 if you don't want to exclude any entities. \
    /// The BOOL parameters that are documented have not been confirmed. They are just documented from what I've found during testing. They may not work as expected in all cases.
    /// 
    /// Returns true if there is anything in that location matching the provided parameters.
    pub inline fn isPositionOccupied(vec: types.Vector3, range: f32, p_4: windows.BOOL, check_vehicles: windows.BOOL, check_peds: windows.BOOL, p_7: windows.BOOL, p_8: windows.BOOL, ignore_entity: types.Entity, p_1_0: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xADCDE75E1C60F32D, .{vec.x, vec.y, vec.z, range, p_4, check_vehicles, check_peds, p_7, p_8, ignore_entity, p_1_0}); } // 0xADCDE75E1C60F32D 0x452E8D9E b323
    pub inline fn isPointObscuredByAMissionEntity(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE54E209C35FFA18D, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0xE54E209C35FFA18D 0xC161558D b323
    /// Example: CLEAR_AREA(0, 0, 0, 30, true, false, false, false);
    pub inline fn clearArea(vec: types.Vector3, radius: f32, p_4: windows.BOOL, ignore_cop_cars: windows.BOOL, ignore_objects: windows.BOOL, p_7: windows.BOOL) !void { try invoker.invoke(void, 0xA56F01F3765B93A0, .{vec.x, vec.y, vec.z, radius, p_4, ignore_cop_cars, ignore_objects, p_7}); } // 0xA56F01F3765B93A0 0x854E9AB8 b323
    /// MISC::CLEAR_AREA_LEAVE_VEHICLE_HEALTH(x, y, z, radius, false, false, false, false); seem to make all objects go away, peds, vehicles etc. All booleans set to true doesn't seem to change anything. 
    pub inline fn clearAreaLeaveVehicleHealth(vec: types.Vector3, radius: f32, p_4: windows.BOOL, p_5: windows.BOOL, p_6: windows.BOOL, p_7: windows.BOOL) !void { try invoker.invoke(void, 0x957838AAF91BD12D, .{vec.x, vec.y, vec.z, radius, p_4, p_5, p_6, p_7}); } // 0x957838AAF91BD12D 0x20E4FFD9 b323
    /// Example: \
    /// CLEAR_AREA_OF_VEHICLES(0.0f, 0.0f, 0.0f, 10000.0f, false, false, false, false, false, false);
    pub inline fn clearAreaOfVehicles(vec: types.Vector3, radius: f32, p_4: windows.BOOL, p_5: windows.BOOL, p_6: windows.BOOL, p_7: windows.BOOL, p_8: windows.BOOL, p_9: windows.BOOL, p_1_0: types.Any) !void { try invoker.invoke(void, 0x01C7B9B38428AEB6, .{vec.x, vec.y, vec.z, radius, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0}); } // 0x01C7B9B38428AEB6 0x63320F3C b323
    pub inline fn clearAngledAreaOfVehicles(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, p_7: windows.BOOL, p_8: windows.BOOL, p_9: windows.BOOL, p_1_0: windows.BOOL, p_1_1: windows.BOOL, p_1_2: types.Any, p_1_3: types.Any) !void { try invoker.invoke(void, 0x11DB3500F042A8AA, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2, p_1_3}); } // 0x11DB3500F042A8AA 0xF11A3018 b323
    /// I looked through the PC scripts that this site provides you with a link to find. It shows the last param mainly uses, (0, 2, 6, 16, and 17) so I am going to assume it is a type of flag. 
    pub inline fn clearAreaOfObjects(vec: types.Vector3, radius: f32, flags: c_int) !void { try invoker.invoke(void, 0xDD9B9B385AAC7F5B, .{vec.x, vec.y, vec.z, radius, flags}); } // 0xDD9B9B385AAC7F5B 0xBB720FE7 b323
    /// Example:       CLEAR_AREA_OF_PEDS(0, 0, 0, 10000, 1);
    pub inline fn clearAreaOfPeds(vec: types.Vector3, radius: f32, flags: c_int) !void { try invoker.invoke(void, 0xBE31FD6CE464AC59, .{vec.x, vec.y, vec.z, radius, flags}); } // 0xBE31FD6CE464AC59 0x25BE7FA8 b323
    /// flags appears to always be 0
    pub inline fn clearAreaOfCops(vec: types.Vector3, radius: f32, flags: c_int) !void { try invoker.invoke(void, 0x04F8FC8FCF58F88D, .{vec.x, vec.y, vec.z, radius, flags}); } // 0x04F8FC8FCF58F88D 0x95C53824 b323
    /// flags is usually 0 in the scripts.
    pub inline fn clearAreaOfProjectiles(vec: types.Vector3, radius: f32, flags: c_int) !void { try invoker.invoke(void, 0x0A1CB9094635D1A6, .{vec.x, vec.y, vec.z, radius, flags}); } // 0x0A1CB9094635D1A6 0x18DB5434 b323
    /// Possibly used to clear scenario points.
    pub inline fn clearScenarioSpawnHistory() !void { try invoker.invoke(void, 0x7EC6F9A478A6A512, .{}); } // 0x7EC6F9A478A6A512  b323
    /// ignoreVehicle - bypasses vehicle check of the local player (it will not open if you are in a vehicle and this is set to false)
    pub inline fn setSaveMenuActive(ignore_vehicle: windows.BOOL) !void { try invoker.invoke(void, 0xC9BF75D28165FF77, .{ignore_vehicle}); } // 0xC9BF75D28165FF77 0xF5CCF164 b323
    pub inline fn getStatusOfManualSave() !c_int { return try invoker.invoke(c_int, 0x397BAA01068BAA96, .{}); } // 0x397BAA01068BAA96 0x39771F21 b323
    pub inline fn setCreditsActive(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB938B7E6D3C0620C, .{toggle}); } // 0xB938B7E6D3C0620C 0xEC2A0ECF b323
    pub inline fn setCreditsFadeOutWithScreen(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB51B9AB9EF81868C, .{toggle}); } // 0xB51B9AB9EF81868C 0x75B06B5A b323
    pub inline fn haveCreditsReachedEnd() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x075F1D57402C93BA, .{}); } // 0x075F1D57402C93BA 0x2569C9A7 b323
    pub inline fn areCreditsRunning() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD19C0826DC20CF1C, .{}); } // 0xD19C0826DC20CF1C  b2802
    pub inline fn terminateAllScriptsWithThisName(script_name: [*c]const u8) !void { try invoker.invoke(void, 0x9DC711BC69C548DF, .{script_name}); } // 0x9DC711BC69C548DF 0x9F861FD4 b323
    pub inline fn networkSetScriptIsSafeForNetworkGame() !void { try invoker.invoke(void, 0x9243BAC96D64C050, .{}); } // 0x9243BAC96D64C050 0x878486CE b323
    /// Returns the index of the newly created hospital spawn point.
    /// 
    /// p3 might be radius?
    pub inline fn addHospitalRestart(vec: types.Vector3, p_3: f32, p_4: types.Any) !c_int { return try invoker.invoke(c_int, 0x1F464EF988465A81, .{vec.x, vec.y, vec.z, p_3, p_4}); } // 0x1F464EF988465A81 0x4F3E3104 b323
    /// The game by default has 5 hospital respawn points. Disabling them all will cause the player to respawn at the last position they were.
    pub inline fn disableHospitalRestart(hospital_index: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC8535819C450EBA8, .{hospital_index, toggle}); } // 0xC8535819C450EBA8 0x09F49C72 b323
    pub inline fn addPoliceRestart(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: types.Any) !c_int { return try invoker.invoke(c_int, 0x452736765B31FC4B, .{p_0, p_1, p_2, p_3, p_4}); } // 0x452736765B31FC4B 0xE96C29FE b323
    /// Disables the spawn point at the police house on the specified index.
    /// 
    /// policeIndex: The police house index. \
    /// toggle: true to enable the spawn point, false to disable.
    /// 
    /// - Nacorpio
    pub inline fn disablePoliceRestart(police_index: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x23285DED6EBD7EA3, .{police_index, toggle}); } // 0x23285DED6EBD7EA3 0x0A280324 b323
    pub inline fn setRestartCoordOverride(vec: types.Vector3, heading: f32) !void { try invoker.invoke(void, 0x706B5EDCAA7FA663, .{vec.x, vec.y, vec.z, heading}); } // 0x706B5EDCAA7FA663  b323
    pub inline fn clearRestartCoordOverride() !void { try invoker.invoke(void, 0xA2716D40842EAF79, .{}); } // 0xA2716D40842EAF79  b323
    pub inline fn pauseDeathArrestRestart(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2C2B3493FBF51C71, .{toggle}); } // 0x2C2B3493FBF51C71 0x296574AE b323
    pub inline fn ignoreNextRestart(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x21FFB63D8C615361, .{toggle}); } // 0x21FFB63D8C615361 0xDA13A4B6 b323
    /// Sets whether the game should fade out after the player dies.
    pub inline fn setFadeOutAfterDeath(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4A18E01DF2C87B86, .{toggle}); } // 0x4A18E01DF2C87B86 0xC9F6F0BC b323
    /// Sets whether the game should fade out after the player is arrested.
    pub inline fn setFadeOutAfterArrest(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1E0B4DC0D990A4E7, .{toggle}); } // 0x1E0B4DC0D990A4E7 0xCB074B9D b323
    /// Sets whether the game should fade in after the player dies or is arrested.
    pub inline fn setFadeInAfterDeathArrest(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDA66D2796BA33F12, .{toggle}); } // 0xDA66D2796BA33F12 0xACDE6985 b323
    pub inline fn setFadeInAfterLoad(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF3D78F59DFE18D79, .{toggle}); } // 0xF3D78F59DFE18D79 0x6E00EB0B b323
    /// returns savehouseHandle
    pub inline fn registerSaveHouse(vec: types.Vector3, p_3: f32, p_4: [*c]const u8, p_5: types.Any, p_6: types.Any) !c_int { return try invoker.invoke(c_int, 0xC0714D0A7EEECA54, .{vec.x, vec.y, vec.z, p_3, p_4, p_5, p_6}); } // 0xC0714D0A7EEECA54 0x39C1849A b323
    pub inline fn setSaveHouse(savehouse_handle: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x4F548CABEAE553BC, .{savehouse_handle, p_1, p_2}); } // 0x4F548CABEAE553BC 0xC3240BB4 b323
    pub inline fn overrideSaveHouse(p_0: windows.BOOL, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: windows.BOOL, p_6: f32, p_7: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1162EA8AE9D24EEA, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0x1162EA8AE9D24EEA 0x47436C12 b323
    pub inline fn getSaveHouseDetailsAfterSuccessfulLoad(p_0: [*c]types.Vector3, p_1: [*c]f32, fade_in_after_load: [*c]windows.BOOL, p_3: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA4A0065E39C9F25C, .{p_0, p_1, fade_in_after_load, p_3}); } // 0xA4A0065E39C9F25C 0xC4D71AB4 b323
    pub inline fn doAutoSave() !void { try invoker.invoke(void, 0x50EEAAD86232EE55, .{}); } // 0x50EEAAD86232EE55 0x54C44B1A b323
    /// Returns true if profile setting 208 is equal to 0.
    pub inline fn getIsAutoSaveOff() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6E04F06094C87047, .{}); } // 0x6E04F06094C87047 0xA8546914 b323
    pub inline fn isAutoSaveInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x69240733738C19A0, .{}); } // 0x69240733738C19A0 0x36F75399 b323
    pub inline fn hasCodeRequestedAutosave() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2107A3773771186D, .{}); } // 0x2107A3773771186D 0x78350773 b323
    pub inline fn clearCodeRequestedAutosave() !void { try invoker.invoke(void, 0x06462A961E94B67C, .{}); } // 0x06462A961E94B67C 0x5A45B11A b323
    pub inline fn beginReplayStats(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xE0E500246FF73D66, .{p_0, p_1}); } // 0xE0E500246FF73D66 0x17F4F44D b323
    pub inline fn addReplayStatValue(value: types.Any) !void { try invoker.invoke(void, 0x69FE6DC87BD2A5E9, .{value}); } // 0x69FE6DC87BD2A5E9 0x81216EE0 b323
    pub inline fn endReplayStats() !void { try invoker.invoke(void, 0xA23E821FBDF8A5F2, .{}); } // 0xA23E821FBDF8A5F2 0xCB570185 b323
    pub inline fn haveReplayStatsBeenStored() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD642319C54AADEB6, .{}); } // 0xD642319C54AADEB6 0xC58250F1 b323
    pub inline fn getReplayStatMissionId() !c_int { return try invoker.invoke(c_int, 0x5B1F2E327B6B6FE1, .{}); } // 0x5B1F2E327B6B6FE1 0x50C39926 b323
    pub inline fn getReplayStatMissionType() !c_int { return try invoker.invoke(c_int, 0x2B626A0150E4D449, .{}); } // 0x2B626A0150E4D449 0x710E5D1E b323
    pub inline fn getReplayStatCount() !c_int { return try invoker.invoke(c_int, 0xDC9274A7EF6B2867, .{}); } // 0xDC9274A7EF6B2867 0xC7BD1AF0 b323
    pub inline fn getReplayStatAtIndex(index: c_int) !c_int { return try invoker.invoke(c_int, 0x8098C8D6597AAE18, .{index}); } // 0x8098C8D6597AAE18 0x22BE2423 b323
    pub inline fn clearReplayStats() !void { try invoker.invoke(void, 0x1B1AB132A16FDA55, .{}); } // 0x1B1AB132A16FDA55 0xC47DFF02 b323
    pub inline fn queueMissionRepeatLoad() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x72DE52178C291CB5, .{}); } // 0x72DE52178C291CB5 0xF62B3C48 b323
    /// Shows the screen which is visible before you redo a mission? The game will make a restoration point where you will cameback when the mission is over. \
    /// Returns 1 if the message isn't currently on screen
    pub inline fn queueMissionRepeatSave() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x44A0BDC559B35F6E, .{}); } // 0x44A0BDC559B35F6E 0x3589452B b323
    pub inline fn queueMissionRepeatSaveForBenchmarkTest() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEB2104E905C6F2E9, .{}); } // 0xEB2104E905C6F2E9  b323
    pub inline fn getStatusOfMissionRepeatSave() !c_int { return try invoker.invoke(c_int, 0x2B5E102E4A42F2BF, .{}); } // 0x2B5E102E4A42F2BF 0x144AAF22 b323
    pub inline fn isMemoryCardInUse() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8A75CE2956274ADD, .{}); } // 0x8A75CE2956274ADD 0x40CE4DFD b323
    pub inline fn shootSingleBulletBetweenCoords(vec_1__: types.Vector3, vec_2__: types.Vector3, damage: c_int, p_7: windows.BOOL, weapon_hash: types.Hash, owner_ped: types.Ped, is_audible: windows.BOOL, is_invisible: windows.BOOL, speed: f32) !void { try invoker.invoke(void, 0x867654CBC7606F2C, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, damage, p_7, weapon_hash, owner_ped, is_audible, is_invisible, speed}); } // 0x867654CBC7606F2C 0xCB7415AC b323
    /// entity - entity to ignore
    pub inline fn shootSingleBulletBetweenCoordsIgnoreEntity(vec_1__: types.Vector3, vec_2__: types.Vector3, damage: c_int, p_7: windows.BOOL, weapon_hash: types.Hash, owner_ped: types.Ped, is_audible: windows.BOOL, is_invisible: windows.BOOL, speed: f32, entity: types.Entity, p_1_4: types.Any) !void { try invoker.invoke(void, 0xE3A7742E0B7A2F8B, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, damage, p_7, weapon_hash, owner_ped, is_audible, is_invisible, speed, entity, p_1_4}); } // 0xE3A7742E0B7A2F8B 0x52ACCB7B b323
    /// entity - entity to ignore \
    /// targetEntity - entity to home in on, if the weapon hash provided supports homing
    pub inline fn shootSingleBulletBetweenCoordsIgnoreEntityNew(vec_1__: types.Vector3, vec_2__: types.Vector3, damage: c_int, p_7: windows.BOOL, weapon_hash: types.Hash, owner_ped: types.Ped, is_audible: windows.BOOL, is_invisible: windows.BOOL, speed: f32, entity: types.Entity, p_1_4: windows.BOOL, p_1_5: windows.BOOL, target_entity: types.Entity, p_1_7: windows.BOOL, p_1_8: types.Any, p_1_9: types.Any, p_2_0: types.Any) !void { try invoker.invoke(void, 0xBFE5756E7407064A, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, damage, p_7, weapon_hash, owner_ped, is_audible, is_invisible, speed, entity, p_1_4, p_1_5, target_entity, p_1_7, p_1_8, p_1_9, p_2_0}); } // 0xBFE5756E7407064A 0xCCDC33CC b323
    /// Gets the dimensions of a model.
    /// 
    /// Calculate (maximum - minimum) to get the size, in which case, Y will be how long the model is.
    /// 
    /// Example from the scripts: MISC::GET_MODEL_DIMENSIONS(ENTITY::GET_ENTITY_MODEL(PLAYER::PLAYER_PED_ID()), &v_1A, &v_17);
    pub inline fn getModelDimensions(model_hash: types.Hash, minimum: [*c]types.Vector3, maximum: [*c]types.Vector3) !void { try invoker.invoke(void, 0x03E8D3D5F549087A, .{model_hash, minimum, maximum}); } // 0x03E8D3D5F549087A 0x91ABB8E0 b323
    /// Sets a visually fake wanted level on the user interface. Used by Rockstar's scripts to "override" regular wanted levels and make custom ones while the real wanted level and multipliers are still in effect.
    /// 
    /// Max is 6, anything above this makes it just 6. Also the mini-map gets the red & blue flashing effect.
    pub inline fn setFakeWantedLevel(fake_wanted_level: c_int) !void { try invoker.invoke(void, 0x1454F2448DE30163, .{fake_wanted_level}); } // 0x1454F2448DE30163 0x85B1C9FA b323
    pub inline fn getFakeWantedLevel() !c_int { return try invoker.invoke(c_int, 0x4C9296CBCD1B971E, .{}); } // 0x4C9296CBCD1B971E 0x0022A430 b323
    pub inline fn usingMissionCreator(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF14878FC50BEC6EE, .{toggle}); } // 0xF14878FC50BEC6EE 0x20AB0B6B b323
    pub inline fn allowMissionCreatorWarp(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDEA36202FC3382DF, .{toggle}); } // 0xDEA36202FC3382DF 0x082BA6F2 b323
    pub inline fn setMinigameInProgress(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x19E00D7322C6F85B, .{toggle}); } // 0x19E00D7322C6F85B 0x348B9046 b323
    pub inline fn isMinigameInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2B4A15E44DE0F478, .{}); } // 0x2B4A15E44DE0F478 0x53A95E13 b323
    pub inline fn isThisAMinigameScript() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7B30F65D7B710098, .{}); } // 0x7B30F65D7B710098 0x7605EF6F b323
    /// This function is hard-coded to always return 0.
    pub inline fn isSniperInverted() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x61A23B7EDA9BDA24, .{}); } // 0x61A23B7EDA9BDA24 0x5C3BF51B b323
    /// Returns true if the game is using the metric measurement system (profile setting 227), false if imperial is used.
    pub inline fn shouldUseMetricMeasurements() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD3D15555431AB793, .{}); } // 0xD3D15555431AB793 0xBAF17315 b323
    pub inline fn getProfileSetting(profile_setting: c_int) !c_int { return try invoker.invoke(c_int, 0xC488FF2356EA7791, .{profile_setting}); } // 0xC488FF2356EA7791 0xD374BEBC b323
    pub inline fn areStringsEqual(string_1: [*c]const u8, string_2: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0C515FAB3FF9EA92, .{string_1, string_2}); } // 0x0C515FAB3FF9EA92 0x877C0BC5 b323
    /// Compares two strings up to a specified number of characters.
    /// 
    /// Parameters: \
    /// str1 - String to be compared. \
    /// str2 - String to be compared. \
    /// matchCase - Comparison will be case-sensitive. \
    /// maxLength - Maximum number of characters to compare. A value of -1 indicates an infinite length.
    /// 
    /// Returns: \
    /// A value indicating the relationship between the strings: \
    /// <0 - The first non-matching character in 'str1' is less than the one in 'str2'. (e.g. 'A' < 'B', so result = -1) \
    /// 0 - The contents of both strings are equal. \
    /// >0 - The first non-matching character in 'str1' is less than the one in 'str2'. (e.g. 'B' > 'A', so result = 1)
    /// 
    /// Examples: \
    /// MISC::COMPARE_STRINGS("STRING", "string", false, -1); // 0; equal \
    /// MISC::COMPARE_STRINGS("TESTING", "test", false, 4); // 0; equal \
    /// MISC::COMPARE_STRINGS("R2D2", "R2xx", false, 2); // 0; equal \
    /// MISC::COMPARE_STRINGS("foo", "bar", false, -1); // 4; 'f' > 'b' \
    /// MISC::COMPARE_STRINGS("A", "A", true, 1); // 0; equal
    /// 
    /// When comparing case-sensitive strings, lower-case characters are greater than upper-case characters: \
    /// MISC::COMPARE_STRINGS("A", "a", true, 1); // -1; 'A' < 'a' \
    /// MISC::COMPARE_STRINGS("a", "A", true, 1); // 1; 'a' > 'A'
    pub inline fn compareStrings(str_1: [*c]const u8, str_2: [*c]const u8, match_case: windows.BOOL, max_length: c_int) !c_int { return try invoker.invoke(c_int, 0x1E34710ECD4AB0EB, .{str_1, str_2, match_case, max_length}); } // 0x1E34710ECD4AB0EB 0xFE25A58F b323
    pub inline fn absi(value: c_int) !c_int { return try invoker.invoke(c_int, 0xF0D31AD191A74F87, .{value}); } // 0xF0D31AD191A74F87 0xB44677C5 b323
    pub inline fn absf(value: f32) !f32 { return try invoker.invoke(f32, 0x73D57CFFDD12C355, .{value}); } // 0x73D57CFFDD12C355 0xAF6F6E0B b323
    /// Determines whether there is a sniper bullet within the specified coordinates. The coordinates form an axis-aligned bounding box.
    pub inline fn isSniperBulletInArea(vec_1__: types.Vector3, vec_2__: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFEFCF11B01287125, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0xFEFCF11B01287125 0x0483715C b323
    /// Determines whether there is a projectile within the specified coordinates. The coordinates form a rectangle.
    /// 
    /// - Nacorpio
    /// 
    /// 
    /// ownedByPlayer = only projectiles fired by the player will be detected.
    pub inline fn isProjectileInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5270A8FBC098C3F8, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, owned_by_player}); } // 0x5270A8FBC098C3F8 0x78E1A557 b323
    /// Determines whether there is a projectile of a specific type within the specified coordinates. The coordinates form a axis-aligned bounding box.
    pub inline fn isProjectileTypeInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, @"type": c_int, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E0DC353342C4A6D, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, @"type", owned_by_player}); } // 0x2E0DC353342C4A6D 0x2B73BCF6 b323
    /// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
    pub inline fn isProjectileTypeInAngledArea(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, p_7: types.Any, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF0BC12401061DEA0, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, p_7, owned_by_player}); } // 0xF0BC12401061DEA0 0xD1AE2681 b323
    pub inline fn isProjectileTypeWithinDistance(vec: types.Vector3, projectile_hash: types.Hash, radius: f32, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x34318593248C8FB2, .{vec.x, vec.y, vec.z, projectile_hash, radius, owned_by_player}); } // 0x34318593248C8FB2 0xBE81F1E2 b323
    pub inline fn getCoordsOfProjectileTypeInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, projectile_hash: types.Hash, projectile_pos: [*c]types.Vector3, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8D7A43EC6A5FEA45, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, projectile_hash, projectile_pos, owned_by_player}); } // 0x8D7A43EC6A5FEA45 0x1A40454B b323
    pub inline fn getCoordsOfProjectileTypeInAngledArea(vecangledareapoint_1__: types.Vector3, vecangledareapoint_2__: types.Vector3, distance_of_opposite_face: f32, weapon_type: types.Hash, position_out: [*c]types.Vector3, b_is_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3DA8C28346B62CED, .{vecangledareapoint_1__.x, vecangledareapoint_1__.y, vecangledareapoint_1__.z, vecangledareapoint_2__.x, vecangledareapoint_2__.y, vecangledareapoint_2__.z, distance_of_opposite_face, weapon_type, position_out, b_is_player}); } // 0x3DA8C28346B62CED  b2802
    pub inline fn getCoordsOfProjectileTypeWithinDistance(ped: types.Ped, weapon_hash: types.Hash, distance: f32, out_coords: [*c]types.Vector3, p_4: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDFB4138EEFED7B81, .{ped, weapon_hash, distance, out_coords, p_4}); } // 0xDFB4138EEFED7B81 0x6BDE5CE4 b323
    pub inline fn getProjectileOfProjectileTypeWithinDistance(ped: types.Ped, weapon_hash: types.Hash, distance: f32, out_coords: [*c]types.Vector3, out_projectile: [*c]types.Object, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x82FDE6A57EE4EE44, .{ped, weapon_hash, distance, out_coords, out_projectile, p_5}); } // 0x82FDE6A57EE4EE44 0x507BC6F7 b323
    /// For projectiles, see: IS_PROJECTILE_TYPE_IN_ANGLED_AREA \
    /// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area. \
    /// Returns True if a bullet, as maintained by a pool within CWeaponManager, has been fired into the defined angled area.
    pub inline fn isBulletInAngledArea(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1A8B5F3C01E2B477, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, owned_by_player}); } // 0x1A8B5F3C01E2B477 0xE2DB58F7 b323
    pub inline fn isBulletInArea(vec: types.Vector3, radius: f32, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3F2023999AD51C1F, .{vec.x, vec.y, vec.z, radius, owned_by_player}); } // 0x3F2023999AD51C1F 0xB54F46CA b323
    pub inline fn isBulletInBox(vec_1__: types.Vector3, vec_2__: types.Vector3, owned_by_player: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDE0F6D7450D37351, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, owned_by_player}); } // 0xDE0F6D7450D37351 0xAB73ED26 b323
    /// p3 - possibly radius?
    pub inline fn hasBulletImpactedInArea(vec: types.Vector3, p_3: f32, p_4: windows.BOOL, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9870ACFB89A90995, .{vec.x, vec.y, vec.z, p_3, p_4, p_5}); } // 0x9870ACFB89A90995 0x902BC7D9 b323
    pub inline fn hasBulletImpactedInBox(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: windows.BOOL, p_7: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDC8C5D7CFEAB8394, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0xDC8C5D7CFEAB8394 0x2C2618CC b323
    /// PS4
    pub inline fn isOrbisVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA72BC0B675B1519E, .{}); } // 0xA72BC0B675B1519E 0x40282018 b323
    /// XBOX ONE
    pub inline fn isDurangoVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4D982ADB1978442D, .{}); } // 0x4D982ADB1978442D 0x46FB06A5 b323
    pub inline fn isXbox360Version() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF6201B4DAF662A9D, .{}); } // 0xF6201B4DAF662A9D 0x24005CC8 b323
    pub inline fn isPs3Version() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCCA1072C29D096C2, .{}); } // 0xCCA1072C29D096C2 0x4C0D5303 b323
    pub inline fn isPcVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x48AF36444B965238, .{}); } // 0x48AF36444B965238 0x4D5D9EE3 b323
    pub inline fn isSteamVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0A27B2B6282F7169, .{}); } // 0x0A27B2B6282F7169  b2545
    pub inline fn isXboxpcVersion_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE2BCD0EFAE90D1F4, .{}); } // 0xE2BCD0EFAE90D1F4  b3504
    /// Used to block some of the prostitute stuff due to laws in Australia.
    pub inline fn isAussieVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9F1935CA1F724008, .{}); } // 0x9F1935CA1F724008 0x944BA1DC b323
    pub inline fn isJapaneseVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB8C0BB75D8A77DB3, .{}); } // 0xB8C0BB75D8A77DB3  b2545
    pub inline fn isXboxPlatform() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x138679CA01E21F53, .{}); } // 0x138679CA01E21F53  b2612
    /// Xbox Series (Scarlett) version...
    pub inline fn isScarlettVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC545AB1CF97ABB34, .{}); } // 0xC545AB1CF97ABB34  b2612
    pub inline fn isScePlatform() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF911E695C1EB8518, .{}); } // 0xF911E695C1EB8518  b2612
    /// PS5 (Prospero) version...
    pub inline fn isProsperoVersion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x807ABE1AB65C24D2, .{}); } // 0x807ABE1AB65C24D2  b2612
    pub inline fn isStringNull(string: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF22B6C47C6EAB066, .{string}); } // 0xF22B6C47C6EAB066 0x8E71E00F b323
    pub inline fn isStringNullOrEmpty(string: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCA042B6957743895, .{string}); } // 0xCA042B6957743895 0x42E9F2CA b323
    /// Returns false if it's a null or empty string or if the string is too long. outInteger will be set to -999 in that case.
    /// 
    /// If all checks have passed successfully, the return value will be set to whatever strtol(string, 0i64, 10); returns.
    pub inline fn stringToInt(string: [*c]const u8, out_integer: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5A5F40FE637EB584, .{string, out_integer}); } // 0x5A5F40FE637EB584 0x590A8160 b323
    pub inline fn setBitsInRange(@"var": [*c]c_int, range_start: c_int, range_end: c_int, p_3: c_int) !void { try invoker.invoke(void, 0x8EF07E15701D61ED, .{@"var", range_start, range_end, p_3}); } // 0x8EF07E15701D61ED 0x32094719 b323
    pub inline fn getBitsInRange(@"var": c_int, range_start: c_int, range_end: c_int) !c_int { return try invoker.invoke(c_int, 0x53158863FCC0893A, .{@"var", range_start, range_end}); } // 0x53158863FCC0893A 0xCA03A1E5 b323
    /// See description of `ADD_STUNT_JUMP_ANGLED` for detailed info. The only difference really is this one does not have the radius (or angle, not sure) floats parameters for entry and landing zones.
    pub inline fn addStuntJump(vec_1__: types.Vector3, vec_2__: types.Vector3, vec_3__: types.Vector3, vec_4__: types.Vector3, cam__: types.Vector3, p_1_5: c_int, p_1_6: c_int, p_1_7: c_int) !c_int { return try invoker.invoke(c_int, 0x1A992DA297A4630C, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, vec_3__.x, vec_3__.y, vec_3__.z, vec_4__.x, vec_4__.y, vec_4__.z, cam__.x, cam__.y, cam__.z, p_1_5, p_1_6, p_1_7}); } // 0x1A992DA297A4630C 0xB630E5FF b323
    /// Creates a new stunt jump.
    /// 
    /// The radius1 and radius2 might actually not be a radius at all, but that's what it seems to me testing them in-game. But they may be 'angle' floats instead, considering this native is named ADD_STUNT_JUMP_**ANGLED**.
    /// 
    /// Info about the specific 'parameter sections':
    /// 
    /// 
    /// **x1, y1, z1, x2, y2, z2 and radius1:**
    /// 
    /// First coordinates are for the jump entry area, and the radius that will be checked around that area. So if you're not exactly within the coordinates, but you are within the outter radius limit then it will still register as entering the stunt jump. Note as mentioned above, the radius is just a guess, I'm not really sure about it's exact purpose.
    /// 
    /// 
    /// **x3, y3, z3, x4, y4, z4 and radius2:**
    /// 
    /// Next part is the landing area, again starting with the left bottom (nearest to the stunt jump entry zone) coordinate, and the second one being the top right furthest away part of the landing area. Followed by another (most likely) radius float, this is usually slightly larger than the entry zone 'radius' float value, just because you have quite a lot of places where you can land (I'm guessing).
    /// 
    /// 
    /// **camX, camY and camZ:**
    /// 
    /// The final coordinate in this native is the Camera position. Rotation and zoom/FOV is managed by the game itself, you just need to provide the camera location.
    /// 
    /// 
    /// **unk1, unk2 and unk3:**
    /// 
    /// Not sure what these are for, but they're always `150, 0, 0` in decompiled scripts.
    /// 
    /// Here is a list of almost all of the stunt jumps from GTA V (taken from decompiled scripts): https://pastebin.com/EW1jBPkY
    pub inline fn addStuntJumpAngled(vec_1__: types.Vector3, vec_2__: types.Vector3, radius_1: f32, vec_3__: types.Vector3, vec_4__: types.Vector3, radius_2: f32, cam__: types.Vector3, p_1_7: c_int, p_1_8: c_int, p_1_9: c_int) !c_int { return try invoker.invoke(c_int, 0xBBE5D803A5360CBF, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, radius_1, vec_3__.x, vec_3__.y, vec_3__.z, vec_4__.x, vec_4__.y, vec_4__.z, radius_2, cam__.x, cam__.y, cam__.z, p_1_7, p_1_8, p_1_9}); } // 0xBBE5D803A5360CBF 0xB9B7E777 b323
    /// Toggles some stunt jump stuff.
    pub inline fn toggleShowOptionalStuntJumpCamera(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFB80AB299D2EE1BD, .{toggle}); } // 0xFB80AB299D2EE1BD  b757
    pub inline fn deleteStuntJump(p_0: c_int) !void { try invoker.invoke(void, 0xDC518000E39DAE1F, .{p_0}); } // 0xDC518000E39DAE1F 0x840CB5DA b323
    pub inline fn enableStuntJumpSet(p_0: c_int) !void { try invoker.invoke(void, 0xE369A5783B866016, .{p_0}); } // 0xE369A5783B866016 0x9D1E7785 b323
    pub inline fn disableStuntJumpSet(p_0: c_int) !void { try invoker.invoke(void, 0xA5272EBEDD4747F6, .{p_0}); } // 0xA5272EBEDD4747F6 0x644C9FA4 b323
    pub inline fn setStuntJumpsCanTrigger(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD79185689F8FD5DF, .{toggle}); } // 0xD79185689F8FD5DF 0x3C806A2D b323
    pub inline fn isStuntJumpInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7A3F19700A4D0525, .{}); } // 0x7A3F19700A4D0525 0xF477D0B1 b323
    pub inline fn isStuntJumpMessageShowing() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2272B0A1343129F4, .{}); } // 0x2272B0A1343129F4 0x021636EE b323
    pub inline fn getNumSuccessfulStuntJumps() !c_int { return try invoker.invoke(c_int, 0x996DD1E1E02F1008, .{}); } // 0x996DD1E1E02F1008 0x006F9BA2 b323
    pub inline fn getTotalSuccessfulStuntJumps() !c_int { return try invoker.invoke(c_int, 0x6856EC3D35C81EA4, .{}); } // 0x6856EC3D35C81EA4 0x495BE324 b323
    pub inline fn cancelStuntJump() !void { try invoker.invoke(void, 0xE6B7B0ACD4E4B75E, .{}); } // 0xE6B7B0ACD4E4B75E 0xF43D9821 b323
    /// Make sure to call this from the correct thread if you're using multiple threads because all other threads except the one which is calling SET_GAME_PAUSED will be paused which means you will lose control and the game remains in paused mode until you exit GTA5.exe
    pub inline fn setGamePaused(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x577D1284D6873711, .{toggle}); } // 0x577D1284D6873711 0x8230FF6C b323
    pub inline fn setThisScriptCanBePaused(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAA391C728106F7AF, .{toggle}); } // 0xAA391C728106F7AF 0xA0C3CE29 b323
    pub inline fn setThisScriptCanRemoveBlipsCreatedByAnyScript(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB98236CAAECEF897, .{toggle}); } // 0xB98236CAAECEF897 0xD06F1720 b323
    /// This native appears on the cheat_controller script and tracks a combination of buttons, which may be used to toggle cheats in-game. Credits to ThreeSocks for the info. The hash contains the combination, while the "amount" represents the amount of buttons used in a combination. The following page can be used to make a button combination: gta5offset.com/ts/hash/
    /// 
    /// INT_SCORES_SCORTED was a hash collision
    pub inline fn hasCheatWithHashBeenActivated(hash: types.Hash, amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x071E2A839DE82D90, .{hash, amount}); } // 0x071E2A839DE82D90 0xFF6191E1 b323
    /// Get inputted "Cheat code", for example:
    /// 
    /// while (TRUE) \
    /// { \
    ///     if (MISC::HAS_PC_CHEAT_WITH_HASH_BEEN_ACTIVATED(${fugitive}))
    ///     {
    ///        // Do something.
    ///     }
    ///     SYSTEM::WAIT(0);
    /// }
    /// 
    /// Calling this will also set the last saved string hash to zero.
    /// 
    pub inline fn hasPcCheatWithHashBeenActivated(hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x557E43C447E700A8, .{hash}); } // 0x557E43C447E700A8  b323
    pub inline fn overrideFreezeFlags(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xFA3FFB0EEBC288A3, .{p_0}); } // 0xFA3FFB0EEBC288A3  b2060
    /// Formerly known as _LOWER_MAP_PROP_DENSITY and wrongly due to idiots as _ENABLE_MP_DLC_MAPS. \
    /// Sets the maximum prop density and changes a loading screen flag from 'loading story mode' to 'loading GTA Online'. Does not touch DLC map data at all.
    /// 
    /// In fact, I doubt this changes the flag whatsoever, that's the OTHER native idiots use together with this that does so, this one only causes a loading screen to show as it reloads map data.
    pub inline fn setInstancePriorityMode(p_0: c_int) !void { try invoker.invoke(void, 0x9BAE5AD2508DF078, .{p_0}); } // 0x9BAE5AD2508DF078 0x721B2492 b323
    /// Sets an unknown flag used by CScene in determining which entities from CMapData scene nodes to draw, similar to SET_INSTANCE_PRIORITY_MODE.
    pub inline fn setInstancePriorityHint(flag: c_int) !void { try invoker.invoke(void, 0xC5F0A8EBD3F361CE, .{flag}); } // 0xC5F0A8EBD3F361CE 0xE202879D b323
    /// This function is hard-coded to always return 0.
    pub inline fn isFrontendFading() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7EA2B6AF97ECA6ED, .{}); } // 0x7EA2B6AF97ECA6ED 0x8FF6232C b323
    /// spawns a few distant/out-of-sight peds, vehicles, animals etc each time it is called
    pub inline fn populateNow() !void { try invoker.invoke(void, 0x7472BB270D7B4F3E, .{}); } // 0x7472BB270D7B4F3E 0x72C20700 b323
    pub inline fn getIndexOfCurrentLevel() !c_int { return try invoker.invoke(c_int, 0xCBAD6729F7B1F4FC, .{}); } // 0xCBAD6729F7B1F4FC 0x6F203C6E b323
    /// level can be from 0 to 3 \
    /// 0: 9.8 - normal \
    /// 1: 2.4 - low \
    /// 2: 0.1 - very low \
    /// 3: 0.0 - off
    pub inline fn setGravityLevel(level: c_int) !void { try invoker.invoke(void, 0x740E14FAD5842351, .{level}); } // 0x740E14FAD5842351 0x2D833F4A b323
    pub inline fn startSaveData(p_0: [*c]types.Any, p_1: types.Any, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xA9575F812C6A7997, .{p_0, p_1, p_2}); } // 0xA9575F812C6A7997 0x881A694D b323
    pub inline fn stopSaveData() !void { try invoker.invoke(void, 0x74E20C9145FB66FD, .{}); } // 0x74E20C9145FB66FD 0x3B1C07C8 b323
    pub inline fn getSizeOfSaveData(p_0: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xA09F896CE912481F, .{p_0}); } // 0xA09F896CE912481F 0x9EF0BC64 b323
    pub inline fn registerIntToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0x34C9EE5986258415, .{p_0, name}); } // 0x34C9EE5986258415 0xB930956F b323
    pub inline fn registerInt64ToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0xA735353C77334EA0, .{p_0, name}); } // 0xA735353C77334EA0  b323
    pub inline fn registerEnumToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0x10C2FA78D0E128A1, .{p_0, name}); } // 0x10C2FA78D0E128A1 0x9B38374A b323
    pub inline fn registerFloatToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0x7CAEC29ECB5DFEBB, .{p_0, name}); } // 0x7CAEC29ECB5DFEBB 0xDB06F7AD b323
    pub inline fn registerBoolToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0xC8F4131414C835A1, .{p_0, name}); } // 0xC8F4131414C835A1 0x5417E0E0 b323
    pub inline fn registerTextLabelToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0xEDB1232C5BEAE62F, .{p_0, name}); } // 0xEDB1232C5BEAE62F 0x284352C4 b323
    /// MISC::REGISTER_TEXT_LABEL_15_TO_SAVE(&a_0._f1, "tlPlateText"); \
    /// MISC::REGISTER_TEXT_LABEL_15_TO_SAVE(&a_0._f1C, "tlPlateText_pending"); \
    /// MISC::REGISTER_TEXT_LABEL_15_TO_SAVE(&a_0._f10B, "tlCarAppPlateText");
    pub inline fn registerTextLabel15ToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0x6F7794F28C6B2535, .{p_0, name}); } // 0x6F7794F28C6B2535 0xE2089749 b323
    /// Only found 3 times in decompiled scripts.
    /// 
    /// MISC::REGISTER_TEXT_LABEL_23_TO_SAVE(a_0, "Movie_Name_For_This_Player"); \
    /// MISC::REGISTER_TEXT_LABEL_23_TO_SAVE(&a_0._fB, "Ringtone_For_This_Player"); \
    /// MISC::REGISTER_TEXT_LABEL_23_TO_SAVE(&a_0._f1EC4._f12[v_A/*6*/], &v_13); // where v_13 is "MPATMLOGSCRS0" thru "MPATMLOGSCRS15"
    pub inline fn registerTextLabel23ToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0x48F069265A0E4BEC, .{p_0, name}); } // 0x48F069265A0E4BEC 0xF91B8C33 b323
    /// Only found 2 times in decompiled scripts.
    /// 
    /// MISC::REGISTER_TEXT_LABEL_31_TO_SAVE(&a_0._f1F5A._f6[0/*8*/], "TEMPSTAT_LABEL"); // gets saved in a struct called "g_SaveData_STRING_ScriptSaves" \
    /// MISC::REGISTER_TEXT_LABEL_31_TO_SAVE(&a_0._f4B4[v_1A/*8*/], &v_5); // where v_5 is "Name0" thru "Name9", gets saved in a struct called "OUTFIT_Name"
    pub inline fn registerTextLabel31ToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0x8269816F6CFD40F8, .{p_0, name}); } // 0x8269816F6CFD40F8 0x74E8FAD9 b323
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(a_0, "Thumb_label"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f10, "Photo_label"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(a_0, "GXTlabel"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f21, "StringComp"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f43, "SecondStringComp"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f53, "ThirdStringComp"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f32, "SenderStringComp"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f726[v_1A/*16*/], &v_20); // where v_20 is "LastJobTL_0_1" thru "LastJobTL_2_1", gets saved in a struct called "LAST_JobGamer_TL" \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f4B, "PAID_PLAYER"); \
    /// MISC::REGISTER_TEXT_LABEL_63_TO_SAVE(&a_0._f5B, "RADIO_STATION");
    pub inline fn registerTextLabel63ToSave(p_0: [*c]types.Any, name: [*c]const u8) !void { try invoker.invoke(void, 0xFAA457EF263E8763, .{p_0, name}); } // 0xFAA457EF263E8763 0x6B4335DD b323
    pub inline fn startSaveStructWithSize(p_0: [*c]types.Any, size: c_int, struct_name: [*c]const u8) !void { try invoker.invoke(void, 0xBF737600CDDBEADD, .{p_0, size, struct_name}); } // 0xBF737600CDDBEADD 0xFB45728E b323
    pub inline fn stopSaveStruct() !void { try invoker.invoke(void, 0xEB1774DF12BB9F12, .{}); } // 0xEB1774DF12BB9F12 0xC2624A28 b323
    pub inline fn startSaveArrayWithSize(p_0: [*c]types.Any, size: c_int, array_name: [*c]const u8) !void { try invoker.invoke(void, 0x60FE567DF1B1AF9D, .{p_0, size, array_name}); } // 0x60FE567DF1B1AF9D 0x893A342C b323
    pub inline fn stopSaveArray() !void { try invoker.invoke(void, 0x04456F95153C6BE4, .{}); } // 0x04456F95153C6BE4 0x0CAD8217 b323
    pub inline fn copyScriptStruct(dst: [*c]types.Any, src: [*c]types.Any, size: c_int) !void { try invoker.invoke(void, 0x213AEB2B90CBA7AC, .{dst, src, size}); } // 0x213AEB2B90CBA7AC  b877
    /// https://alloc8or.re/gta5/doc/enums/DispatchType.txt
    pub inline fn enableDispatchService(dispatch_service: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDC0F817884CDD856, .{dispatch_service, toggle}); } // 0xDC0F817884CDD856 0x0B710A51 b323
    pub inline fn blockDispatchServiceResourceCreation(dispatch_service: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9B2BD3773123EA2F, .{dispatch_service, toggle}); } // 0x9B2BD3773123EA2F 0xE0F0684F b323
    pub inline fn getNumberResourcesAllocatedToWantedLevel(dispatch_service: c_int) !c_int { return try invoker.invoke(c_int, 0xEB4A0C2D56441717, .{dispatch_service}); } // 0xEB4A0C2D56441717 0x3CE5BF6B b323
    /// As for the 'police' incident, it will call police cars to you, but unlike PedsInCavalcades & Merryweather they won't start shooting at you unless you shoot first or shoot at them. The top 2 however seem to cancel theirselves if there is noone dead around you or a fire. I only figured them out as I found out the 3rd param is definately the amountOfPeople and they called incident 3 in scripts with 4 people (which the firetruck has) and incident 5 with 2 people (which the ambulence has). The 4 param I cant say is radius, but for the pedsInCavalcades and Merryweather R* uses 0.0f and for the top 3 (Emergency Services) they use 3.0f. 
    /// 
    /// Side Note: It seems calling the pedsInCavalcades or Merryweather then removing it seems to break you from calling the EmergencyEvents and I also believe pedsInCavalcades. (The V cavalcades of course not IV).
    /// 
    /// Side Note 2: I say it breaks as if you call this proper, \
    /// if(CREATE_INCIDENT) etc it will return false if you do as I said above. \
    /// =====================================================
    pub inline fn createIncident(dispatch_service: c_int, vec: types.Vector3, num_units: c_int, radius: f32, out_incident_i_d: [*c]c_int, p_7: types.Any, p_8: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3F892CAF67444AE7, .{dispatch_service, vec.x, vec.y, vec.z, num_units, radius, out_incident_i_d, p_7, p_8}); } // 0x3F892CAF67444AE7 0xFC5FF7B3 b323
    /// As for the 'police' incident, it will call police cars to you, but unlike PedsInCavalcades & Merryweather they won't start shooting at you unless you shoot first or shoot at them. The top 2 however seem to cancel theirselves if there is noone dead around you or a fire. I only figured them out as I found out the 3rd param is definately the amountOfPeople and they called incident 3 in scripts with 4 people (which the firetruck has) and incident 5 with 2 people (which the ambulence has). The 4 param I cant say is radius, but for the pedsInCavalcades and Merryweather R* uses 0.0f and for the top 3 (Emergency Services) they use 3.0f. 
    /// 
    /// Side Note: It seems calling the pedsInCavalcades or Merryweather then removing it seems to break you from calling the EmergencyEvents and I also believe pedsInCavalcades. (The V cavalcades of course not IV).
    /// 
    /// Side Note 2: I say it breaks as if you call this proper, \
    /// if(CREATE_INCIDENT) etc it will return false if you do as I said above. \
    /// =====================================================
    pub inline fn createIncidentWithEntity(dispatch_service: c_int, ped: types.Ped, num_units: c_int, radius: f32, out_incident_i_d: [*c]c_int, p_5: types.Any, p_6: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x05983472F0494E60, .{dispatch_service, ped, num_units, radius, out_incident_i_d, p_5, p_6}); } // 0x05983472F0494E60 0xBBC35B03 b323
    /// Delete an incident with a given id.
    /// 
    /// ======================================================= \
    /// Correction, I have change this to int, instead of int* \
    /// as it doesn't use a pointer to the createdIncident. \
    /// If you try it you will crash (or) freeze. \
    /// =======================================================
    pub inline fn deleteIncident(incident_id: c_int) !void { try invoker.invoke(void, 0x556C1AA270D5A207, .{incident_id}); } // 0x556C1AA270D5A207 0x212BD0DC b323
    /// ======================================================= \
    /// Correction, I have change this to int, instead of int* \
    /// as it doesn't use a pointer to the createdIncident. \
    /// If you try it you will crash (or) freeze. \
    /// =======================================================
    pub inline fn isIncidentValid(incident_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC8BC6461E629BEAA, .{incident_id}); } // 0xC8BC6461E629BEAA 0x31FD0BA4 b323
    pub inline fn setIncidentRequestedUnits(incident_id: c_int, dispatch_service: c_int, num_units: c_int) !void { try invoker.invoke(void, 0xB08B85D860E7BA3C, .{incident_id, dispatch_service, num_units}); } // 0xB08B85D860E7BA3C 0x0242D88E b323
    pub inline fn setIdealSpawnDistanceForIncident(incident_id: c_int, p_1: f32) !void { try invoker.invoke(void, 0xD261BA3E7E998072, .{incident_id, p_1}); } // 0xD261BA3E7E998072 0x1F38102E b323
    /// Finds a position ahead of the player by predicting the players next actions. \
    /// The positions match path finding node positions. \
    /// When roads diverge, the position may rapidly change between two or more positions. This is due to the engine not being certain of which path the player will take.
    pub inline fn findSpawnPointInDirection(pos__: types.Vector3, fwdvec__: types.Vector3, distance: f32, spawn_point: [*c]types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6874E2190B0C1972, .{pos__.x, pos__.y, pos__.z, fwdvec__.x, fwdvec__.y, fwdvec__.z, distance, spawn_point}); } // 0x6874E2190B0C1972 0x71AEFD77 b323
    pub inline fn addPopMultiplierArea(vec_1__: types.Vector3, vec_2__: types.Vector3, p_6: f32, p_7: f32, p_8: windows.BOOL, p_9: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x67F6413D3220E18D, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_6, p_7, p_8, p_9}); } // 0x67F6413D3220E18D 0x42BF09B3 b323
    pub inline fn doesPopMultiplierAreaExist(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1327E2FE9746BAEE, .{id}); } // 0x1327E2FE9746BAEE 0xE933B34A b323
    pub inline fn removePopMultiplierArea(id: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xB129E447A2EDA4BF, .{id, p_1}); } // 0xB129E447A2EDA4BF 0xFBDBE374 b323
    pub inline fn isPopMultiplierAreaNetworked(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1312F4B242609CE3, .{id}); } // 0x1312F4B242609CE3  b1290
    /// This native is adding a zone, where you can change density settings. For example, you can add a zone on 0.0, 0.0, 0.0 with radius 900.0 and vehicleMultiplier 0.0, and you will not see any new population vehicle spawned in a radius of 900.0 from 0.0, 0.0, 0.0. Returns the id. You can have only 15 zones at the same time. You can remove zone using REMOVE_POP_MULTIPLIER_SPHERE
    pub inline fn addPopMultiplierSphere(vec: types.Vector3, radius: f32, ped_multiplier: f32, vehicle_multiplier: f32, p_6: windows.BOOL, p_7: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x32C7A7E8C43A1F80, .{vec.x, vec.y, vec.z, radius, ped_multiplier, vehicle_multiplier, p_6, p_7}); } // 0x32C7A7E8C43A1F80 0xCE4A3D20 b323
    pub inline fn doesPopMultiplierSphereExist(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x171BAFB3C60389F4, .{id}); } // 0x171BAFB3C60389F4 0xD2B7A5A0 b791
    /// Removes population multiplier sphere
    pub inline fn removePopMultiplierSphere(id: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xE6869BECDD8F2403, .{id, p_1}); } // 0xE6869BECDD8F2403 0x92E7E4EB b323
    /// Makes the ped jump around like they're in a tennis match
    pub inline fn enableTennisMode(ped: types.Ped, toggle: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x28A04B411933F8A6, .{ped, toggle, p_2}); } // 0x28A04B411933F8A6 0x0BD3F9EC b323
    pub inline fn isTennisMode(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5D5479D115290C3F, .{ped}); } // 0x5D5479D115290C3F 0x04A947BA b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn playTennisSwingAnim(ped: types.Ped, anim_dict: [*c]const u8, anim_name: [*c]const u8, p_3: f32, p_4: f32, p_5: windows.BOOL) !void { try invoker.invoke(void, 0xE266ED23311F24D4, .{ped, anim_dict, anim_name, p_3, p_4, p_5}); } // 0xE266ED23311F24D4 0xC20A7D2B b323
    pub inline fn getTennisSwingAnimComplete(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x17DF68D720AA77F8, .{ped}); } // 0x17DF68D720AA77F8 0x8501E727 b323
    pub inline fn getTennisSwingAnimCanBeInterrupted(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x19BFED045C647C49, .{ped}); } // 0x19BFED045C647C49 0x1A332D2D b323
    pub inline fn getTennisSwingAnimSwung(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE95B0C7D5BA3B96B, .{ped}); } // 0xE95B0C7D5BA3B96B  b323
    pub inline fn playTennisDiveAnim(ped: types.Ped, p_1: c_int, p_2: f32, p_3: f32, p_4: f32, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x8FA9C42FC5D7C64B, .{ped, p_1, p_2, p_3, p_4, p_5}); } // 0x8FA9C42FC5D7C64B 0x0C8865DF b323
    /// From the scripts:
    /// 
    /// MISC::SET_TENNIS_MOVE_NETWORK_SIGNAL_FLOAT(sub_aa49(a_0), "ForcedStopDirection", v_E);
    /// 
    /// Related to tennis mode.
    pub inline fn setTennisMoveNetworkSignalFloat(ped: types.Ped, p_1: [*c]const u8, p_2: f32) !void { try invoker.invoke(void, 0x54F157E0336A3822, .{ped, p_1, p_2}); } // 0x54F157E0336A3822 0x49F977A9 b323
    pub inline fn resetDispatchSpawnLocation() !void { try invoker.invoke(void, 0x5896F2BD5683A4E1, .{}); } // 0x5896F2BD5683A4E1  b1868
    pub inline fn setDispatchSpawnLocation(vec: types.Vector3) !void { try invoker.invoke(void, 0xD10F442036302D50, .{vec.x, vec.y, vec.z}); } // 0xD10F442036302D50 0x6F009E33 b323
    pub inline fn resetDispatchIdealSpawnDistance() !void { try invoker.invoke(void, 0x77A84429DD9F0A15, .{}); } // 0x77A84429DD9F0A15 0xDA65ECAA b323
    pub inline fn setDispatchIdealSpawnDistance(distance: f32) !void { try invoker.invoke(void, 0x6FE601A64180D423, .{distance}); } // 0x6FE601A64180D423 0x6283BE32 b323
    pub inline fn resetDispatchTimeBetweenSpawnAttempts(p_0: types.Any) !void { try invoker.invoke(void, 0xEB2DB0CAD13154B3, .{p_0}); } // 0xEB2DB0CAD13154B3 0x1479E85A b323
    pub inline fn setDispatchTimeBetweenSpawnAttempts(p_0: types.Any, p_1: f32) !void { try invoker.invoke(void, 0x44F7CBC1BEB3327D, .{p_0, p_1}); } // 0x44F7CBC1BEB3327D 0xABADB709 b323
    pub inline fn setDispatchTimeBetweenSpawnAttemptsMultiplier(p_0: types.Any, p_1: f32) !void { try invoker.invoke(void, 0x48838ED9937A15D1, .{p_0, p_1}); } // 0x48838ED9937A15D1 0x1C996BCD b323
    /// To remove, see: REMOVE_DISPATCH_SPAWN_BLOCKING_AREA \
    /// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
    pub inline fn addDispatchSpawnAngledBlockingArea(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32) !c_int { return try invoker.invoke(c_int, 0x918C7B2D2FF3928B, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width}); } // 0x918C7B2D2FF3928B 0xF557BAF9 b323
    pub inline fn addDispatchSpawnSphereBlockingArea(vec_1__: types.Vector2, vec_2__: types.Vector2) !c_int { return try invoker.invoke(c_int, 0x2D4259F1FEB81DA9, .{vec_1__.x, vec_1__.y, vec_2__.x, vec_2__.y}); } // 0x2D4259F1FEB81DA9  b323
    pub inline fn removeDispatchSpawnBlockingArea(p_0: c_int) !void { try invoker.invoke(void, 0x264AC28B01B353A5, .{p_0}); } // 0x264AC28B01B353A5 0xA8D2FB92 b323
    pub inline fn resetDispatchSpawnBlockingAreas() !void { try invoker.invoke(void, 0xAC7BFD5C1D83EA75, .{}); } // 0xAC7BFD5C1D83EA75 0x9A17F835 b323
    pub inline fn resetWantedResponseNumPedsToSpawn() !void { try invoker.invoke(void, 0xD9F692D349249528, .{}); } // 0xD9F692D349249528 0xE0C9307E b323
    pub inline fn setWantedResponseNumPedsToSpawn(p_0: c_int, p_1: c_int) !void { try invoker.invoke(void, 0xE532EC1A63231B4F, .{p_0, p_1}); } // 0xE532EC1A63231B4F 0xA0D8C749 b323
    pub inline fn addTacticalNavMeshPoint(vec: types.Vector3) !void { try invoker.invoke(void, 0xB8721407EE9C3FF6, .{vec.x, vec.y, vec.z}); } // 0xB8721407EE9C3FF6 0x24A4E0B2 b323
    pub inline fn clearTacticalNavMeshPoints() !void { try invoker.invoke(void, 0xB3CD58CCA6CDA852, .{}); } // 0xB3CD58CCA6CDA852 0x66C3C59C b323
    /// Activates (usused?) riot mode. All NPCs are being hostile to each other (including player). Also the game will give weapons (pistols, smgs) to random NPCs.
    pub inline fn setRiotModeEnabled(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2587A48BC88DFADF, .{toggle}); } // 0x2587A48BC88DFADF 0xD9660339 b323
    pub inline fn displayOnscreenKeyboardWithLongerInitialString(p_0: c_int, window_title: [*c]const u8, p_2: [*c]types.Any, default_text: [*c]const u8, default_concat_1: [*c]const u8, default_concat_2: [*c]const u8, default_concat_3: [*c]const u8, default_concat_4: [*c]const u8, default_concat_5: [*c]const u8, default_concat_6: [*c]const u8, default_concat_7: [*c]const u8, max_input_length: c_int) !void { try invoker.invoke(void, 0xCA78CFA0366592FE, .{p_0, window_title, p_2, default_text, default_concat_1, default_concat_2, default_concat_3, default_concat_4, default_concat_5, default_concat_6, default_concat_7, max_input_length}); } // 0xCA78CFA0366592FE 0xD2688412 b323
    /// sfink: note, p0 is set to 6 for PC platform in at least 1 script, or to `unk::_get_ui_language_id() == 0` otherwise.
    /// 
    /// NOTE: windowTitle uses text labels, and an invalid value will display nothing.
    /// 
    /// www.gtaforums.com/topic/788343-vrel-script-hook-v/?p=1067380474
    /// 
    /// windowTitle's \
    /// ----------------- \
    /// CELL_EMAIL_BOD  =   "Enter your Eyefind message" \
    /// CELL_EMAIL_BODE =   "Message too long. Try again" \
    /// CELL_EMAIL_BODF    =   "Forbidden message. Try again" \
    /// CELL_EMAIL_SOD    =   "Enter your Eyefind subject" \
    /// CELL_EMAIL_SODE =   "Subject too long. Try again" \
    /// CELL_EMAIL_SODF    =   "Forbidden text. Try again" \
    /// CELL_EMASH_BOD   =   "Enter your Eyefind message" \
    /// CELL_EMASH_BODE =   "Message too long. Try again" \
    /// CELL_EMASH_BODF    =   "Forbidden message. Try again" \
    /// CELL_EMASH_SOD    =   "Enter your Eyefind subject" \
    /// CELL_EMASH_SODE =   "Subject too long. Try again" \
    /// CELL_EMASH_SODF    =   "Forbidden Text. Try again" \
    /// FMMC_KEY_TIP10   =   "Enter Synopsis" \
    /// FMMC_KEY_TIP12  =   "Enter Custom Team Name" \
    /// FMMC_KEY_TIP12F =   "Forbidden Text. Try again" \
    /// FMMC_KEY_TIP12N  =   "Custom Team Name" \
    /// FMMC_KEY_TIP8 =   "Enter Message" \
    /// FMMC_KEY_TIP8F   =   "Forbidden Text. Try again" \
    /// FMMC_KEY_TIP8FS  =   "Invalid Message. Try again" \
    /// FMMC_KEY_TIP8S  =   "Enter Message" \
    /// FMMC_KEY_TIP9    =   "Enter Outfit Name" \
    /// FMMC_KEY_TIP9F   =   "Invalid Outfit Name. Try again" \
    /// FMMC_KEY_TIP9N  =   "Outfit Name" \
    /// PM_NAME_CHALL  =   "Enter Challenge Name"
    pub inline fn displayOnscreenKeyboard(p_0: c_int, window_title: [*c]const u8, p_2: [*c]const u8, default_text: [*c]const u8, default_concat_1: [*c]const u8, default_concat_2: [*c]const u8, default_concat_3: [*c]const u8, max_input_length: c_int) !void { try invoker.invoke(void, 0x00DC833F2568DBF6, .{p_0, window_title, p_2, default_text, default_concat_1, default_concat_2, default_concat_3, max_input_length}); } // 0x00DC833F2568DBF6 0xAD99F2CE b323
    /// Returns the current status of the onscreen keyboard, and updates the output.
    /// 
    /// Status Codes:
    /// 
    /// -1: Keyboard isn't active \
    /// 0: User still editing \
    /// 1: User has finished editing \
    /// 2: User has canceled editing
    pub inline fn updateOnscreenKeyboard() !c_int { return try invoker.invoke(c_int, 0x0CF2B696BBF945AE, .{}); } // 0x0CF2B696BBF945AE 0x23D0A1CE b323
    /// Returns NULL unless UPDATE_ONSCREEN_KEYBOARD() returns 1 in the same tick.
    pub inline fn getOnscreenKeyboardResult() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x8362B09B91893647, .{}); } // 0x8362B09B91893647 0x44828FB3 b323
    /// DO NOT use this as it doesn't clean up the text input box properly and your script will get stuck in the UPDATE_ONSCREEN_KEYBOARD() loop. \
    /// Use FORCE_CLOSE_TEXT_INPUT_BOX instead.
    pub inline fn cancelOnscreenKeyboard() !void { try invoker.invoke(void, 0x58A39BE597CE99CD, .{}); } // 0x58A39BE597CE99CD  b757
    /// p0 was always 2 in R* scripts. \
    /// Called before calling DISPLAY_ONSCREEN_KEYBOARD if the input needs to be saved.
    pub inline fn nextOnscreenKeyboardResultWillDisplayUsingTheseFonts(p_0: c_int) !void { try invoker.invoke(void, 0x3ED1438C1F5C6612, .{p_0}); } // 0x3ED1438C1F5C6612 0x3301EA47 b323
    /// Appears to remove stealth kill action from memory
    pub inline fn actionManagerEnableAction(hash: types.Hash, enable: windows.BOOL) !void { try invoker.invoke(void, 0xA6A12939F16D85BE, .{hash, enable}); } // 0xA6A12939F16D85BE 0x42B484ED b323
    /// GET_GAME_TIMER() / 1000
    pub inline fn getRealWorldTime() !c_int { return try invoker.invoke(c_int, 0x3F60413F5DF65748, .{}); } // 0x3F60413F5DF65748  b2612
    pub inline fn supressRandomEventThisFrame(event_type: c_int, suppress: windows.BOOL) !void { try invoker.invoke(void, 0x1EAE0A6E978894A2, .{event_type, suppress}); } // 0x1EAE0A6E978894A2 0x8F60366E b323
    pub inline fn setExplosiveAmmoThisFrame(player: types.Player) !void { try invoker.invoke(void, 0xA66C71C98D5F2CFB, .{player}); } // 0xA66C71C98D5F2CFB 0x2EAFA1D1 b323
    pub inline fn setFireAmmoThisFrame(player: types.Player) !void { try invoker.invoke(void, 0x11879CDD803D30F4, .{player}); } // 0x11879CDD803D30F4 0x7C18FC8A b323
    pub inline fn setExplosiveMeleeThisFrame(player: types.Player) !void { try invoker.invoke(void, 0xFF1BED81BFDC0FE0, .{player}); } // 0xFF1BED81BFDC0FE0 0x96663D56 b323
    pub inline fn setSuperJumpThisFrame(player: types.Player) !void { try invoker.invoke(void, 0x57FFF03E423A4C0B, .{player}); } // 0x57FFF03E423A4C0B 0x86745EF3 b323
    pub inline fn setBeastJumpThisFrame(player: types.Player) !void { try invoker.invoke(void, 0x438822C279B73B93, .{player}); } // 0x438822C279B73B93  b573
    pub inline fn setForcedJumpThisFrame(player: types.Player) !void { try invoker.invoke(void, 0xA1183BCFEE0F93D1, .{player}); } // 0xA1183BCFEE0F93D1  b1180
    pub inline fn hasGameInstalledThisSession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6FDDF453C0C756EC, .{}); } // 0x6FDDF453C0C756EC 0xC3C10FCC b323
    pub inline fn setTickerJohnmarstonIsDone() !void { try invoker.invoke(void, 0xFB00CA71DA386228, .{}); } // 0xFB00CA71DA386228 0x054EC103 b323
    pub inline fn areProfileSettingsValid() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5AA3BEFA29F03AD4, .{}); } // 0x5AA3BEFA29F03AD4 0x46B5A15C b323
    pub inline fn preventArrestStateThisFrame() !void { try invoker.invoke(void, 0xE3D969D2785FFB5E, .{}); } // 0xE3D969D2785FFB5E  b323
    /// Sets the localplayer playerinfo state back to playing (State 0)
    /// 
    /// States are: \
    /// -1: "Invalid" \
    /// 0: "Playing" \
    /// 1: "Died" \
    /// 2: "Arrested" \
    /// 3: "Failed Mission" \
    /// 4: "Left Game" \
    /// 5: "Respawn" \
    /// 6: "In MP Cutscene"
    pub inline fn forceGameStatePlaying() !void { try invoker.invoke(void, 0xC0AA53F866B3134D, .{}); } // 0xC0AA53F866B3134D 0x5D209F25 b323
    pub inline fn scriptRaceInit(p_0: c_int, p_1: c_int, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x0A60017F841A54F2, .{p_0, p_1, p_2, p_3}); } // 0x0A60017F841A54F2 0x2D33F15A b323
    pub inline fn scriptRaceShutdown() !void { try invoker.invoke(void, 0x1FF6BF9A63E5757F, .{}); } // 0x1FF6BF9A63E5757F 0xDF99925C b323
    pub inline fn scriptRacePlayerHitCheckpoint(player: types.Player, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x1BB299305C3E8C13, .{player, p_1, p_2, p_3}); } // 0x1BB299305C3E8C13 0xA27F4472 b323
    pub inline fn scriptRaceGetPlayerSplitTime(player: types.Player, p_1: [*c]c_int, p_2: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8EF5573A1F801A5C, .{player, p_1, p_2}); } // 0x8EF5573A1F801A5C 0x07FF553F b323
    pub inline fn startEndUserBenchmark() !void { try invoker.invoke(void, 0x92790862E36C2ADA, .{}); } // 0x92790862E36C2ADA  b323
    pub inline fn stopEndUserBenchmark() !void { try invoker.invoke(void, 0xC7DB36C24634F52B, .{}); } // 0xC7DB36C24634F52B  b323
    pub inline fn resetEndUserBenchmark() !void { try invoker.invoke(void, 0x437138B6A830166A, .{}); } // 0x437138B6A830166A  b323
    /// Saves the benchmark recording to %USERPROFILE%\Documents\Rockstar Games\GTA V\Benchmarks and submits some metrics.
    pub inline fn saveEndUserBenchmark() !void { try invoker.invoke(void, 0x37DEB0AA183FB6D8, .{}); } // 0x37DEB0AA183FB6D8  b323
    /// Returns true if the current frontend menu is FE_MENU_VERSION_SP_PAUSE
    pub inline fn uiStartedEndUserBenchmark() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEA2F2061875EED90, .{}); } // 0xEA2F2061875EED90  b323
    /// Returns true if the current frontend menu is FE_MENU_VERSION_LANDING_MENU
    pub inline fn landingScreenStartedEndUserBenchmark() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3BBBD13E5041A79E, .{}); } // 0x3BBBD13E5041A79E  b323
    /// Returns true if command line option '-benchmark' is set.
    pub inline fn isCommandlineEndUserBenchmark() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA049A5BE0F04F2F8, .{}); } // 0xA049A5BE0F04F2F8  b323
    /// Returns value of the '-benchmarkIterations' command line option.
    pub inline fn getBenchmarkIterations() !c_int { return try invoker.invoke(c_int, 0x4750FC27570311EC, .{}); } // 0x4750FC27570311EC  b323
    /// Returns value of the '-benchmarkPass' command line option.
    pub inline fn getBenchmarkPass() !c_int { return try invoker.invoke(c_int, 0x1B2366C3F2A5C8DF, .{}); } // 0x1B2366C3F2A5C8DF  b323
    /// In singleplayer it does exactly what the name implies. In FiveM / GTA:Online it shows `Disconnecting from GTA Online` HUD and then quits the game.
    pub inline fn restartGame() !void { try invoker.invoke(void, 0xE574A662ACAEFBB1, .{}); } // 0xE574A662ACAEFBB1  b372
    /// Exits the game and downloads a fresh social club update on next restart.
    pub inline fn quitGame() !void { try invoker.invoke(void, 0xEB6891F03362FB12, .{}); } // 0xEB6891F03362FB12  b323
    /// Hardcoded to always return true.
    pub inline fn hasAsyncInstallFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x14832BF2ABA53FC5, .{}); } // 0x14832BF2ABA53FC5  b323
    pub inline fn cleanupAsyncInstall() !void { try invoker.invoke(void, 0xC79AE21974B01FB2, .{}); } // 0xC79AE21974B01FB2  b323
    /// aka "constrained"
    pub inline fn plmIsInConstrainedMode() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x684A41975F077262, .{}); } // 0x684A41975F077262  b323
    /// Returns duration of how long the game has been in power-saving mode (aka "constrained") in milliseconds.
    pub inline fn plmGetConstrainedDurationMs() !c_int { return try invoker.invoke(c_int, 0xABB2FA71C83A1B72, .{}); } // 0xABB2FA71C83A1B72  b323
    /// If toggle is true, the ped's head is shown in the pause menu \
    /// If toggle is false, the ped's head is not shown in the pause menu
    pub inline fn setPlayerIsInAnimalForm(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4EBB7E87AA0DBED4, .{toggle}); } // 0x4EBB7E87AA0DBED4  b323
    /// Although we don't have a jenkins hash for this one, the name is 100% confirmed.
    pub inline fn getIsPlayerInAnimalForm() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9689123E3F213AA5, .{}); } // 0x9689123E3F213AA5  b323
    pub inline fn setPlayerIsRepeatingAMission(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9D8D44ADBBA61EF2, .{toggle}); } // 0x9D8D44ADBBA61EF2  b323
    /// Does nothing (it's a nullsub).
    pub inline fn disableScreenDimmingThisFrame() !void { try invoker.invoke(void, 0x23227DF0B2115469, .{}); } // 0x23227DF0B2115469  b323
    pub inline fn getCityDensity() !f32 { return try invoker.invoke(f32, 0xD10282B6E3751BA0, .{}); } // 0xD10282B6E3751BA0  b323
    pub inline fn useActiveCameraForTimeslicingCentre() !void { try invoker.invoke(void, 0x693478ACBD7F18E7, .{}); } // 0x693478ACBD7F18E7  b1103
    pub inline fn setContentIdIndex(content_id: types.Hash, index: c_int) !void { try invoker.invoke(void, 0x4B82FA6F2D624634, .{content_id, index}); } // 0x4B82FA6F2D624634  b2612
    pub inline fn getContentIdIndex(content_id: types.Hash) !c_int { return try invoker.invoke(c_int, 0xECF041186C5A94DC, .{content_id}); } // 0xECF041186C5A94DC  b2612
    pub inline fn setContentPropType_(model: types.Hash, @"type": c_int) !void { try invoker.invoke(void, 0xBA4583AF4C678A9B, .{model, @"type"}); } // 0xBA4583AF4C678A9B  b3095
    /// Returns prop type for given model hash
    pub inline fn getContentPropType_(model: types.Hash) !c_int { return try invoker.invoke(c_int, 0x8BAF8AD59F47AAFC, .{model}); } // 0x8BAF8AD59F47AAFC  b3095
};

pub const Mobile = struct
{
    /// Creates a mobile phone of the specified type.
    /// 
    /// Possible phone types:
    /// 
    /// 0 - Default phone / Michael's phone \
    /// 1 - Trevor's phone \
    /// 2 - Franklin's phone \
    /// 3 - Unused police phone \
    /// 4 - Prologue phone
    /// 
    /// Higher values may crash your game.
    pub inline fn createMobilePhone(phone_type: c_int) !void { try invoker.invoke(void, 0xA4E8E696C532FBC7, .{phone_type}); } // 0xA4E8E696C532FBC7 0x5BBC5E23 b323
    /// Destroys the currently active mobile phone.
    pub inline fn destroyMobilePhone() !void { try invoker.invoke(void, 0x3BC861DF703E5097, .{}); } // 0x3BC861DF703E5097 0x1A65037B b323
    /// The minimum/default is 500.0f. If you plan to make it bigger set it's position as well. Also this seems to need to be called in a loop as when you close the phone the scale is reset. If not in a loop you'd need to call it everytime before you re-open the phone.
    pub inline fn setMobilePhoneScale(scale: f32) !void { try invoker.invoke(void, 0xCBDD322A73D6D932, .{scale}); } // 0xCBDD322A73D6D932 0x09BCF1BE b323
    /// Last parameter is unknown and always zero.
    pub inline fn setMobilePhoneRotation(rot__: types.Vector3, p_3: types.Any) !void { try invoker.invoke(void, 0xBB779C0CA917E865, .{rot__.x, rot__.y, rot__.z, p_3}); } // 0xBB779C0CA917E865 0x209C28CF b323
    pub inline fn getMobilePhoneRotation(rotation: [*c]types.Vector3, p_1: types.Vehicle) !void { try invoker.invoke(void, 0x1CEFB61F193070AE, .{rotation, p_1}); } // 0x1CEFB61F193070AE 0x17A29F23 b323
    pub inline fn setMobilePhonePosition(pos__: types.Vector3) !void { try invoker.invoke(void, 0x693A5C6D6734085B, .{pos__.x, pos__.y, pos__.z}); } // 0x693A5C6D6734085B 0x841800B3 b323
    pub inline fn getMobilePhonePosition(position: [*c]types.Vector3) !void { try invoker.invoke(void, 0x584FDFDA48805B86, .{position}); } // 0x584FDFDA48805B86 0xB2E1E1A0 b323
    /// If bool Toggle = true so the mobile is hide to screen. \
    /// If bool Toggle = false so the mobile is show to screen.
    pub inline fn scriptIsMovingMobilePhoneOffscreen(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF511F759238A5122, .{toggle}); } // 0xF511F759238A5122 0x29828690 b323
    /// This one is weird and seems to return a TRUE state regardless of whether the phone is visible on screen or tucked away.
    /// 
    /// 
    /// I can confirm the above. This function is hard-coded to always return 1.
    pub inline fn canPhoneBeSeenOnScreen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC4E2813898C97A4B, .{}); } // 0xC4E2813898C97A4B 0x5F978584 b323
    pub inline fn setMobilePhoneDofState(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x375A706A5C2FD084, .{toggle}); } // 0x375A706A5C2FD084  b372
    /// For move the finger of player, the value of int goes 1 at 5.
    pub inline fn cellSetInput(direction: c_int) !void { try invoker.invoke(void, 0x95C9E72F3D7DEC9B, .{direction}); } // 0x95C9E72F3D7DEC9B  b323
    /// if the bool "Toggle" is "true" so the phone is lean. \
    /// if the bool "Toggle" is "false" so the phone is not lean.
    pub inline fn cellHorizontalModeToggle(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x44E44169EF70138E, .{toggle}); } // 0x44E44169EF70138E  b323
    pub inline fn cellCamActivate(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xFDE8F069C542D126, .{p_0, p_1}); } // 0xFDE8F069C542D126 0x234C1AE9 b323
    pub inline fn cellCamActivateSelfieMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x015C49A93E3E086E, .{toggle}); } // 0x015C49A93E3E086E 0x4479B304 b323
    pub inline fn cellCamActivateShallowDofMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA2CCBE62CD4C91A4, .{toggle}); } // 0xA2CCBE62CD4C91A4 0xC273BB4D b323
    pub inline fn cellCamSetSelfieModeSideOffsetScaling(p_0: f32) !void { try invoker.invoke(void, 0x1B0B4AEED5B9B41C, .{p_0}); } // 0x1B0B4AEED5B9B41C  b323
    pub inline fn cellCamSetSelfieModeHorzPanOffset(horizontal_pan: f32) !void { try invoker.invoke(void, 0x53F4892D18EC90A4, .{horizontal_pan}); } // 0x53F4892D18EC90A4  b323
    pub inline fn cellCamSetSelfieModeVertPanOffset(vert_pan: f32) !void { try invoker.invoke(void, 0x3117D84EFA60F77B, .{vert_pan}); } // 0x3117D84EFA60F77B  b323
    pub inline fn cellCamSetSelfieModeRollOffset(roll: f32) !void { try invoker.invoke(void, 0x15E69E2802C24B8D, .{roll}); } // 0x15E69E2802C24B8D  b323
    pub inline fn cellCamSetSelfieModeDistanceScaling(distance_scaling: f32) !void { try invoker.invoke(void, 0xAC2890471901861C, .{distance_scaling}); } // 0xAC2890471901861C  b323
    pub inline fn cellCamSetSelfieModeHeadYawOffset(yaw: f32) !void { try invoker.invoke(void, 0xD6ADE981781FCA09, .{yaw}); } // 0xD6ADE981781FCA09  b323
    pub inline fn cellCamSetSelfieModeHeadRollOffset(roll: f32) !void { try invoker.invoke(void, 0xF1E22DC13F5EEBAD, .{roll}); } // 0xF1E22DC13F5EEBAD  b323
    pub inline fn cellCamSetSelfieModeHeadPitchOffset(pitch: f32) !void { try invoker.invoke(void, 0x466DA42C89865553, .{pitch}); } // 0x466DA42C89865553  b323
    pub inline fn cellCamIsCharVisibleNoFaceCheck(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x439E9BC95B7E7FBE, .{entity}); } // 0x439E9BC95B7E7FBE 0xBEA88097 b323
    pub inline fn getMobilePhoneRenderId(render_id: [*c]c_int) !void { try invoker.invoke(void, 0xB4A53E05F68B6FA1, .{render_id}); } // 0xB4A53E05F68B6FA1 0x88E4FECE b323
};

pub const Money = struct
{
    pub inline fn networkInitializeCash(wallet: c_int, bank: c_int) !void { try invoker.invoke(void, 0x3DA5ECD1A56CBA6D, .{wallet, bank}); } // 0x3DA5ECD1A56CBA6D 0x66DA9935 b323
    /// Note the 2nd parameters are always 1, 0. I have a feeling it deals with your money, wallet, bank. So when you delete the character it of course wipes the wallet cash at that time. So if that was the case, it would be eg, NETWORK_DELETE_CHARACTER(characterIndex, deleteWalletCash, deleteBankCash);
    pub inline fn networkDeleteCharacter(character_slot: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x05A50AF38947EB8D, .{character_slot, p_1, p_2}); } // 0x05A50AF38947EB8D 0xA9F7E9C3 b323
    pub inline fn networkManualDeleteCharacter(character_slot: c_int) !void { try invoker.invoke(void, 0x821418C727FCACD7, .{character_slot}); } // 0x821418C727FCACD7  b791
    pub inline fn networkGetPlayerIsHighEarner() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFB2456B2040A6A67, .{}); } // 0xFB2456B2040A6A67 0x63F093A6 b323
    pub inline fn networkClearCharacterWallet(character_slot: c_int) !void { try invoker.invoke(void, 0xA921DED15FDF28F5, .{character_slot}); } // 0xA921DED15FDF28F5 0x19F0C471 b323
    pub inline fn networkGivePlayerJobshareCash(amount: c_int, gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0xFB18DF9CB95E0105, .{amount, gamer_handle}); } // 0xFB18DF9CB95E0105 0xC6047FDB b323
    pub inline fn networkReceivePlayerJobshareCash(value: c_int, gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0x56A3B51944C50598, .{value, gamer_handle}); } // 0x56A3B51944C50598 0x4ED71C1A b323
    pub inline fn networkCanShareJobCash() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1C2473301B1C66BA, .{}); } // 0x1C2473301B1C66BA 0xA27B9FE8 b323
    /// index \
    /// ------- \
    /// See function sub_1005 in am_boat_taxi.ysc
    /// 
    /// context \
    /// ---------- \
    /// "BACKUP_VAGOS" \
    /// "BACKUP_LOST" \
    /// "BACKUP_FAMILIES" \
    /// "HIRE_MUGGER" \
    /// "HIRE_MERCENARY" \
    /// "BUY_CARDROPOFF" \
    /// "HELI_PICKUP" \
    /// "BOAT_PICKUP" \
    /// "CLEAR_WANTED" \
    /// "HEAD_2_HEAD" \
    /// "CHALLENGE" \
    /// "SHARE_LAST_JOB" \
    /// "DEFAULT"
    /// 
    /// reason \
    /// --------- \
    /// "NOTREACHTARGET" \
    /// "TARGET_ESCAPE" \
    /// "DELIVERY_FAIL" \
    /// "NOT_USED" \
    /// "TEAM_QUIT" \
    /// "SERVER_ERROR" \
    /// "RECEIVE_LJ_L" \
    /// "CHALLENGE_PLAYER_LEFT" \
    /// "DEFAULT"
    /// 
    /// unk \
    /// ----- \
    /// Unknown bool value
    /// 
    /// 
    pub inline fn networkRefundCash(index: c_int, context: [*c]const u8, reason: [*c]const u8, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xF9C812CD7C46E817, .{index, context, reason, p_3}); } // 0xF9C812CD7C46E817 0x07C92F21 b323
    pub inline fn networkDeductCash(amount: c_int, p_1: [*c]const u8, p_2: [*c]const u8, p_3: windows.BOOL, p_4: windows.BOOL, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x18B7AE224B087E26, .{amount, p_1, p_2, p_3, p_4, p_5}); } // 0x18B7AE224B087E26  b323
    pub inline fn networkMoneyCanBet(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x81404F3DC124FE5B, .{amount, p_1, p_2}); } // 0x81404F3DC124FE5B 0x8474E6F0 b323
    pub inline fn networkCanBet(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3A54E33660DED67F, .{amount}); } // 0x3A54E33660DED67F 0xE3802533 b323
    /// GTAO_CASINO_HOUSE \
    /// GTAO_CASINO_INSIDETRACK \
    /// GTAO_CASINO_LUCKYWHEEL \
    /// GTAO_CASINO_BLACKJACK \
    /// GTAO_CASINO_ROULETTE \
    /// GTAO_CASINO_SLOTS \
    /// GTAO_CASINO_PURCHASE_CHIPS
    /// 
    /// NETWORK_C*
    pub inline fn networkCasinoCanBet(hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x158C16F5E4CF41F8, .{hash}); } // 0x158C16F5E4CF41F8  b1734
    pub inline fn networkCasinoCanBetPvc() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x394DCDB9E836B7A9, .{}); } // 0x394DCDB9E836B7A9  b1734
    pub inline fn networkCasinoCanBetAmount(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF62F6D9528358FE4, .{p_0}); } // 0xF62F6D9528358FE4  b1734
    pub inline fn networkCasinoCanBuyChipsPvc() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8968D4D8C6C40C11, .{}); } // 0x8968D4D8C6C40C11  b1734
    pub inline fn networkCasinoBuyChips(p_0: c_int, p_1: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3BD101471C7F9EEC, .{p_0, p_1}); } // 0x3BD101471C7F9EEC  b1734
    pub inline fn networkCasinoSellChips(p_0: c_int, p_1: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xED44897CB336F480, .{p_0, p_1}); } // 0xED44897CB336F480  b1734
    /// Does nothing (it's a nullsub).
    pub inline fn networkDeferCashTransactionsUntilShopSave() !void { try invoker.invoke(void, 0xCD0F5B5D932AE473, .{}); } // 0xCD0F5B5D932AE473 0xC4CD928D b323
    pub inline fn canPayAmountToBoss(p_0: c_int, p_1: c_int, amount: c_int, p_3: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9777734DAD16992F, .{p_0, p_1, amount, p_3}); } // 0x9777734DAD16992F  b573
    pub inline fn networkEarnFromPickup(amount: c_int) !void { try invoker.invoke(void, 0xED1517D3AF17C698, .{amount}); } // 0xED1517D3AF17C698 0x70A0ED62 b323
    pub inline fn networkEarnFromCashingOut(amount: c_int) !void { try invoker.invoke(void, 0x718FBBF67414FA36, .{amount}); } // 0x718FBBF67414FA36  b1290
    pub inline fn networkEarnFromGangattackPickup(amount: c_int) !void { try invoker.invoke(void, 0xA03D4ACE0A3284CE, .{amount}); } // 0xA03D4ACE0A3284CE 0x33C20BC4 b323
    pub inline fn networkEarnAssassinateTargetKilled(amount: c_int) !void { try invoker.invoke(void, 0xFA700D8A9905F78A, .{amount}); } // 0xFA700D8A9905F78A  b1604
    /// For the money bags that drop a max of $40,000. Often called 40k bags.
    /// 
    /// Most likely NETWORK_EARN_FROM_ROB***
    pub inline fn networkEarnFromRobArmoredCars(amount: c_int) !void { try invoker.invoke(void, 0xF514621E8EA463D0, .{amount}); } // 0xF514621E8EA463D0 0x30B3EC0A b323
    pub inline fn networkEarnFromCrateDrop(amount: c_int) !void { try invoker.invoke(void, 0xB1CC1B9EC3007A2A, .{amount}); } // 0xB1CC1B9EC3007A2A 0xEAF04923 b323
    pub inline fn networkEarnFromBetting(amount: c_int, p_1: [*c]const u8) !void { try invoker.invoke(void, 0x827A5BA1A44ACA6D, .{amount, p_1}); } // 0x827A5BA1A44ACA6D 0xA0F7F07C b323
    pub inline fn networkEarnFromJob(amount: c_int, p_1: [*c]const u8) !void { try invoker.invoke(void, 0xB2CC4836834E8A98, .{amount, p_1}); } // 0xB2CC4836834E8A98 0x0B6997FC b323
    pub inline fn networkEarnFromJobx2(amount: c_int, p_1: [*c]const u8) !void { try invoker.invoke(void, 0xDEBBF584665411D0, .{amount, p_1}); } // 0xDEBBF584665411D0  b1734
    pub inline fn networkEarnFromPremiumJob(amount: c_int, p_1: [*c]const u8) !void { try invoker.invoke(void, 0xC8407624CEF2354B, .{amount, p_1}); } // 0xC8407624CEF2354B  b791
    pub inline fn networkEarnFromBendJob(amount: c_int, heist_hash: [*c]const u8) !void { try invoker.invoke(void, 0x61326EE6DF15B0CA, .{amount, heist_hash}); } // 0x61326EE6DF15B0CA 0xBB293400 b323
    pub inline fn networkEarnFromChallengeWin(p_0: types.Any, p_1: [*c]types.Any, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x2B171E6B2F64D8DF, .{p_0, p_1, p_2}); } // 0x2B171E6B2F64D8DF 0x2BEFB6C4 b323
    pub inline fn networkEarnFromBounty(amount: c_int, gamer_handle: [*c]types.Any, p_2: [*c]types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x131BB5DA15453ACF, .{amount, gamer_handle, p_2, p_3}); } // 0x131BB5DA15453ACF 0x127F2DAE b323
    pub inline fn networkEarnFromImportExport(amount: c_int, model_hash: types.Hash) !void { try invoker.invoke(void, 0xF92A014A634442D6, .{amount, model_hash}); } // 0xF92A014A634442D6 0xF11FC458 b323
    pub inline fn networkEarnFromHoldups(amount: c_int) !void { try invoker.invoke(void, 0x45B8154E077D9E4D, .{amount}); } // 0x45B8154E077D9E4D 0xE6B90E9C b323
    pub inline fn networkEarnFromProperty(amount: c_int, property_name: types.Hash) !void { try invoker.invoke(void, 0x849648349D77F5C5, .{amount, property_name}); } // 0x849648349D77F5C5 0x9BE4F7E1 b323
    /// DSPORT
    pub inline fn networkEarnFromAiTargetKill(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x515B4A22E4D3C6D7, .{p_0, p_1}); } // 0x515B4A22E4D3C6D7 0x866004A8 b323
    pub inline fn networkEarnFromNotBadsport(amount: c_int) !void { try invoker.invoke(void, 0x4337511FA8221D36, .{amount}); } // 0x4337511FA8221D36 0xCC068380 b323
    pub inline fn networkEarnFromVehicle(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any) !void { try invoker.invoke(void, 0xB539BD8A4C1EECF8, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0xB539BD8A4C1EECF8 0xF803589D b323
    pub inline fn networkEarnFromPersonalVehicle(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any) !void { try invoker.invoke(void, 0x3F4D00167E41E0AD, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0x3F4D00167E41E0AD 0x96B8BEE8 b323
    /// type either Monthly,Weekly,Daily
    pub inline fn networkEarnFromDailyObjectives(amount: c_int, @"type": [*c]const u8, character_slot: c_int) !void { try invoker.invoke(void, 0x6EA318C91C1A8786, .{amount, @"type", character_slot}); } // 0x6EA318C91C1A8786 0xAB6BD72F b323
    /// Example for p1: "AM_DISTRACT_COPS"
    pub inline fn networkEarnFromAmbientJob(p_0: c_int, p_1: [*c]const u8, p_2: [*c]types.Any) !void { try invoker.invoke(void, 0xFB6DB092FBAE29E6, .{p_0, p_1, p_2}); } // 0xFB6DB092FBAE29E6 0xA14CC95D b323
    pub inline fn networkEarnFromJobBonus(p_0: types.Any, p_1: [*c]types.Any, p_2: [*c]types.Any) !void { try invoker.invoke(void, 0x6816FB4416760775, .{p_0, p_1, p_2}); } // 0x6816FB4416760775 0xBEE23713 b323
    pub inline fn networkEarnFromCriminalMastermind(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xFA009A62990671D4, .{p_0, p_1, p_2}); } // 0xFA009A62990671D4  b1290
    pub inline fn networkEarnHeistAward(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x9D4FDBB035229669, .{p_0, p_1, p_2}); } // 0x9D4FDBB035229669  b1290
    pub inline fn networkEarnFirstTimeBonus(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x11B0A20C493F7E36, .{p_0, p_1, p_2}); } // 0x11B0A20C493F7E36  b1290
    pub inline fn networkEarnGoon(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xCDA1C62BE2777802, .{p_0, p_1, p_2}); } // 0xCDA1C62BE2777802  b573
    pub inline fn networkEarnBoss(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x08B0CA7A6AB3AC32, .{p_0, p_1, p_2}); } // 0x08B0CA7A6AB3AC32  b573
    pub inline fn networkEarnAgency(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x0CB1BE0633C024A8, .{p_0, p_1, p_2, p_3}); } // 0x0CB1BE0633C024A8  b573
    pub inline fn networkEarnFromWarehouse(amount: c_int, id: c_int) !void { try invoker.invoke(void, 0x3E4ADAFF1830F146, .{amount, id}); } // 0x3E4ADAFF1830F146  b757
    pub inline fn networkEarnFromContraband(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0xECA658CE2A4E5A72, .{amount, p_1}); } // 0xECA658CE2A4E5A72  b757
    pub inline fn networkEarnFromDestroyingContraband(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x84C0116D012E8FC2, .{p_0, p_1, p_2}); } // 0x84C0116D012E8FC2  b757
    pub inline fn networkEarnFromSmugglerWork(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0x6B7E4FB50D5F3D65, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x6B7E4FB50D5F3D65  b1180
    pub inline fn networkEarnFromHangarTrade(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x31BA138F6304FB9F, .{p_0, p_1}); } // 0x31BA138F6304FB9F  b1180
    pub inline fn networkEarnPurchaseClubHouse(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x55A1E095DB052FA5, .{p_0, p_1}); } // 0x55A1E095DB052FA5  b877
    pub inline fn networkEarnFromBusinessProduct(amount: c_int, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x8586789730B10CAF, .{amount, p_1, p_2, p_3}); } // 0x8586789730B10CAF  b877
    pub inline fn networkEarnFromVehicleExport(amount: c_int, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xEDEAD9A91EC768B3, .{amount, p_1, p_2}); } // 0xEDEAD9A91EC768B3  b944
    pub inline fn networkEarnSmugglerAgency(amount: c_int, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xDEE612F2D71B0308, .{amount, p_1, p_2, p_3}); } // 0xDEE612F2D71B0308  b1180
    pub inline fn networkEarnBountyHunterReward(p_0: types.Any) !void { try invoker.invoke(void, 0xF6B170F9A02E9E87, .{p_0}); } // 0xF6B170F9A02E9E87  b1493
    pub inline fn networkEarnFromBusinessBattle(p_0: types.Any) !void { try invoker.invoke(void, 0x42FCE14F50F27291, .{p_0}); } // 0x42FCE14F50F27291  b1493
    pub inline fn networkEarnFromClubManagementParticipation(p_0: types.Any, p_1: c_int) !void { try invoker.invoke(void, 0xA75EAC69F59E96E7, .{p_0, p_1}); } // 0xA75EAC69F59E96E7  b1493
    pub inline fn networkEarnFromFmbbPhonecallMission(p_0: types.Any) !void { try invoker.invoke(void, 0xC5156361F26E2212, .{p_0}); } // 0xC5156361F26E2212  b1493
    pub inline fn networkEarnFromBusinessHubSell(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x0B39CF0D53F1C883, .{p_0, p_1, p_2}); } // 0x0B39CF0D53F1C883  b1493
    pub inline fn networkEarnFromFmbbBossWork(p_0: types.Any) !void { try invoker.invoke(void, 0x1FDA0AA679C9919B, .{p_0}); } // 0x1FDA0AA679C9919B  b1493
    pub inline fn networkEarnFmbbWageBonus(p_0: types.Any) !void { try invoker.invoke(void, 0xFFFBA1B1F7C0B6F4, .{p_0}); } // 0xFFFBA1B1F7C0B6F4  b1493
    pub inline fn networkCanSpendMoney(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL, p_4: types.Any, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAB3CAA6B422164DA, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0xAB3CAA6B422164DA 0x5AA379D9 b323
    pub inline fn networkCanSpendMoney2(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL, p_4: [*c]types.Any, p_5: types.Any, p_6: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7303E27CC6532080, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x7303E27CC6532080  b323
    pub inline fn networkBuyItem(amount: c_int, item: types.Hash, p_2: types.Any, p_3: types.Any, p_4: windows.BOOL, item__name: [*c]const u8, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: windows.BOOL) !void { try invoker.invoke(void, 0xF0077C797F66A355, .{amount, item, p_2, p_3, p_4, item__name, p_6, p_7, p_8, p_9}); } // 0xF0077C797F66A355 0xA07B6368 b323
    pub inline fn networkSpentTaxi(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x17C3A7D31EAE39F9, .{amount, p_1, p_2, p_3, p_4}); } // 0x17C3A7D31EAE39F9 0x1F3DB3E3 b323
    pub inline fn networkPayEmployeeWage(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x5FD5ED82CBBE9989, .{p_0, p_1, p_2}); } // 0x5FD5ED82CBBE9989 0xBE70849B b323
    pub inline fn networkPayMatchEntryFee(amount: c_int, match_id: [*c]const u8, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x9346E14F2AF74D46, .{amount, match_id, p_2, p_3}); } // 0x9346E14F2AF74D46 0x224A3488 b323
    pub inline fn networkSpentBetting(amount: c_int, p_1: c_int, match_id: [*c]const u8, p_3: windows.BOOL, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x1C436FD11FFA692F, .{amount, p_1, match_id, p_3, p_4}); } // 0x1C436FD11FFA692F 0xF8A07513 b323
    pub inline fn networkSpentWager(p_0: types.Any, p_1: types.Any, amount: c_int) !void { try invoker.invoke(void, 0xD99DB210089617FE, .{p_0, p_1, amount}); } // 0xD99DB210089617FE  b573
    pub inline fn networkSpentInStripclub(p_0: types.Any, p_1: windows.BOOL, p_2: types.Any, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xEE99784E4467689C, .{p_0, p_1, p_2, p_3}); } // 0xEE99784E4467689C 0x8957038E b323
    pub inline fn networkBuyHealthcare(cost: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xD9B067E55253E3DD, .{cost, p_1, p_2}); } // 0xD9B067E55253E3DD 0x832150E5 b323
    /// p1 = 0 (always) \
    /// p2 = 1 (always)
    pub inline fn networkBuyAirstrike(cost: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x763B4BD305338F19, .{cost, p_1, p_2, p_3}); } // 0x763B4BD305338F19 0x40470683 b323
    pub inline fn networkBuyBackupGang(p_0: c_int, p_1: c_int, p_2: windows.BOOL, p_3: windows.BOOL, npc_provider: c_int) !void { try invoker.invoke(void, 0xA3EDDAA42411D3B9, .{p_0, p_1, p_2, p_3, npc_provider}); } // 0xA3EDDAA42411D3B9 0x2AD2EC51 b323
    /// p1 = 0 (always) \
    /// p2 = 1 (always)
    pub inline fn networkBuyHeliStrike(cost: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x81AA4610E3FD3A69, .{cost, p_1, p_2, p_3}); } // 0x81AA4610E3FD3A69 0x047547D4 b323
    pub inline fn networkSpentAmmoDrop(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xB162DC95C0A3317B, .{p_0, p_1, p_2, p_3}); } // 0xB162DC95C0A3317B 0x4B643076 b323
    /// p1 is just an assumption. p2 was false and p3 was true.
    pub inline fn networkBuyBounty(amount: c_int, victim: types.Player, p_2: windows.BOOL, p_3: windows.BOOL, p_4: types.Any) !void { try invoker.invoke(void, 0x7B718E197453F2D9, .{amount, victim, p_2, p_3, p_4}); } // 0x7B718E197453F2D9 0xCB89CBE0 b323
    pub inline fn networkBuyProperty(cost: c_int, property_name: types.Hash, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x650A08A280870AF6, .{cost, property_name, p_2, p_3}); } // 0x650A08A280870AF6 0x7D479AAB b323
    pub inline fn networkBuySmokes(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x75AF80E61248EEBD, .{p_0, p_1, p_2}); } // 0x75AF80E61248EEBD 0xC0AB03EB b323
    pub inline fn networkSpentHeliPickup(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x7BF1D73DB2ECA492, .{p_0, p_1, p_2, p_3}); } // 0x7BF1D73DB2ECA492 0x27EEBCAB b323
    pub inline fn networkSpentBoatPickup(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x524EE43A37232C00, .{p_0, p_1, p_2, p_3}); } // 0x524EE43A37232C00 0xB241CABD b323
    pub inline fn networkSpentBullShark(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xA6DD8458CE24012C, .{p_0, p_1, p_2, p_3}); } // 0xA6DD8458CE24012C 0xDE7D398C b323
    pub inline fn networkSpentCashDrop(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x289016EC778D60E0, .{amount, p_1, p_2}); } // 0x289016EC778D60E0 0x87BD1D11 b323
    /// Only used once in a script (am_contact_requests) \
    /// p1 = 0 \
    /// p2 = 1
    pub inline fn networkSpentHireMugger(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xE404BFB981665BF0, .{p_0, p_1, p_2, p_3}); } // 0xE404BFB981665BF0 0xE792C4A5 b323
    pub inline fn networkSpentRobbedByMugger(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x995A65F15F581359, .{amount, p_1, p_2, p_3}); } // 0x995A65F15F581359 0xE6AAA0D5 b323
    pub inline fn networkSpentHireMercenary(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xE7B80E2BF9D80BD6, .{p_0, p_1, p_2, p_3}); } // 0xE7B80E2BF9D80BD6 0x99CF02C4 b323
    pub inline fn networkSpentBuyWantedlevel(p_0: types.Any, p_1: [*c]types.Any, p_2: windows.BOOL, p_3: windows.BOOL, p_4: types.Any) !void { try invoker.invoke(void, 0xE1B13771A843C4F6, .{p_0, p_1, p_2, p_3, p_4}); } // 0xE1B13771A843C4F6 0xE7CB4F95 b323
    pub inline fn networkSpentBuyOfftheradar(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xA628A745E2275C5D, .{p_0, p_1, p_2, p_3}); } // 0xA628A745E2275C5D 0x20DDCF2F b323
    pub inline fn networkSpentBuyRevealPlayers(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x6E176F1B18BC0637, .{p_0, p_1, p_2, p_3}); } // 0x6E176F1B18BC0637 0x2F7836E2 b323
    pub inline fn networkSpentCarwash(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: windows.BOOL, p_4: windows.BOOL) !void { try invoker.invoke(void, 0xEC03C719DB2F4306, .{p_0, p_1, p_2, p_3, p_4}); } // 0xEC03C719DB2F4306 0x8283E028 b323
    pub inline fn networkSpentCinema(p_0: types.Any, p_1: types.Any, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x6B38ECB05A63A685, .{p_0, p_1, p_2, p_3}); } // 0x6B38ECB05A63A685 0x1100CAF5 b323
    pub inline fn networkSpentTelescope(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x7FE61782AD94CC09, .{p_0, p_1, p_2}); } // 0x7FE61782AD94CC09 0xAE7FF044 b323
    pub inline fn networkSpentHoldups(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xD9B86B9872039763, .{p_0, p_1, p_2}); } // 0xD9B86B9872039763 0x1B3803B1 b323
    pub inline fn networkSpentBuyPassiveMode(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x6D3A430D1A809179, .{p_0, p_1, p_2, p_3}); } // 0x6D3A430D1A809179 0x7E97C92C b323
    pub inline fn networkSpentBankInterest(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xCA230C9682556CF1, .{p_0, p_1, p_2}); } // 0xCA230C9682556CF1 0xF02E92D7 b323
    pub inline fn networkSpentProstitutes(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xB21B89501CFAC79E, .{p_0, p_1, p_2}); } // 0xB21B89501CFAC79E 0x78436D07 b323
    pub inline fn networkSpentArrestBail(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x812F5488B1B2A299, .{p_0, p_1, p_2}); } // 0x812F5488B1B2A299 0x5AEE2FC1 b323
    /// According to how I understood this in the freemode script alone, \
    /// The first parameter is determined by a function named, func_5749 within the freemode script which has a list of all the vehicles and a set price to return which some vehicles deals with globals as well. So the first parameter is basically the set in stone insurance cost it's gonna charge you for that specific vehicle model.
    /// 
    /// The second parameter whoever put it was right, they call GET_ENTITY_MODEL with the vehicle as the paremeter.
    /// 
    /// The third parameter is the network handle as they call their little struct<13> func or atleast how the script decompiled it to look which in lamens terms just returns the network handle of the previous owner based on DECOR_GET_INT(vehicle, "Previous_Owner").
    /// 
    /// The fourth parameter is a bool that returns true/false depending on if your bank balance is greater then 0.
    /// 
    /// The fifth and last parameter is a bool that returns true/false depending on if you have the money for the car based on the cost returned by func_5749. In the freemode script eg, \
    /// bool hasTheMoney = MONEY::_GET_BANK_BALANCE() < carCost.
    pub inline fn networkSpentPayVehicleInsurancePremium(amount: c_int, vehicle_model: types.Hash, gamer_handle: [*c]types.Any, not_bankrupt: windows.BOOL, has_the_money: windows.BOOL) !void { try invoker.invoke(void, 0x9FF28D88C766E3E8, .{amount, vehicle_model, gamer_handle, not_bankrupt, has_the_money}); } // 0x9FF28D88C766E3E8 0x4E665BB2 b323
    pub inline fn networkSpentCallPlayer(p_0: types.Any, p_1: [*c]types.Any, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xACDE7185B374177C, .{p_0, p_1, p_2, p_3}); } // 0xACDE7185B374177C 0x1A89B5FC b323
    pub inline fn networkSpentBounty(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x29B260B84947DFCC, .{p_0, p_1, p_2}); } // 0x29B260B84947DFCC 0x3401FC96 b323
    pub inline fn networkSpentFromRockstar(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x6A445B64ED7ABEB5, .{p_0, p_1, p_2}); } // 0x6A445B64ED7ABEB5 0x54198922 b323
    /// Hardcoded to return 0.
    pub inline fn networkSpendEarnedFromBankAndWallets(amount: c_int) !c_int { return try invoker.invoke(c_int, 0x9B5016A6433A68C5, .{amount}); } // 0x9B5016A6433A68C5 0xBD64F1B7 b323
    /// This isn't a hash collision.
    pub inline fn processCashGift(p_0: [*c]c_int, p_1: [*c]c_int, p_2: [*c]const u8) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x20194D48EAEC9A41, .{p_0, p_1, p_2}); } // 0x20194D48EAEC9A41 0xC5D8B1E9 b323
    pub inline fn networkSpentMoveSubmarine(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xCD4D66B43B1DD28D, .{p_0, p_1, p_2}); } // 0xCD4D66B43B1DD28D  b2189
    pub inline fn networkSpentPlayerHealthcare(p_0: c_int, p_1: c_int, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x7C99101F7FCE2EE5, .{p_0, p_1, p_2, p_3}); } // 0x7C99101F7FCE2EE5 0x3D96A21C b323
    pub inline fn networkSpentNoCops(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xD5BB406F4E04019F, .{p_0, p_1, p_2, p_3}); } // 0xD5BB406F4E04019F 0x2E51C61C b323
    pub inline fn networkSpentCargoSourcing(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !void { try invoker.invoke(void, 0x948705F6F9C50824, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x948705F6F9C50824  b2699
    pub inline fn networkSpentRequestJob(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x8204DA7934DF3155, .{p_0, p_1, p_2, p_3}); } // 0x8204DA7934DF3155 0xD57A5125 b323
    pub inline fn networkSpentRequestHeist(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x9D26502BB97BFE62, .{p_0, p_1, p_2, p_3}); } // 0x9D26502BB97BFE62 0xF4287778 b323
    /// The first parameter is the amount spent which is store in a global when this native is called. The global returns 10. Which is the price for both rides.
    /// 
    /// The last 3 parameters are,  \
    /// 2,0,1 in the am_ferriswheel.c \
    /// 1,0,1 in the am_rollercoaster.c
    /// 
    pub inline fn networkBuyFairgroundRide(amount: c_int, p_1: types.Any, p_2: windows.BOOL, p_3: windows.BOOL, p_4: types.Any) !void { try invoker.invoke(void, 0x8A7B3952DD64D2B5, .{amount, p_1, p_2, p_3, p_4}); } // 0x8A7B3952DD64D2B5 0xD9622D64 b323
    pub inline fn networkEconomyHasFixedCrazyNumbers() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7C4FCCD2E4DEB394, .{}); } // 0x7C4FCCD2E4DEB394  b323
    pub inline fn networkSpentJobSkip(amount: c_int, match_id: [*c]const u8, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x28F174A67B8D0C2F, .{amount, match_id, p_2, p_3}); } // 0x28F174A67B8D0C2F  b323
    pub inline fn networkSpentBossGoon(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFFBE02CD385356BD, .{amount, p_1, p_2}); } // 0xFFBE02CD385356BD  b573
    pub inline fn networkSpendGoon(p_0: c_int, p_1: c_int, amount: c_int) !void { try invoker.invoke(void, 0x08A1B82B91900682, .{p_0, p_1, amount}); } // 0x08A1B82B91900682  b573
    pub inline fn networkSpendBoss(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xDBC966A01C02BCA7, .{p_0, p_1, p_2}); } // 0xDBC966A01C02BCA7  b573
    pub inline fn networkSpentMoveYacht(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xE7DF4E0545DFB56E, .{amount, p_1, p_2}); } // 0xE7DF4E0545DFB56E  b573
    pub inline fn networkSpentRenameOrganization(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xFC4EE00A7B3BFB76, .{p_0, p_1, p_2, p_3}); } // 0xFC4EE00A7B3BFB76  b573
    pub inline fn networkBuyContrabandMission(p_0: c_int, p_1: c_int, p_2: types.Hash, p_3: windows.BOOL, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x30FD873ECE50E9F6, .{p_0, p_1, p_2, p_3, p_4}); } // 0x30FD873ECE50E9F6  b757
    pub inline fn networkSpentPaServiceHeli(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x112209CE0290C03A, .{p_0, p_1, p_2, p_3}); } // 0x112209CE0290C03A  b757
    pub inline fn networkSpentPaServiceVehicle(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xED5FD7AF10F5E262, .{p_0, p_1, p_2, p_3}); } // 0xED5FD7AF10F5E262  b757
    pub inline fn networkSpentPaServiceSnack(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x0D30EB83668E63C5, .{p_0, p_1, p_2, p_3}); } // 0x0D30EB83668E63C5  b757
    pub inline fn networkSpentPaServiceDancer(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xB49ECA122467D05F, .{p_0, p_1, p_2, p_3}); } // 0xB49ECA122467D05F  b757
    pub inline fn networkSpentPaServiceImpound(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xE23ADC6FCB1F29AE, .{p_0, p_1, p_2}); } // 0xE23ADC6FCB1F29AE  b757
    pub inline fn networkSpentPaHeliPickup(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x0FE8E1FCD2B86B33, .{p_0, p_1, p_2, p_3}); } // 0x0FE8E1FCD2B86B33  b757
    pub inline fn networkSpentPurchaseOfficeProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x69EF772B192614C1, .{p_0, p_1, p_2, p_3, p_4}); } // 0x69EF772B192614C1  b757
    pub inline fn networkSpentUpgradeOfficeProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x8E243837643D9583, .{p_0, p_1, p_2, p_3, p_4}); } // 0x8E243837643D9583  b757
    pub inline fn networkSpentPurchaseWarehouseProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xBD0EFB25CCA8F97A, .{p_0, p_1, p_2, p_3}); } // 0xBD0EFB25CCA8F97A  b757
    pub inline fn networkSpentUpgradeWarehouseProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xA95F667A755725DA, .{p_0, p_1, p_2, p_3}); } // 0xA95F667A755725DA  b757
    pub inline fn networkSpentPurchaseImpexpWarehouseProperty(amount: c_int, data: [*c]types.Any, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x33981D6804E62F49, .{amount, data, p_2, p_3}); } // 0x33981D6804E62F49  b944
    pub inline fn networkSpentUpgradeImpexpWarehouseProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x4128464231E3CA0B, .{p_0, p_1, p_2, p_3}); } // 0x4128464231E3CA0B  b944
    pub inline fn networkSpentTradeImpexpWarehouseProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x2FAB6614CE22E196, .{p_0, p_1, p_2, p_3}); } // 0x2FAB6614CE22E196  b944
    pub inline fn networkSpentOrderWarehouseVehicle(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x05F04155A226FBBF, .{p_0, p_1, p_2, p_3}); } // 0x05F04155A226FBBF  b757
    pub inline fn networkSpentOrderBodyguardVehicle(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xE8B0B270B6E7C76E, .{p_0, p_1, p_2, p_3}); } // 0xE8B0B270B6E7C76E  b757
    pub inline fn networkSpentJukebox(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x5BCDE0F640C773D2, .{p_0, p_1, p_2, p_3}); } // 0x5BCDE0F640C773D2  b877
    pub inline fn networkSpentPurchaseClubHouse(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x998E18CEB44487FC, .{p_0, p_1, p_2, p_3}); } // 0x998E18CEB44487FC  b877
    pub inline fn networkSpentUpgradeClubHouse(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xFA07759E6FDDD7CF, .{p_0, p_1, p_2, p_3}); } // 0xFA07759E6FDDD7CF  b877
    pub inline fn networkSpentPurchaseBusinessProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x6FD97159FE3C971A, .{p_0, p_1, p_2, p_3}); } // 0x6FD97159FE3C971A  b877
    pub inline fn networkSpentUpgradeBusinessProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x675D19C6067CAE08, .{p_0, p_1, p_2, p_3}); } // 0x675D19C6067CAE08  b877
    pub inline fn networkSpentTradeBusinessProperty(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xA51B086B0B2C0F7A, .{p_0, p_1, p_2, p_3}); } // 0xA51B086B0B2C0F7A  b877
    pub inline fn networkSpentMcAbility(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xD7CCCBA28C4ECAF0, .{p_0, p_1, p_2, p_3, p_4}); } // 0xD7CCCBA28C4ECAF0  b877
    pub inline fn networkSpentPayBusinessSupplies(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x0035BB914316F1E3, .{p_0, p_1, p_2, p_3}); } // 0x0035BB914316F1E3  b877
    pub inline fn networkSpentChangeAppearance(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x5F456788B05FAEAC, .{p_0, p_1, p_2}); } // 0x5F456788B05FAEAC  b944
    pub inline fn networkSpentVehicleExportMods(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: types.Any) !void { try invoker.invoke(void, 0xA75CCF58A60A5FD1, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9}); } // 0xA75CCF58A60A5FD1  b944
    pub inline fn networkSpentPurchaseOfficeGarage(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xB4C2EC463672474E, .{p_0, p_1, p_2, p_3}); } // 0xB4C2EC463672474E  b944
    pub inline fn networkSpentUpgradeOfficeGarage(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x2AFC2D19B50797F2, .{p_0, p_1, p_2, p_3}); } // 0x2AFC2D19B50797F2  b944
    pub inline fn networkSpentImportExportRepair(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xC1952F3773BA18FE, .{p_0, p_1, p_2}); } // 0xC1952F3773BA18FE  b944
    pub inline fn networkSpentPurchaseHangar(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xCCB339CC970452DA, .{p_0, p_1, p_2, p_3}); } // 0xCCB339CC970452DA  b1180
    pub inline fn networkSpentUpgradeHangar(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x615EB504B0788DAF, .{p_0, p_1, p_2, p_3}); } // 0x615EB504B0788DAF  b1180
    pub inline fn networkSpentHangarUtilityCharges(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xB18AC2ECBB15CB6A, .{amount, p_1, p_2}); } // 0xB18AC2ECBB15CB6A  b1180
    pub inline fn networkSpentHangarStaffCharges(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xB1F1346FD57685D7, .{amount, p_1, p_2}); } // 0xB1F1346FD57685D7  b1180
    pub inline fn networkSpentBuyTruck(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xAC272C0AE01B4BD8, .{p_0, p_1, p_2, p_3}); } // 0xAC272C0AE01B4BD8  b1103
    pub inline fn networkSpentUpgradeTruck(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x365E877C61D6988B, .{p_0, p_1, p_2, p_3}); } // 0x365E877C61D6988B  b1103
    pub inline fn networkSpentBuyBunker(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x12D148D26538D0F9, .{p_0, p_1, p_2, p_3}); } // 0x12D148D26538D0F9  b1103
    pub inline fn networkSpentUpradeBunker(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x0C82D21A77C22D49, .{p_0, p_1, p_2, p_3}); } // 0x0C82D21A77C22D49  b1103
    pub inline fn networkEarnFromSellBunker(amount: c_int, bunker_hash: types.Hash) !void { try invoker.invoke(void, 0x9251B6ABF2D0A5B4, .{amount, bunker_hash}); } // 0x9251B6ABF2D0A5B4  b1103
    pub inline fn networkSpentBallisticEquipment(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x5D97630A8A0EF123, .{amount, p_1, p_2}); } // 0x5D97630A8A0EF123  b1103
    pub inline fn networkEarnRdrBonus(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0x7A5349B773584675, .{amount, p_1}); } // 0x7A5349B773584675  b1290
    pub inline fn networkEarnWagePayment(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0x35F8DA0E8A31EF1B, .{amount, p_1}); } // 0x35F8DA0E8A31EF1B  b1180
    pub inline fn networkEarnWagePaymentBonus(amount: c_int) !void { try invoker.invoke(void, 0x005ACA7100BD101D, .{amount}); } // 0x005ACA7100BD101D  b1180
    pub inline fn networkSpentBuyBase(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x4EA3F425C7744D21, .{p_0, p_1, p_2, p_3}); } // 0x4EA3F425C7744D21  b1290
    pub inline fn networkSpentUpgradeBase(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x3DD3F33A5D55EA6F, .{p_0, p_1, p_2, p_3}); } // 0x3DD3F33A5D55EA6F  b1290
    pub inline fn networkSpentBuyTiltrotor(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x0CCE73BC7A11E885, .{p_0, p_1, p_2, p_3}); } // 0x0CCE73BC7A11E885  b1290
    pub inline fn networkSpentUpgradeTiltrotor(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x165E135D6DFA2907, .{p_0, p_1, p_2, p_3}); } // 0x165E135D6DFA2907  b1290
    pub inline fn networkSpentEmployAssassins(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x5BBBD92186E1F1C5, .{p_0, p_1, p_2, p_3}); } // 0x5BBBD92186E1F1C5  b1290
    pub inline fn networkSpendGangopsCannon(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x771ADB0E7635B7BF, .{p_0, p_1, p_2, p_3}); } // 0x771ADB0E7635B7BF  b1290
    pub inline fn networkSpendGangopsSkipMission(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xDA947AE8880D5C18, .{p_0, p_1, p_2, p_3}); } // 0xDA947AE8880D5C18  b1290
    pub inline fn networkSpendCasinoHeistSkipMission(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x487009DD91D93429, .{p_0, p_1, p_2, p_3}); } // 0x487009DD91D93429  b1868
    pub inline fn networkEarnSellBase(amount: c_int, base_name_hash: types.Hash) !void { try invoker.invoke(void, 0x0E1E2FF3F4EC11AA, .{amount, base_name_hash}); } // 0x0E1E2FF3F4EC11AA  b1290
    pub inline fn networkEarnTargetRefund(amount: c_int, p_1: c_int) !void { try invoker.invoke(void, 0x5B669CF2299A271F, .{amount, p_1}); } // 0x5B669CF2299A271F  b1290
    pub inline fn networkEarnGangopsWages(amount: c_int, p_1: c_int) !void { try invoker.invoke(void, 0x2DCB19ABAB0380A8, .{amount, p_1}); } // 0x2DCB19ABAB0380A8  b1290
    pub inline fn networkEarnGangopsWagesBonus(amount: c_int, p_1: c_int) !void { try invoker.invoke(void, 0x15BB2A5C757EB91F, .{amount, p_1}); } // 0x15BB2A5C757EB91F  b1290
    pub inline fn networkEarnDarChallenge(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0xCAC672087B4A24AB, .{amount, p_1}); } // 0xCAC672087B4A24AB  b1290
    pub inline fn networkEarnDoomsdayFinaleBonus(amount: c_int, vehicle_hash: types.Hash) !void { try invoker.invoke(void, 0x128A747F4A230952, .{amount, vehicle_hash}); } // 0x128A747F4A230952  b1290
    pub inline fn networkEarnGangopsAward(amount: c_int, p_1: [*c]const u8, p_2: types.Any) !void { try invoker.invoke(void, 0xA9A31475F530DFDA, .{amount, p_1, p_2}); } // 0xA9A31475F530DFDA  b1290
    pub inline fn networkEarnGangopsElite(amount: c_int, p_1: [*c]const u8, act_index: c_int) !void { try invoker.invoke(void, 0x2597A0D4A4FC2C77, .{amount, p_1, act_index}); } // 0x2597A0D4A4FC2C77  b1290
    pub inline fn networkServiceEarnGangopsRivalDelivery(earned_money: c_int) !void { try invoker.invoke(void, 0x1B882107C23A9022, .{earned_money}); } // 0x1B882107C23A9022  b1290
    pub inline fn networkSpendGangopsStartStrand(@"type": c_int, amount: c_int, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xA19EC0786E326E06, .{@"type", amount, p_2, p_3}); } // 0xA19EC0786E326E06  b1290
    pub inline fn networkSpendGangopsTripSkip(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x5ECE6FD7B4EC8D6A, .{amount, p_1, p_2}); } // 0x5ECE6FD7B4EC8D6A  b1290
    pub inline fn networkEarnGangopsPrepParticipation(amount: c_int) !void { try invoker.invoke(void, 0xED26584F6BDCBBFD, .{amount}); } // 0xED26584F6BDCBBFD  b1290
    pub inline fn networkEarnGangopsSetup(amount: c_int, p_1: [*c]const u8) !void { try invoker.invoke(void, 0xA9160796D47A2CF8, .{amount, p_1}); } // 0xA9160796D47A2CF8  b1290
    pub inline fn networkEarnGangopsFinale(amount: c_int, p_1: [*c]const u8) !void { try invoker.invoke(void, 0x1C121FC9545E0D52, .{amount, p_1}); } // 0x1C121FC9545E0D52  b1290
    pub inline fn networkSpendGangopsRepairCost(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x2A7CEC72C3443BCC, .{p_0, p_1, p_2}); } // 0x2A7CEC72C3443BCC  b1290
    pub inline fn networkEarnNightclub(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xE0F82D68C7039158, .{p_0, p_1}); } // 0xE0F82D68C7039158  b1493
    pub inline fn networkEarnNightclubDancing(p_0: types.Any) !void { try invoker.invoke(void, 0xB4DEAE67F35E2ACD, .{p_0}); } // 0xB4DEAE67F35E2ACD  b1493
    pub inline fn networkEarnBbEventBonus(amount: c_int) !void { try invoker.invoke(void, 0xFDD8D2440DAF1590, .{amount}); } // 0xFDD8D2440DAF1590  b1604
    pub inline fn networkSpentPurchaseHackerTruck(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x2A93C46AAB1EACC9, .{p_0, p_1, p_2, p_3}); } // 0x2A93C46AAB1EACC9  b1493
    pub inline fn networkSpentUpgradeHackerTruck(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x226C284C830D0CA8, .{p_0, p_1, p_2, p_3}); } // 0x226C284C830D0CA8  b1493
    pub inline fn networkEarnHackerTruck(p_0: types.Any, amount: c_int, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xE8815FE993896AD3, .{p_0, amount, p_2, p_3}); } // 0xE8815FE993896AD3  b1493
    pub inline fn networkSpentPurchaseNightclubAndWarehouse(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xED76D195E6E3BF7F, .{p_0, p_1, p_2, p_3}); } // 0xED76D195E6E3BF7F  b1493
    pub inline fn networkSpentUpgradeNightclubAndWarehouse(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x1DC9B749E7AE282B, .{p_0, p_1, p_2, p_3}); } // 0x1DC9B749E7AE282B  b1493
    pub inline fn networkEarnNightclubAndWarehouse(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !void { try invoker.invoke(void, 0xC6E74CF8C884C880, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0xC6E74CF8C884C880  b1493
    pub inline fn networkSpendNightclubAndWarehouse(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x65482BFD0923C8A1, .{p_0, p_1, p_2, p_3}); } // 0x65482BFD0923C8A1  b1493
    pub inline fn networkSpentRdrHatchetBonus(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xE284D46FFDB82E36, .{amount, p_1, p_2}); } // 0xE284D46FFDB82E36  b1493
    pub inline fn networkSpentNightclubEntryFee(player: types.Player, amount: c_int, p_1: types.Any, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x876056684281655D, .{player, amount, p_1, p_2, p_3}); } // 0x876056684281655D  b1493
    pub inline fn networkSpendNightclubBarDrink(amount: c_int, p_1: types.Any, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xDD21B016E4289465, .{amount, p_1, p_2, p_3}); } // 0xDD21B016E4289465  b1493
    pub inline fn networkSpendBountyHunterMission(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x1BEA0CD93470BB1F, .{amount, p_1, p_2}); } // 0x1BEA0CD93470BB1F  b1493
    pub inline fn networkSpentRehireDj(amount: c_int, p_1: types.Any, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xF6C8A544E4CF14FC, .{amount, p_1, p_2, p_3}); } // 0xF6C8A544E4CF14FC  b1493
    pub inline fn networkSpentArenaJoinSpectator(amount: c_int, p_1: types.Any, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x14EAEA58F93B55AF, .{amount, p_1, p_2, p_3}); } // 0x14EAEA58F93B55AF  b1604
    pub inline fn networkEarnArenaSkillLevelProgression(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0xE08256F972C7BB2C, .{amount, p_1}); } // 0xE08256F972C7BB2C  b1604
    pub inline fn networkEarnArenaCareerProgression(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0x0F99F70C61F14619, .{amount, p_1}); } // 0x0F99F70C61F14619  b1604
    pub inline fn networkSpendMakeItRain(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xE5F5A060439C2F5D, .{amount, p_1, p_2}); } // 0xE5F5A060439C2F5D  b1604
    pub inline fn networkSpendBuyArena(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: [*c]const u8) !void { try invoker.invoke(void, 0x40D5DA9550B7CB46, .{amount, p_1, p_2, p_3}); } // 0x40D5DA9550B7CB46  b1604
    pub inline fn networkSpendUpgradeArena(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: [*c]const u8) !void { try invoker.invoke(void, 0x037ABB06825D7AB1, .{amount, p_1, p_2, p_3}); } // 0x037ABB06825D7AB1  b1604
    /// type either, 1 for cam spectate, 2 for drone
    pub inline fn networkSpendArenaSpectatorBox(amount: c_int, @"type": c_int, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x7049BF858601DC0F, .{amount, @"type", p_2, p_3}); } // 0x7049BF858601DC0F  b1604
    pub inline fn networkSpendSpinTheWheelPayment(amount: c_int, p_1: types.Any, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x9A5BD1D0000B339C, .{amount, p_1, p_2}); } // 0x9A5BD1D0000B339C  b1604
    pub inline fn networkEarnSpinTheWheelCash(amount: c_int) !void { try invoker.invoke(void, 0x676C48776CACBB5A, .{amount}); } // 0x676C48776CACBB5A  b1604
    pub inline fn networkSpendArenaPremium(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x619496D837EFD920, .{amount, p_1, p_2}); } // 0x619496D837EFD920  b1604
    pub inline fn networkEarnArenaWar(amount: c_int, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x631F1CB8FB4130AA, .{amount, p_1, p_2, p_3}); } // 0x631F1CB8FB4130AA  b1604
    pub inline fn networkEarnArenaWarAssassinateTarget(amount: c_int) !void { try invoker.invoke(void, 0x5E7AE8AABE8B7C0D, .{amount}); } // 0x5E7AE8AABE8B7C0D  b1604
    pub inline fn networkEarnArenaWarEventCargo(amount: c_int) !void { try invoker.invoke(void, 0xA82959062361B259, .{amount}); } // 0xA82959062361B259  b1604
    pub inline fn networkEarnRcTimeTrial(amount: c_int) !void { try invoker.invoke(void, 0xDFF49EE984E7AAE8, .{amount}); } // 0xDFF49EE984E7AAE8  b1734
    pub inline fn networkEarnDailyObjectiveEvent(amount: c_int) !void { try invoker.invoke(void, 0x5128DF14A5BB86FC, .{amount}); } // 0x5128DF14A5BB86FC  b1734
    pub inline fn networkSpendCasinoMembership(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: c_int) !void { try invoker.invoke(void, 0xFBBE0570EDF39D46, .{amount, p_1, p_2, p_3}); } // 0xFBBE0570EDF39D46  b1734
    pub inline fn networkSpendBuyCasino(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, data: [*c]types.Any) !void { try invoker.invoke(void, 0x34A6FC4D06C4DA0F, .{amount, p_1, p_2, data}); } // 0x34A6FC4D06C4DA0F  b1734
    pub inline fn networkSpendUpgradeCasino(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, data: [*c]types.Any) !void { try invoker.invoke(void, 0x4740D62BC1B4EBEA, .{amount, p_1, p_2, data}); } // 0x4740D62BC1B4EBEA  b1734
    pub inline fn networkSpendCasinoGeneric(amount: c_int, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x88BF9B612B84D3C3, .{amount, p_1, p_2, p_3, p_4}); } // 0x88BF9B612B84D3C3  b1734
    pub inline fn networkEarnCasinoTimeTrialWin(amount: c_int) !void { try invoker.invoke(void, 0x0819DB99FD2FBBD8, .{amount}); } // 0x0819DB99FD2FBBD8  b1734
    pub inline fn networkEarnCollectablesActionFigures(amount: c_int) !void { try invoker.invoke(void, 0x5517F90043466049, .{amount}); } // 0x5517F90043466049  b1734
    pub inline fn networkEarnCasinoCollectableCompletedCollection(amount: c_int) !void { try invoker.invoke(void, 0x83AD64F53F4E9483, .{amount}); } // 0x83AD64F53F4E9483  b1734
    pub inline fn networkEarnSellPrizeVehicle(amount: c_int, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x8BCB27A057DF7B7F, .{amount, p_1, p_2}); } // 0x8BCB27A057DF7B7F  b1734
    pub inline fn networkEarnCasinoMissionReward(amount: c_int) !void { try invoker.invoke(void, 0x566FD402B25787DE, .{amount}); } // 0x566FD402B25787DE  b1734
    pub inline fn networkEarnCasinoStoryMissionReward(amount: c_int) !void { try invoker.invoke(void, 0xAC95ED552157E092, .{amount}); } // 0xAC95ED552157E092  b1734
    pub inline fn networkEarnCasinoMissionParticipation(amount: c_int) !void { try invoker.invoke(void, 0x09E8F18641BE2575, .{amount}); } // 0x09E8F18641BE2575  b1734
    pub inline fn networkEarnCasinoAward(amount: c_int, hash: types.Hash) !void { try invoker.invoke(void, 0x973A9781A34F8DEB, .{amount, hash}); } // 0x973A9781A34F8DEB  b1734
    pub inline fn networkSpendBuyArcade(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x870289A558348378, .{p_0, p_1, p_2, p_3}); } // 0x870289A558348378  b1868
    pub inline fn networkSpendUpgradeArcade(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x5574637681911FDA, .{p_0, p_1, p_2, p_3}); } // 0x5574637681911FDA  b1868
    pub inline fn networkSpendCasinoHeist(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: types.Any, p_1_0: types.Any) !void { try invoker.invoke(void, 0xD30E8392F407C328, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0}); } // 0xD30E8392F407C328  b1868
    pub inline fn networkSpendArcadeMgmt(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xB5B58E24868CB09E, .{p_0, p_1, p_2, p_3, p_4}); } // 0xB5B58E24868CB09E  b1868
    pub inline fn networkSpendPlayArcade(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xEAD3D81F2C3A1458, .{p_0, p_1, p_2, p_3, p_4}); } // 0xEAD3D81F2C3A1458  b1868
    pub inline fn networkSpendArcade(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x43AA7FAC4E6D6687, .{p_0, p_1, p_2, p_3, p_4}); } // 0x43AA7FAC4E6D6687  b1868
    pub inline fn networkEarnCasinoHeist(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !void { try invoker.invoke(void, 0x72E7C7B9615FA3C3, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x72E7C7B9615FA3C3  b1868
    pub inline fn networkEarnUpgradeArcade(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x4C3B75694F7E0D9C, .{p_0, p_1, p_2}); } // 0x4C3B75694F7E0D9C  b1868
    pub inline fn networkEarnArcade(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0xD29334ED1A256DBF, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0xD29334ED1A256DBF  b1868
    pub inline fn networkEarnCollectables(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xA95CFB4E02390842, .{p_0, p_1, p_2}); } // 0xA95CFB4E02390842  b1868
    pub inline fn networkEarnChallenge(amount: c_int, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x0DD362F14F18942A, .{amount, p_1, p_2}); } // 0x0DD362F14F18942A  b1868
    pub inline fn networkEarnCasinoHeistAwards(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x3EC7471E6909798A, .{p_0, p_1, p_2, p_3, p_4}); } // 0x3EC7471E6909798A  b1868
    pub inline fn networkEarnCollectableItem(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0x84FF63BD4966F33D, .{amount, p_1}); } // 0x84FF63BD4966F33D  b1734
    pub inline fn networkEarnCollectableCompletedCollection(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0x5C9B198AF5A54FA6, .{amount, p_1}); } // 0x5C9B198AF5A54FA6  b2060
    pub inline fn networkEarnYatchMission(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0xDE68E30D89F97132, .{amount, p_1}); } // 0xDE68E30D89F97132  b2060
    pub inline fn networkEarnDispatchCall(amount: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0xE2E244AB823B4483, .{amount, p_1}); } // 0xE2E244AB823B4483  b2060
    pub inline fn networkSpendBeachParty(p_0: types.Any) !void { try invoker.invoke(void, 0x54ABA22FA6371249, .{p_0}); } // 0x54ABA22FA6371249  b2189
    pub inline fn networkSpendSubmarine(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0x6C8BC1488527AAAB, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x6C8BC1488527AAAB  b2189
    pub inline fn networkSpendCasinoClub(amount_1: c_int, p_1: types.Any, p_2: windows.BOOL, p_3: types.Any, p_4: c_int, p_5: c_int, p_6: c_int, amount_2: c_int, p_8: types.Any) !void { try invoker.invoke(void, 0xC991C255AA6D90B2, .{amount_1, p_1, p_2, p_3, p_4, p_5, p_6, amount_2, p_8}); } // 0xC991C255AA6D90B2  b2189
    pub inline fn networkSpendBuySub(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x90CD7C6871FBF1B4, .{p_0, p_1, p_2, p_3}); } // 0x90CD7C6871FBF1B4  b2189
    pub inline fn networkSpendUpgradeSub(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x89049A84065CE68E, .{p_0, p_1, p_2, p_3}); } // 0x89049A84065CE68E  b2189
    pub inline fn networkSpendIslandHeist(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xE86689E5F82DE429, .{p_0, p_1, p_2, p_3}); } // 0xE86689E5F82DE429  b2189
    pub inline fn networkEarnIslandHeist(amount_1: c_int, p_1: types.Any, p_2: types.Any, p_3: types.Any, amount_2: c_int, p_5: c_int) !void { try invoker.invoke(void, 0xD21D111C46BA9F15, .{amount_1, p_1, p_2, p_3, amount_2, p_5}); } // 0xD21D111C46BA9F15  b2189
    pub inline fn networkEarnBeachPartyLostFound(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xA51338E0DCCD4065, .{p_0, p_1, p_2}); } // 0xA51338E0DCCD4065  b2189
    pub inline fn networkEarnFromIslandHeistDjMission(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xE2BB399D90942091, .{p_0, p_1}); } // 0xE2BB399D90942091  b2189
    pub inline fn networkSpendCarClubMembership(amount_1: c_int, p_1: types.Any, p_2: types.Any, amount_2: c_int, p_4: types.Any) !void { try invoker.invoke(void, 0x1464E17207CD36E2, .{amount_1, p_1, p_2, amount_2, p_4}); } // 0x1464E17207CD36E2  b2372
    pub inline fn networkSpendCarClubBar(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x925227803A0EAA1B, .{p_0, p_1, p_2, p_3}); } // 0x925227803A0EAA1B  b2372
    pub inline fn networkSpendAutoshopModify(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x9BEA350D7C48061B, .{p_0, p_1, p_2, p_3, p_4}); } // 0x9BEA350D7C48061B  b2372
    pub inline fn networkSpendCarClubTakeover(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xD1E46824E6FB92B5, .{p_0, p_1, p_2, p_3}); } // 0xD1E46824E6FB92B5  b2372
    pub inline fn networkSpendBuyAutoshop(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xEEB7E5D1FEB20869, .{p_0, p_1, p_2, p_3}); } // 0xEEB7E5D1FEB20869  b2372
    pub inline fn networkSpendUpgradeAutoshop(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xDD829AA198FDC46C, .{p_0, p_1, p_2, p_3}); } // 0xDD829AA198FDC46C  b2372
    pub inline fn networkEarnAutoshopBusiness(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x36A7FD5A7194B03E, .{p_0, p_1, p_2}); } // 0x36A7FD5A7194B03E  b2372
    pub inline fn networkEarnAutoshopIncome(p_0: types.Any, p_1: c_int) !void { try invoker.invoke(void, 0xC66D1CF99ED7FE25, .{p_0, p_1}); } // 0xC66D1CF99ED7FE25  b2372
    pub inline fn networkEarnCarclubMembership(p_0: types.Any) !void { try invoker.invoke(void, 0xBC6227792A188E2E, .{p_0}); } // 0xBC6227792A188E2E  b2372
    pub inline fn networkEarnDailyVehicle(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x533073E8A596008C, .{p_0, p_1}); } // 0x533073E8A596008C  b2372
    pub inline fn networkEarnDailyVehicleBonus(p_0: types.Any) !void { try invoker.invoke(void, 0xFE65AFE7308E32B2, .{p_0}); } // 0xFE65AFE7308E32B2  b2372
    pub inline fn networkEarnTunerAward(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xB846F547D3792DF6, .{p_0, p_1, p_2}); } // 0xB846F547D3792DF6  b2372
    pub inline fn networkEarnTunerRobbery(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xBCB266247193AC61, .{p_0, p_1, p_2, p_3, p_4}); } // 0xBCB266247193AC61  b2372
    pub inline fn networkEarnUpgradeAutoshop(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xC10322A8D3E061EE, .{p_0, p_1}); } // 0xC10322A8D3E061EE  b2372
    pub inline fn networkSpendInteractionMenuAbility(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x93AA4165CB67E925, .{p_0, p_1, p_2, p_3}); } // 0x93AA4165CB67E925  b2372
    pub inline fn networkSpendSetCommonFields(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xB9F7A469460E7A4A, .{p_0, p_1, p_2, p_3}); } // 0xB9F7A469460E7A4A  b2372
    pub inline fn networkSpendSetDiscount(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x7E2F4E8F44CAF4E0, .{p_0}); } // 0x7E2F4E8F44CAF4E0  b2699
    pub inline fn networkSpendBuyAgency(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xEA8CD3C9B3C35884, .{p_0, p_1, p_2, p_3}); } // 0xEA8CD3C9B3C35884  b2545
    pub inline fn networkSpendUpgradeAgency(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x6CCA64840589A3B6, .{p_0, p_1, p_2, p_3}); } // 0x6CCA64840589A3B6  b2545
    pub inline fn networkSpendAgency(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x1B2120405080125C, .{p_0, p_1, p_2, p_3, p_4}); } // 0x1B2120405080125C  b2545
    pub inline fn networkSpendHidden(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xBF8793B91EA094A7, .{p_0, p_1, p_2, p_3}); } // 0xBF8793B91EA094A7  b2545
    pub inline fn networkSpendSourceBike(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xD9DF467CBE4398C8, .{p_0, p_1, p_2, p_3}); } // 0xD9DF467CBE4398C8  b2545
    pub inline fn networkSpendCompSuv(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xD86581F9E7CDA383, .{p_0, p_1, p_2, p_3}); } // 0xD86581F9E7CDA383  b2545
    pub inline fn networkSpendSuvFstTrvl(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x61A2DF64ED2D396E, .{p_0, p_1, p_2, p_3}); } // 0x61A2DF64ED2D396E  b2545
    pub inline fn networkSpendSupply(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xEBD482B82ACB8BAD, .{p_0, p_1, p_2, p_3}); } // 0xEBD482B82ACB8BAD  b2545
    pub inline fn networkSpendBikeShop(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x923AEA8E78F8DF0B, .{p_0, p_1, p_2, p_3}); } // 0x923AEA8E78F8DF0B  b2699
    pub inline fn networkSpendVehicleRequested(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x02D24A35A9CC3503, .{p_0, p_1, p_2, p_3, p_4}); } // 0x02D24A35A9CC3503  b2699
    pub inline fn networkSpendGunrunning(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x2CEB0E0BC2A77C05, .{p_0, p_1, p_2, p_3}); } // 0x2CEB0E0BC2A77C05  b2699
    pub inline fn networkEarnAgencySafe(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x663B4B9D11742A12, .{p_0, p_1}); } // 0x663B4B9D11742A12  b2545
    pub inline fn networkEarnAwardContract(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x146D4EB6D22A403F, .{p_0, p_1}); } // 0x146D4EB6D22A403F  b2545
    pub inline fn networkEarnAgencyContract(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x38482AD49CB905C7, .{p_0, p_1}); } // 0x38482AD49CB905C7  b2545
    pub inline fn networkEarnAwardPhone(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x7397A115030F1BE3, .{p_0, p_1}); } // 0x7397A115030F1BE3  b2545
    pub inline fn networkEarnAgencyPhone(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xE29F3D5FA63B1B82, .{p_0, p_1, p_2}); } // 0xE29F3D5FA63B1B82  b2545
    pub inline fn networkEarnAwardFixerMission(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x88D6C327D6C57C45, .{p_0, p_1}); } // 0x88D6C327D6C57C45  b2545
    pub inline fn networkEarnFixerPrep(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x6283E5DE4C4460C6, .{p_0, p_1}); } // 0x6283E5DE4C4460C6  b2545
    pub inline fn networkEarnFixerFinale(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xBA154373C5FE51E8, .{p_0, p_1}); } // 0xBA154373C5FE51E8  b2545
    pub inline fn networkEarnFixerAgencyShortTrip(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xF4A8E57460BF2037, .{p_0, p_1}); } // 0xF4A8E57460BF2037  b2545
    pub inline fn networkEarnAwardShortTrip(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x5B4DBDED84D6A420, .{p_0, p_1}); } // 0x5B4DBDED84D6A420  b2545
    pub inline fn networkEarnFixerRivalDelivery(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x235D41210B3A1A5E, .{p_0, p_1}); } // 0x235D41210B3A1A5E  b2545
    pub inline fn networkEarnUpgradeAgency(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xD07C7C3F1995108C, .{p_0, p_1}); } // 0xD07C7C3F1995108C  b2545
    pub inline fn networkSpendApartmentUtilities(amount: c_int, p_1: windows.BOOL, p_2: windows.BOOL, data: [*c]types.Any) !void { try invoker.invoke(void, 0x1254B5B3925EFD3D, .{amount, p_1, p_2, data}); } // 0x1254B5B3925EFD3D  b2545
    pub inline fn networkSpendBusinessPropertyFees(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x92D1CFDA1227FF1C, .{p_0, p_1, p_2, p_3}); } // 0x92D1CFDA1227FF1C  b2545
    pub inline fn networkEarnSightseeingReward(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x45087AE480B233AC, .{p_0, p_1, p_2, p_3}); } // 0x45087AE480B233AC  b2699
    pub inline fn networkEarnBikerShop(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x2C5809EB9DF57257, .{p_0, p_1}); } // 0x2C5809EB9DF57257  b2699
    pub inline fn networkEarnBiker(p_0: types.Any) !void { try invoker.invoke(void, 0x71BEC32FA466E105, .{p_0}); } // 0x71BEC32FA466E105  b2699
    pub inline fn networkYohanSourceGoods(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x59498BC8B1C8B15C, .{p_0, p_1, p_2, p_3}); } // 0x59498BC8B1C8B15C  b2699
    pub inline fn networkSpendBuyMfgarage_(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xA2ED36DCF0FCA413, .{p_0, p_1, p_2, p_3}); } // 0xA2ED36DCF0FCA413  b2802
    pub inline fn networkSpendUpgradeMfgarage_(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xCF8F346DDDC66643, .{p_0, p_1, p_2, p_3}); } // 0xCF8F346DDDC66643  b2802
    pub inline fn networkSpendBuySupplies_(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: c_int) !void { try invoker.invoke(void, 0xB48185C0CA67B16B, .{p_0, p_1, p_2, p_3}); } // 0xB48185C0CA67B16B  b2802
    pub inline fn networkSpendBuyAcidLab_(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xF1E26A7924327152, .{p_0, p_1, p_2, p_3}); } // 0xF1E26A7924327152  b2802
    pub inline fn networkSpendUpgradeAcidLabEquipment_(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x110EE9D486C23126, .{p_0, p_1, p_2, p_3}); } // 0x110EE9D486C23126  b2802
    pub inline fn networkSpendUpgradeAcidLabArmor_(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: c_int) !void { try invoker.invoke(void, 0xA7D541C9ACD63133, .{p_0, p_1, p_2, p_3}); } // 0xA7D541C9ACD63133  b2802
    pub inline fn networkSpendUpgradeAcidLabScoop_(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: c_int) !void { try invoker.invoke(void, 0x2940558E05BCC2EC, .{p_0, p_1, p_2, p_3}); } // 0x2940558E05BCC2EC  b2802
    pub inline fn networkSpendUpgradeAcidLabMines_(p_0: c_int, p_1: windows.BOOL, p_2: windows.BOOL, p_3: c_int) !void { try invoker.invoke(void, 0x4B99AB08C92C54E4, .{p_0, p_1, p_2, p_3}); } // 0x4B99AB08C92C54E4  b2802
    pub inline fn networkSpendRenameAcidLab_(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x842B1C5AF61ACDE9, .{p_0, p_1, p_2, p_3}); } // 0x842B1C5AF61ACDE9  b2802
    pub inline fn networkSpendRenameAcidProduct_(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x446798F7495DD7D8, .{p_0, p_1, p_2, p_3}); } // 0x446798F7495DD7D8  b2802
    pub inline fn networkEarnAwardJuggaloMission_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xDDF047577F1A02A7, .{p_0, p_1}); } // 0xDDF047577F1A02A7  b2802
    pub inline fn networkEarnAwardAcidLab_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xD1A8165767AD2D23, .{p_0, p_1}); } // 0xD1A8165767AD2D23  b2802
    pub inline fn networkEarnAwardDailyStash_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xC30650FA74A19D02, .{p_0, p_1}); } // 0xC30650FA74A19D02  b2802
    pub inline fn networkEarnAwardDeadDrop_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xD01EBAEA1F905EF6, .{p_0, p_1}); } // 0xD01EBAEA1F905EF6  b2802
    pub inline fn networkEarnAwardRandomEvent_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xBEAFBB1B98B7EF55, .{p_0, p_1}); } // 0xBEAFBB1B98B7EF55  b2802
    pub inline fn networkEarnAwardTaxi_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xA914768AD35CD3A5, .{p_0, p_1}); } // 0xA914768AD35CD3A5  b2802
    pub inline fn networkEarnStreetDealer_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xA81017EE1324FDFE, .{p_0, p_1}); } // 0xA81017EE1324FDFE  b2802
    pub inline fn networkEarnSellAcid_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x79B656937DF6DF5D, .{p_0, p_1}); } // 0x79B656937DF6DF5D  b2802
    pub inline fn networkEarnSetupParticipationAcidLab_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xE3942D59E8A7F70D, .{p_0, p_1}); } // 0xE3942D59E8A7F70D  b2802
    pub inline fn networkEarnSourceParticipationAcidLab_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x136F11B5DF1B304D, .{p_0, p_1}); } // 0x136F11B5DF1B304D  b2802
    pub inline fn networkEarnSellParticipationAcidLab_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xCA3EF9B09A8D76B4, .{p_0, p_1}); } // 0xCA3EF9B09A8D76B4  b2802
    pub inline fn networkEarnJuggaloStoryMission_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xE01D10BA8CD53621, .{p_0, p_1}); } // 0xE01D10BA8CD53621  b2802
    pub inline fn networkEarnJuggaloStoryMissionParticipation_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x40FF6CCCC476185C, .{p_0, p_1}); } // 0x40FF6CCCC476185C  b2802
    /// JUGGALO_PHONE_MISSION...
    pub inline fn networkEarnFooliganJob_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xCE4452AE85F5E252, .{p_0, p_1}); } // 0xCE4452AE85F5E252  b2802
    /// JUGGALO_PHONE_MISSION_PARTICIPATION...
    pub inline fn networkEarnFooliganJobParticipation_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xC376B92D0E060970, .{p_0, p_1}); } // 0xC376B92D0E060970  b2802
    pub inline fn networkEarnTaxiJob_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x991E1588FAD9019D, .{p_0, p_1}); } // 0x991E1588FAD9019D  b2802
    pub inline fn networkEarnDailyStashHouseCompleted_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xCABC9874AFA70D6D, .{p_0, p_1}); } // 0xCABC9874AFA70D6D  b2802
    pub inline fn networkEarnDailyStashHouseParticipation_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x9C0C6BD0F94CE391, .{p_0, p_1}); } // 0x9C0C6BD0F94CE391  b2802
    /// Used for SERVICE_EARN_AVENGER_OPERATIONS & SERVICE_EARN_AVENGER_OPS_BONUS
    pub inline fn networkEarnAvenger_(amount: c_int, p_1: c_int) !void { try invoker.invoke(void, 0x55F006B9D4A46C1D, .{amount, p_1}); } // 0x55F006B9D4A46C1D  b2944
    pub inline fn networkEarnSmugglerOps_(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xDEA273D5F8A9661A, .{p_0, p_1, p_2}); } // 0xDEA273D5F8A9661A  b2944
    pub inline fn networkEarnBonusObjective_(amount: c_int, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xDCEF983C24191997, .{amount, p_1, p_2}); } // 0xDCEF983C24191997  b2944
    pub inline fn networkEarnProgressHub_(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xF8332B06F0EECC9C, .{p_0, p_1}); } // 0xF8332B06F0EECC9C  b2944
    pub inline fn networkSpentAirFreight_(hangar_cargo_sourcing_price: c_int, from_bank: windows.BOOL, from_bank_and_wallet: windows.BOOL, cost: c_int, warehouse_id: c_int, warehouse_slot: c_int, p_6: types.Any) !void { try invoker.invoke(void, 0x8C7E8D6F96C9E948, .{hangar_cargo_sourcing_price, from_bank, from_bank_and_wallet, cost, warehouse_id, warehouse_slot, p_6}); } // 0x8C7E8D6F96C9E948  b2944
    pub inline fn networkSpentSkipCargoSourceSetup_(amount: c_int, from_bank: windows.BOOL, from_bank_and_wallet: windows.BOOL, cost: c_int) !void { try invoker.invoke(void, 0xED1B407BADA42CEC, .{amount, from_bank, from_bank_and_wallet, cost}); } // 0xED1B407BADA42CEC  b2944
    /// Hash p3 = STEALTH_MODULE
    pub inline fn networkSpentStealthModule_(amount: c_int, from_bank: windows.BOOL, from_bank_and_wallet: windows.BOOL, p_3: types.Hash) !void { try invoker.invoke(void, 0x95CE79A6939C537A, .{amount, from_bank, from_bank_and_wallet, p_3}); } // 0x95CE79A6939C537A  b2944
    /// Hash p3 = MISSILE_JAMMER
    pub inline fn networkSpentMissileJammer_(amount: c_int, from_bank: windows.BOOL, from_bank_and_wallet: windows.BOOL, p_3: types.Hash) !void { try invoker.invoke(void, 0xD687100F616163F4, .{amount, from_bank, from_bank_and_wallet, p_3}); } // 0xD687100F616163F4  b2944
    pub inline fn networkSpentGeneric_(price: c_int, p_1: windows.BOOL, p_2: windows.BOOL, stat: types.Hash, spent: types.Hash, p_5: [*c]const u8, p_6: [*c]const u8, data: [*c]types.Any) !void { try invoker.invoke(void, 0x2803B027479FB640, .{price, p_1, p_2, stat, spent, p_5, p_6, data}); } // 0x2803B027479FB640  b3095
    /// _NETWORK_EARN_G*
    pub inline fn networkEarnGeneric_(amount: c_int, earn: types.Hash, p_2: [*c]const u8, p_3: [*c]const u8, data: [*c]types.Any) !void { try invoker.invoke(void, 0xBF7B5BB7ED890380, .{amount, earn, p_2, p_3, data}); } // 0xBF7B5BB7ED890380  b3095
    pub inline fn networkClearTransactionTelemetryNonce_() !void { try invoker.invoke(void, 0xE03B9F95556E48E9, .{}); } // 0xE03B9F95556E48E9  b3095
    pub inline fn networkGetVcBankBalance() !c_int { return try invoker.invoke(c_int, 0x76EF28DA05EA395A, .{}); } // 0x76EF28DA05EA395A 0x16184FB5 b323
    pub inline fn networkGetVcWalletBalance(character_slot: c_int) !c_int { return try invoker.invoke(c_int, 0xA40F9C2623F6A8B5, .{character_slot}); } // 0xA40F9C2623F6A8B5 0x4F5B781C b323
    pub inline fn networkGetVcBalance() !c_int { return try invoker.invoke(c_int, 0x5CBAD97E059E1B94, .{}); } // 0x5CBAD97E059E1B94 0xADF8F882 b323
    pub inline fn networkGetEvcBalance() !c_int { return try invoker.invoke(c_int, 0x5D1E75F91C07DEE5, .{}); } // 0x5D1E75F91C07DEE5 0xF1EDB7F4 b323
    pub inline fn networkGetPvcBalance() !c_int { return try invoker.invoke(c_int, 0x4F54F3B6C202FB4E, .{}); } // 0x4F54F3B6C202FB4E 0x56485B56 b323
    pub inline fn networkGetStringWalletBalance(character_slot: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xF9B10B529DCFB33B, .{character_slot}); } // 0xF9B10B529DCFB33B 0xC1A11435 b323
    pub inline fn networkGetStringBankBalance() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xA6FA3979BED01B81, .{}); } // 0xA6FA3979BED01B81 0xAA7EA3BD b323
    pub inline fn networkGetStringBankWalletBalance(character: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x700AF71AE615E6DD, .{character}); } // 0x700AF71AE615E6DD 0x7D4FD28C b323
    /// Returns true if wallet balance >= amount.
    pub inline fn networkGetCanSpendFromWallet(amount: c_int, character_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xED5AB8860415BABA, .{amount, character_slot}); } // 0xED5AB8860415BABA 0x0EA2188C b323
    /// Returns true if bank balance >= amount.
    pub inline fn networkGetCanSpendFromBank(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA31FD6A0865B6D14, .{amount}); } // 0xA31FD6A0865B6D14 0xABED6020 b323
    /// Returns true if bank balance + wallet balance >= amount.
    pub inline fn networkGetCanSpendFromBankAndWallet(amount: c_int, character_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDC18531D7019A535, .{amount, character_slot}); } // 0xDC18531D7019A535 0xCA23FD25 b323
    /// Retturns the same value as NETWORK_GET_REMAINING_TRANSFER_BALANCE.
    pub inline fn networkGetPvcTransferBalance() !c_int { return try invoker.invoke(c_int, 0x13A8DE2FD77D04F3, .{}); } // 0x13A8DE2FD77D04F3 0xC670C814 b323
    /// Returns false if amount > wallet balance or daily transfer limit has been hit.
    pub inline fn networkGetCanTransferCash(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x08E8EEADFD0DC4A0, .{amount}); } // 0x08E8EEADFD0DC4A0 0x03461981 b323
    pub inline fn networkCanReceivePlayerCash(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5D17BE59D2123284, .{p_0, p_1, p_2, p_3}); } // 0x5D17BE59D2123284 0x41F5F10E b323
    /// Returns the same value as NETWORK_GET_PVC_TRANSFER_BALANCE.
    pub inline fn networkGetRemainingTransferBalance() !c_int { return try invoker.invoke(c_int, 0xEA560AC9EEB1E19B, .{}); } // 0xEA560AC9EEB1E19B 0xA9021211 b323
    /// Does nothing and always returns 0.
    pub inline fn withdrawVc(amount: c_int) !c_int { return try invoker.invoke(c_int, 0xF70EFA14FE091429, .{amount}); } // 0xF70EFA14FE091429 0x8B755993 b323
    /// Does nothing and always returns false.
    pub inline fn depositVc(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE260E0BB9CD995AC, .{amount}); } // 0xE260E0BB9CD995AC 0x8F266745 b323
    /// This function is hard-coded to always return 1.
    pub inline fn hasVcWithdrawalCompleted(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE154B48B68EF72BC, .{p_0}); } // 0xE154B48B68EF72BC 0x531E4892 b323
    /// This function is hard-coded to always return 1.
    pub inline fn wasVcWithdrawalSuccessful(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6FCF8DDEA146C45B, .{p_0}); } // 0x6FCF8DDEA146C45B 0xB96C7ABE b323
};

pub const Netshopping = struct
{
    pub inline fn netGameserverUseServerTransactions() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7D2708796355B20B, .{}); } // 0x7D2708796355B20B  b1290
    pub inline fn netGameserverCatalogItemIsValid(name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBD4D7EAF8A30F637, .{name}); } // 0xBD4D7EAF8A30F637  b323
    pub inline fn netGameserverCatalogItemKeyIsValid(hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x247F0F73A182EA0B, .{hash}); } // 0x247F0F73A182EA0B  b323
    /// bool is always true in game scripts
    pub inline fn netGameserverGetPrice(item_hash: types.Hash, category_hash: types.Hash, p_2: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xC27009422FCCA88D, .{item_hash, category_hash, p_2}); } // 0xC27009422FCCA88D  b323
    pub inline fn netGameserverCatalogIsValid() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3C4487461E9B0DCB, .{}); } // 0x3C4487461E9B0DCB  b323
    pub inline fn netGameserverIsCatalogCurrent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2B949A1E6AEC8F6A, .{}); } // 0x2B949A1E6AEC8F6A  b323
    pub inline fn netGameserverGetCatalogCloudCrc() !types.Hash { return try invoker.invoke(types.Hash, 0x85F6C9ABA1DE2BCF, .{}); } // 0x85F6C9ABA1DE2BCF  b323
    pub inline fn netGameserverRefreshServerCatalog() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x357B152EF96C30B6, .{}); } // 0x357B152EF96C30B6  b323
    pub inline fn netGameserverRetrieveCatalogRefreshStatus(state: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCF38DAFBB49EDE5E, .{state}); } // 0xCF38DAFBB49EDE5E  b323
    pub inline fn netGameserverInitSession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE3E5A7C64CA2C6ED, .{}); } // 0xE3E5A7C64CA2C6ED  b323
    pub inline fn netGameserverRetrieveInitSessionStatus(p_0: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0395CB47B022E62C, .{p_0}); } // 0x0395CB47B022E62C  b323
    pub inline fn netGameserverStartSession(char_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA135AC892A58FC07, .{char_slot}); } // 0xA135AC892A58FC07  b323
    pub inline fn netGameserverStartSessionPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x72EB7BA9B69BF6AB, .{}); } // 0x72EB7BA9B69BF6AB  b323
    pub inline fn netGameserverRetrieveStartSessionStatus(p_0: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x170910093218C8B9, .{p_0}); } // 0x170910093218C8B9  b323
    pub inline fn netGameserverRetrieveSessionErrorCode(p_0: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC13C38E47EA5DF31, .{p_0}); } // 0xC13C38E47EA5DF31  b323
    pub inline fn netGameserverIsSessionValid(char_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB24F0944DA203D9E, .{char_slot}); } // 0xB24F0944DA203D9E  b323
    pub inline fn netGameserverClearSession(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74A0FD0688F1EE45, .{p_0}); } // 0x74A0FD0688F1EE45  b323
    pub inline fn netGameserverSessionApplyReceivedData(char_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2F41D51BA3BCD1F1, .{char_slot}); } // 0x2F41D51BA3BCD1F1  b323
    pub inline fn netGameserverIsSessionRefreshPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x810E8431C0614BF9, .{}); } // 0x810E8431C0614BF9  b323
    /// Note: only one of the arguments can be set to true at a time
    pub inline fn netGameserverStartSessionRestart(inventory: windows.BOOL, playerbalance: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x35A1B3E1D1315CFA, .{inventory, playerbalance}); } // 0x35A1B3E1D1315CFA  b323
    pub inline fn netGameserverTransactionInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x613F125BA3BD2EB9, .{}); } // 0x613F125BA3BD2EB9  b372
    pub inline fn netGameserverGetSessionStateAndStatus(p_0: [*c]c_int, p_1: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x897433D292B44130, .{p_0, p_1}); } // 0x897433D292B44130  b323
    pub inline fn netGameserverBasketStart(transaction_id: [*c]c_int, category_hash: types.Hash, action_hash: types.Hash, flags: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x279F08B1A4B29B7E, .{transaction_id, category_hash, action_hash, flags}); } // 0x279F08B1A4B29B7E  b323
    pub inline fn netGameserverBasketEnd() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFA336E7F40C0A0D0, .{}); } // 0xFA336E7F40C0A0D0  b372
    pub inline fn netGameserverBasketIsActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA65568121DF2EA26, .{}); } // 0xA65568121DF2EA26  b323
    pub inline fn netGameserverBasketAddItem(item_data: [*c]types.Any, quantity: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF30980718C8ED876, .{item_data, quantity}); } // 0xF30980718C8ED876  b323
    pub inline fn netGameserverBasketIsFull() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x27F76CC6C55AD30E, .{}); } // 0x27F76CC6C55AD30E  b323
    pub inline fn netGameserverBasketApplyServerData(p_0: types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE1A0450ED46A7812, .{p_0, p_1}); } // 0xE1A0450ED46A7812  b323
    pub inline fn netGameserverCheckoutStart(transaction_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x39BE7CEA8D9CC8E6, .{transaction_id}); } // 0x39BE7CEA8D9CC8E6  b323
    pub inline fn netGameserverCheckoutPending(transaction_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4B64CD6D18474126, .{transaction_id}); } // 0x4B64CD6D18474126  b3570
    pub inline fn netGameserverBeginService(transaction_id: [*c]c_int, category_hash: types.Hash, item_hash: types.Hash, action_type_hash: types.Hash, value: c_int, flags: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3C5FD37B5499582E, .{transaction_id, category_hash, item_hash, action_type_hash, value, flags}); } // 0x3C5FD37B5499582E  b323
    pub inline fn netGameserverEndService(transaction_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE2A99A9B524BEFFF, .{transaction_id}); } // 0xE2A99A9B524BEFFF  b323
    pub inline fn netGameserverDeleteCharacter(slot: c_int, transfer: windows.BOOL, reason: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x51F1A8E48C3D2F6D, .{slot, transfer, reason}); } // 0x51F1A8E48C3D2F6D  b323
    pub inline fn netGameserverDeleteCharacterGetStatus() !c_int { return try invoker.invoke(c_int, 0x0A6D923DFFC9BD89, .{}); } // 0x0A6D923DFFC9BD89  b323
    pub inline fn netGameserverDeleteSetTelemetryNonceSeed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x112CEF1615A1139F, .{}); } // 0x112CEF1615A1139F  b323
    pub inline fn netGameserverTransferBankToWallet(char_slot: c_int, amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD47A2C1BA117471D, .{char_slot, amount}); } // 0xD47A2C1BA117471D  b323
    pub inline fn netGameserverTransferWalletToBank(char_slot: c_int, amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC2F7FE5309181C7D, .{char_slot, amount}); } // 0xC2F7FE5309181C7D  b323
    /// Same as 0x350AA5EBC03D3BD2
    pub inline fn netGameserverTransferBankToWalletGetStatus() !c_int { return try invoker.invoke(c_int, 0x23789E777D14CE44, .{}); } // 0x23789E777D14CE44  b323
    /// Same as 0x23789E777D14CE44
    pub inline fn netGameserverTransferWalletToBankGetStatus() !c_int { return try invoker.invoke(c_int, 0x350AA5EBC03D3BD2, .{}); } // 0x350AA5EBC03D3BD2  b323
    /// Used to be NETWORK_SHOP_CASH_TRANSFER_SET_TELEMETRY_NONCE_SEED
    pub inline fn netGameserverTransferCashSetTelemetryNonceSeed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x498C1E05CE5F7877, .{}); } // 0x498C1E05CE5F7877  b323
    pub inline fn netGameserverSetTelemetryNonceSeed(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9507D4271988E1AE, .{p_0}); } // 0x9507D4271988E1AE  b323
};

pub const Network = struct
{
    /// Online version is defined here: update\update.rpf\common\data\version.txt
    /// 
    /// Example:
    /// 
    /// [ONLINE_VERSION_NUMBER] \
    /// 1.33
    /// 
    /// _GET_ONLINE_VERSION() will return "1.33"
    pub inline fn getOnlineVersion() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xFCA9373EF340AC0A, .{}); } // 0xFCA9373EF340AC0A  b323
    /// Returns whether the player is signed into Social Club.
    pub inline fn networkIsSignedIn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x054354A99211EB96, .{}); } // 0x054354A99211EB96 0xADD0B40F b323
    /// Returns whether the game is not in offline mode.
    /// 
    /// seemed not to work for some ppl
    pub inline fn networkIsSignedOnline() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1077788E268557C2, .{}); } // 0x1077788E268557C2 0x6E5BDCE2 b323
    /// This function is hard-coded to always return 1.
    pub inline fn networkIsNpAvailable() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBD545D44CCE70597, .{}); } // 0xBD545D44CCE70597  b323
    /// This function is hard-coded to always return 1.
    pub inline fn networkIsNpPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEBCAB9E5048434F4, .{}); } // 0xEBCAB9E5048434F4  b323
    /// Hardcoded to return zero.
    /// 
    /// ==== PS4 specific info ====
    /// 
    /// Returns some sort of unavailable reason: \
    /// -1 = REASON_INVALID \
    ///  0 = REASON_OTHER \
    ///  1 = REASON_SYSTEM_UPDATE \
    ///  2 = REASON_GAME_UPDATE \
    ///  3 = REASON_SIGNED_OUT \
    ///  4 = REASON_AGE \
    ///  5 = REASON_CONNECTION
    /// 
    /// =================================
    pub inline fn networkGetNpUnavailableReason() !c_int { return try invoker.invoke(c_int, 0x74FB3E29E6D10FA9, .{}); } // 0x74FB3E29E6D10FA9  b323
    /// This function is hard-coded to always return 1.
    pub inline fn networkIsConnetedToNpPresence() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7808619F31FF22DB, .{}); } // 0x7808619F31FF22DB  b323
    /// This function is hard-coded to always return 0.
    pub inline fn networkIsLoggedInToPsn() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0FA4EC6A05DA44E, .{}); } // 0xA0FA4EC6A05DA44E  b323
    /// Returns whether the signed-in user has valid Rockstar Online Services (ROS) credentials.
    pub inline fn networkHasValidRosCredentials() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x85443FF4C328F53B, .{}); } // 0x85443FF4C328F53B 0x3FB40673 b323
    pub inline fn networkIsRefreshingRosCredentials() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8D11E61A4ABF49CC, .{}); } // 0x8D11E61A4ABF49CC 0xBDC8F63E b323
    pub inline fn networkIsCloudAvailable() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9A4CF4F48AD77302, .{}); } // 0x9A4CF4F48AD77302 0xC7FF5AFC b323
    pub inline fn networkHasSocialClubAccount() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x67A5589628E0CFF6, .{}); } // 0x67A5589628E0CFF6 0x66EC713F b323
    pub inline fn networkAreSocialClubPoliciesCurrent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBA9775570DB788CF, .{}); } // 0xBA9775570DB788CF 0x358D1D77 b323
    /// If you are host, returns true else returns false.
    pub inline fn networkIsHost() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8DB296B814EDDA07, .{}); } // 0x8DB296B814EDDA07 0xE46AC10F b323
    pub inline fn networkGetHostPlayerIndex() !types.Player { return try invoker.invoke(types.Player, 0x8251FB94DC4FDFC8, .{}); } // 0x8251FB94DC4FDFC8  b2612
    pub inline fn networkWasGameSuspended() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4237E822315D8BA9, .{}); } // 0x4237E822315D8BA9  b323
    pub inline fn networkHaveOnlinePrivileges() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x25CB5A9F37BFD063, .{}); } // 0x25CB5A9F37BFD063 0xEF63BFDF b323
    /// For the XboxPC version this returns true if XPRIVILEGE_MULTIPLAYER_SESSIONS is granted but XPRIVILEGE_CROSS_PLAY is NOT granted. \
    /// For more information, see https://learn.microsoft.com/en-us/gaming/gdk/_content/gc/live/features/identity/privileges/concepts/live-user-privileges-client#privilege-ids-to-check
    /// 
    /// Always returns false for non-XboxPC versions.
    pub inline fn networkMultiplayerCrossplayNotAllowed_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA6BC0D9BCF9662FA, .{}); } // 0xA6BC0D9BCF9662FA  b3504
    pub inline fn networkHasAgeRestrictions() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1353F87E89946207, .{}); } // 0x1353F87E89946207  b323
    pub inline fn networkHaveUserContentPrivileges(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x72D918C99BCACC54, .{p_0}); } // 0x72D918C99BCACC54 0x1F88819D b323
    pub inline fn networkHaveCommunicationPrivileges(p_0: c_int, player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAEEF48CDF5B6CE7C, .{p_0, player}); } // 0xAEEF48CDF5B6CE7C 0x2D817A5E b323
    /// Appears to be PlayStation-specific. Always returns true on other platforms if signed in with the primary user profile
    pub inline fn networkHavePlatformCommunicationPrivileges_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE1E02509169C124E, .{}); } // 0xE1E02509169C124E  b3095
    pub inline fn networkCheckOnlinePrivileges(p_0: types.Any, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x78321BEA235FD8CD, .{p_0, p_1}); } // 0x78321BEA235FD8CD  b323
    pub inline fn networkCheckUserContentPrivileges(p_0: c_int, p_1: c_int, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x595F028698072DD9, .{p_0, p_1, p_2}); } // 0x595F028698072DD9 0xBB54AA3D b323
    pub inline fn networkCheckCommunicationPrivileges(p_0: c_int, p_1: c_int, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x83F28CE49FBBFFBA, .{p_0, p_1, p_2}); } // 0x83F28CE49FBBFFBA 0xA79E5B05 b323
    pub inline fn networkCheckTextCommunicationPrivileges(p_0: types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x07EAB372C8841D99, .{p_0, p_1, p_2}); } // 0x07EAB372C8841D99  b1011
    pub inline fn networkIsUsingOnlinePromotion() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x906CA41A4B74ECA4, .{}); } // 0x906CA41A4B74ECA4  b1493
    pub inline fn networkShouldShowPromotionAlertScreen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x023ACAB2DC9DC4A4, .{}); } // 0x023ACAB2DC9DC4A4  b1493
    pub inline fn networkHasSocialNetworkingSharingPriv() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x76BF03FADBF154F5, .{}); } // 0x76BF03FADBF154F5 0xEB864288 b323
    pub inline fn networkGetAgeGroup() !c_int { return try invoker.invoke(c_int, 0x9614B71F8ADB982B, .{}); } // 0x9614B71F8ADB982B 0xAB07CBBE b323
    pub inline fn networkCheckPrivileges(p_0: types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0CF6CC51AA18F0F8, .{p_0, p_1, p_2}); } // 0x0CF6CC51AA18F0F8  b1180
    /// Hardcoded to return false.
    pub inline fn networkIsPrivilegeCheckInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x64E5C4CC82847B73, .{}); } // 0x64E5C4CC82847B73  b1734
    pub inline fn networkSetPrivilegeCheckResultNotNeeded() !void { try invoker.invoke(void, 0x1F7BC3539F9E0224, .{}); } // 0x1F7BC3539F9E0224  b1180
    /// Hardcoded to return true.
    pub inline fn networkResolvePrivilegeUserContent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDE9225854F37BF72, .{}); } // 0xDE9225854F37BF72  b2612
    pub inline fn networkHavePlatformSubscription() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5EA784D197556507, .{}); } // 0x5EA784D197556507  b323
    pub inline fn networkIsPlatformSubscriptionCheckPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA8ACB6459542A8C8, .{}); } // 0xA8ACB6459542A8C8  b323
    pub inline fn networkShowAccountUpgradeUi() !void { try invoker.invoke(void, 0x83FE8D7229593017, .{}); } // 0x83FE8D7229593017  b323
    pub inline fn networkIsShowingSystemUiOrRecentlyRequestedUpsell() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7788DFE15016A182, .{}); } // 0x7788DFE15016A182  b2612
    pub inline fn networkNeedToStartNewGameButBlocked() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x53C10C8BD774F2C9, .{}); } // 0x53C10C8BD774F2C9  b1011
    pub inline fn networkCanBail() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x580CE4438479CC61, .{}); } // 0x580CE4438479CC61 0x60E1FEDF b323
    pub inline fn networkBail(p_0: c_int, p_1: c_int, p_2: c_int) !void { try invoker.invoke(void, 0x95914459A87EBA28, .{p_0, p_1, p_2}); } // 0x95914459A87EBA28 0x87D79A04 b323
    pub inline fn networkOnReturnToSinglePlayer() !void { try invoker.invoke(void, 0x283B6062A2C01E9B, .{}); } // 0x283B6062A2C01E9B 0x96E28FE2 b323
    pub inline fn networkTransitionStart(p_0: c_int, p_1: types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8B4FFC790CA131EF, .{p_0, p_1, p_2, p_3}); } // 0x8B4FFC790CA131EF  b617
    pub inline fn networkTransitionAddStage(hash: types.Hash, p_1: c_int, p_2: c_int, state: c_int, p_4: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC3BFED92026A2AAD, .{hash, p_1, p_2, state, p_4}); } // 0xC3BFED92026A2AAD  b617
    pub inline fn networkTransitionFinish(p_0: types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x04918A41BC9B8157, .{p_0, p_1, p_2}); } // 0x04918A41BC9B8157  b617
    /// 11 - Need to download tunables. \
    /// 12 - Need to download background script.
    /// 
    /// Returns 1 if the multiplayer is loaded, otherwhise 0.
    pub inline fn networkCanAccessMultiplayer(loading_state: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAF50DA1A3F8B1BA4, .{loading_state}); } // 0xAF50DA1A3F8B1BA4 0xA520B982 b323
    pub inline fn networkCheckCanAccessAndAlert() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6FA9825D0B5A721B, .{}); } // 0x6FA9825D0B5A721B  b3570
    pub inline fn networkGetAccessCodeLabelHeading_(access_code: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x967E6FB554E1B6DE, .{access_code}); } // 0x967E6FB554E1B6DE  b3570
    pub inline fn networkGetAccessCodeLabelBody_(access_code: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x214CA1730793EBA8, .{access_code}); } // 0x214CA1730793EBA8  b3570
    pub inline fn networkIsMultiplayerDisabled() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9747292807126EDA, .{}); } // 0x9747292807126EDA 0x05518C0F b323
    pub inline fn networkCanEnterMultiplayer() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7E782A910C362C25, .{}); } // 0x7E782A910C362C25 0x4A23B9C9 b323
    pub inline fn networkSessionDoFreeroamQuickmatch(p_0: types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x330ED4D05491934F, .{p_0, p_1, p_2}); } // 0x330ED4D05491934F  b323
    pub inline fn networkSessionDoFriendMatchmaking(p_0: c_int, p_1: c_int, p_2: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2CFC76E0D087C994, .{p_0, p_1, p_2}); } // 0x2CFC76E0D087C994  b323
    /// p4 seems to be unused in 1.60/build 2628
    pub inline fn networkSessionDoCrewMatchmaking(crew_id: c_int, p_1: c_int, p_2: c_int, max_players: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x94BC51E9449D917F, .{crew_id, p_1, p_2, max_players}); } // 0x94BC51E9449D917F  b323
    pub inline fn networkSessionDoActivityQuickmatch(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBE3E347A87ACEB82, .{p_0, p_1, p_2, p_3, p_4}); } // 0xBE3E347A87ACEB82  b323
    /// Does nothing in online but in offline it will cause the screen to fade to black. Nothing happens past then, the screen will sit at black until you restart GTA. Other stuff must be needed to actually host a session.
    pub inline fn networkSessionHost(p_0: c_int, max_players: c_int, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6F3D4ED9BEE4E61D, .{p_0, max_players, p_2}); } // 0x6F3D4ED9BEE4E61D 0x6716460F b323
    pub inline fn networkSessionHostClosed(p_0: c_int, max_players: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xED34C0C02C098BB7, .{p_0, max_players}); } // 0xED34C0C02C098BB7 0x8AC9EA19 b323
    /// Does nothing in online but in offline it will cause the screen to fade to black. Nothing happens past then, the screen will sit at black until you restart GTA. Other stuff must be needed to actually host a session.
    pub inline fn networkSessionHostFriendsOnly(p_0: c_int, max_players: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB9CFD27A5D578D83, .{p_0, max_players}); } // 0xB9CFD27A5D578D83 0x26864403 b323
    pub inline fn networkSessionIsClosedFriends() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFBCFA2EA2E206890, .{}); } // 0xFBCFA2EA2E206890 0x56E75FE4 b323
    pub inline fn networkSessionIsClosedCrew() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74732C6CA90DA2B4, .{}); } // 0x74732C6CA90DA2B4 0xA95299B9 b323
    pub inline fn networkSessionIsSolo() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF3929C2379B60CCE, .{}); } // 0xF3929C2379B60CCE 0x3D2C1916 b323
    pub inline fn networkSessionIsPrivate() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCEF70AA5B3F89BA1, .{}); } // 0xCEF70AA5B3F89BA1 0xDB67785D b323
    pub inline fn networkSessionLeaveIncludingReason_(leave_flags: c_int, leave_reason: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE0128328CF1FD9F4, .{leave_flags, leave_reason}); } // 0xE0128328CF1FD9F4  b3095
    pub inline fn networkSessionLeave(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB9351A07A0D458B1, .{p_0}); } // 0xB9351A07A0D458B1  b2060
    /// Only works as host.
    pub inline fn networkSessionKickPlayer(player: types.Player) !void { try invoker.invoke(void, 0xFA8904DC5F304220, .{player}); } // 0xFA8904DC5F304220 0x1E20138A b323
    pub inline fn networkSessionGetKickVote(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD6D09A6F32F49EF1, .{player}); } // 0xD6D09A6F32F49EF1 0x8A559D26 b323
    pub inline fn networkSessionReserveSlotsTransition(p_0: types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x041C7F2A6C9894E6, .{p_0, p_1, p_2}); } // 0x041C7F2A6C9894E6  b463
    pub inline fn networkJoinPreviouslyFailedSession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x59DF79317F85A7E0, .{}); } // 0x59DF79317F85A7E0 0x6CDAA7D2 b323
    pub inline fn networkJoinPreviouslyFailedTransition() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFFE1E5B792D92B34, .{}); } // 0xFFE1E5B792D92B34 0xBF21818E b323
    pub inline fn networkSessionSetMatchmakingGroup(matchmaking_group: c_int) !void { try invoker.invoke(void, 0x49EC8030F5015F8B, .{matchmaking_group}); } // 0x49EC8030F5015F8B 0x3C3E2AB6 b323
    /// playerType is an unsigned int from 0 to 4 \
    /// 0 = regular joiner \
    /// 4 = spectator
    pub inline fn networkSessionSetMatchmakingGroupMax(player_type: c_int, player_count: c_int) !void { try invoker.invoke(void, 0x8B6A4DD0AF9CE215, .{player_type, player_count}); } // 0x8B6A4DD0AF9CE215 0x5F29A7E0 b323
    pub inline fn networkSessionGetMatchmakingGroupFree(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x56CE820830EF040B, .{p_0}); } // 0x56CE820830EF040B 0x36EAD960 b323
    /// groupId range: [0, 4]
    pub inline fn networkSessionAddActiveMatchmakingGroup(group_id: c_int) !void { try invoker.invoke(void, 0xCAE55F48D3D7875C, .{group_id}); } // 0xCAE55F48D3D7875C 0x5BE529F7 b323
    pub inline fn networkSessionSetUniqueCrewLimit(p_0: types.Any) !void { try invoker.invoke(void, 0xF49ABC20D8552257, .{p_0}); } // 0xF49ABC20D8552257 0x454C7B67 b323
    pub inline fn networkSessionGetUniqueCrewLimit() !c_int { return try invoker.invoke(c_int, 0xCDC936BF35EDCB73, .{}); } // 0xCDC936BF35EDCB73  b3095
    pub inline fn networkSessionSetUniqueCrewLimitTransition(p_0: types.Any) !void { try invoker.invoke(void, 0x4811BBAC21C5FCD5, .{p_0}); } // 0x4811BBAC21C5FCD5 0xE5961511 b323
    pub inline fn networkSessionSetUniqueCrewOnlyCrewsTransition(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x5539C3EBF104A53A, .{p_0}); } // 0x5539C3EBF104A53A 0xAE396263 b323
    pub inline fn networkSessionSetCrewLimitMaxMembersTransition(p_0: types.Any) !void { try invoker.invoke(void, 0x702BC4D605522539, .{p_0}); } // 0x702BC4D605522539 0x913FD7D6 b323
    pub inline fn networkSessionSetMatchmakingPropertyId(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x3F52E880AAF6C8CA, .{p_0}); } // 0x3F52E880AAF6C8CA 0xB3D9A67F b323
    /// p0 in the decompiled scripts is always the stat mesh_texblend * 0.07 to int
    pub inline fn networkSessionSetMatchmakingMentalState(p_0: c_int) !void { try invoker.invoke(void, 0xF1EEA2DDA9FFA69D, .{p_0}); } // 0xF1EEA2DDA9FFA69D 0x6CC062FC b323
    pub inline fn networkSessionSetNumBosses(num: c_int) !void { try invoker.invoke(void, 0x59D421683D31835A, .{num}); } // 0x59D421683D31835A  b573
    pub inline fn networkSessionSetScriptValidateJoin() !void { try invoker.invoke(void, 0x1153FA02A659051C, .{}); } // 0x1153FA02A659051C 0x57F9BC83 b323
    pub inline fn networkSessionValidateJoin(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xC19F6C8E7865A6FF, .{p_0}); } // 0xC19F6C8E7865A6FF 0xF3768F90 b323
    /// ..
    pub inline fn networkAddFollowers(p_0: [*c]c_int, p_1: c_int) !void { try invoker.invoke(void, 0x236406F60CF216D6, .{p_0, p_1}); } // 0x236406F60CF216D6 0x0EC62629 b323
    pub inline fn networkClearFollowers() !void { try invoker.invoke(void, 0x058F43EC59A8631A, .{}); } // 0x058F43EC59A8631A 0x5E557307 b323
    pub inline fn networkGetGlobalMultiplayerClock(hours: [*c]c_int, minutes: [*c]c_int, seconds: [*c]c_int) !void { try invoker.invoke(void, 0x6D03BFBD643B2A02, .{hours, minutes, seconds}); } // 0x6D03BFBD643B2A02 0x74E8C53E b323
    pub inline fn networkSessionSetGamemode(p_0: types.Any) !void { try invoker.invoke(void, 0x600F8CB31C7AAB6E, .{p_0}); } // 0x600F8CB31C7AAB6E 0x959E43A3 b323
    pub inline fn networkSessionGetHostAimPreference() !c_int { return try invoker.invoke(c_int, 0xDFFA5BE8381C3314, .{}); } // 0xDFFA5BE8381C3314  b463
    pub inline fn networkFindGamersInCrew(crew_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE532D6811B3A4D2A, .{crew_id}); } // 0xE532D6811B3A4D2A 0x7771AB83 b323
    /// Uses attributes to find players with similar stats. Upper/Lower limit must be above zero or the fallback limit +/-0.1 is used. \
    /// There can be up to 15 attributes, they are as follows:
    /// 
    /// 0 = Races \
    /// 1 = Parachuting \
    /// 2 = Horde \
    /// 3 = Darts \
    /// 4 = Arm Wrestling \
    /// 5 = Tennis \
    /// 6 = Golf \
    /// 7 = Shooting Range \
    /// 8 = Deathmatch \
    /// 9 = MPPLY_MCMWIN/MPPLY_CRMISSION
    pub inline fn networkFindMatchedGamers(attribute: c_int, fallback_limit: f32, lower_limit: f32, upper_limit: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF7B2CFDE5C9F700D, .{attribute, fallback_limit, lower_limit, upper_limit}); } // 0xF7B2CFDE5C9F700D 0xA13045D4 b323
    pub inline fn networkIsFindingGamers() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDDDF64C91BFCF0AA, .{}); } // 0xDDDF64C91BFCF0AA 0xA6DAA79F b323
    pub inline fn networkDidFindGamersSucceed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF9B83B77929D8863, .{}); } // 0xF9B83B77929D8863 0xBEDC4503 b323
    pub inline fn networkGetNumFoundGamers() !c_int { return try invoker.invoke(c_int, 0xA1B043EE79A916FB, .{}); } // 0xA1B043EE79A916FB 0xF4B80C7E b323
    pub inline fn networkGetFoundGamer(p_0: [*c]types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9DCFF2AFB68B3476, .{p_0, p_1}); } // 0x9DCFF2AFB68B3476 0xA08C9141 b323
    pub inline fn networkClearFoundGamers() !void { try invoker.invoke(void, 0x6D14CCEE1B40381A, .{}); } // 0x6D14CCEE1B40381A 0x6AA9A154 b323
    pub inline fn networkQueueGamerForStatus(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x85A0EF54A500882C, .{p_0}); } // 0x85A0EF54A500882C 0x42BD0780 b323
    pub inline fn networkGetGamerStatusFromQueue() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2CC848A861D01493, .{}); } // 0x2CC848A861D01493 0xBEB98840 b323
    pub inline fn networkIsGettingGamerStatus() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x94A8394D150B013A, .{}); } // 0x94A8394D150B013A 0x08029970 b323
    pub inline fn networkDidGetGamerStatusSucceed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5AE17C6B0134B7F1, .{}); } // 0x5AE17C6B0134B7F1 0xC871E745 b323
    pub inline fn networkGetGamerStatusResult(p_0: [*c]types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x02A8BEC6FD9AF660, .{p_0, p_1}); } // 0x02A8BEC6FD9AF660 0xB5ABC4B4 b323
    pub inline fn networkClearGetGamerStatus() !void { try invoker.invoke(void, 0x86E0660E4F5C956D, .{}); } // 0x86E0660E4F5C956D 0x3F7EDBBD b323
    pub inline fn networkSessionJoinInvite() !void { try invoker.invoke(void, 0xC6F8AB8A4189CF3A, .{}); } // 0xC6F8AB8A4189CF3A 0x3D6360B5 b323
    pub inline fn networkSessionCancelInvite() !void { try invoker.invoke(void, 0x2FBF47B1B36D36F9, .{}); } // 0x2FBF47B1B36D36F9 0x20317535 b323
    pub inline fn networkSessionForceCancelInvite() !void { try invoker.invoke(void, 0xA29177F7703B5644, .{}); } // 0xA29177F7703B5644 0x3FD49D3B b323
    pub inline fn networkHasPendingInvite() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAC8C7B9B88C4A668, .{}); } // 0xAC8C7B9B88C4A668 0x0C207D6E b323
    pub inline fn networkHasConfirmedInvite() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC42DD763159F3461, .{}); } // 0xC42DD763159F3461 0xFBBAC350 b323
    /// Triggers a CEventNetworkInviteConfirmed event
    pub inline fn networkRequestInviteConfirmedEvent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x62A0296C1BB1CEB3, .{}); } // 0x62A0296C1BB1CEB3 0x0907A6BF b323
    pub inline fn networkSessionWasInvited() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x23DFB504655D0CE4, .{}); } // 0x23DFB504655D0CE4 0x6A0BEA60 b323
    pub inline fn networkSessionGetInviter(gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0xE57397B4A3429DD0, .{gamer_handle}); } // 0xE57397B4A3429DD0 0xE9C6B3FD b323
    /// Seems to be true while "Getting GTA Online session details" shows up.
    pub inline fn networkSessionIsAwaitingInviteResponse() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD313DE83394AF134, .{}); } // 0xD313DE83394AF134 0x3EA9D44C b323
    pub inline fn networkSessionIsDisplayingInviteConfirmation() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBDB6F89C729CF388, .{}); } // 0xBDB6F89C729CF388 0x9374523F b323
    pub inline fn networkSuppressInvite(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA0682D67EF1FBA3D, .{toggle}); } // 0xA0682D67EF1FBA3D 0x323DC78C b323
    pub inline fn networkBlockInvites(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x34F9E9049454A7A0, .{toggle}); } // 0x34F9E9049454A7A0 0xD156FD1A b323
    pub inline fn networkBlockJoinQueueInvites(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCFEB8AF24FC1D0BB, .{toggle}); } // 0xCFEB8AF24FC1D0BB 0x8AB4890B b323
    pub inline fn networkSetCanReceiveRsInvites(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x68980414688F7F9D, .{p_0}); } // 0x68980414688F7F9D  b2612
    pub inline fn networkStoreInviteThroughRestart() !void { try invoker.invoke(void, 0xF814FEC6A19FD6E0, .{}); } // 0xF814FEC6A19FD6E0 0x32B7A076 b323
    pub inline fn networkAllowInviteProcessInPlayerSwitch(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x6B07B9CE4D390375, .{p_0}); } // 0x6B07B9CE4D390375 0x0FCE995D b323
    pub inline fn networkSetScriptReadyForEvents(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7AC752103856FB20, .{toggle}); } // 0x7AC752103856FB20 0xA639DCA2 b323
    pub inline fn networkIsOfflineInvitePending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74698374C45701D2, .{}); } // 0x74698374C45701D2 0x70ED476A b323
    pub inline fn networkClearOfflineInvitePending() !void { try invoker.invoke(void, 0x140E6A44870A11CE, .{}); } // 0x140E6A44870A11CE 0x50507BED b323
    /// Retrieves the failed invite join alert reason
    pub inline fn networkInviteGetJoinFailReason_() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x7B335F84501145BB, .{}); } // 0x7B335F84501145BB  b3179
    /// Clears the failed invite join alert reason
    pub inline fn networkInviteClearJoinFailReason_() !void { try invoker.invoke(void, 0x8EF5F5811A940F82, .{}); } // 0x8EF5F5811A940F82  b3179
    /// Loads up the map that is loaded when beeing in mission creator \
    /// Player gets placed in a mix between online/offline mode \
    /// p0 is always 2 in R* scripts.
    /// 
    /// Appears to be patched in gtav b757 (game gets terminated) alonside with most other network natives to prevent online modding ~ghost30812
    pub inline fn networkSessionHostSinglePlayer(p_0: c_int) !void { try invoker.invoke(void, 0xC74C33FCA52856D5, .{p_0}); } // 0xC74C33FCA52856D5 0xF3B1CA85 b323
    pub inline fn networkSessionLeaveSinglePlayer() !void { try invoker.invoke(void, 0x3442775428FD2DAA, .{}); } // 0x3442775428FD2DAA 0xC692F86A b323
    pub inline fn networkIsGameInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x10FAB35428CCC9D7, .{}); } // 0x10FAB35428CCC9D7 0x09B88E3E b323
    pub inline fn networkIsSessionActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD83C2B94E7508980, .{}); } // 0xD83C2B94E7508980 0x715CB8C4 b323
    pub inline fn networkIsInSession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCA97246103B63917, .{}); } // 0xCA97246103B63917 0x4BC4105E b323
    /// Hardcoded to return 0.
    pub inline fn networkIsAmericasVersion_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0292BD7F3766CEBC, .{}); } // 0x0292BD7F3766CEBC  b3095
    /// This checks if player is playing on gta online or not. \
    /// Please add an if and block your mod if this is "true".
    pub inline fn networkIsSessionStarted() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9DE624D2FC4B603F, .{}); } // 0x9DE624D2FC4B603F 0x9D854A37 b323
    pub inline fn networkIsSessionBusy() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF4435D66A8E2905E, .{}); } // 0xF4435D66A8E2905E 0x8592152D b323
    pub inline fn networkCanSessionEnd() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4EEBC3694E49C572, .{}); } // 0x4EEBC3694E49C572 0xE1FCCDBA b323
    pub inline fn networkGetGameMode() !c_int { return try invoker.invoke(c_int, 0x4C9034162368E206, .{}); } // 0x4C9034162368E206  b2060
    pub inline fn networkSessionMarkVisible(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x271CC6AB59EBF9A5, .{toggle}); } // 0x271CC6AB59EBF9A5 0x7017257D b323
    pub inline fn networkSessionIsVisible() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBA416D68C631496A, .{}); } // 0xBA416D68C631496A 0x4977AC28 b323
    pub inline fn networkSessionBlockJoinRequests(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA73667484D7037C3, .{toggle}); } // 0xA73667484D7037C3 0xE6EEF8AF b323
    /// num player slots allowed in session, seems to work? 32 max
    pub inline fn networkSessionChangeSlots(slots: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xB4AB419E0D86ACAE, .{slots, p_1}); } // 0xB4AB419E0D86ACAE 0x6BB93227 b323
    pub inline fn networkSessionGetPrivateSlots() !c_int { return try invoker.invoke(c_int, 0x53AFD64C6758F2F9, .{}); } // 0x53AFD64C6758F2F9 0xE642F2FD b323
    pub inline fn networkSessionVoiceHost() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9C1556705F864230, .{}); } // 0x9C1556705F864230 0x345C2980 b323
    pub inline fn networkSessionVoiceLeave() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6793E42BE02B575D, .{}); } // 0x6793E42BE02B575D 0xE566C7DA b323
    pub inline fn networkSessionVoiceConnectToPlayer(gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0xABD5E88B8A2D3DB2, .{gamer_handle}); } // 0xABD5E88B8A2D3DB2 0x9DFD89E6 b323
    pub inline fn networkSessionVoiceRespondToRequest(p_0: windows.BOOL, p_1: c_int) !void { try invoker.invoke(void, 0x7F8413B7FC2AA6B9, .{p_0, p_1}); } // 0x7F8413B7FC2AA6B9 0x075321B5 b323
    pub inline fn networkSessionVoiceSetTimeout(timeout: c_int) !void { try invoker.invoke(void, 0x5B8ED3DB018927B1, .{timeout}); } // 0x5B8ED3DB018927B1 0x6EFC2FD0 b323
    pub inline fn networkSessionIsInVoiceSession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x855BC38818F6F684, .{}); } // 0x855BC38818F6F684 0x60AA4AA1 b323
    pub inline fn networkSessionIsVoiceSessionActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB5D3453C98456528, .{}); } // 0xB5D3453C98456528  b323
    pub inline fn networkSessionIsVoiceSessionBusy() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEF0912DDF7C4CB4B, .{}); } // 0xEF0912DDF7C4CB4B 0x132CA01E b323
    /// Message is limited to 64 characters.
    pub inline fn networkSendTextMessage(message: [*c]const u8, gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3A214F2EC889B100, .{message, gamer_handle}); } // 0x3A214F2EC889B100 0xAFFEA720 b323
    pub inline fn networkSetActivitySpectator(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x75138790B4359A74, .{toggle}); } // 0x75138790B4359A74 0xFC9AD060 b323
    pub inline fn networkIsActivitySpectator() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x12103B9E0C9F92FB, .{}); } // 0x12103B9E0C9F92FB 0xAF329720 b323
    pub inline fn networkSetActivityPlayerMax(p_0: types.Any) !void { try invoker.invoke(void, 0x0E4F77F7B9D74D84, .{p_0}); } // 0x0E4F77F7B9D74D84 0x04CB2AB4 b573
    pub inline fn networkSetActivitySpectatorMax(max_spectators: c_int) !void { try invoker.invoke(void, 0x9D277B76D1D12222, .{max_spectators}); } // 0x9D277B76D1D12222 0x74E0BC0A b323
    pub inline fn networkGetActivityPlayerNum(p_0: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x73E2B500410DA5A2, .{p_0}); } // 0x73E2B500410DA5A2 0x31F951FD b323
    pub inline fn networkIsActivitySpectatorFromHandle(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2763BBAA72A7BCB9, .{gamer_handle}); } // 0x2763BBAA72A7BCB9 0x58F1DF7D b323
    /// p0: Unknown int \
    /// p1: Unknown int \
    /// p2: Unknown int \
    /// p3: Unknown int \
    /// p4: Unknown always 0 in decompiled scripts \
    /// p5: BOOL purpose unknown, both 0 and 1 are used in decompiled scripts. \
    /// p6: BOOL purpose unknown, both 0 and 1 are used in decompiled scripts. \
    /// p7: Unknown int, it's an int according to decompiled scripts, however the value is always 0 or 1. \
    /// p8: Unknown int, it's an int according to decompiled scripts, however the value is always 0 or 1. \
    /// p9: Unknown int, sometimes 0, but also 32768 or 16384 appear in decompiled scripst, maybe a flag of some sort?
    /// 
    /// From what I can tell it looks like it does the following: \
    /// Creates/hosts a new transition to another online session, using this in FiveM will result in other players being disconencted from the server/preventing them from joining. This is most likely because I entered the wrong session parameters since they're pretty much all unknown right now. \
    /// You also need to use `NetworkJoinTransition(Player player)` and `NetworkLaunchTransition()`.
    pub inline fn networkHostTransition(p_0: c_int, p_1: c_int, p_2: c_int, p_3: c_int, p_4: types.Any, p_5: windows.BOOL, p_6: windows.BOOL, p_7: c_int, p_8: types.Any, p_9: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA60BB5CE242BB254, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9}); } // 0xA60BB5CE242BB254 0x146764FB b323
    pub inline fn networkDoTransitionQuickmatch(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71FB0EBCD4915D56, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x71FB0EBCD4915D56 0x2FF65C0B b323
    pub inline fn networkDoTransitionQuickmatchAsync(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA091A5E44F0072E5, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0xA091A5E44F0072E5 0x47D61C99 b323
    pub inline fn networkDoTransitionQuickmatchWithGroup(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: [*c]types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9C4AB58491FDC98A, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0x9C4AB58491FDC98A 0x5CE60A11 b323
    pub inline fn networkJoinGroupActivity() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA06509A691D12BE4, .{}); } // 0xA06509A691D12BE4 0x0D7E5CF9 b323
    pub inline fn networkClearGroupActivity() !void { try invoker.invoke(void, 0x1888694923EF4591, .{}); } // 0x1888694923EF4591 0x157D44D3 b393
    pub inline fn networkRetainActivityGroup() !void { try invoker.invoke(void, 0xB13E88E655E5A3BC, .{}); } // 0xB13E88E655E5A3BC 0x36A5F2DA b323
    pub inline fn networkIsTransitionClosedFriends() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6512765E3BE78C50, .{}); } // 0x6512765E3BE78C50 0x95FFACF8 b323
    pub inline fn networkIsTransitionClosedCrew() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0DBD5D7E3C5BEC3B, .{}); } // 0x0DBD5D7E3C5BEC3B 0xB97A966B b323
    pub inline fn networkIsTransitionSolo() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5DC577201723960A, .{}); } // 0x5DC577201723960A 0x063DC4A5 b323
    pub inline fn networkIsTransitionPrivate() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5A6AA44FF8E931E6, .{}); } // 0x5A6AA44FF8E931E6 0x104DDE8D b323
    pub inline fn networkGetNumTransitionNonAsyncGamers() !c_int { return try invoker.invoke(c_int, 0x617F49C2668E6155, .{}); } // 0x617F49C2668E6155  b757
    pub inline fn networkMarkAsPreferredActivity(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x261E97AD7BCF3D40, .{p_0}); } // 0x261E97AD7BCF3D40 0x7EF353E1 b323
    pub inline fn networkMarkAsWaitingAsync(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x39917E1B4CB0F911, .{p_0}); } // 0x39917E1B4CB0F911 0xF60986FC b323
    pub inline fn networkSetInProgressFinishTime(p_0: types.Any) !void { try invoker.invoke(void, 0x2CE9D95E4051AECD, .{p_0}); } // 0x2CE9D95E4051AECD  b678
    pub inline fn networkSetTransitionCreatorHandle(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0xEF26739BCD9907D5, .{p_0}); } // 0xEF26739BCD9907D5 0x1DD01FE7 b323
    pub inline fn networkClearTransitionCreatorHandle() !void { try invoker.invoke(void, 0xFB3272229A82C759, .{}); } // 0xFB3272229A82C759 0x8BB336F7 b323
    pub inline fn networkInviteGamersToTransition(p_0: [*c]types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4A595C32F77DFF76, .{p_0, p_1}); } // 0x4A595C32F77DFF76 0x5332E645 b323
    pub inline fn networkSetGamerInvitedToTransition(gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0xCA2C8073411ECDB6, .{gamer_handle}); } // 0xCA2C8073411ECDB6 0x17F1C69D b323
    pub inline fn networkLeaveTransition() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD23A1A815D21DB19, .{}); } // 0xD23A1A815D21DB19 0x3A3599B7 b323
    pub inline fn networkLaunchTransition() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2DCF46CB1A4F0884, .{}); } // 0x2DCF46CB1A4F0884 0xE3570BA2 b323
    /// Appears to set whether a transition should be started when the session is migrating.
    pub inline fn networkSetDoNotLaunchFromJoinAsMigratedHost(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA2E9C1AB8A92E8CD, .{toggle}); } // 0xA2E9C1AB8A92E8CD 0x8D014B23 b323
    pub inline fn networkCancelTransitionMatchmaking() !void { try invoker.invoke(void, 0x023782EFC70585EE, .{}); } // 0x023782EFC70585EE  b2699
    pub inline fn networkBailTransition(p_0: c_int, p_1: c_int, p_2: c_int) !void { try invoker.invoke(void, 0xEAA572036990CD1B, .{p_0, p_1, p_2}); } // 0xEAA572036990CD1B 0xB59D74CA b323
    pub inline fn networkDoTransitionToGame(p_0: windows.BOOL, max_players: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3E9BB38102A589B0, .{p_0, max_players}); } // 0x3E9BB38102A589B0 0x1B2114D2 b323
    pub inline fn networkDoTransitionToNewGame(p_0: windows.BOOL, max_players: c_int, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4665F51EFED00034, .{p_0, max_players, p_2}); } // 0x4665F51EFED00034 0x58AFBE63 b323
    /// p2 is true 3/4 of the occurrences I found. \
    /// 'players' is the number of players for a session. On PS3/360 it's always 18. On PC it's 32.
    pub inline fn networkDoTransitionToFreemode(p_0: [*c]types.Any, p_1: types.Any, p_2: windows.BOOL, players: c_int, p_4: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3AAD8B2FCA1E289F, .{p_0, p_1, p_2, players, p_4}); } // 0x3AAD8B2FCA1E289F 0xC7CB8ADF b323
    pub inline fn networkDoTransitionToNewFreemode(p_0: [*c]types.Any, p_1: types.Any, players: c_int, p_3: windows.BOOL, p_4: windows.BOOL, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9E80A5BA8109F974, .{p_0, p_1, players, p_3, p_4, p_5}); } // 0x9E80A5BA8109F974 0xAD13375E b323
    pub inline fn networkIsTransitionToGame() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9D7696D8F4FA6CB7, .{}); } // 0x9D7696D8F4FA6CB7 0x17146B2B b323
    /// Returns count.
    pub inline fn networkGetTransitionMembers(data: [*c]types.Any, data_count: c_int) !c_int { return try invoker.invoke(c_int, 0x73B000F7FBC55829, .{data, data_count}); } // 0x73B000F7FBC55829 0x31F19263 b323
    pub inline fn networkApplyTransitionParameter(p_0: c_int, p_1: c_int) !void { try invoker.invoke(void, 0x521638ADA1BA0D18, .{p_0, p_1}); } // 0x521638ADA1BA0D18 0xCEE79711 b323
    pub inline fn networkApplyTransitionParameterString(p_0: c_int, string: [*c]const u8, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xEBEFC2E77084F599, .{p_0, string, p_2}); } // 0xEBEFC2E77084F599 0xE0C28DB5 b323
    pub inline fn networkSendTransitionGamerInstruction(gamer_handle: [*c]types.Any, p_1: [*c]const u8, p_2: c_int, p_3: c_int, p_4: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x31D1D2B858D25E6B, .{gamer_handle, p_1, p_2, p_3, p_4}); } // 0x31D1D2B858D25E6B 0x468B0884 b323
    pub inline fn networkMarkTransitionGamerAsFullyJoined(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5728BB6D63E3FF1D, .{p_0}); } // 0x5728BB6D63E3FF1D 0x03383F57 b323
    pub inline fn networkIsTransitionHost() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0B824797C9BF2159, .{}); } // 0x0B824797C9BF2159 0x0C0900BC b323
    pub inline fn networkIsTransitionHostFromHandle(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6B5C83BA3EFE6A10, .{gamer_handle}); } // 0x6B5C83BA3EFE6A10 0x0E2854C4 b323
    pub inline fn networkGetTransitionHost(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x65042B9774C4435E, .{gamer_handle}); } // 0x65042B9774C4435E 0x73098D40 b323
    pub inline fn networkIsInTransition() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x68049AEFF83D8F0A, .{}); } // 0x68049AEFF83D8F0A 0xC3CDB626 b323
    pub inline fn networkIsTransitionStarted() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x53FA83401D9C07FE, .{}); } // 0x53FA83401D9C07FE 0x7917E111 b323
    pub inline fn networkIsTransitionBusy() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x520F3282A53D26B7, .{}); } // 0x520F3282A53D26B7 0xA357A2C6 b323
    pub inline fn networkIsTransitionMatchmaking() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x292564C735375EDF, .{}); } // 0x292564C735375EDF 0x8262C70E b323
    pub inline fn networkIsTransitionLeavePostponed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC571D0E77D8BBC29, .{}); } // 0xC571D0E77D8BBC29 0x4F4BB300 b323
    pub inline fn networkTransitionSetInProgress(p_0: types.Any) !void { try invoker.invoke(void, 0x1398582B7F72B3ED, .{p_0}); } // 0x1398582B7F72B3ED  b505
    pub inline fn networkTransitionSetContentCreator(p_0: types.Any) !void { try invoker.invoke(void, 0x1F8E00FB18239600, .{p_0}); } // 0x1F8E00FB18239600  b573
    pub inline fn networkTransitionSetActivityIsland(p_0: types.Any) !void { try invoker.invoke(void, 0xF6F4383B7C92F11A, .{p_0}); } // 0xF6F4383B7C92F11A  b573
    pub inline fn networkOpenTransitionMatchmaking() !void { try invoker.invoke(void, 0x2B3A8F7CA3A38FDE, .{}); } // 0x2B3A8F7CA3A38FDE 0xC71E607B b323
    pub inline fn networkCloseTransitionMatchmaking() !void { try invoker.invoke(void, 0x43F4DBA69710E01E, .{}); } // 0x43F4DBA69710E01E 0x82D32D07 b323
    pub inline fn networkIsTransitionOpenToMatchmaking() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x37A4494483B9F5C9, .{}); } // 0x37A4494483B9F5C9 0xC901AA9F b323
    pub inline fn networkSetTransitionVisibilityLock(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x0C978FDA19692C2C, .{p_0, p_1}); } // 0x0C978FDA19692C2C 0x4AF0ADF5 b323
    pub inline fn networkIsTransitionVisibilityLocked() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD0A484CB2F829FBE, .{}); } // 0xD0A484CB2F829FBE 0xF637166E b323
    pub inline fn networkSetTransitionActivityId(p_0: types.Any) !void { try invoker.invoke(void, 0x30DE938B516F0AD2, .{p_0}); } // 0x30DE938B516F0AD2 0xCCA9C022 b323
    pub inline fn networkChangeTransitionSlots(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xEEEDA5E6D7080987, .{p_0, p_1}); } // 0xEEEDA5E6D7080987 0x1E5F6AEF b323
    pub inline fn networkTransitionBlockJoinRequests(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x973D76AA760A6CB6, .{p_0}); } // 0x973D76AA760A6CB6 0x0532DDD2 b323
    pub inline fn networkHasPlayerStartedTransition(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9AC9CCBFA8C29795, .{player}); } // 0x9AC9CCBFA8C29795 0x4ABD1E59 b323
    pub inline fn networkAreTransitionDetailsValid(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2615AA2A695930C1, .{p_0}); } // 0x2615AA2A695930C1 0xCDEBCCE7 b323
    /// int handle[76]; \
    ///           NETWORK_HANDLE_FROM_FRIEND(iSelectedPlayer, &handle[0], 13);
    ///           Player uVar2 = NETWORK_GET_PLAYER_FROM_GAMER_HANDLE(&handle[0]);
    ///           NETWORK_JOIN_TRANSITION(uVar2);
    /// nothing doin.
    pub inline fn networkJoinTransition(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9D060B08CD63321A, .{player}); } // 0x9D060B08CD63321A 0xB054EC4B b323
    pub inline fn networkHasInvitedGamerToTransition(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7284A47B3540E6CF, .{p_0}); } // 0x7284A47B3540E6CF 0x4F41DF6B b323
    pub inline fn networkHasTransitionInviteBeenAcked(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3F9990BF5F22759C, .{p_0}); } // 0x3F9990BF5F22759C 0x00F26CDC b323
    pub inline fn networkIsActivitySession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x05095437424397FA, .{}); } // 0x05095437424397FA 0x577DAA8A b323
    pub inline fn networkDisableRealtimeMultiplayer() !void { try invoker.invoke(void, 0x236905C700FDB54D, .{}); } // 0x236905C700FDB54D  b2612
    /// Does nothing. It's just a nullsub.
    pub inline fn networkSetPresenceSessionInvitesBlocked(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4A9FDE3A5A6D0437, .{toggle}); } // 0x4A9FDE3A5A6D0437 0x18F03AFD b323
    pub inline fn networkSendInviteViaPresence(gamer_handle: [*c]types.Any, p_1: [*c]const u8, data_count: c_int, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC3C7A6AFDB244624, .{gamer_handle, p_1, data_count, p_3}); } // 0xC3C7A6AFDB244624 0x8B99B72B b323
    pub inline fn networkSendTransitionInviteViaPresence(gamer_handle: [*c]types.Any, p_1: [*c]const u8, data_count: c_int, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC116FF9B4D488291, .{gamer_handle, p_1, data_count, p_3}); } // 0xC116FF9B4D488291 0x877C0E1C b323
    /// Contains the string "NETWORK_SEND_PRESENCE_TRANSITION_INVITE" but so does 0xC116FF9B4D488291; seems to fit alphabetically here, tho.
    pub inline fn networkSendImportantTransitionInviteViaPresence(gamer_handle: [*c]types.Any, p_1: [*c]const u8, data_count: c_int, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1171A97A3D3981B6, .{gamer_handle, p_1, data_count, p_3}); } // 0x1171A97A3D3981B6  b323
    pub inline fn networkGetPresenceInviteIndexById(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x742B58F723233ED9, .{p_0}); } // 0x742B58F723233ED9 0x5E832444 b323
    pub inline fn networkGetNumPresenceInvites() !c_int { return try invoker.invoke(c_int, 0xCEFA968912D0F78D, .{}); } // 0xCEFA968912D0F78D 0x3FDA00F3 b323
    pub inline fn networkAcceptPresenceInvite(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFA91550DF9318B22, .{p_0}); } // 0xFA91550DF9318B22 0xE5DA4CED b323
    pub inline fn networkRemovePresenceInvite(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF0210268DB0974B1, .{p_0}); } // 0xF0210268DB0974B1 0x93C665FA b323
    pub inline fn networkGetPresenceInviteId(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0xDFF09646E12EC386, .{p_0}); } // 0xDFF09646E12EC386 0xD50DF46C b323
    pub inline fn networkGetPresenceInviteInviter(p_0: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x4962CC4AA2F345B7, .{p_0}); } // 0x4962CC4AA2F345B7 0x19EC65D9 b323
    pub inline fn networkGetPresenceInviteHandle(p_0: types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x38D5B0FEBB086F75, .{p_0, p_1}); } // 0x38D5B0FEBB086F75 0xB2451429 b323
    pub inline fn networkGetPresenceInviteSessionId(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x26E1CD96B0903D60, .{p_0}); } // 0x26E1CD96B0903D60 0xC5E0C989 b323
    pub inline fn networkGetPresenceInviteContentId(p_0: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x24409FC4C55CB22D, .{p_0}); } // 0x24409FC4C55CB22D 0xA4302183 b323
    pub inline fn networkGetPresenceInvitePlaylistLength(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0xD39B3FFF8FFDD5BF, .{p_0}); } // 0xD39B3FFF8FFDD5BF 0x51B2D848 b323
    pub inline fn networkGetPresenceInvitePlaylistCurrent(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x728C4CC7920CD102, .{p_0}); } // 0x728C4CC7920CD102 0x4677C656 b323
    pub inline fn networkGetPresenceInviteFromAdmin(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3DBF2DF0AEB7D289, .{p_0}); } // 0x3DBF2DF0AEB7D289 0xF5E3401C b323
    pub inline fn networkGetPresenceInviteIsTournament(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8806CEBFABD3CE05, .{p_0}); } // 0x8806CEBFABD3CE05 0x7D593B4C b323
    pub inline fn networkHasFollowInvite() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x76D9B976C4C09FDE, .{}); } // 0x76D9B976C4C09FDE 0xE96CFE7D b323
    pub inline fn networkActionFollowInvite() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC88156EBB786F8D5, .{}); } // 0xC88156EBB786F8D5 0xAB969F00 b323
    pub inline fn networkClearFollowInvite() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x439BFDE3CD0610F6, .{}); } // 0x439BFDE3CD0610F6 0x3242F952 b323
    pub inline fn networkRemoveAndCancelAllInvites() !void { try invoker.invoke(void, 0xEBF8284D8CADEB53, .{}); } // 0xEBF8284D8CADEB53 0x9773F36A b323
    pub inline fn networkRemoveTransitionInvite(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x7524B431B2E6F7EE, .{p_0}); } // 0x7524B431B2E6F7EE 0xFDE84CB7 b323
    pub inline fn networkRemoveAllTransitionInvite() !void { try invoker.invoke(void, 0x726E0375C7A26368, .{}); } // 0x726E0375C7A26368 0xF7134E73 b323
    pub inline fn networkRemoveAndCancelAllTransitionInvites() !void { try invoker.invoke(void, 0xF083835B70BA9BFE, .{}); } // 0xF083835B70BA9BFE 0xC47352E7 b323
    pub inline fn networkInviteGamers(p_0: [*c]types.Any, p_1: types.Any, p_2: [*c]types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9D80CD1D0E6327DE, .{p_0, p_1, p_2, p_3}); } // 0x9D80CD1D0E6327DE 0x52FB8074 b323
    pub inline fn networkHasInvitedGamer(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4D86CD31E8976ECE, .{p_0}); } // 0x4D86CD31E8976ECE 0xEC651BC0 b323
    pub inline fn networkHasMadeInviteDecision(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71DC455F5CD1C2B1, .{gamer_handle}); } // 0x71DC455F5CD1C2B1  b505
    pub inline fn networkGetInviteReplyStatus(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x3855FB5EB2C5E8B2, .{p_0}); } // 0x3855FB5EB2C5E8B2  b505
    pub inline fn networkGetCurrentlySelectedGamerHandleFromInviteMenu(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74881E6BCAE2327C, .{p_0}); } // 0x74881E6BCAE2327C 0x72BA00CE b323
    pub inline fn networkSetCurrentlySelectedGamerHandleFromInviteMenu(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7206F674F2A3B1BB, .{p_0}); } // 0x7206F674F2A3B1BB 0xFD95899E b323
    pub inline fn networkSetInviteOnCallForInviteMenu(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x66F010A4B031A331, .{p_0}); } // 0x66F010A4B031A331 0x11378777 b323
    pub inline fn networkCheckDataManagerSucceededForHandle(p_0: c_int, gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x44B37CDCAE765AAE, .{p_0, gamer_handle}); } // 0x44B37CDCAE765AAE 0x13301529 b323
    pub inline fn networkCheckDataManagerForHandle(p_0: types.Any, gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4AD490AE1536933B, .{p_0, gamer_handle}); } // 0x4AD490AE1536933B  b372
    pub inline fn networkSetInviteFailedMessageForInviteMenu(p_0: [*c]types.Any, p_1: [*c]types.Any) !void { try invoker.invoke(void, 0x0D77A82DC2D0DA59, .{p_0, p_1}); } // 0x0D77A82DC2D0DA59 0x0808D4CC b323
    pub inline fn filloutPmPlayerList(gamer_handle: [*c]types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCBBD7C4991B64809, .{gamer_handle, p_1, p_2}); } // 0xCBBD7C4991B64809 0xCE40F423 b323
    pub inline fn filloutPmPlayerListWithNames(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x716B6DB9D1886106, .{p_0, p_1, p_2, p_3}); } // 0x716B6DB9D1886106 0xB8DF604E b323
    pub inline fn refreshPlayerListStats(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE26CCFF8094D8C74, .{p_0}); } // 0xE26CCFF8094D8C74 0xF49C1533 b323
    pub inline fn networkSetCurrentDataManagerHandle(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x796A87B3B68D1F3D, .{p_0}); } // 0x796A87B3B68D1F3D  b323
    /// Hardcoded to return false.
    pub inline fn networkIsInPlatformParty() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2FC5650B0271CB57, .{}); } // 0x2FC5650B0271CB57 0xA812B6CB b323
    pub inline fn networkGetPlatformPartyMemberCount() !c_int { return try invoker.invoke(c_int, 0x01ABCE5E7CBDA196, .{}); } // 0x01ABCE5E7CBDA196  b323
    pub inline fn networkGetPlatformPartyMembers(data: [*c]types.Any, data_size: c_int) !c_int { return try invoker.invoke(c_int, 0x120364DE2845DAF8, .{data, data_size}); } // 0x120364DE2845DAF8 0xF30E5814 b323
    /// Hardcoded to return false.
    pub inline fn networkIsInPlatformPartyChat() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFD8B834A8BA05048, .{}); } // 0xFD8B834A8BA05048 0xC6609191 b323
    /// This would be nice to see if someone is in party chat, but 2 sad notes. \
    /// 1) It only becomes true if said person is speaking in that party at the time. \
    /// 2) It will never, become true unless you are in that party with said person.
    pub inline fn networkIsChattingInPlatformParty(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8DE9945BCC9AEC52, .{gamer_handle}); } // 0x8DE9945BCC9AEC52 0x51367B34 b323
    pub inline fn networkCanQueueForPreviousSessionJoin() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2BF66D2E7414F686, .{}); } // 0x2BF66D2E7414F686 0x9156EFC0 b323
    pub inline fn networkIsQueuingForSessionJoin() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x14922ED3E38761F0, .{}); } // 0x14922ED3E38761F0 0x8FA6EE0E b323
    pub inline fn networkClearQueuedJoinRequest() !void { try invoker.invoke(void, 0x6CE50E47F5543D0C, .{}); } // 0x6CE50E47F5543D0C  b573
    pub inline fn networkSendQueuedJoinRequest() !void { try invoker.invoke(void, 0xFA2888E3833C8E96, .{}); } // 0xFA2888E3833C8E96 0x7F70C15A b323
    pub inline fn networkRemoveAllQueuedJoinRequests() !void { try invoker.invoke(void, 0x25D990F8E0E3F13C, .{}); } // 0x25D990F8E0E3F13C 0x4FD83F5B b323
    pub inline fn networkSeedRandomNumberGenerator(seed: c_int) !void { try invoker.invoke(void, 0xF1B84178F8674195, .{seed}); } // 0xF1B84178F8674195 0x41702C8A b323
    pub inline fn networkGetRandomInt() !c_int { return try invoker.invoke(c_int, 0x599E4FA1F87EB5FF, .{}); } // 0x599E4FA1F87EB5FF 0x208DD848 b323
    /// Same as GET_RANDOM_INT_IN_RANGE
    pub inline fn networkGetRandomIntRanged(range_start: c_int, range_end: c_int) !c_int { return try invoker.invoke(c_int, 0xE30CF56F1EFA5F43, .{range_start, range_end}); } // 0xE30CF56F1EFA5F43 0xF9B6426D b323
    pub inline fn networkGetRandomFloatRanged_(range_start: f32, range_end: f32) !f32 { return try invoker.invoke(f32, 0x04BD27B5ACB67067, .{range_start, range_end}); } // 0x04BD27B5ACB67067  b2802
    pub inline fn networkPlayerIsCheater() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x655B91F1495A9090, .{}); } // 0x655B91F1495A9090 0xA51DC214 b323
    pub inline fn networkPlayerGetCheaterReason() !c_int { return try invoker.invoke(c_int, 0x172F75B6EE2233BA, .{}); } // 0x172F75B6EE2233BA 0x1720ABA6 b323
    pub inline fn networkPlayerIsBadsport() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x19D8DA0E5A68045A, .{}); } // 0x19D8DA0E5A68045A 0xA19708E3 b323
    pub inline fn remoteCheaterPlayerDetected(player: types.Player, a: c_int, b: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x472841A026D26D8B, .{player, a, b}); } // 0x472841A026D26D8B  b1103
    pub inline fn badSportPlayerLeftDetected(gamer_handle: [*c]types.Any, event: c_int, amount_received: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEC5E3AF5289DCA81, .{gamer_handle, event, amount_received}); } // 0xEC5E3AF5289DCA81 0x4C2C6B6A b323
    pub inline fn networkAddInvalidObjectModel(model_hash: types.Hash, p_1: types.Any) !void { try invoker.invoke(void, 0x7F562DBC212E81F9, .{model_hash, p_1}); } // 0x7F562DBC212E81F9  b2545
    pub inline fn networkRemoveInvalidObjectModel(model_hash: types.Hash) !void { try invoker.invoke(void, 0x791EDB5803B2F468, .{model_hash}); } // 0x791EDB5803B2F468  b2545
    pub inline fn networkClearInvalidObjectModels() !void { try invoker.invoke(void, 0x03B2F03A53D85E41, .{}); } // 0x03B2F03A53D85E41  b2545
    pub inline fn networkApplyPedScarData(ped: types.Ped, p_1: c_int) !void { try invoker.invoke(void, 0xE66C690248F11150, .{ped, p_1}); } // 0xE66C690248F11150 0x4818ACD0 b323
    pub inline fn networkSetThisScriptIsNetworkScript(max_num_mission_participants: c_int, p_1: windows.BOOL, instance_id: c_int) !void { try invoker.invoke(void, 0x1CA59E306ECB80A5, .{max_num_mission_participants, p_1, instance_id}); } // 0x1CA59E306ECB80A5 0x470810ED b323
    pub inline fn networkTryToSetThisScriptIsNetworkScript(p_0: types.Any, p_1: windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD1110739EEADB592, .{p_0, p_1, p_2}); } // 0xD1110739EEADB592  b323
    pub inline fn networkGetThisScriptIsNetworkScript() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2910669969E9535E, .{}); } // 0x2910669969E9535E 0xD9BF6549 b323
    pub inline fn networkGetMaxNumParticipants() !c_int { return try invoker.invoke(c_int, 0xA6C90FBC38E395EE, .{}); } // 0xA6C90FBC38E395EE 0xCCD8C02D b323
    pub inline fn networkGetNumParticipants() !c_int { return try invoker.invoke(c_int, 0x18D0456E86604654, .{}); } // 0x18D0456E86604654 0x3E25A3C5 b323
    pub inline fn networkGetScriptStatus() !c_int { return try invoker.invoke(c_int, 0x57D158647A6BFABF, .{}); } // 0x57D158647A6BFABF 0x2BE9235A b323
    pub inline fn networkRegisterHostBroadcastVariables(vars: [*c]c_int, num_vars: c_int, debug_name: [*c]const u8) !void { try invoker.invoke(void, 0x3E9B2F01C50DF595, .{vars, num_vars, debug_name}); } // 0x3E9B2F01C50DF595 0xDAF3B0AE b323
    pub inline fn networkRegisterPlayerBroadcastVariables(vars: [*c]c_int, num_vars: c_int, debug_name: [*c]const u8) !void { try invoker.invoke(void, 0x3364AA97340CA215, .{vars, num_vars, debug_name}); } // 0x3364AA97340CA215 0xBE3D32B4 b323
    pub inline fn networkRegisterHighFrequencyHostBroadcastVariables(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xEA8C0DDB10E2822A, .{p_0, p_1, p_2}); } // 0xEA8C0DDB10E2822A  b1868
    pub inline fn networkRegisterHighFrequencyPlayerBroadcastVariables(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xD6D7478CA62B8D41, .{p_0, p_1, p_2}); } // 0xD6D7478CA62B8D41  b1868
    pub inline fn networkFinishBroadcastingData() !void { try invoker.invoke(void, 0x64F62AFB081E260D, .{}); } // 0x64F62AFB081E260D 0xA71A1D2A b323
    pub inline fn networkGetHostBroadcastDataSizeUnsynced_(script_name_hash: types.Hash, instance: c_int, position_hash: types.Hash, handler_num: c_int) !c_int { return try invoker.invoke(c_int, 0x72C8588ABE22C972, .{script_name_hash, instance, position_hash, handler_num}); } // 0x72C8588ABE22C972  b3586
    pub inline fn networkGetPlayerBroadcastDataSizeUnsynced_(script_name_hash: types.Hash, instance: c_int, position_hash: types.Hash, handler_num: c_int) !c_int { return try invoker.invoke(c_int, 0xB99CD664FD4720A1, .{script_name_hash, instance, position_hash, handler_num}); } // 0xB99CD664FD4720A1  b3586
    pub inline fn networkGetBroadcastDataHostUpdateSize_(script_name_hash: types.Hash, instance: c_int, position_hash: types.Hash, handler_num: c_int) !c_int { return try invoker.invoke(c_int, 0xE448693B3EA3B92C, .{script_name_hash, instance, position_hash, handler_num}); } // 0xE448693B3EA3B92C  b3586
    pub inline fn networkGetBroadcastDataPlayerUpdateSize_(script_name_hash: types.Hash, instance: c_int, position_hash: types.Hash, handler_num: c_int) !c_int { return try invoker.invoke(c_int, 0xAC3F722321800755, .{script_name_hash, instance, position_hash, handler_num}); } // 0xAC3F722321800755  b3586
    pub inline fn networkHasReceivedHostBroadcastData() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5D10B3795F3FC886, .{}); } // 0x5D10B3795F3FC886 0x0B739F53 b323
    pub inline fn networkGetPlayerIndex(player: types.Player) !types.Player { return try invoker.invoke(types.Player, 0x24FB80D107371267, .{player}); } // 0x24FB80D107371267 0xBE1C1506 b323
    pub inline fn networkGetParticipantIndex(index: c_int) !c_int { return try invoker.invoke(c_int, 0x1B84DF6AF2A46938, .{index}); } // 0x1B84DF6AF2A46938 0xC4D91094 b323
    /// Returns the Player associated to a given Ped when in an online session.
    pub inline fn networkGetPlayerIndexFromPed(ped: types.Ped) !types.Player { return try invoker.invoke(types.Player, 0x6C0E2E0125610278, .{ped}); } // 0x6C0E2E0125610278 0x40DBF464 b323
    /// Returns the amount of players connected in the current session. Only works when connected to a session/server.
    pub inline fn networkGetNumConnectedPlayers() !c_int { return try invoker.invoke(c_int, 0xA4A79DD2D9600654, .{}); } // 0xA4A79DD2D9600654 0xF7952E62 b323
    pub inline fn networkIsPlayerConnected(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x93DC1BE4E1ABE9D1, .{player}); } // 0x93DC1BE4E1ABE9D1 0x168EE2C2 b323
    pub inline fn networkGetTotalNumPlayers() !c_int { return try invoker.invoke(c_int, 0xCF61D4B4702EE9EB, .{}); } // 0xCF61D4B4702EE9EB 0xF4F13B06 b323
    pub inline fn networkIsParticipantActive(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6FF8FF40B6357D45, .{p_0}); } // 0x6FF8FF40B6357D45 0x4E2C348B b323
    pub inline fn networkIsPlayerActive(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB8DFD30D6973E135, .{player}); } // 0xB8DFD30D6973E135 0x43657B17 b323
    pub inline fn networkIsPlayerAParticipant(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3CA58F6CB7CBD784, .{player}); } // 0x3CA58F6CB7CBD784 0xB08B6992 b323
    pub inline fn networkIsHostOfThisScript() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x83CD99A1E6061AB5, .{}); } // 0x83CD99A1E6061AB5 0x6970BA94 b323
    pub inline fn networkGetHostOfThisScript() !types.Player { return try invoker.invoke(types.Player, 0xC7B4D79B01FA7A5C, .{}); } // 0xC7B4D79B01FA7A5C 0x89EA7B54 b323
    /// scriptName examples: \
    /// "freemode", "AM_CR_SecurityVan", ...
    /// 
    /// Most of the time, these values are used: \
    /// instance_id = -1 \
    /// position_hash = 0
    pub inline fn networkGetHostOfScript(script_name: [*c]const u8, instance__id: c_int, position__hash: c_int) !types.Player { return try invoker.invoke(types.Player, 0x1D6A14F1F9A736FC, .{script_name, instance__id, position__hash}); } // 0x1D6A14F1F9A736FC 0x9C95D0BB b323
    pub inline fn networkGetHostOfThread(thread_id: c_int) !types.Player { return try invoker.invoke(types.Player, 0xD3DEBE2991FE8098, .{thread_id}); } // 0xD3DEBE2991FE8098  b3717
    pub inline fn networkSetMissionFinished() !void { try invoker.invoke(void, 0x3B3D11CD9FFCDFC9, .{}); } // 0x3B3D11CD9FFCDFC9 0x3083FAD7 b323
    pub inline fn networkIsScriptActive(script_name: [*c]const u8, instance__id: c_int, p_2: windows.BOOL, position__hash: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9D40DF90FAD26098, .{script_name, instance__id, p_2, position__hash}); } // 0x9D40DF90FAD26098 0x4A65250C b323
    pub inline fn networkIsScriptActiveByHash(script_hash: types.Hash, p_1: c_int, p_2: windows.BOOL, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDA7DE67F5FE5EE13, .{script_hash, p_1, p_2, p_3}); } // 0xDA7DE67F5FE5EE13  b2245
    pub inline fn networkIsThreadANetworkScript(thread_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x560B423D73015E77, .{thread_id}); } // 0x560B423D73015E77  b1604
    pub inline fn networkGetNumScriptParticipants(script_name: [*c]const u8, instance__id: c_int, position__hash: c_int) !c_int { return try invoker.invoke(c_int, 0x3658E8CD94FC121A, .{script_name, instance__id, position__hash}); } // 0x3658E8CD94FC121A 0x8F7D9F46 b323
    pub inline fn networkGetInstanceIdOfThisScript() !c_int { return try invoker.invoke(c_int, 0x638A3A81733086DB, .{}); } // 0x638A3A81733086DB 0xDB8B5D71 b323
    pub inline fn networkGetPositionHashOfThisScript() !types.Hash { return try invoker.invoke(types.Hash, 0x257ED0FADF750BCF, .{}); } // 0x257ED0FADF750BCF  b2372
    pub inline fn networkIsPlayerAParticipantOnScript(player: types.Player, script: [*c]const u8, instance__id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1AD5B71586B94820, .{player, script, instance__id}); } // 0x1AD5B71586B94820 0xCEA55F4C b323
    pub inline fn networkPreventScriptHostMigration() !void { try invoker.invoke(void, 0x2302C0264EA58D31, .{}); } // 0x2302C0264EA58D31 0x8DCFE77D b323
    pub inline fn networkRequestToBeHostOfThisScript() !void { try invoker.invoke(void, 0x741A3D8380319A81, .{}); } // 0x741A3D8380319A81 0x331D9A27 b323
    /// Return the local Participant ID
    pub inline fn participantId() !types.Player { return try invoker.invoke(types.Player, 0x90986E8876CE0A83, .{}); } // 0x90986E8876CE0A83 0x9C35A221 b323
    /// Return the local Participant ID.
    /// 
    /// This native is exactly the same as 'PARTICIPANT_ID' native.
    pub inline fn participantIdToInt() !c_int { return try invoker.invoke(c_int, 0x57A3BDDAD8E5AA0A, .{}); } // 0x57A3BDDAD8E5AA0A 0x907498B0 b323
    pub inline fn networkGetKillerOfPlayer(player: types.Player, weapon_hash: [*c]types.Hash) !types.Player { return try invoker.invoke(types.Player, 0x2DA41ED6E1FCD7A5, .{player, weapon_hash}); } // 0x2DA41ED6E1FCD7A5  b463
    pub inline fn networkGetDestroyerOfNetworkId(net_id: c_int, weapon_hash: [*c]types.Hash) !types.Player { return try invoker.invoke(types.Player, 0x7A1ADEEF01740A24, .{net_id, weapon_hash}); } // 0x7A1ADEEF01740A24 0x4FCA6436 b323
    pub inline fn networkGetDestroyerOfEntity(entity: types.Entity, weapon_hash: [*c]types.Hash) !types.Player { return try invoker.invoke(types.Player, 0xC434133D9BA52777, .{entity, weapon_hash}); } // 0xC434133D9BA52777  b463
    /// NETWORK_GET_ASSISTED_DAMAGE_OF_ENTITY that ensures the entity is dead (IS_ENTITY_DEAD)
    pub inline fn networkGetAssistedKillOfEntity(player: types.Player, entity: types.Entity, p_2: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x83660B734994124D, .{player, entity, p_2}); } // 0x83660B734994124D  b463
    pub inline fn networkGetAssistedDamageOfEntity(player: types.Player, entity: types.Entity, p_2: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4CACA84440FA26F6, .{player, entity, p_2}); } // 0x4CACA84440FA26F6 0x28A45454 b323
    pub inline fn networkGetEntityKillerOfPlayer(player: types.Player, weapon_hash: [*c]types.Hash) !types.Entity { return try invoker.invoke(types.Entity, 0x42B2DAA6B596F5F8, .{player, weapon_hash}); } // 0x42B2DAA6B596F5F8 0xA7E7E04F b323
    pub inline fn networkSetCurrentPublicContentId(mission_id: [*c]const u8) !void { try invoker.invoke(void, 0x2C863ACDCD12B3DB, .{mission_id}); } // 0x2C863ACDCD12B3DB  b2699
    pub inline fn networkSetCurrentChatOption(new_chat_option: c_int) !void { try invoker.invoke(void, 0x3DAD00265FBF356B, .{new_chat_option}); } // 0x3DAD00265FBF356B  b2802
    /// mpSettingSpawn:
    /// 
    /// enum eMpSettingSpawn \
    /// { \
    ///     MP_SETTING_SPAWN_NULL,
    ///     MP_SETTING_SPAWN_PROPERTY,
    ///     MP_SETTING_SPAWN_LAST_POSITION,
    ///     MP_SETTING_SPAWN_GARAGE,
    ///     MP_SETTING_SPAWN_RANDOM,
    ///     MP_SETTING_SPAWN_PRIVATE_YACHT,
    ///     MP_SETTING_SPAWN_OFFICE,
    ///     MP_SETTING_SPAWN_CLUBHOUSE,
    ///     MP_SETTING_SPAWN_IE_WAREHOUSE,
    ///     MP_SETTING_SPAWN_BUNKER,
    ///     MP_SETTING_SPAWN_HANGAR,
    ///     MP_SETTING_SPAWN_DEFUNCT_BASE,
    ///     MP_SETTING_SPAWN_NIGHTCLUB,
    ///     MP_SETTING_SPAWN_ARENA_GARAGE,
    ///     MP_SETTING_SPAWN_CASINO_APARTMENT,
    ///     MP_SETTING_SPAWN_ARCADE,
    ///     MP_SETTING_SPAWN_SUBMARINE,
    ///     MP_SETTING_SPAWN_CAR_MEET,
    ///     MP_SETTING_SPAWN_AUTO_SHOP,
    ///     MP_SETTING_SPAWN_FIXER_HQ,
    ///     MP_SETTING_SPAWN_MAX,
    /// };
    pub inline fn networkSetCurrentSpawnLocationOption(mp_setting_spawn: types.Hash) !void { try invoker.invoke(void, 0xAA6D5451DC3448B6, .{mp_setting_spawn}); } // 0xAA6D5451DC3448B6  b2699
    /// Used by MetricVEHICLE_DIST_DRIVEN
    pub inline fn networkSetVehicleDrivenInTestDrive(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8C70252FC40F320B, .{toggle}); } // 0x8C70252FC40F320B  b2699
    /// Sets 'loc' variable used in MetricVEHICLE_DIST_DRIVEN
    pub inline fn networkSetVehicleDrivenLocation(location: types.Hash) !void { try invoker.invoke(void, 0xA0CE91E47531D3BB, .{location}); } // 0xA0CE91E47531D3BB  b2944
    pub inline fn networkResurrectLocalPlayer(vec: types.Vector3, heading: f32, p_4: windows.BOOL, changetime: windows.BOOL, p_6: windows.BOOL, p_7: c_int, p_8: c_int) !void { try invoker.invoke(void, 0xEA23C49EAA83ACFB, .{vec.x, vec.y, vec.z, heading, p_4, changetime, p_6, p_7, p_8}); } // 0xEA23C49EAA83ACFB 0xF1F9D4B4 b323
    pub inline fn networkSetLocalPlayerInvincibleTime(time: c_int) !void { try invoker.invoke(void, 0x2D95C7E2D7E07307, .{time}); } // 0x2D95C7E2D7E07307 0xFEA9B85C b323
    pub inline fn networkIsLocalPlayerInvincible() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8A8694B48715B000, .{}); } // 0x8A8694B48715B000 0x8DE13B36 b323
    pub inline fn networkDisableInvincibleFlashing(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9DD368BF06983221, .{player, toggle}); } // 0x9DD368BF06983221 0x8D27280E b323
    pub inline fn networkPatchPostCutsceneHs4fTunEnt(ped: types.Ped) !void { try invoker.invoke(void, 0xF0BC9BCD24A511D5, .{ped}); } // 0xF0BC9BCD24A511D5  b2372
    pub inline fn networkSetLocalPlayerSyncLookAt(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x524FF0AEFF9C3973, .{toggle}); } // 0x524FF0AEFF9C3973 0xB72F086D b323
    pub inline fn networkHasEntityBeenRegisteredWithThisThread(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB07D3185E11657A5, .{entity}); } // 0xB07D3185E11657A5 0xEDA68956 b323
    pub inline fn networkGetNetworkIdFromEntity(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0xA11700682F3AD45C, .{entity}); } // 0xA11700682F3AD45C 0x9E35DAB6 b323
    pub inline fn networkGetEntityFromNetworkId(net_id: c_int) !types.Entity { return try invoker.invoke(types.Entity, 0xCE4E5D9B0A4FF560, .{net_id}); } // 0xCE4E5D9B0A4FF560 0x5B912C3F b323
    pub inline fn networkGetEntityIsNetworked(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC7827959479DCC78, .{entity}); } // 0xC7827959479DCC78 0xD7F934F4 b323
    pub inline fn networkGetEntityIsLocal(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0991549DE4D64762, .{entity}); } // 0x0991549DE4D64762 0x813353ED b323
    pub inline fn networkRegisterEntityAsNetworked(entity: types.Entity) !void { try invoker.invoke(void, 0x06FAACD625D80CAA, .{entity}); } // 0x06FAACD625D80CAA 0x31A630A4 b323
    pub inline fn networkUnregisterNetworkedEntity(entity: types.Entity) !void { try invoker.invoke(void, 0x7368E683BB9038D6, .{entity}); } // 0x7368E683BB9038D6 0x5C645F64 b323
    pub inline fn networkDoesNetworkIdExist(net_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x38CE16C96BD11344, .{net_id}); } // 0x38CE16C96BD11344 0xB8D2C99E b323
    pub inline fn networkDoesEntityExistWithNetworkId(net_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x18A47D074708FD68, .{net_id}); } // 0x18A47D074708FD68 0x1E2E3177 b323
    pub inline fn networkRequestControlOfNetworkId(net_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA670B3662FAFFBD0, .{net_id}); } // 0xA670B3662FAFFBD0 0x9262A60A b323
    pub inline fn networkHasControlOfNetworkId(net_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4D36070FE0215186, .{net_id}); } // 0x4D36070FE0215186 0x92E77D21 b323
    /// Returns true if the specified network id is controlled by someone else.
    pub inline fn networkIsNetworkIdRemotelyControlled(net_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7242F8B741CE1086, .{net_id}); } // 0x7242F8B741CE1086  b678
    pub inline fn networkRequestControlOfEntity(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB69317BF5E782347, .{entity}); } // 0xB69317BF5E782347 0xA05FEBD7 b323
    pub inline fn networkRequestControlOfDoor(door_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x870DDFD5A4A796E4, .{door_i_d}); } // 0x870DDFD5A4A796E4 0xF60DAAF6 b323
    pub inline fn networkHasControlOfEntity(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x01BF60A500E28887, .{entity}); } // 0x01BF60A500E28887 0x005FD797 b323
    pub inline fn networkHasControlOfPickup(pickup: types.Pickup) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5BC9495F0B3B6FA6, .{pickup}); } // 0x5BC9495F0B3B6FA6 0xF7784FC8 b323
    pub inline fn networkHasControlOfDoor(door_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCB3C68ADB06195DF, .{door_hash}); } // 0xCB3C68ADB06195DF 0x136326EC b323
    pub inline fn networkIsDoorNetworked(door_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC01E93FAC20C3346, .{door_hash}); } // 0xC01E93FAC20C3346 0xD14D9C07 b323
    /// calls from vehicle to net.
    /// 
    pub inline fn vehToNet(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xB4C94523F023419C, .{vehicle}); } // 0xB4C94523F023419C 0xF17634EB b323
    /// gets the network id of a ped
    pub inline fn pedToNet(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x0EDEC3C276198689, .{ped}); } // 0x0EDEC3C276198689 0x86A0B759 b323
    /// Lets objects spawn online simply do it like this:
    /// 
    /// int createdObject = OBJ_TO_NET(CREATE_OBJECT_NO_OFFSET(oball, pCoords.x, pCoords.y, pCoords.z, 1, 0, 0));
    pub inline fn objToNet(object: types.Object) !c_int { return try invoker.invoke(c_int, 0x99BFDC94A603E541, .{object}); } // 0x99BFDC94A603E541 0x1E05F29F b323
    pub inline fn netToVeh(net_handle: c_int) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x367B936610BA360C, .{net_handle}); } // 0x367B936610BA360C 0x7E02FAEA b323
    /// gets the ped id of a network id
    pub inline fn netToPed(net_handle: c_int) !types.Ped { return try invoker.invoke(types.Ped, 0xBDCD95FC216A8B3E, .{net_handle}); } // 0xBDCD95FC216A8B3E 0x87717DD4 b323
    /// gets the object id of a network id
    pub inline fn netToObj(net_handle: c_int) !types.Object { return try invoker.invoke(types.Object, 0xD8515F5FEA14CB3F, .{net_handle}); } // 0xD8515F5FEA14CB3F 0x27AA14D8 b323
    /// gets the entity id of a network id
    pub inline fn netToEnt(net_handle: c_int) !types.Entity { return try invoker.invoke(types.Entity, 0xBFFEAB45A9A9094A, .{net_handle}); } // 0xBFFEAB45A9A9094A 0x5E149683 b323
    pub inline fn networkGetLocalHandle(gamer_handle: [*c]types.Any, gamer_handle_size: c_int) !void { try invoker.invoke(void, 0xE86051786B66CD8E, .{gamer_handle, gamer_handle_size}); } // 0xE86051786B66CD8E 0x08023B16 b323
    pub inline fn networkHandleFromUserId(user_id: [*c]const u8, gamer_handle: [*c]types.Any, gamer_handle_size: c_int) !void { try invoker.invoke(void, 0xDCD51DD8F87AEC5C, .{user_id, gamer_handle, gamer_handle_size}); } // 0xDCD51DD8F87AEC5C 0x74C2C1B7 b323
    pub inline fn networkHandleFromMemberId(member_id: [*c]const u8, gamer_handle: [*c]types.Any, gamer_handle_size: c_int) !void { try invoker.invoke(void, 0xA0FD21BED61E5C4C, .{member_id, gamer_handle, gamer_handle_size}); } // 0xA0FD21BED61E5C4C 0x9BFC9FE2 b323
    pub inline fn networkHandleFromPlayer(player: types.Player, gamer_handle: [*c]types.Any, gamer_handle_size: c_int) !void { try invoker.invoke(void, 0x388EB2B86C73B6B3, .{player, gamer_handle, gamer_handle_size}); } // 0x388EB2B86C73B6B3 0xD3498917 b323
    pub inline fn networkHashFromPlayerHandle(player: types.Player) !types.Hash { return try invoker.invoke(types.Hash, 0xBC1D768F2F5D6C05, .{player}); } // 0xBC1D768F2F5D6C05 0xF8D7AF3B b323
    pub inline fn networkHashFromGamerHandle(gamer_handle: [*c]types.Any) !types.Hash { return try invoker.invoke(types.Hash, 0x58575AC3CF2CA8EC, .{gamer_handle}); } // 0x58575AC3CF2CA8EC 0x5AC9F04D b323
    pub inline fn networkHandleFromFriend(friend_index: c_int, gamer_handle: [*c]types.Any, gamer_handle_size: c_int) !void { try invoker.invoke(void, 0xD45CB817D7E177D2, .{friend_index, gamer_handle, gamer_handle_size}); } // 0xD45CB817D7E177D2 0x3B0BB3A3 b323
    pub inline fn networkGamertagFromHandleStart(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9F0C0A981D73FA56, .{gamer_handle}); } // 0x9F0C0A981D73FA56 0xEBA00C2A b323
    pub inline fn networkGamertagFromHandlePending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB071E27958EF4CF0, .{}); } // 0xB071E27958EF4CF0 0xF000828E b323
    pub inline fn networkGamertagFromHandleSucceeded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFD00798DBA7523DD, .{}); } // 0xFD00798DBA7523DD 0x89C2B5EA b323
    pub inline fn networkGetGamertagFromHandle(gamer_handle: [*c]types.Any) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x426141162EBE5CDB, .{gamer_handle}); } // 0x426141162EBE5CDB 0xA18A1B26 b323
    /// Hardcoded to return -1.
    pub inline fn networkDisplaynamesFromHandlesStart(p_0: [*c]types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0xD66C9E72B3CC4982, .{p_0, p_1}); } // 0xD66C9E72B3CC4982  b323
    /// This function is hard-coded to always return 0.
    pub inline fn networkGetDisplaynamesFromHandles(p_0: types.Any, p_1: types.Any, p_2: types.Any) !c_int { return try invoker.invoke(c_int, 0x58CC181719256197, .{p_0, p_1, p_2}); } // 0x58CC181719256197  b323
    pub inline fn networkAreHandlesTheSame(gamer_handle_1: [*c]types.Any, gamer_handle_2: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57DBA049E110F217, .{gamer_handle_1, gamer_handle_2}); } // 0x57DBA049E110F217 0x45975AE3 b323
    pub inline fn networkIsHandleValid(gamer_handle: [*c]types.Any, gamer_handle_size: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6F79B93B0A8E4133, .{gamer_handle, gamer_handle_size}); } // 0x6F79B93B0A8E4133 0xF0996C6E b323
    pub inline fn networkGetPlayerFromGamerHandle(gamer_handle: [*c]types.Any) !types.Player { return try invoker.invoke(types.Player, 0xCE5F689CF5A0A49D, .{gamer_handle}); } // 0xCE5F689CF5A0A49D 0x2E96EF1E b323
    pub inline fn networkMemberIdFromGamerHandle(gamer_handle: [*c]types.Any) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xC82630132081BB6F, .{gamer_handle}); } // 0xC82630132081BB6F 0x62EF0A63 b323
    pub inline fn networkIsGamerInMySession(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0F10B05DDF8D16E9, .{gamer_handle}); } // 0x0F10B05DDF8D16E9 0x59127716 b323
    pub inline fn networkShowProfileUi(gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0x859ED1CEA343FCA8, .{gamer_handle}); } // 0x859ED1CEA343FCA8 0xF00A20B0 b323
    /// Returns the name of a given player. Returns "**Invalid**" if rlGamerInfo of the given player cannot be retrieved or the player doesn't exist.
    pub inline fn networkPlayerGetName(player: types.Player) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x7718D2E2060837D2, .{player}); } // 0x7718D2E2060837D2 0xCE48F260 b323
    /// Returns a string of the player's Rockstar Id.  \
    /// Takes a 24 char buffer. Returns the buffer or "**Invalid**" if rlGamerInfo of the given player cannot be retrieved or the player doesn't exist.
    pub inline fn networkPlayerGetUserid(player: types.Player, user_i_d: [*c]c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x4927FC39CD0869A0, .{player, user_i_d}); } // 0x4927FC39CD0869A0 0x4EC0D983 b323
    /// Checks if a specific value (BYTE) in CNetGamePlayer is nonzero. \
    /// Returns always false in Singleplayer.
    /// 
    /// No longer used for dev checks since first mods were released on PS3 & 360. \
    /// R* now checks with the IS_DLC_PRESENT native for the dlc hash 2532323046, \
    /// if that is present it will unlock dev stuff.
    pub inline fn networkPlayerIsRockstarDev(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x544ABDDA3B409B6D, .{player}); } // 0x544ABDDA3B409B6D 0xF6659045 b323
    pub inline fn networkPlayerIndexIsCheater(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x565E430DB3B05BEC, .{player}); } // 0x565E430DB3B05BEC 0xD265B049 b323
    pub inline fn networkEntityGetObjectId(entity: types.Entity) !c_int { return try invoker.invoke(c_int, 0x815F18AD865F057F, .{entity}); } // 0x815F18AD865F057F  b463
    /// I've had this return the player's ped handle sometimes, but also other random entities. \
    /// Whatever p0 is, it's at least not synced to other players. \
    /// At least not all the time, some p0 values actually output the same entity, (different handle of course, but same entity). \
    /// But another p0 value may return an entity for player x, but not for player y (it'll just return -1 even if the entity exists on both clients).
    /// 
    /// Returns an entity handle or -1, value changes based on p0's value.
    pub inline fn networkGetEntityFromObjectId(p_0: types.Any) !types.Entity { return try invoker.invoke(types.Entity, 0x37D5F739FD494675, .{p_0}); } // 0x37D5F739FD494675  b505
    pub inline fn networkIsInactiveProfile(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7E58745504313A2E, .{p_0}); } // 0x7E58745504313A2E 0x95481343 b323
    /// Returns the name from given friend gamer handle.
    pub inline fn networkLoadGamerDisplayName_(gamer_handle: [*c]types.Any) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x338ECE3637937BC2, .{gamer_handle}); } // 0x338ECE3637937BC2  b3258
    pub inline fn networkGetMaxFriends() !c_int { return try invoker.invoke(c_int, 0xAFEBB0D5D8F687D2, .{}); } // 0xAFEBB0D5D8F687D2 0x048171BC b323
    pub inline fn networkGetFriendCount() !c_int { return try invoker.invoke(c_int, 0x203F1CFD823B27A4, .{}); } // 0x203F1CFD823B27A4 0xA396ACDE b323
    pub inline fn networkGetFriendName(friend_index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xE11EBBB2A783FE8B, .{friend_index}); } // 0xE11EBBB2A783FE8B 0x97420B6D b323
    pub inline fn networkGetFriendDisplayName(friend_index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x4164F227D052E293, .{friend_index}); } // 0x4164F227D052E293  b323
    pub inline fn networkIsFriendOnline(name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x425A44533437B64D, .{name}); } // 0x425A44533437B64D 0xE0A42430 b323
    pub inline fn networkIsFriendHandleOnline(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x87EB7A3FFCB314DB, .{gamer_handle}); } // 0x87EB7A3FFCB314DB  b323
    /// In scripts R* calls 'NETWORK_GET_FRIEND_NAME' in this param.
    pub inline fn networkIsFriendInSameTitle(friend_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2EA9A3BEDF3F17B8, .{friend_name}); } // 0x2EA9A3BEDF3F17B8 0xC54365C2 b323
    pub inline fn networkIsFriendInMultiplayer(friend_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57005C18827F3A28, .{friend_name}); } // 0x57005C18827F3A28 0x400BDDD9 b323
    pub inline fn networkIsFriend(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1A24A179F9B31654, .{gamer_handle}); } // 0x1A24A179F9B31654 0x2DA4C282 b323
    /// This function is hard-coded to always return 0.
    pub inline fn networkIsPendingFriend(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0BE73DA6984A6E33, .{p_0}); } // 0x0BE73DA6984A6E33 0x5C85FF81 b323
    pub inline fn networkIsAddingFriend() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6EA101606F6E4D81, .{}); } // 0x6EA101606F6E4D81 0xBB7EC8C4 b323
    pub inline fn networkAddFriend(gamer_handle: [*c]types.Any, message: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8E02D73914064223, .{gamer_handle, message}); } // 0x8E02D73914064223 0x20E5B3EE b323
    pub inline fn networkIsFriendIndexOnline(friend_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBAD8F2A42B844821, .{friend_index}); } // 0xBAD8F2A42B844821 0x94AE7172 b323
    pub inline fn networkSetPlayerIsPassive(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1B857666604B1A74, .{toggle}); } // 0x1B857666604B1A74 0x76A9FEB6 b323
    pub inline fn networkGetPlayerOwnsWaypoint(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x82377B65E943F72D, .{player}); } // 0x82377B65E943F72D 0xB802B671 b323
    pub inline fn networkCanSetWaypoint() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC927EC229934AF60, .{}); } // 0xC927EC229934AF60 0x009E68F3 b323
    pub inline fn networkIgnoreRemoteWaypoints() !void { try invoker.invoke(void, 0x4C2A9FDC22377075, .{}); } // 0x4C2A9FDC22377075  b372
    /// communicationType: 0 = VOICE; 1 = TEXT_CHAT; 2 = TEXT_MESSAGE; 3 = EMAIL; 4 = USER_CONTENT; 5 = USER_TEXT
    pub inline fn networkDoesCommunicationGroupHavePermission_(communication_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDBDF80673BBA3D65, .{communication_type}); } // 0xDBDF80673BBA3D65  b3095
    pub inline fn networkDoesCommunicationGroupHaveSettingsEnabled_(communication_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x20C12650830A64EC, .{communication_type}); } // 0x20C12650830A64EC  b3570
    /// Returns communicationGroupFlag \
    /// communicationType: see 0xDBDF80673BBA3D65
    /// 
    /// enum eCommunicationGroupFlag \
    /// { \
    ///     COMMUNICATION_GROUP_LOCAL_PLAYER = 1 << 0,
    ///     COMMUNICATION_GROUP_FRIENDS = 1 << 1,
    ///     COMMUNICATION_GROUP_SMALL_CREW = 1 << 2,
    ///     COMMUNICATION_GROUP_LARGE_CREW = 1 << 3,
    ///     COMMUNICATION_GROUP_RECENT_PLAYER = 1 << 4,
    ///     COMMUNICATION_GROUP_SAME_SESSION = 1 << 5,
    ///     COMMUNICATION_GROUP_SAME_TEAM = 1 << 6,
    ///     COMMUNICATION_GROUP_INVALID = 1 << 7,
    /// };
    pub inline fn networkGetCommunicationGroupFlags_(communication_type: c_int) !c_int { return try invoker.invoke(c_int, 0x40DF02F371F40883, .{communication_type}); } // 0x40DF02F371F40883  b3095
    pub inline fn networkGetCommunicationGroupDefaultFlags_(communication_type: c_int) !c_int { return try invoker.invoke(c_int, 0x97F35B898D2D067F, .{communication_type}); } // 0x97F35B898D2D067F  b3570
    pub inline fn networkGetCommunicationGroupValue_(communication_type: c_int) !c_int { return try invoker.invoke(c_int, 0xBF66ACD9AE81A99F, .{communication_type}); } // 0xBF66ACD9AE81A99F  b3570
    /// communicationType: see 0xDBDF80673BBA3D65 \
    /// communicationGroupFlag: see 0x40DF02F371F40883
    pub inline fn networkSetCommunicationGroupFlags_(communication_type: c_int, communication_group_flag: c_int) !void { try invoker.invoke(void, 0xE549F846DE7D32D5, .{communication_type, communication_group_flag}); } // 0xE549F846DE7D32D5  b3095
    /// _NETWORK_HAS_P* \
    /// checkType 3 is similar as using 0x9F633448E4C73207
    pub inline fn networkHasPlayerPassedCheckType_(check_type: c_int, gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x62E29CDA11F9C230, .{check_type, gamer_handle}); } // 0x62E29CDA11F9C230  b3258
    pub inline fn networkIsPlayerOnBlocklist(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAD4326FCA30D62F8, .{gamer_handle}); } // 0xAD4326FCA30D62F8  b2802
    pub inline fn networkSetScriptAutomuted(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB309EBEA797E001F, .{p_0}); } // 0xB309EBEA797E001F 0x5C0AB2A9 b323
    pub inline fn networkHasAutomuteOverride() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x26F07DD83A5F7F98, .{}); } // 0x26F07DD83A5F7F98 0x9A176B6E b323
    pub inline fn networkHasHeadset() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE870F9F1F7B4F1FA, .{}); } // 0xE870F9F1F7B4F1FA 0xA7DC5657 b323
    pub inline fn networkSetLookAtTalkers(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x7D395EA61622E116, .{p_0}); } // 0x7D395EA61622E116 0x5C05B7E1 b323
    pub inline fn networkIsPushToTalkActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC0D2AF00BCC234CA, .{}); } // 0xC0D2AF00BCC234CA  b323
    pub inline fn networkGamerHasHeadset(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF2FD55CB574BCC55, .{gamer_handle}); } // 0xF2FD55CB574BCC55 0xD036DA4A b323
    pub inline fn networkIsGamerTalking(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71C33B22606CD88A, .{gamer_handle}); } // 0x71C33B22606CD88A 0x99B58DBC b323
    pub inline fn networkPermissionsHasGamerRecord(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x559EBF901A8C68E0, .{gamer_handle}); } // 0x559EBF901A8C68E0  b2699
    pub inline fn networkCanCommunicateWithGamer(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8F5D1AD832AEB06C, .{gamer_handle}); } // 0x8F5D1AD832AEB06C 0xD05EB7F6 b323
    pub inline fn networkCanTextChatWithGamer(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA150A4F065806B1F, .{gamer_handle}); } // 0xA150A4F065806B1F  b944
    pub inline fn networkIsGamerMutedByMe(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCE60DE011B6C7978, .{gamer_handle}); } // 0xCE60DE011B6C7978 0x001B4046 b323
    pub inline fn networkAmIMutedByGamer(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDF02A2C93F1F26DA, .{gamer_handle}); } // 0xDF02A2C93F1F26DA 0x7685B333 b323
    pub inline fn networkIsGamerBlockedByMe(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE944C4F5AF1B5883, .{gamer_handle}); } // 0xE944C4F5AF1B5883 0x3FDCC8D7 b323
    pub inline fn networkAmIBlockedByGamer(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x15337C7C268A27B2, .{gamer_handle}); } // 0x15337C7C268A27B2 0xD19B312C b323
    pub inline fn networkCanViewGamerUserContent(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB57A49545BA53CE7, .{gamer_handle}); } // 0xB57A49545BA53CE7  b323
    pub inline fn networkHasViewGamerUserContentResult(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCCA4318E1AB03F1F, .{gamer_handle}); } // 0xCCA4318E1AB03F1F  b323
    /// NETWORK_CAN_*
    pub inline fn networkCanTextFromGamerBeViewed_(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9F633448E4C73207, .{gamer_handle}); } // 0x9F633448E4C73207  b3258
    pub inline fn networkCanPlayMultiplayerWithGamer(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x07DD29D5E22763F1, .{gamer_handle}); } // 0x07DD29D5E22763F1  b323
    pub inline fn networkCanGamerPlayMultiplayerWithMe(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x135F9B7B7ADD2185, .{gamer_handle}); } // 0x135F9B7B7ADD2185  b323
    pub inline fn networkCanSendLocalInvite(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x021ABCBD98EC4320, .{gamer_handle}); } // 0x021ABCBD98EC4320  b2612
    pub inline fn networkCanReceiveLocalInvite(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x421E34C55F125964, .{gamer_handle}); } // 0x421E34C55F125964  b2612
    /// returns true if someone is screaming or talking in a microphone
    pub inline fn networkIsPlayerTalking(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x031E11F3D447647E, .{player}); } // 0x031E11F3D447647E 0xDA9FD9DB b323
    pub inline fn networkPlayerHasHeadset(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3FB99A8B08D18FD6, .{player}); } // 0x3FB99A8B08D18FD6 0x451FB6B6 b323
    pub inline fn networkIsPlayerMutedByMe(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8C71288AE68EDE39, .{player}); } // 0x8C71288AE68EDE39 0x7A21050E b323
    pub inline fn networkAmIMutedByPlayer(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9D6981DFC91A8604, .{player}); } // 0x9D6981DFC91A8604 0xE128F2B0 b323
    pub inline fn networkIsPlayerBlockedByMe(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57AF1F8E27483721, .{player}); } // 0x57AF1F8E27483721 0xAE4F4560 b323
    pub inline fn networkAmIBlockedByPlayer(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x87F395D957D4353D, .{player}); } // 0x87F395D957D4353D 0x953EF45E b323
    pub inline fn networkGetPlayerLoudness(player: types.Player) !f32 { return try invoker.invoke(f32, 0x21A1684A25C2867F, .{player}); } // 0x21A1684A25C2867F 0xF2F67014 b323
    pub inline fn networkSetTalkerProximity(value: f32) !void { try invoker.invoke(void, 0xCBF12D65F95AD686, .{value}); } // 0xCBF12D65F95AD686 0x67555C66 b323
    pub inline fn networkGetTalkerProximity() !f32 { return try invoker.invoke(f32, 0x84F0F13120B4E098, .{}); } // 0x84F0F13120B4E098 0x19991ADD b323
    pub inline fn networkSetVoiceActive(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBABEC9E69A91C57B, .{toggle}); } // 0xBABEC9E69A91C57B 0x8011247F b323
    pub inline fn networkRemainInGameChat(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xCFEB46DCD7D8D5EB, .{p_0}); } // 0xCFEB46DCD7D8D5EB 0x1A3EA6CD b323
    pub inline fn networkOverrideTransitionChat(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xAF66059A131AA269, .{p_0}); } // 0xAF66059A131AA269 0xCAB21090 b323
    pub inline fn networkSetTeamOnlyChat(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD5B4883AC32F24C3, .{toggle}); } // 0xD5B4883AC32F24C3 0x3813019A b323
    pub inline fn networkSetScriptControllingTeams(p_0: types.Any) !void { try invoker.invoke(void, 0x265559DA40B3F327, .{p_0}); } // 0x265559DA40B3F327  b573
    pub inline fn networkSetSameTeamAsLocalPlayer(p_0: types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4348BFDA56023A2F, .{p_0, p_1}); } // 0x4348BFDA56023A2F  b573
    pub inline fn networkOverrideTeamRestrictions(team: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6F697A66CE78674E, .{team, toggle}); } // 0x6F697A66CE78674E 0xC8CC9E75 b323
    pub inline fn networkSetOverrideSpectatorMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x70DA3BF8DACD3210, .{toggle}); } // 0x70DA3BF8DACD3210 0xA0FD42D3 b323
    pub inline fn networkSetOverrideTutorialSessionChat(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3C5C1E2C2FF814B1, .{toggle}); } // 0x3C5C1E2C2FF814B1 0xC9DDA85B b323
    pub inline fn networkSetProximityAffectsTeam(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9D7AFCBF21C51712, .{toggle}); } // 0x9D7AFCBF21C51712 0xE5219410 b323
    pub inline fn networkSetNoSpectatorChat(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF46A1E03E8755980, .{toggle}); } // 0xF46A1E03E8755980 0xD33AFF79 b323
    pub inline fn networkSetIgnoreSpectatorChatLimitsSameTeam(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6A5D89D7769A40D8, .{toggle}); } // 0x6A5D89D7769A40D8 0x4FFEFE43 b323
    /// Could possibly bypass being muted or automatically muted
    pub inline fn networkOverrideChatRestrictions(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3039AE5AD2C9C0C4, .{player, toggle}); } // 0x3039AE5AD2C9C0C4 0x74EE2D8B b323
    /// This is used alongside the native, \
    /// 'NETWORK_OVERRIDE_RECEIVE_RESTRICTIONS'. Read its description for more info.
    pub inline fn networkOverrideSendRestrictions(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x97DD4C5944CC2E6A, .{player, toggle}); } // 0x97DD4C5944CC2E6A 0x6C344AE3 b323
    pub inline fn networkOverrideSendRestrictionsAll(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x57B192B4D4AD23D5, .{toggle}); } // 0x57B192B4D4AD23D5 0x2F98B405 b323
    /// R* uses this to hear all player when spectating.  \
    /// It allows you to hear other online players when their chat is on none, crew and or friends
    pub inline fn networkOverrideReceiveRestrictions(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDDF73E2B1FEC5AB4, .{player, toggle}); } // 0xDDF73E2B1FEC5AB4 0x95F1C60D b323
    /// p0 is always false in scripts.
    pub inline fn networkOverrideReceiveRestrictionsAll(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0FF2862B61A58AF9, .{toggle}); } // 0x0FF2862B61A58AF9 0x1BCD3DDF b323
    pub inline fn networkSetVoiceChannel(channel: c_int) !void { try invoker.invoke(void, 0xEF6212C2EFEF1A23, .{channel}); } // 0xEF6212C2EFEF1A23 0x3974879F b323
    pub inline fn networkClearVoiceChannel() !void { try invoker.invoke(void, 0xE036A705F989E049, .{}); } // 0xE036A705F989E049 0x9ECF722A b323
    pub inline fn networkApplyVoiceProximityOverride(vec: types.Vector3) !void { try invoker.invoke(void, 0xDBD2056652689917, .{vec.x, vec.y, vec.z}); } // 0xDBD2056652689917 0xF1E84832 b323
    pub inline fn networkClearVoiceProximityOverride() !void { try invoker.invoke(void, 0xF03755696450470C, .{}); } // 0xF03755696450470C 0x7F9B9052 b323
    pub inline fn networkEnableVoiceBandwidthRestriction(player: types.Player) !void { try invoker.invoke(void, 0x5E3AA4CA2B6FB0EE, .{player}); } // 0x5E3AA4CA2B6FB0EE 0x7BBEA8CF b323
    pub inline fn networkDisableVoiceBandwidthRestriction(player: types.Player) !void { try invoker.invoke(void, 0xCA575C391FEA25CC, .{player}); } // 0xCA575C391FEA25CC 0xE797A4B6 b323
    /// NETWORK_GET_M[A-U]
    pub inline fn networkGetMuteCountForPlayer(p_0: types.Player, p_1: [*c]f32, p_2: [*c]f32) !void { try invoker.invoke(void, 0xADB57E5B663CCA8B, .{p_0, p_1, p_2}); } // 0xADB57E5B663CCA8B 0x92268BB5 b323
    pub inline fn networkSetSpectatorToNonSpectatorTextChat(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8EF52ACAECC51D9C, .{toggle}); } // 0x8EF52ACAECC51D9C  b1734
    /// Same as _IS_TEXT_CHAT_ACTIVE, except it does not check if the text chat HUD component is initialized, and therefore may crash.
    pub inline fn networkTextChatIsTyping() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5FCF4D7069B09026, .{}); } // 0x5FCF4D7069B09026  b323
    /// Starts a new singleplayer game (at the prologue).
    pub inline fn shutdownAndLaunchSinglePlayerGame() !void { try invoker.invoke(void, 0x593850C16A36B692, .{}); } // 0x593850C16A36B692 0x92B7351C b323
    /// In singleplayer this will re-load your game.
    /// 
    /// In FiveM / GTA:Online this disconnects you from the session, and starts loading single player, however you still remain connected to the server (only if you're the host, if you're not then you also (most likely) get disconnected from the server) and other players will not be able to join until you exit the game.
    /// 
    /// You might need to DoScreenFadeIn and ShutdownLoadingScreen otherwise you probably won't end up loading into SP at all.
    /// 
    /// Somewhat related note: opening the pause menu after loading into this 'singleplayer' mode crashes the game.
    pub inline fn shutdownAndLoadMostRecentSave() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9ECA15ADFE141431, .{}); } // 0x9ECA15ADFE141431  b505
    pub inline fn networkSetFriendlyFireOption(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF808475FA571D823, .{toggle}); } // 0xF808475FA571D823 0x6BAF95FA b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn networkSetRichPresence(p_0: c_int, p_1: c_int, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x1DCCACDCFC569362, .{p_0, p_1, p_2, p_3}); } // 0x1DCCACDCFC569362 0x932A6CED b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn networkSetRichPresenceString(p_0: c_int, text_label: [*c]const u8) !void { try invoker.invoke(void, 0x3E200C2BCF4164EB, .{p_0, text_label}); } // 0x3E200C2BCF4164EB 0x017E6777 b323
    pub inline fn networkGetTimeoutTime() !c_int { return try invoker.invoke(c_int, 0x5ED0356A0CE3A34F, .{}); } // 0x5ED0356A0CE3A34F 0xE1F86C6A b323
    /// p4 and p5 are always 0 in scripts
    pub inline fn networkLeavePedBehindBeforeWarp(player: types.Player, vec: types.Vector3, p_4: windows.BOOL, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x9769F811D1785B03, .{player, vec.x, vec.y, vec.z, p_4, p_5}); } // 0x9769F811D1785B03 0xBE6A30C3 b323
    pub inline fn networkLeavePedBehindBeforeCutscene(player: types.Player, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xBF22E0F32968E967, .{player, p_1}); } // 0xBF22E0F32968E967 0x22E03AD0 b323
    /// entity must be a valid entity; ped can be NULL
    pub inline fn removeAllStickyBombsFromEntity(entity: types.Entity, ped: types.Ped) !void { try invoker.invoke(void, 0x715135F4B82AC90D, .{entity, ped}); } // 0x715135F4B82AC90D 0xCEAE5AFC b323
    pub inline fn networkKeepEntityCollisionDisabledAfterAnimScene(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x17C9E241111A674D, .{p_0, p_1}); } // 0x17C9E241111A674D  b2060
    pub inline fn networkIsAnyPlayerNear(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E4C123D1C8A710E, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x2E4C123D1C8A710E  b505
    pub inline fn networkClanServiceIsValid() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x579CCED0265D4896, .{}); } // 0x579CCED0265D4896 0xF5F4BD95 b323
    pub inline fn networkClanPlayerIsActive(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB124B57F571D8F18, .{gamer_handle}); } // 0xB124B57F571D8F18 0xAB8319A3 b323
    /// bufferSize is 35 in the scripts.
    /// 
    /// bufferSize is the elementCount of p0(desc), sizeof(p0) == 280 == p1*8 == 35 * 8, p2(netHandle) is obtained from NETWORK::NETWORK_HANDLE_FROM_PLAYER.  And no, I can't explain why 35 * sizeof(int) == 280 and not 140, but I'll get back to you on that.
    /// 
    /// the answer is: because p0 an int64_t* / int64_t[35].  and FYI p2 is an int64_t[13]
    /// 
    /// https://pastebin.com/cSZniHak
    pub inline fn networkClanPlayerGetDesc(clan_desc: [*c]types.Any, buffer_size: c_int, gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEEE6EACBE8874FBA, .{clan_desc, buffer_size, gamer_handle}); } // 0xEEE6EACBE8874FBA 0x6EE4A282 b323
    /// bufferSize is 35 in the scripts.
    pub inline fn networkClanIsRockstarClan(clan_desc: [*c]types.Any, buffer_size: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7543BB439F63792B, .{clan_desc, buffer_size}); } // 0x7543BB439F63792B 0x54E79E9C b323
    /// bufferSize is 35 in the scripts.
    pub inline fn networkClanGetUiFormattedTag(clan_desc: [*c]types.Any, buffer_size: c_int, formatted_tag: [*c]u8) !void { try invoker.invoke(void, 0xF45352426FF3A4F0, .{clan_desc, buffer_size, formatted_tag}); } // 0xF45352426FF3A4F0 0xF633805A b323
    pub inline fn networkClanGetLocalMembershipsCount() !c_int { return try invoker.invoke(c_int, 0x1F471B79ACC90BEF, .{}); } // 0x1F471B79ACC90BEF 0x807B3450 b323
    pub inline fn networkClanGetMembershipDesc(member_desc: [*c]types.Any, p_1: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x48DE78AF2C8885B8, .{member_desc, p_1}); } // 0x48DE78AF2C8885B8 0x3369DD1F b323
    pub inline fn networkClanDownloadMembership(gamer_handle: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA989044E70010ABE, .{gamer_handle}); } // 0xA989044E70010ABE 0x8E8CB520 b323
    pub inline fn networkClanDownloadMembershipPending(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5B9E023DC6EBEDC0, .{p_0}); } // 0x5B9E023DC6EBEDC0 0x1FDB590F b323
    pub inline fn networkClanAnyDownloadMembershipPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB3F64A6A91432477, .{}); } // 0xB3F64A6A91432477 0x83ED8E08 b323
    pub inline fn networkClanRemoteMembershipsAreInCache(p_0: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBB6E6FEE99D866B2, .{p_0}); } // 0xBB6E6FEE99D866B2 0x40202867 b323
    pub inline fn networkClanGetMembershipCount(p_0: [*c]c_int) !c_int { return try invoker.invoke(c_int, 0xAAB11F6C4ADBC2C1, .{p_0}); } // 0xAAB11F6C4ADBC2C1 0x25924010 b323
    pub inline fn networkClanGetMembershipValid(p_0: [*c]c_int, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x48A59CF88D43DF0E, .{p_0, p_1}); } // 0x48A59CF88D43DF0E 0x48914F6A b323
    pub inline fn networkClanGetMembership(p_0: [*c]c_int, clan_membership: [*c]types.Any, p_2: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC8BC2011F67B3411, .{p_0, clan_membership, p_2}); } // 0xC8BC2011F67B3411 0xCDC4A590 b323
    pub inline fn networkClanJoin(clan_desc: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9FAAA4F4FC71F87F, .{clan_desc}); } // 0x9FAAA4F4FC71F87F 0x79C916C5 b323
    /// Only documented...
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn networkClanCrewinfoGetStringValue(anim_dict: [*c]const u8, anim_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x729E3401F0430686, .{anim_dict, anim_name}); } // 0x729E3401F0430686 0xBDA90BAC b323
    pub inline fn networkClanCrewinfoGetCrewranktitle(p_0: c_int, p_1: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2B51EDBEFC301339, .{p_0, p_1}); } // 0x2B51EDBEFC301339 0x8E952B12 b323
    pub inline fn networkClanHasCrewinfoMetadataBeenReceived() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC32EA7A2F6CA7557, .{}); } // 0xC32EA7A2F6CA7557 0x966C90FD b323
    pub inline fn networkClanGetEmblemTxdName(net_handle: [*c]types.Any, txd_name: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5835D9CD92E83184, .{net_handle, txd_name}); } // 0x5835D9CD92E83184 0xBA672146 b323
    pub inline fn networkClanRequestEmblem(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x13518FF1C6B28938, .{p_0}); } // 0x13518FF1C6B28938 0x7963FA4D b323
    pub inline fn networkClanIsEmblemReady(p_0: types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA134777FF7F33331, .{p_0, p_1}); } // 0xA134777FF7F33331 0x88B13CDC b323
    pub inline fn networkClanReleaseEmblem(p_0: types.Any) !void { try invoker.invoke(void, 0x113E6E3E50E286B0, .{p_0}); } // 0x113E6E3E50E286B0 0xD6E3D5EA b323
    pub inline fn networkGetPrimaryClanDataClear() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9AA46BADAD0E27ED, .{}); } // 0x9AA46BADAD0E27ED 0xE22445DA b323
    pub inline fn networkGetPrimaryClanDataCancel() !void { try invoker.invoke(void, 0x042E4B70B93E6054, .{}); } // 0x042E4B70B93E6054 0x455DDF5C b323
    pub inline fn networkGetPrimaryClanDataStart(p_0: [*c]types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCE86D8191B762107, .{p_0, p_1}); } // 0xCE86D8191B762107 0x89DB0EC7 b323
    pub inline fn networkGetPrimaryClanDataPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB5074DB804E28CE7, .{}); } // 0xB5074DB804E28CE7 0xA4EF02F3 b323
    pub inline fn networkGetPrimaryClanDataSuccess() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5B4F04F19376A0BA, .{}); } // 0x5B4F04F19376A0BA 0x068A054E b323
    pub inline fn networkGetPrimaryClanDataNew(p_0: [*c]types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC080FF658B2E41DA, .{p_0, p_1}); } // 0xC080FF658B2E41DA 0x9B8631EB b323
    /// Whether or not another player is allowed to take control of the entity
    pub inline fn setNetworkIdCanMigrate(net_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x299EEB23175895FC, .{net_id, toggle}); } // 0x299EEB23175895FC 0x47C8E5FF b323
    pub inline fn setNetworkIdExistsOnAllMachines(net_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE05E81A888FA63C8, .{net_id, toggle}); } // 0xE05E81A888FA63C8 0x68D486B2 b323
    pub inline fn setNetworkIdAlwaysExistsForPlayer(net_id: c_int, player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA8A024587329F36A, .{net_id, player, toggle}); } // 0xA8A024587329F36A 0x4D15FDB1 b323
    /// "No Reassign" in CPhysicalScriptGameStateDataNode
    pub inline fn setNetworkIdCanBeReassigned(net_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9D724B400A7E8FFC, .{net_id, toggle}); } // 0x9D724B400A7E8FFC  b2189
    pub inline fn networkSetEntityCanBlend(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD830567D88A1E873, .{entity, toggle}); } // 0xD830567D88A1E873 0xDE8C0DB8 b323
    pub inline fn networkSetObjectCanBlendWhenFixed(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0379DAF89BA09AA5, .{object, toggle}); } // 0x0379DAF89BA09AA5  b944
    /// if set to true other network players can't see it \
    /// if set to false other network player can see it \
    /// ========================================= \
    /// ^^ I attempted this by grabbing an object with GET_ENTITY_PLAYER_IS_FREE_AIMING_AT and setting this naive no matter the toggle he could still see it.
    /// 
    /// pc or last gen?
    /// 
    /// ^^ last-gen
    pub inline fn networkSetEntityOnlyExistsForParticipants(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF1CA12B18AEF5298, .{entity, toggle}); } // 0xF1CA12B18AEF5298 0x09CBC4B0 b323
    pub inline fn setNetworkIdVisibleInCutscene(net_id: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xA6928482543022B4, .{net_id, p_1, p_2}); } // 0xA6928482543022B4 0x199E75EF b323
    pub inline fn setNetworkIdVisibleInCutsceneHack(net_id: c_int, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x32EBD154CB6B8B99, .{net_id, p_1, p_2}); } // 0x32EBD154CB6B8B99  b505
    pub inline fn setNetworkIdVisibleInCutsceneRemainHack(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x76B3F29D3F967692, .{p_0, p_1, p_2}); } // 0x76B3F29D3F967692  b2189
    pub inline fn setNetworkCutsceneEntities(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAAA553E7DD28A457, .{toggle}); } // 0xAAA553E7DD28A457 0xFD0F7EDD b323
    /// Getter for SET_NETWORK_CUTSCENE_ENTITIES.
    pub inline fn areCutsceneEntitiesNetworked() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x66D6A5E9C511214A, .{}); } // 0x66D6A5E9C511214A  b2699
    pub inline fn setNetworkIdPassControlInTutorial(net_id: c_int, state: windows.BOOL) !void { try invoker.invoke(void, 0x3FA36981311FA4FF, .{net_id, state}); } // 0x3FA36981311FA4FF 0x00AE4E17 b323
    pub inline fn networkSetTutorialSpecialSession_(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x35AEB4AC7C73C6E1, .{toggle}); } // 0x35AEB4AC7C73C6E1  b3717
    pub inline fn networkIsSpecialTutorialSession_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4666CD7431DE98E2, .{}); } // 0x4666CD7431DE98E2  b3717
    pub inline fn isNetworkIdOwnedByParticipant(net_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA1607996431332DF, .{net_id}); } // 0xA1607996431332DF 0xEA5176C0 b323
    pub inline fn setRemotePlayerVisibleInCutscene(player: types.Player, locally_visible: windows.BOOL) !void { try invoker.invoke(void, 0x96320E6549DAE7B4, .{player, locally_visible}); } // 0x96320E6549DAE7B4  b2802
    pub inline fn setLocalPlayerVisibleInCutscene(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xD1065D68947E7B6E, .{p_0, p_1}); } // 0xD1065D68947E7B6E 0x59F3479B b323
    pub inline fn setLocalPlayerInvisibleLocally(b_include_players_vehicle: windows.BOOL) !void { try invoker.invoke(void, 0xE5F773C1A1D9D168, .{b_include_players_vehicle}); } // 0xE5F773C1A1D9D168 0x764F6222 b323
    pub inline fn setLocalPlayerVisibleLocally(b_include_players_vehicle: windows.BOOL) !void { try invoker.invoke(void, 0x7619364C82D3BF14, .{b_include_players_vehicle}); } // 0x7619364C82D3BF14 0x324B56DB b323
    pub inline fn setPlayerInvisibleLocally(player: types.Player, b_include_players_vehicle: windows.BOOL) !void { try invoker.invoke(void, 0x12B37D54667DB0B8, .{player, b_include_players_vehicle}); } // 0x12B37D54667DB0B8 0x18227209 b323
    pub inline fn setPlayerVisibleLocally(player: types.Player, b_include_players_vehicle: windows.BOOL) !void { try invoker.invoke(void, 0xFAA10F1FAFB11AF2, .{player, b_include_players_vehicle}); } // 0xFAA10F1FAFB11AF2 0xBA2BB4B4 b323
    /// Hardcoded to not work in SP.
    pub inline fn fadeOutLocalPlayer(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x416DBD4CD6ED8DD2, .{p_0}); } // 0x416DBD4CD6ED8DD2 0x8FA7CEBD b323
    /// normal - transition like when your coming out of LSC \
    /// slow - transition like when you walk into a mission
    ///  
    pub inline fn networkFadeOutEntity(entity: types.Entity, normal: windows.BOOL, slow: windows.BOOL) !void { try invoker.invoke(void, 0xDE564951F95E09ED, .{entity, normal, slow}); } // 0xDE564951F95E09ED 0x47EDEE56 b323
    /// state - 0 does 5 fades \
    /// state - 1 does 6 fades
    /// 
    /// p3: setting to 1 made vehicle fade in slower, probably "slow" as per NETWORK_FADE_OUT_ENTITY
    pub inline fn networkFadeInEntity(entity: types.Entity, state: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0x1F4ED342ACEFE62D, .{entity, state, p_2}); } // 0x1F4ED342ACEFE62D 0x9B9FCD02 b323
    pub inline fn networkIsPlayerFading(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x631DC5DFF4B110E3, .{player}); } // 0x631DC5DFF4B110E3 0x065C597B b323
    pub inline fn networkIsEntityFading(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x422F32CC7E56ABAD, .{entity}); } // 0x422F32CC7E56ABAD 0xB5087ACF b323
    pub inline fn isPlayerInCutscene(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE73092F4157CD126, .{player}); } // 0xE73092F4157CD126 0xE0A619BD b323
    pub inline fn setEntityVisibleInCutscene(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xE0031D3C8F36AB82, .{p_0, p_1, p_2}); } // 0xE0031D3C8F36AB82 0xDBFB067B b323
    /// Makes the provided entity visible for yourself for the current frame.
    pub inline fn setEntityLocallyInvisible(entity: types.Entity) !void { try invoker.invoke(void, 0xE135A9FF3F5D05D8, .{entity}); } // 0xE135A9FF3F5D05D8 0x51ADCC5F b323
    pub inline fn setEntityLocallyVisible(entity: types.Entity) !void { try invoker.invoke(void, 0x241E289B5C059EDC, .{entity}); } // 0x241E289B5C059EDC 0x235A57B3 b323
    pub inline fn isDamageTrackerActiveOnNetworkId(net_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6E192E33AD436366, .{net_i_d}); } // 0x6E192E33AD436366 0x597063BA b323
    pub inline fn activateDamageTrackerOnNetworkId(net_i_d: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD45B1FFCCD52FF19, .{net_i_d, toggle}); } // 0xD45B1FFCCD52FF19 0x95D07BA5 b323
    pub inline fn isDamageTrackerActiveOnPlayer(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB2092A1EAA7FD45F, .{player}); } // 0xB2092A1EAA7FD45F  b757
    pub inline fn activateDamageTrackerOnPlayer(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBEC0816FF5ACBCDA, .{player, toggle}); } // 0xBEC0816FF5ACBCDA  b757
    pub inline fn isSphereVisibleToAnotherMachine(p_0: f32, p_1: f32, p_2: f32, p_3: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD82CF8E64C8729D8, .{p_0, p_1, p_2, p_3}); } // 0xD82CF8E64C8729D8 0x23C5274E b323
    pub inline fn isSphereVisibleToPlayer(p_0: types.Any, p_1: f32, p_2: f32, p_3: f32, p_4: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDC3A310219E5DA62, .{p_0, p_1, p_2, p_3, p_4}); } // 0xDC3A310219E5DA62 0xE9FCFB32 b323
    pub inline fn reserveNetworkMissionObjects(amount: c_int) !void { try invoker.invoke(void, 0x4E5C93BD0C32FBF8, .{amount}); } // 0x4E5C93BD0C32FBF8 0x391DF4F3 b323
    pub inline fn reserveNetworkMissionPeds(amount: c_int) !void { try invoker.invoke(void, 0xB60FEBA45333D36F, .{amount}); } // 0xB60FEBA45333D36F 0x54998C37 b323
    pub inline fn reserveNetworkMissionVehicles(amount: c_int) !void { try invoker.invoke(void, 0x76B02E21ED27A469, .{amount}); } // 0x76B02E21ED27A469 0x5062875E b323
    pub inline fn reserveLocalNetworkMissionObjects(amount: c_int) !void { try invoker.invoke(void, 0x797F9C5E661D920E, .{amount}); } // 0x797F9C5E661D920E  b1290
    pub inline fn reserveLocalNetworkMissionPeds(amount: c_int) !void { try invoker.invoke(void, 0x2C8DF5D129595281, .{amount}); } // 0x2C8DF5D129595281  b1493
    pub inline fn reserveLocalNetworkMissionVehicles(amount: c_int) !void { try invoker.invoke(void, 0x42613035157E4208, .{amount}); } // 0x42613035157E4208  b1103
    pub inline fn canRegisterMissionObjects(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x800DD4721A8B008B, .{amount}); } // 0x800DD4721A8B008B 0x7F85DFDE b323
    pub inline fn canRegisterMissionPeds(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBCBF4FEF9FA5D781, .{amount}); } // 0xBCBF4FEF9FA5D781 0xCCAA5CE9 b323
    pub inline fn canRegisterMissionVehicles(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7277F1F2E085EE74, .{amount}); } // 0x7277F1F2E085EE74 0x818B6830 b323
    pub inline fn canRegisterMissionPickups(amount: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0A49D1CB6E34AF72, .{amount}); } // 0x0A49D1CB6E34AF72  b757
    pub inline fn canRegisterMissionDoors(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE16AA70CE9BEEDC3, .{p_0}); } // 0xE16AA70CE9BEEDC3  b877
    pub inline fn canRegisterMissionEntities(ped__amt: c_int, vehicle__amt: c_int, object__amt: c_int, pickup__amt: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x69778E7564BADE6D, .{ped__amt, vehicle__amt, object__amt, pickup__amt}); } // 0x69778E7564BADE6D 0x83794008 b323
    /// p0 appears to be for MP
    pub inline fn getNumReservedMissionObjects(p_0: windows.BOOL, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0xAA81B5F10BC43AC2, .{p_0, p_1}); } // 0xAA81B5F10BC43AC2 0x16A80CD6 b323
    /// p0 appears to be for MP
    pub inline fn getNumReservedMissionPeds(p_0: windows.BOOL, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x1F13D5AE5CB17E17, .{p_0, p_1}); } // 0x1F13D5AE5CB17E17 0x6C25975C b323
    /// p0 appears to be for MP
    pub inline fn getNumReservedMissionVehicles(p_0: windows.BOOL, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0xCF3A965906452031, .{p_0, p_1}); } // 0xCF3A965906452031 0xA9A308F3 b323
    pub inline fn getNumCreatedMissionObjects(p_0: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x12B6281B6C6706C0, .{p_0}); } // 0x12B6281B6C6706C0 0x603FA104 b323
    pub inline fn getNumCreatedMissionPeds(p_0: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xCB215C4B56A7FAE7, .{p_0}); } // 0xCB215C4B56A7FAE7 0xD8FEC4F8 b323
    pub inline fn getNumCreatedMissionVehicles(p_0: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x0CD9AB83489430EA, .{p_0}); } // 0x0CD9AB83489430EA 0x20527695 b323
    pub inline fn getReservedMissionEntitiesInArea(vec: types.Vector3, p_3: types.Any, out_1: [*c]types.Any, out_2: [*c]types.Any, out_3: [*c]types.Any) !void { try invoker.invoke(void, 0xE42D626EEC94E5D9, .{vec.x, vec.y, vec.z, p_3, out_1, out_2, out_3}); } // 0xE42D626EEC94E5D9  b1290
    pub inline fn getMaxNumNetworkObjects() !c_int { return try invoker.invoke(c_int, 0xC7BE335216B5EC7C, .{}); } // 0xC7BE335216B5EC7C 0x8687E285 b323
    pub inline fn getMaxNumNetworkPeds() !c_int { return try invoker.invoke(c_int, 0x0C1F7D49C39D2289, .{}); } // 0x0C1F7D49C39D2289 0x744AC008 b323
    pub inline fn getMaxNumNetworkVehicles() !c_int { return try invoker.invoke(c_int, 0x0AFCE529F69B21FF, .{}); } // 0x0AFCE529F69B21FF 0xC3A12135 b323
    pub inline fn getMaxNumNetworkPickups() !c_int { return try invoker.invoke(c_int, 0xA72835064DD63E4C, .{}); } // 0xA72835064DD63E4C 0x6A036061 b323
    pub inline fn networkSetObjectScopeDistance(object: types.Object, range: f32) !void { try invoker.invoke(void, 0xBA7F0B77D80A4EB7, .{object, range}); } // 0xBA7F0B77D80A4EB7  b372
    pub inline fn networkAllowCloningWhileInTutorial(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x0F1A4B45B7693B95, .{p_0, p_1}); } // 0x0F1A4B45B7693B95  b2189
    /// A value between 1.0 and 5.0
    pub inline fn networkSetTaskCutsceneInscopeMultipler(multiplier: f32) !void { try invoker.invoke(void, 0xC6FCEE21C6FCEE21, .{multiplier}); } // 0xC6FCEE21C6FCEE21  b2545
    pub inline fn networkHideEntityInTutorialSession_(net_handle: c_int, hide: windows.BOOL) !void { try invoker.invoke(void, 0xCFE359CCCFE359CC, .{net_handle, hide}); } // 0xCFE359CCCFE359CC  b3258
    pub inline fn getNetworkTime() !c_int { return try invoker.invoke(c_int, 0x7A5487FE9FAA6B48, .{}); } // 0x7A5487FE9FAA6B48 0x998103C2 b323
    /// Returns the same value as GET_NETWORK_TIME in freemode, but as opposed to `GET_NETWORK_TIME` it always gets the most recent time, instead of once per tick. \
    /// Could be used for benchmarking since it can return times in ticks.
    pub inline fn getNetworkTimeAccurate() !c_int { return try invoker.invoke(c_int, 0x89023FBBF9200E9F, .{}); } // 0x89023FBBF9200E9F 0x98AA48E5 b323
    pub inline fn hasNetworkTimeStarted() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x46718ACEEDEAFC84, .{}); } // 0x46718ACEEDEAFC84 0x4538C4A2 b323
    /// Adds the first argument to the second.
    pub inline fn getTimeOffset(time_a: c_int, time_b: c_int) !c_int { return try invoker.invoke(c_int, 0x017008CCDAD48503, .{time_a, time_b}); } // 0x017008CCDAD48503 0x2E079AE6 b323
    /// Subtracts the second argument from the first, then returns whether the result is negative.
    pub inline fn isTimeLessThan(time_a: c_int, time_b: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCB2CF5148012C8D0, .{time_a, time_b}); } // 0xCB2CF5148012C8D0 0x50EF8FC6 b323
    /// Subtracts the first argument from the second, then returns whether the result is negative.
    pub inline fn isTimeMoreThan(time_a: c_int, time_b: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDE350F8651E4346C, .{time_a, time_b}); } // 0xDE350F8651E4346C 0xBBB6DF61 b323
    /// Returns true if the two times are equal; otherwise returns false.
    pub inline fn isTimeEqualTo(time_a: c_int, time_b: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF5BC95857BD6D512, .{time_a, time_b}); } // 0xF5BC95857BD6D512 0x8B4D1C06 b323
    /// Subtracts the second argument from the first.
    pub inline fn getTimeDifference(time_a: c_int, time_b: c_int) !c_int { return try invoker.invoke(c_int, 0xA2C6FC031D46FFF0, .{time_a, time_b}); } // 0xA2C6FC031D46FFF0 0x5666A837 b323
    pub inline fn getTimeAsString(time: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x9E23B1777A927DAD, .{time}); } // 0x9E23B1777A927DAD 0x8218944E b323
    /// Same as GET_CLOUD_TIME_AS_INT but returns the value as a hex string (%I64X).
    pub inline fn getCloudTimeAsString() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xF12E6CD06C73D69E, .{}); } // 0xF12E6CD06C73D69E  b1103
    /// Returns POSIX timestamp, an int representing the cloud time.
    pub inline fn getCloudTimeAsInt() !c_int { return try invoker.invoke(c_int, 0x9A73240B49945C76, .{}); } // 0x9A73240B49945C76 0xF2FDF2E0 b323
    /// Takes the specified time and writes it to the structure specified in the second argument.
    /// 
    /// struct date_time \
    /// { \
    ///     int year;
    ///     int PADDING1;
    ///     int month;
    ///     int PADDING2;
    ///     int day;
    ///     int PADDING3;
    ///     int hour;
    ///     int PADDING4;
    ///     int minute;
    ///     int PADDING5;
    ///     int second;
    ///     int PADDING6;
    /// };
    pub inline fn convertPosixTime(posix_time: c_int, time_structure: [*c]types.Any) !void { try invoker.invoke(void, 0xAC97AF97FA68E5D5, .{posix_time, time_structure}); } // 0xAC97AF97FA68E5D5 0xBB7CCE49 b323
    pub inline fn networkSetInSpectatorMode(toggle: windows.BOOL, player_ped: types.Ped) !void { try invoker.invoke(void, 0x423DE3854BB50894, .{toggle, player_ped}); } // 0x423DE3854BB50894 0x5C4C8458 b323
    pub inline fn networkSetInSpectatorModeExtended(toggle: windows.BOOL, player_ped: types.Ped, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x419594E137637120, .{toggle, player_ped, p_2}); } // 0x419594E137637120 0x54058F5F b323
    pub inline fn networkSetInFreeCamMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFC18DB55AE19E046, .{toggle}); } // 0xFC18DB55AE19E046 0xA7E36020 b323
    pub inline fn networkSetAntagonisticToPlayer(toggle: windows.BOOL, player: types.Player) !void { try invoker.invoke(void, 0x5C707A667DF8B9FA, .{toggle, player}); } // 0x5C707A667DF8B9FA 0x64235620 b323
    pub inline fn networkIsInSpectatorMode() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x048746E388762E11, .{}); } // 0x048746E388762E11 0x3EAD9DB8 b323
    pub inline fn networkSetInMpCutscene(p_0: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x9CA5DE655269FEC4, .{p_0, p_1}); } // 0x9CA5DE655269FEC4 0x8434CB43 b323
    pub inline fn networkIsInMpCutscene() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6CC27C9FA2040220, .{}); } // 0x6CC27C9FA2040220 0x4BB33316 b323
    pub inline fn networkIsPlayerInMpCutscene(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x63F9EE203C3619F2, .{player}); } // 0x63F9EE203C3619F2 0x56F961E4 b323
    pub inline fn networkHideProjectileInCutscene() !void { try invoker.invoke(void, 0xFAC18E7356BD3210, .{}); } // 0xFAC18E7356BD3210  b1180
    pub inline fn setNetworkVehicleRespotTimer(net_id: c_int, time: c_int, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xEC51713AB6EC36E8, .{net_id, time, p_2, p_3}); } // 0xEC51713AB6EC36E8 0x2C30912D b323
    pub inline fn isNetworkVehicleRunningRespotTimer(network_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDD7CEF5B3A4DA8A6, .{network_i_d}); } // 0xDD7CEF5B3A4DA8A6  b2802
    pub inline fn setNetworkVehicleAsGhost(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6274C4712850841E, .{vehicle, toggle}); } // 0x6274C4712850841E 0xEA235081 b323
    /// rage::netBlenderLinInterp::GetPositionMaxForUpdateLevel
    pub inline fn setNetworkVehicleMaxPositionDeltaMultiplier(vehicle: types.Vehicle, multiplier: f32) !void { try invoker.invoke(void, 0xA2A707979FE754DC, .{vehicle, multiplier}); } // 0xA2A707979FE754DC  b877
    /// Enables a periodic ShapeTest within the NetBlender and invokes rage::netBlenderLinInterp::GoStraightToTarget (or some functional wrapper).
    pub inline fn setNetworkEnableHighSpeedEdgeFallDetection(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x838DA0936A24ED4D, .{vehicle, toggle}); } // 0x838DA0936A24ED4D  b944
    pub inline fn setLocalPlayerAsGhost(toggle: windows.BOOL, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x5FFE9B4144F9712F, .{toggle, p_1}); } // 0x5FFE9B4144F9712F  b323
    pub inline fn isEntityAGhost(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x21D04D7BC538C146, .{entity}); } // 0x21D04D7BC538C146  b323
    pub inline fn setNonParticipantsOfThisScriptAsGhosts(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x13F1FCB111B820B0, .{p_0}); } // 0x13F1FCB111B820B0  b877
    /// Enables ghosting between specific players
    pub inline fn setRemotePlayerAsGhost(player: types.Player, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xA7C511FA1C5BDA38, .{player, p_1}); } // 0xA7C511FA1C5BDA38  b463
    /// Must be a value between 1 and 254
    pub inline fn setGhostAlpha(alpha: c_int) !void { try invoker.invoke(void, 0x658500AE6D723A7E, .{alpha}); } // 0x658500AE6D723A7E  b791
    /// Resets the entity ghost alpha to the default value (128)
    pub inline fn resetGhostAlpha() !void { try invoker.invoke(void, 0x17330EBF2F2124A8, .{}); } // 0x17330EBF2F2124A8  b791
    pub inline fn setEntityGhostedForGhostPlayers(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4BA166079D658ED4, .{entity, toggle}); } // 0x4BA166079D658ED4  b944
    pub inline fn setInvertGhosting(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xD7B6C73CAD419BCF, .{p_0}); } // 0xD7B6C73CAD419BCF  b944
    pub inline fn isEntityInGhostCollision(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7EF7649B64D7FF10, .{entity}); } // 0x7EF7649B64D7FF10  b944
    /// reportData includes mc, ceo, yacht and licenceplate names
    pub inline fn setFreemodeReportData_(gamer_handle: [*c]types.Any, report_data: [*c]types.Any) !void { try invoker.invoke(void, 0x527803286A8B6C81, .{gamer_handle, report_data}); } // 0x527803286A8B6C81  b3258
    pub inline fn isObjectReassignmentInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x28123C8B056CC8AA, .{}); } // 0x28123C8B056CC8AA  b3274
    pub inline fn usePlayerColourInsteadOfTeamColour(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x77758139EC9B66C7, .{toggle}); } // 0x77758139EC9B66C7 0x4DD46DAE b323
    pub inline fn networkCreateSynchronisedScene(vec: types.Vector3, rot__: types.Vector3, rotation_order: c_int, use_occlusion_portal: windows.BOOL, looped: windows.BOOL, p_9: f32, anim_time: f32, p_1_1: f32) !c_int { return try invoker.invoke(c_int, 0x7CD6BC4C2BBDD526, .{vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, rotation_order, use_occlusion_portal, looped, p_9, anim_time, p_1_1}); } // 0x7CD6BC4C2BBDD526 0xB06FE3FE b323
    pub inline fn networkAddPedToSynchronisedScene(ped: types.Ped, net_scene: c_int, anim_dict: [*c]const u8, animn_name: [*c]const u8, speed: f32, speed_multiplier: f32, duration: c_int, flag: c_int, playback_rate: f32, p_9: types.Any) !void { try invoker.invoke(void, 0x742A637471BCECD9, .{ped, net_scene, anim_dict, animn_name, speed, speed_multiplier, duration, flag, playback_rate, p_9}); } // 0x742A637471BCECD9 0xB386713E b323
    pub inline fn networkAddPedToSynchronisedSceneWithIk(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: types.Any) !void { try invoker.invoke(void, 0xA5EAFE473E45C442, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9}); } // 0xA5EAFE473E45C442  b1290
    pub inline fn networkAddEntityToSynchronisedScene(entity: types.Entity, net_scene: c_int, anim_dict: [*c]const u8, anim_name: [*c]const u8, speed: f32, speed_mulitiplier: f32, flag: c_int) !void { try invoker.invoke(void, 0xF2404D68CBC855FA, .{entity, net_scene, anim_dict, anim_name, speed, speed_mulitiplier, flag}); } // 0xF2404D68CBC855FA 0x10DD636C b323
    /// Similar structure as NETWORK_ADD_ENTITY_TO_SYNCHRONISED_SCENE but it includes this time a hash. \
    /// In casino_slots it is used one time in a synced scene involving a ped and the slot machine?
    pub inline fn networkAddMapEntityToSynchronisedScene(net_scene: c_int, model_hash: types.Hash, vec: types.Vector3, p_5: f32, p_6: [*c]const u8, p_7: f32, p_8: f32, flags: c_int) !void { try invoker.invoke(void, 0x45F35C0EDC33B03B, .{net_scene, model_hash, vec.x, vec.y, vec.z, p_5, p_6, p_7, p_8, flags}); } // 0x45F35C0EDC33B03B  b1734
    pub inline fn networkAddSynchronisedSceneCamera(net_scene: c_int, anim_dict: [*c]const u8, anim_name: [*c]const u8) !void { try invoker.invoke(void, 0xCF8BD3B0BD6D42D7, .{net_scene, anim_dict, anim_name}); } // 0xCF8BD3B0BD6D42D7 0xBFFE8B5C b323
    pub inline fn networkAttachSynchronisedSceneToEntity(net_scene: c_int, entity: types.Entity, bone: c_int) !void { try invoker.invoke(void, 0x478DCBD2A98B705A, .{net_scene, entity, bone}); } // 0x478DCBD2A98B705A 0x3FE5B222 b323
    pub inline fn networkStartSynchronisedScene(net_scene: c_int) !void { try invoker.invoke(void, 0x9A1B3FCDB36C8697, .{net_scene}); } // 0x9A1B3FCDB36C8697 0xA9DFDC40 b323
    pub inline fn networkStopSynchronisedScene(net_scene: c_int) !void { try invoker.invoke(void, 0xC254481A4574CB2F, .{net_scene}); } // 0xC254481A4574CB2F 0x97B1CDF6 b323
    pub inline fn networkGetLocalSceneFromNetworkId(net_id: c_int) !c_int { return try invoker.invoke(c_int, 0x02C40BF885C567B6, .{net_id}); } // 0x02C40BF885C567B6 0x16AED87B b323
    pub inline fn networkForceLocalUseOfSyncedSceneCamera(net_scene: c_int) !void { try invoker.invoke(void, 0xC9B43A33D09CADA7, .{net_scene}); } // 0xC9B43A33D09CADA7 0xC3AA2EC7 b323
    pub inline fn networkAllowRemoteSyncedSceneLocalPlayerRequests(p_0: types.Any) !void { try invoker.invoke(void, 0x144DA052257AE7D8, .{p_0}); } // 0x144DA052257AE7D8  b1103
    /// p0 is always 0. p1 is pointing to a global.
    pub inline fn networkFindLargestBunchOfPlayers(p_0: c_int, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFB1F9381E80FA13F, .{p_0, p_1}); } // 0xFB1F9381E80FA13F 0x0679CE71 b323
    /// One of the first things it does is get the players ped. \
    /// Then it calls a function that is used in some tasks and ped based functions. \
    /// p5, p6, p7 is another coordinate (or zero), often related to `GET_BLIP_COORDS, in the decompiled scripts.
    pub inline fn networkStartRespawnSearchForPlayer(player: types.Player, vec: types.Vector3, radius: f32, p_5: f32, p_6: f32, p_7: f32, flags: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5A6FFA2433E2F14C, .{player, vec.x, vec.y, vec.z, radius, p_5, p_6, p_7, flags}); } // 0x5A6FFA2433E2F14C 0xC62E77B3 b323
    /// p8, p9, p10 is another coordinate, or zero, often related to `GET_BLIP_COORDS in the decompiled scripts.
    pub inline fn networkStartRespawnSearchInAngledAreaForPlayer(player: types.Player, vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, p_8: f32, p_9: f32, p_1_0: f32, flags: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4BA92A18502BCA61, .{player, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, p_8, p_9, p_1_0, flags}); } // 0x4BA92A18502BCA61 0x74D6B13C b323
    pub inline fn networkQueryRespawnResults(p_0: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0x3C891A251567DFCE, .{p_0}); } // 0x3C891A251567DFCE 0x90700C7D b323
    pub inline fn networkCancelRespawnSearch() !void { try invoker.invoke(void, 0xFB8F2A6F3DF08CBE, .{}); } // 0xFB8F2A6F3DF08CBE 0x44BFB619 b323
    /// Based on scripts such as in freemode.c how they call their vars vVar and fVar the 2nd and 3rd param it a Vector3 and Float, but the first is based on get_random_int_in_range..
    pub inline fn networkGetRespawnResult(random_int: c_int, coordinates: [*c]types.Vector3, heading: [*c]f32) !void { try invoker.invoke(void, 0x371EA43692861CF1, .{random_int, coordinates, heading}); } // 0x371EA43692861CF1 0xDDFE9FBC b323
    pub inline fn networkGetRespawnResultFlags(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x6C34F1208B8923FD, .{p_0}); } // 0x6C34F1208B8923FD 0x03287FD2 b323
    pub inline fn networkStartSoloTutorialSession() !void { try invoker.invoke(void, 0x17E0198B3882C2CB, .{}); } // 0x17E0198B3882C2CB 0x408A9436 b323
    /// teamId must be < 3, instanceId must be < 64
    pub inline fn networkAllowGangToJoinTutorialSession(team_id: c_int, instance_id: c_int) !void { try invoker.invoke(void, 0xFB680D403909DC70, .{team_id, instance_id}); } // 0xFB680D403909DC70 0xFFB2ADA1 b323
    pub inline fn networkEndTutorialSession() !void { try invoker.invoke(void, 0xD0AFAFF5A51D72F7, .{}); } // 0xD0AFAFF5A51D72F7 0xBA57E53E b323
    pub inline fn networkIsInTutorialSession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xADA24309FE08DACF, .{}); } // 0xADA24309FE08DACF 0x34DD7B28 b323
    pub inline fn networkWaitingPopClearTutorialSession() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB37E4E6A2388CA7B, .{}); } // 0xB37E4E6A2388CA7B 0x755A2B3E b323
    pub inline fn networkIsTutorialSessionChangePending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x35F0B98A8387274D, .{}); } // 0x35F0B98A8387274D 0xA003C40B b323
    pub inline fn networkGetPlayerTutorialSessionInstance(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x3B39236746714134, .{player}); } // 0x3B39236746714134 0x5E1020CC b323
    pub inline fn networkArePlayersInSameTutorialSession(player: types.Player, index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9DE986FC9A87C474, .{player, index}); } // 0x9DE986FC9A87C474 0xE66A0B40 b323
    pub inline fn networkBlockProxyMigrationBetweenTutorialSessions(p_0: types.Any) !void { try invoker.invoke(void, 0xFEA7A352DDB34D52, .{p_0}); } // 0xFEA7A352DDB34D52  b2545
    pub inline fn networkConcealPlayer(player: types.Player, toggle: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xBBDF066252829606, .{player, toggle, p_2}); } // 0xBBDF066252829606 0x72052DB3 b323
    pub inline fn networkIsPlayerConcealed(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x919B3C98ED8292F9, .{player}); } // 0x919B3C98ED8292F9 0xB0313590 b323
    pub inline fn networkConcealEntity(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1632BE0AC1E62876, .{entity, toggle}); } // 0x1632BE0AC1E62876  b877
    /// Note: This only works for vehicles, which appears to be a bug (since the setter _does_ work for every entity type and the name is 99% correct).
    pub inline fn networkIsEntityConcealed(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71302EC70689052A, .{entity}); } // 0x71302EC70689052A  b877
    /// Works in Singleplayer too. \
    /// Passing wrong data (e.g. hours above 23) will cause the game to crash.
    pub inline fn networkOverrideClockTime(hours: c_int, minutes: c_int, seconds: c_int) !void { try invoker.invoke(void, 0xE679E3E06E363892, .{hours, minutes, seconds}); } // 0xE679E3E06E363892 0xC077BCD6 b323
    pub inline fn networkOverrideClockRate(ms: c_int) !void { try invoker.invoke(void, 0x42BF1D2E723B6D7E, .{ms}); } // 0x42BF1D2E723B6D7E  b2189
    pub inline fn networkClearClockTimeOverride() !void { try invoker.invoke(void, 0xD972DF67326F966E, .{}); } // 0xD972DF67326F966E 0xC4AEAF49 b323
    pub inline fn networkClearClockSyncTimeOverride_(start_global_transition: windows.BOOL, transition_time: c_int) !void { try invoker.invoke(void, 0x0C1BF187985B15C8, .{start_global_transition, transition_time}); } // 0x0C1BF187985B15C8  b3717
    /// Does nothing in final builds.
    pub inline fn networkSyncClockTimeOverride() !void { try invoker.invoke(void, 0xCBD02360C5E16871, .{}); } // 0xCBD02360C5E16871  b3570
    pub inline fn networkIsClockTimeOverridden() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD7C95D322FF57522, .{}); } // 0xD7C95D322FF57522 0x2465296D b323
    pub inline fn networkAddEntityArea(vec_1__: types.Vector3, vec_2__: types.Vector3) !c_int { return try invoker.invoke(c_int, 0x494C8FB299290269, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x494C8FB299290269 0x51030E5B b323
    /// To remove, see: NETWORK_REMOVE_ENTITY_AREA \
    /// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
    pub inline fn networkAddEntityAngledArea(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32) !c_int { return try invoker.invoke(c_int, 0x376C6375BA60293A, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width}); } // 0x376C6375BA60293A 0xCD69BEA1 b323
    pub inline fn networkAddClientEntityArea(vec_1__: types.Vector3, vec_2__: types.Vector3) !c_int { return try invoker.invoke(c_int, 0x25B99872D588A101, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x25B99872D588A101 0x4C2C2B12 b323
    pub inline fn networkAddClientEntityAngledArea(vec_1__: types.Vector3, vec_2__: types.Vector3, radius: f32) !c_int { return try invoker.invoke(c_int, 0x2B1C623823DB0D9D, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, radius}); } // 0x2B1C623823DB0D9D  b1103
    pub inline fn networkRemoveEntityArea(area_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x93CF869BAA0C4874, .{area_handle}); } // 0x93CF869BAA0C4874 0xEAB97F25 b323
    pub inline fn networkEntityAreaDoesExist(area_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE64A3CA08DFA37A9, .{area_handle}); } // 0xE64A3CA08DFA37A9 0x69956127 b323
    pub inline fn networkEntityAreaHaveAllReplied(area_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4DF7CFFF471A7FB1, .{area_handle}); } // 0x4DF7CFFF471A7FB1 0xCB1CD6D3 b323
    pub inline fn networkEntityAreaIsOccupied(area_handle: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4A2D4E8BF4265B0F, .{area_handle}); } // 0x4A2D4E8BF4265B0F 0xC6D53AA0 b323
    pub inline fn networkUseHighPrecisionBlending(net_i_d: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2B1813ABA29016C5, .{net_i_d, toggle}); } // 0x2B1813ABA29016C5 0x155465EE b323
    pub inline fn networkSetCustomArenaBallParams(net_id: c_int) !void { try invoker.invoke(void, 0xA6FCECCF4721D679, .{net_id}); } // 0xA6FCECCF4721D679  b1604
    pub inline fn networkEntityUseHighPrecisionRotation(net_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x95BAF97C82464629, .{net_id, toggle}); } // 0x95BAF97C82464629  b1604
    pub inline fn networkRequestCloudBackgroundScripts() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x924426BFFD82E915, .{}); } // 0x924426BFFD82E915 0x98EFB921 b323
    pub inline fn networkIsCloudBackgroundScriptRequestPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8132C0EB8B2B3293, .{}); } // 0x8132C0EB8B2B3293 0x20AB933A b323
    pub inline fn networkRequestCloudTunables() !void { try invoker.invoke(void, 0x42FB3B532D526E6C, .{}); } // 0x42FB3B532D526E6C 0xD760CAD5 b323
    pub inline fn networkIsTunableCloudRequestPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0467C11ED88B7D28, .{}); } // 0x0467C11ED88B7D28 0x47978D7F b323
    /// Actually returns the version (TUNABLE_VERSION)
    pub inline fn networkGetTunableCloudCrc() !c_int { return try invoker.invoke(c_int, 0x10BD227A753B0D84, .{}); } // 0x10BD227A753B0D84 0x231CFD12 b323
    /// Sets up tunable contexts for _NETWORK_GET_TUNABLES_REGISTRATION_{BOOL|INT|FLOAT}
    pub inline fn networkSetTunablesRegistrationContexts_(tunable_context_data: [*c]types.Any) !void { try invoker.invoke(void, 0x014A73449675121D, .{tunable_context_data}); } // 0x014A73449675121D  b3258
    /// Clears tunable contexts that were set up using _NETWORK_SET_TUNABLES_REGISTRATION_CONTEXTS
    pub inline fn networkClearTunablesRegistrationContexts_() !void { try invoker.invoke(void, 0x0C87C83C8950432B, .{}); } // 0x0C87C83C8950432B  b3258
    /// Checks if the given tunable exists and returns its value. Otherwise returns defaultValue. \
    /// Possible tunable contexts must first be set up using _NETWORK_SET_TUNABLES_REGISTRATION_CONTEXTS.
    pub inline fn networkGetTunablesRegistrationBool_(tunable_name: types.Hash, default_value: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB327CF1B8C2C0EA3, .{tunable_name, default_value}); } // 0xB327CF1B8C2C0EA3  b3258
    /// Checks if the given tunable exists and returns its value. Otherwise returns defaultValue. \
    /// Possible tunable contexts must first be set up using _NETWORK_SET_TUNABLES_REGISTRATION_CONTEXTS.
    pub inline fn networkGetTunablesRegistrationInt_(tunable_name: types.Hash, default_value: c_int) !c_int { return try invoker.invoke(c_int, 0x0D94071E55F4C9CE, .{tunable_name, default_value}); } // 0x0D94071E55F4C9CE  b3258
    /// Checks if the given tunable exists and returns its value. Otherwise returns defaultValue. \
    /// Possible tunable contexts must first be set up using _NETWORK_SET_TUNABLES_REGISTRATION_CONTEXTS.
    pub inline fn networkGetTunablesRegistrationFloat_(tunable_name: types.Hash, default_value: f32) !f32 { return try invoker.invoke(f32, 0x367E5E33E7F0DD1A, .{tunable_name, default_value}); } // 0x367E5E33E7F0DD1A  b3258
    pub inline fn networkDoesTunableExist(tunable_context: [*c]const u8, tunable_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x85E5F8B9B898B20A, .{tunable_context, tunable_name}); } // 0x85E5F8B9B898B20A 0x9FCE9C9A b323
    pub inline fn networkAccessTunableInt(tunable_context: [*c]const u8, tunable_name: [*c]const u8, value: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8BE1146DFD5D4468, .{tunable_context, tunable_name, value}); } // 0x8BE1146DFD5D4468 0xE4B3726A b323
    pub inline fn networkAccessTunableFloat(tunable_context: [*c]const u8, tunable_name: [*c]const u8, value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE5608CA7BC163A5F, .{tunable_context, tunable_name, value}); } // 0xE5608CA7BC163A5F 0x41E8912A b323
    pub inline fn networkAccessTunableBool(tunable_context: [*c]const u8, tunable_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAA6A47A573ABB75A, .{tunable_context, tunable_name}); } // 0xAA6A47A573ABB75A 0x8A04E1FE b323
    pub inline fn networkDoesTunableExistHash(tunable_context: types.Hash, tunable_name: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE4E53E1419D81127, .{tunable_context, tunable_name}); } // 0xE4E53E1419D81127 0x25915CB9 b323
    pub inline fn networkAccessTunableModificationDetectionClear() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFAFC23AEE23868DB, .{}); } // 0xFAFC23AEE23868DB  b393
    pub inline fn networkAccessTunableIntHash(tunable_context: types.Hash, tunable_name: types.Hash, value: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x40FCE03E50E8DBE8, .{tunable_context, tunable_name, value}); } // 0x40FCE03E50E8DBE8 0xB2E83B75 b323
    pub inline fn networkAccessTunableIntModificationDetectionRegistrationHash(context_hash: types.Hash, name_hash: types.Hash, value: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3A8B55FDA4C8DDEF, .{context_hash, name_hash, value}); } // 0x3A8B55FDA4C8DDEF  b393
    pub inline fn networkAccessTunableFloatHash(tunable_context: types.Hash, tunable_name: types.Hash, value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x972BC203BBC4C4D5, .{tunable_context, tunable_name, value}); } // 0x972BC203BBC4C4D5 0x3972551F b323
    pub inline fn networkAccessTunableFloatModificationDetectionRegistrationHash(context_hash: types.Hash, name_hash: types.Hash, value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1950DAE9848A4739, .{context_hash, name_hash, value}); } // 0x1950DAE9848A4739  b393
    pub inline fn networkAccessTunableBoolHash(tunable_context: types.Hash, tunable_name: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEA16B69D93D71A45, .{tunable_context, tunable_name}); } // 0xEA16B69D93D71A45 0x18867C61 b323
    pub inline fn networkAccessTunableBoolModificationDetectionRegistrationHash(context_hash: types.Hash, name_hash: types.Hash, value: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x697F508861875B42, .{context_hash, name_hash, value}); } // 0x697F508861875B42  b393
    /// Returns defaultValue if the tunable doesn't exist.
    pub inline fn networkTryAccessTunableBoolHash(tunable_context: types.Hash, tunable_name: types.Hash, default_value: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC7420099936CE286, .{tunable_context, tunable_name, default_value}); } // 0xC7420099936CE286 0x8AFE3D90 b323
    /// Return the content modifier id (the tunables context if you want) of a specific content.
    /// 
    /// It takes the content hash (which is the mission id hash), and return the content modifier id, used as the tunables context.
    /// 
    /// The mission id can be found on the Social club, for example, 'socialclub.rockstargames.com/games/gtav/jobs/job/A8M6Bz8MLEC5xngvDCzGwA'
    /// 
    /// 'A8M6Bz8MLEC5xngvDCzGwA' is the mission id, so the game hash this and use it as the parameter for this native.
    /// 
    pub inline fn networkGetContentModifierListId(content_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x187382F8A3E0A6C3, .{content_hash}); } // 0x187382F8A3E0A6C3 0xA78571CA b323
    pub inline fn networkGetBoneIdOfFatalHit() !c_int { return try invoker.invoke(c_int, 0x7DB53B37A2F211A0, .{}); } // 0x7DB53B37A2F211A0 0x053BB329 b323
    pub inline fn networkResetBodyTracker() !void { try invoker.invoke(void, 0x72433699B4E6DD64, .{}); } // 0x72433699B4E6DD64 0x3914463F b323
    pub inline fn networkGetNumberBodyTrackerHits() !c_int { return try invoker.invoke(c_int, 0xD38C4A6D047C019D, .{}); } // 0xD38C4A6D047C019D 0x17CBC608 b323
    pub inline fn networkHasBoneBeenHitByKiller(bone_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E0BF682CC778D49, .{bone_index}); } // 0x2E0BF682CC778D49 0xBFAA349B b323
    pub inline fn networkSetAttributeDamageToPlayer(ped: types.Ped, player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0EDE326D47CD0F3E, .{ped, player}); } // 0x0EDE326D47CD0F3E 0xBEB7281A b323
    /// Allows vehicle wheels to be destructible even when the vehicle entity is invincible.
    pub inline fn networkTriggerDamageEventForZeroDamage(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x890E2C5ABED7236D, .{entity, toggle}); } // 0x890E2C5ABED7236D  b1365
    pub inline fn networkTriggerDamageEventForZeroPedDamage_(entity: types.Entity, trigger: windows.BOOL) !void { try invoker.invoke(void, 0xE9D0244ACBEE1BC4, .{entity, trigger}); } // 0xE9D0244ACBEE1BC4  b3258
    pub inline fn networkTriggerDamageEventForZeroWeaponHash(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x38B7C51AB1EDC7D8, .{entity, toggle}); } // 0x38B7C51AB1EDC7D8  b1734
    pub inline fn networkSetNoLongerNeeded(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3FC795691834481D, .{entity, toggle}); } // 0x3FC795691834481D  b1868
    /// In the console script dumps, this is only referenced once.  \
    /// NETWORK::NETWORK_EXPLODE_VEHICLE(vehicle, 1, 0, 0);
    /// 
    /// ^^^^^ That must be PC script dumps? In X360 Script Dumps it is reference a few times with 2 differences in the parameters. \
    /// Which as you see below is 1, 0, 0 + 1, 1, 0 + 1, 0, and a *param?
    /// 
    /// am_plane_takedown.c  \
    /// network_explode_vehicle(net_to_veh(Local_40.imm_2), 1, 1, 0);
    /// 
    /// armenian2.c  \
    /// network_explode_vehicle(Local_80[6 <2>], 1, 0, 0);
    /// 
    /// fm_horde_controler.c \
    /// network_explode_vehicle(net_to_veh(*uParam0), 1, 0, *uParam0);
    /// 
    /// fm_mission_controller.c, has 6 hits so not going to list them.
    /// 
    /// Side note, setting the first parameter to 0 seems to mute sound or so?
    /// 
    /// Seems it's like ADD_EXPLOSION, etc. the first 2 params. The 3rd atm no need to worry since it always seems to be 0.
    /// 
    pub inline fn networkExplodeVehicle(vehicle: types.Vehicle, is_audible: windows.BOOL, is_invisible: windows.BOOL, net_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x301A42153C9AD707, .{vehicle, is_audible, is_invisible, net_id}); } // 0x301A42153C9AD707 0x0E1B38AE b323
    pub inline fn networkExplodeHeli(vehicle: types.Vehicle, is_audible: windows.BOOL, is_invisible: windows.BOOL, net_id: c_int) !void { try invoker.invoke(void, 0x2A5E0621DD815A9A, .{vehicle, is_audible, is_invisible, net_id}); } // 0x2A5E0621DD815A9A 0x955B31BF b463
    pub inline fn networkUseLogarithmicBlendingThisFrame(entity: types.Entity) !void { try invoker.invoke(void, 0xCD71A4ECAB22709E, .{entity}); } // 0xCD71A4ECAB22709E 0xBC54371B b323
    pub inline fn networkOverrideCoordsAndHeading(entity: types.Entity, vec: types.Vector3, heading: f32) !void { try invoker.invoke(void, 0xA7E30DE9272B6D49, .{entity, vec.x, vec.y, vec.z, heading}); } // 0xA7E30DE9272B6D49 0x644141C5 b323
    pub inline fn networkEnableExtraVehicleOrientationBlendChecks(net_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE6717E652B8C8D8A, .{net_id, toggle}); } // 0xE6717E652B8C8D8A  b617
    pub inline fn networkDisableProximityMigration(net_i_d: c_int) !void { try invoker.invoke(void, 0x407091CF6037118E, .{net_i_d}); } // 0x407091CF6037118E 0x9F82917F b323
    /// p0 in the decompiled scripts is always the stat mesh_texblend * 0.07 to int
    pub inline fn networkSetPlayerMentalState(p_0: c_int) !void { try invoker.invoke(void, 0x367EF5E2F439B4C6, .{p_0}); } // 0x367EF5E2F439B4C6 0x53C9563C b323
    pub inline fn networkSetMinimumRankForMission(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x94538037EE44F5CF, .{p_0}); } // 0x94538037EE44F5CF 0x6B97075B b323
    pub inline fn networkCacheLocalPlayerHeadBlendData() !void { try invoker.invoke(void, 0xBD0BE0BFC927EAC1, .{}); } // 0xBD0BE0BFC927EAC1 0x94AB35A9 b323
    pub inline fn networkHasCachedPlayerHeadBlendData(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x237D5336A9A54108, .{player}); } // 0x237D5336A9A54108 0x7B2A0337 b323
    pub inline fn networkApplyCachedPlayerHeadBlendData(ped: types.Ped, player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x99B72C7ABDE5C910, .{ped, player}); } // 0x99B72C7ABDE5C910 0x99F58A07 b323
    pub inline fn networkSetIgnoreVehicleRammedByNonVehicle_(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x67F7C81C1395672A, .{toggle}); } // 0x67F7C81C1395672A  b3717
    pub inline fn getNumCommerceItems() !c_int { return try invoker.invoke(c_int, 0xF2EAC213D5EA0623, .{}); } // 0xF2EAC213D5EA0623 0x965EA007 b323
    pub inline fn isCommerceDataValid() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEA14EEF5B7CD2C30, .{}); } // 0xEA14EEF5B7CD2C30 0xEEFC8A55 b323
    /// Does nothing (it's a nullsub).
    pub inline fn triggerCommerceDataFetch(p_0: types.Any) !void { try invoker.invoke(void, 0xB606E6CC59664972, .{p_0}); } // 0xB606E6CC59664972 0x866D1B67 b323
    pub inline fn isCommerceDataFetchInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1D4DC17C38FEAFF0, .{}); } // 0x1D4DC17C38FEAFF0 0xED4A272F b323
    pub inline fn getCommerceItemId(index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x662635855957C411, .{index}); } // 0x662635855957C411 0x4ACF110C b323
    pub inline fn getCommerceItemName(index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xB4271092CA7EDF48, .{index}); } // 0xB4271092CA7EDF48 0x1AA3A0D5 b323
    pub inline fn getCommerceProductPrice(index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xCA94551B50B4932C, .{index}); } // 0xCA94551B50B4932C 0x37877757 b323
    pub inline fn getCommerceItemNumCats(index: c_int) !c_int { return try invoker.invoke(c_int, 0x2A7776C709904AB0, .{index}); } // 0x2A7776C709904AB0 0x1CF89DA5 b323
    /// index2 is unused
    pub inline fn getCommerceItemCat(index: c_int, index_2: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x6F44CBF56D79FAC0, .{index, index_2}); } // 0x6F44CBF56D79FAC0 0x16E53875 b323
    pub inline fn openCommerceStore(p_0: [*c]const u8, p_1: [*c]const u8, p_2: c_int) !void { try invoker.invoke(void, 0x58C21165F6545892, .{p_0, p_1, p_2}); } // 0x58C21165F6545892 0x365C50EE b323
    pub inline fn isCommerceStoreOpen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2EAC52B4019E2782, .{}); } // 0x2EAC52B4019E2782 0x25E2DBA9 b323
    /// Access to the store for shark cards etc...
    pub inline fn setStoreEnabled(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9641A9FF718E9C5E, .{toggle}); } // 0x9641A9FF718E9C5E 0xC1F6443B b323
    pub inline fn requestCommerceItemImage(index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA2F952104FC6DD4B, .{index}); } // 0xA2F952104FC6DD4B 0x1FDC75DC b323
    pub inline fn releaseAllCommerceItemImages() !void { try invoker.invoke(void, 0x72D0706CD6CCDB58, .{}); } // 0x72D0706CD6CCDB58 0xCA7A0A49 b323
    pub inline fn getCommerceItemTexturename(index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x722F5D28B61C5EA8, .{index}); } // 0x722F5D28B61C5EA8 0x44A58B0A b323
    pub inline fn isStoreAvailableToUser() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x883D79C4071E18B3, .{}); } // 0x883D79C4071E18B3 0xD32FA11F b323
    pub inline fn delayMpStoreOpen() !void { try invoker.invoke(void, 0x265635150FB0D82E, .{}); } // 0x265635150FB0D82E 0xA7FA70AE b323
    pub inline fn resetStoreNetworkGameTracking() !void { try invoker.invoke(void, 0x444C4525ECE0A4B9, .{}); } // 0x444C4525ECE0A4B9 0xCC7DCE24 b323
    pub inline fn isUserOldEnoughToAccessStore() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x59328EB08C5CEB2B, .{}); } // 0x59328EB08C5CEB2B 0x70F6D3AD b323
    pub inline fn setLastViewedShopItem(p_0: types.Hash, p_1: c_int, p_2: types.Hash) !void { try invoker.invoke(void, 0xFAE628F1E9ADB239, .{p_0, p_1, p_2}); } // 0xFAE628F1E9ADB239 0xD59A822B b323
    /// Checks some commerce stuff
    pub inline fn getUserPremiumAccess() !c_int { return try invoker.invoke(c_int, 0x754615490A029508, .{}); } // 0x754615490A029508  b1290
    /// Checks some commerce stuff
    pub inline fn getUserStarterAccess() !c_int { return try invoker.invoke(c_int, 0x155467ACA0F55705, .{}); } // 0x155467ACA0F55705  b1290
    pub inline fn cloudDeleteMemberFile(p_0: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0xC64DED7EF0D2FE37, .{p_0}); } // 0xC64DED7EF0D2FE37 0x2B7B57B3 b323
    pub inline fn cloudHasRequestCompleted(request_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C61B39930D045DA, .{request_id}); } // 0x4C61B39930D045DA 0xBAF52DD8 b323
    pub inline fn cloudDidRequestSucceed(request_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3A3D5568AF297CD5, .{request_id}); } // 0x3A3D5568AF297CD5 0x9B9AFFF1 b323
    /// Downloads prod.cloud.rockstargames.com/titles/gta5/[platform]/check.json
    pub inline fn cloudCheckAvailability() !void { try invoker.invoke(void, 0x4F18196C8D38768D, .{}); } // 0x4F18196C8D38768D 0xC38E9DB0 b323
    pub inline fn cloudIsCheckingAvailability() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC7ABAC5DE675EE3B, .{}); } // 0xC7ABAC5DE675EE3B 0x32A4EB22 b323
    pub inline fn cloudGetAvailabilityCheckResult() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0B0CC10720653F3B, .{}); } // 0x0B0CC10720653F3B 0x9262744C b323
    /// This function is hard-coded to always return 0.
    pub inline fn getContentToLoadType() !c_int { return try invoker.invoke(c_int, 0x8B0C2964BA471961, .{}); } // 0x8B0C2964BA471961  b323
    /// This function is hard-coded to always return 0.
    pub inline fn getIsLaunchFromLiveArea() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x88B588B41FF7868E, .{}); } // 0x88B588B41FF7868E  b323
    /// This function is hard-coded to always return 0.
    pub inline fn getIsLiveAreaLaunchWithContent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x67FC09BC554A75E5, .{}); } // 0x67FC09BC554A75E5  b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn clearServiceEventArguments() !void { try invoker.invoke(void, 0x966DD84FB6A46017, .{}); } // 0x966DD84FB6A46017  b323
    pub inline fn ugcCopyContent(p_0: [*c]types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x152D90E4C1B4738A, .{p_0, p_1}); } // 0x152D90E4C1B4738A 0x08243B79 b323
    pub inline fn ugcIsCreating() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9FEDF86898F100E9, .{}); } // 0x9FEDF86898F100E9 0x798D6C27 b323
    pub inline fn ugcHasCreateFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5E24341A7F92A74B, .{}); } // 0x5E24341A7F92A74B 0xE69E8D0D b323
    pub inline fn ugcDidCreateSucceed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x24E4E51FC16305F9, .{}); } // 0x24E4E51FC16305F9 0x742075FE b323
    pub inline fn ugcGetCreateResult() !c_int { return try invoker.invoke(c_int, 0xFBC5E768C7A77A6A, .{}); } // 0xFBC5E768C7A77A6A 0xCE569932 b323
    pub inline fn ugcGetCreateContentId() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xC55A0B40FFB1ED23, .{}); } // 0xC55A0B40FFB1ED23 0x82146BE9 b323
    pub inline fn ugcClearCreateResult() !void { try invoker.invoke(void, 0x17440AA15D1D3739, .{}); } // 0x17440AA15D1D3739 0x133FF2D5 b323
    pub inline fn ugcQueryMyContent(p_0: types.Any, p_1: types.Any, p_2: [*c]types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9BF438815F5D96EA, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x9BF438815F5D96EA 0xCBA7242F b323
    pub inline fn ugcQueryByCategory(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: [*c]const u8, p_4: types.Any, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x692D58DF40657E8C, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x692D58DF40657E8C  b323
    pub inline fn ugcQueryByContentId(content_id: [*c]const u8, latest_version: windows.BOOL, content_type_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x158EC424F35EC469, .{content_id, latest_version, content_type_name}); } // 0x158EC424F35EC469 0xDED82A6E b323
    pub inline fn ugcQueryByContentIds(data: [*c]types.Any, count: c_int, latest_version: windows.BOOL, content_type_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC7397A83F7A2A462, .{data, count, latest_version, content_type_name}); } // 0xC7397A83F7A2A462 0x47B3C35E b323
    pub inline fn ugcQueryMostRecentlyCreatedContent(offset: c_int, count: c_int, content_type_name: [*c]const u8, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6D4CB481FAC835E8, .{offset, count, content_type_name, p_3}); } // 0x6D4CB481FAC835E8 0x40CF0783 b323
    pub inline fn ugcGetBookmarkedContent(p_0: types.Any, p_1: types.Any, p_2: [*c]const u8, p_3: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD5A4B59980401588, .{p_0, p_1, p_2, p_3}); } // 0xD5A4B59980401588 0x4609D596 b323
    pub inline fn ugcGetMyContent(p_0: types.Any, p_1: types.Any, p_2: [*c]const u8, p_3: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3195F8DD0D531052, .{p_0, p_1, p_2, p_3}); } // 0x3195F8DD0D531052 0x4C2C0D1F b323
    pub inline fn ugcGetFriendContent(p_0: types.Any, p_1: types.Any, p_2: [*c]const u8, p_3: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF9E1CCAE8BA4C281, .{p_0, p_1, p_2, p_3}); } // 0xF9E1CCAE8BA4C281 0x9EFBD5D1 b323
    pub inline fn ugcGetCrewContent(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: [*c]const u8, p_4: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9F6E2821885CAEE2, .{p_0, p_1, p_2, p_3, p_4}); } // 0x9F6E2821885CAEE2 0xA6D8B798 b323
    pub inline fn ugcGetGetByCategory(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: [*c]const u8, p_4: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x678BB03C1A3BD51E, .{p_0, p_1, p_2, p_3, p_4}); } // 0x678BB03C1A3BD51E 0x67E74842 b323
    pub inline fn ugcGetGetByContentId(content_id: [*c]const u8, content_type_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x815E5E3073DA1D67, .{content_id, content_type_name}); } // 0x815E5E3073DA1D67 0xE123C7AC b323
    pub inline fn ugcGetGetByContentIds(data: [*c]types.Any, data_count: c_int, content_type_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB8322EEB38BE7C26, .{data, data_count, content_type_name}); } // 0xB8322EEB38BE7C26 0x22C33603 b323
    pub inline fn ugcGetMostRecentlyCreatedContent(p_0: types.Any, p_1: types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA7862BC5ED1DFD7E, .{p_0, p_1, p_2, p_3}); } // 0xA7862BC5ED1DFD7E 0x37F5BD93 b323
    pub inline fn ugcGetMostRecentlyPlayedContent(p_0: types.Any, p_1: types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x97A770BEEF227E2B, .{p_0, p_1, p_2, p_3}); } // 0x97A770BEEF227E2B 0x1CFB3F51 b323
    pub inline fn ugcGetTopRatedContent(p_0: types.Any, p_1: types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5324A0E3E4CE3570, .{p_0, p_1, p_2, p_3}); } // 0x5324A0E3E4CE3570 0x87D1E6BD b323
    pub inline fn ugcCancelQuery() !void { try invoker.invoke(void, 0xE9B99B6853181409, .{}); } // 0xE9B99B6853181409 0x021D5A94 b323
    pub inline fn ugcIsGetting() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD53ACDBEF24A46E8, .{}); } // 0xD53ACDBEF24A46E8 0x4908A514 b323
    pub inline fn ugcHasGetFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x02ADA21EA2F6918F, .{}); } // 0x02ADA21EA2F6918F 0x50296140 b323
    pub inline fn ugcDidGetSucceed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x941E5306BCD7C2C7, .{}); } // 0x941E5306BCD7C2C7 0x3970B0DA b323
    pub inline fn ugcWasQueryForceCancelled() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC87E740D9F3872CC, .{}); } // 0xC87E740D9F3872CC 0xC1487110 b323
    pub inline fn ugcGetQueryResult() !c_int { return try invoker.invoke(c_int, 0xEDF7F927136C224B, .{}); } // 0xEDF7F927136C224B 0xCC2356E3 b323
    pub inline fn ugcGetContentNum() !c_int { return try invoker.invoke(c_int, 0xE0A6138401BCB837, .{}); } // 0xE0A6138401BCB837 0x2DE69817 b323
    pub inline fn ugcGetContentTotal() !c_int { return try invoker.invoke(c_int, 0x769951E2455E2EB5, .{}); } // 0x769951E2455E2EB5 0x81BD8D3B b323
    pub inline fn ugcGetContentHash() !types.Hash { return try invoker.invoke(types.Hash, 0x3A17A27D75C74887, .{}); } // 0x3A17A27D75C74887 0x8E1D8F78 b323
    pub inline fn ugcClearQueryResults() !void { try invoker.invoke(void, 0xBA96394A0EECFA65, .{}); } // 0xBA96394A0EECFA65 0x0D35DD93 b323
    pub inline fn ugcGetContentUserId(p_0: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xCD67AD041A394C9C, .{p_0}); } // 0xCD67AD041A394C9C 0x8F3137E6 b323
    pub inline fn ugcGetContentCreatorGamerHandle(p_0: c_int, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x584770794D758C18, .{p_0, p_1}); } // 0x584770794D758C18  b323
    pub inline fn ugcGetContentCreatedByLocalPlayer(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8C8D2739BA44AF0F, .{p_0}); } // 0x8C8D2739BA44AF0F  b323
    pub inline fn ugcGetContentUserName(p_0: types.Any) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x703F12425ECA8BF5, .{p_0}); } // 0x703F12425ECA8BF5 0xB9137BA7 b323
    pub inline fn ugcGetContentIsUsingScNickname(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAEAB987727C5A8A4, .{p_0}); } // 0xAEAB987727C5A8A4 0x9FEEAA9C b323
    pub inline fn ugcGetContentCategory(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0xA7BAB11E7C9C6C5A, .{p_0}); } // 0xA7BAB11E7C9C6C5A 0x5E8A7559 b323
    /// Return the mission id of a job.
    pub inline fn ugcGetContentId(p_0: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x55AA95F481D694D2, .{p_0}); } // 0x55AA95F481D694D2 0x331AEABF b323
    /// Return the root content id of a job.
    pub inline fn ugcGetRootContentId(p_0: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xC0173D6BFF4E0348, .{p_0}); } // 0xC0173D6BFF4E0348 0x0E5E8E5C b323
    pub inline fn ugcGetContentName(p_0: types.Any) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xBF09786A7FCAB582, .{p_0}); } // 0xBF09786A7FCAB582 0xA5A0C695 b323
    pub inline fn ugcGetContentDescription(index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x4A56710BAB5C4DB4, .{index}); } // 0x4A56710BAB5C4DB4  b3407
    pub inline fn ugcGetContentDescriptionHash(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x7CF0448787B23758, .{p_0}); } // 0x7CF0448787B23758 0x91534C6E b323
    pub inline fn ugcGetContentPath(p_0: c_int, p_1: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xBAF6BABF9E7CCC13, .{p_0, p_1}); } // 0xBAF6BABF9E7CCC13 0x744A9EA5 b323
    pub inline fn ugcGetContentUpdatedDate(p_0: types.Any, p_1: [*c]types.Any) !void { try invoker.invoke(void, 0xCFD115B373C0DF63, .{p_0, p_1}); } // 0xCFD115B373C0DF63 0xA19A238D b323
    pub inline fn ugcGetContentFileVersion(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x37025B27D9B658B1, .{p_0, p_1}); } // 0x37025B27D9B658B1 0xFF7D44E6 b323
    pub inline fn ugcGetContentHasLoResPhoto(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1D610EB0FEA716D9, .{p_0}); } // 0x1D610EB0FEA716D9  b323
    pub inline fn ugcGetContentHasHiResPhoto(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7FCC39C46C3C03BD, .{p_0}); } // 0x7FCC39C46C3C03BD  b323
    pub inline fn ugcGetContentLanguage(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x32DD916F3F7C9672, .{p_0}); } // 0x32DD916F3F7C9672 0xA2C5BD9D b323
    pub inline fn ugcGetContentIsPublished(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3054F114121C21EA, .{p_0}); } // 0x3054F114121C21EA 0xA850DDE1 b323
    pub inline fn ugcGetContentIsVerified(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA9240A96C74CCA13, .{p_0}); } // 0xA9240A96C74CCA13 0x8F6754AE b323
    pub inline fn ugcGetContentRating(p_0: types.Any, p_1: types.Any) !f32 { return try invoker.invoke(f32, 0x1ACCFBA3D8DAB2EE, .{p_0, p_1}); } // 0x1ACCFBA3D8DAB2EE 0x1E34953F b323
    pub inline fn ugcGetContentRatingCount(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x759299C5BB31D2A9, .{p_0, p_1}); } // 0x759299C5BB31D2A9 0x771FE190 b323
    pub inline fn ugcGetContentRatingPositiveCount(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x87E5C46C187FE0AE, .{p_0, p_1}); } // 0x87E5C46C187FE0AE 0x3276D9D3 b323
    pub inline fn ugcGetContentRatingNegativeCount(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x4E548C0D7AE39FF9, .{p_0, p_1}); } // 0x4E548C0D7AE39FF9 0x41A0FB02 b323
    pub inline fn ugcGetContentHasPlayerRecord(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x70EA8DA57840F9BE, .{p_0}); } // 0x70EA8DA57840F9BE 0x11DC0F27 b323
    pub inline fn ugcGetContentHasPlayerBookmarked(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x993CBE59D350D225, .{p_0}); } // 0x993CBE59D350D225 0x0DEB3F5A b323
    pub inline fn ugcRequestContentDataFromIndex(p_0: c_int, p_1: c_int) !c_int { return try invoker.invoke(c_int, 0x171DF6A0C07FB3DC, .{p_0, p_1}); } // 0x171DF6A0C07FB3DC 0x84315226 b323
    pub inline fn ugcRequestContentDataFromParams(content_type_name: [*c]const u8, content_id: [*c]const u8, p_2: c_int, p_3: c_int, p_4: c_int) !c_int { return try invoker.invoke(c_int, 0x7FD2990AF016795E, .{content_type_name, content_id, p_2, p_3, p_4}); } // 0x7FD2990AF016795E 0x38FC2EEB b323
    pub inline fn ugcRequestCachedDescription(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x5E0165278F6339EE, .{p_0}); } // 0x5E0165278F6339EE 0x1C4F9FDB b323
    pub inline fn ugcIsDescriptionRequestInProgress(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2D5DC831176D0114, .{p_0}); } // 0x2D5DC831176D0114 0xA69AE16C b323
    pub inline fn ugcHasDescriptionRequestFinished(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEBFA8D50ADDC54C4, .{p_0}); } // 0xEBFA8D50ADDC54C4 0xF50BC67A b323
    pub inline fn ugcDidDescriptionRequestSucceed(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x162C23CA83ED0A62, .{p_0}); } // 0x162C23CA83ED0A62 0xB3BBD241 b323
    pub inline fn ugcGetCachedDescription(p_0: types.Any, p_1: types.Any) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x40F7E66472DF3E5C, .{p_0, p_1}); } // 0x40F7E66472DF3E5C 0x70A2845C b323
    pub inline fn ugcReleaseCachedDescription(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5A34CD9C3C5BEC44, .{p_0}); } // 0x5A34CD9C3C5BEC44 0x346B506C b323
    pub inline fn ugcReleaseAllCachedDescriptions() !void { try invoker.invoke(void, 0x68103E2247887242, .{}); } // 0x68103E2247887242 0x0095DB71 b323
    pub inline fn ugcHasPermissionToWrite() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC33E7CBC06EC1A8D, .{}); } // 0xC33E7CBC06EC1A8D  b3095
    pub inline fn ugcPublish(content_id: [*c]const u8, base_content_id: [*c]const u8, content_type_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1DE0F5F50D723CAA, .{content_id, base_content_id, content_type_name}); } // 0x1DE0F5F50D723CAA 0xAD334B40 b323
    pub inline fn ugcSetBookmarked(content_id: [*c]const u8, bookmarked: windows.BOOL, content_type_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x274A1519DFC1094F, .{content_id, bookmarked, content_type_name}); } // 0x274A1519DFC1094F 0x980D45D7 b323
    pub inline fn ugcSetDeleted(p_0: [*c]types.Any, p_1: windows.BOOL, p_2: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD05D1A6C74DA3498, .{p_0, p_1, p_2}); } // 0xD05D1A6C74DA3498 0x48CCC328 b323
    pub inline fn ugcIsModifying() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x45E816772E93A9DB, .{}); } // 0x45E816772E93A9DB 0x8E664EFD b323
    pub inline fn ugcHasModifyFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x299EF3C576773506, .{}); } // 0x299EF3C576773506 0x611E0BE2 b323
    pub inline fn ugcDidModifySucceed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x793FF272D5B365F4, .{}); } // 0x793FF272D5B365F4 0xF0211AC1 b323
    pub inline fn ugcGetModifyResult() !c_int { return try invoker.invoke(c_int, 0x5A0A3D1A186A5508, .{}); } // 0x5A0A3D1A186A5508 0x1F0DD8AF b323
    pub inline fn ugcClearModifyResult() !void { try invoker.invoke(void, 0xA1E5E0204A6FCC70, .{}); } // 0xA1E5E0204A6FCC70 0x405ECA16 b323
    pub inline fn ugcGetCreatorsByUserId(p_0: [*c]types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB746D20B17F2A229, .{p_0, p_1}); } // 0xB746D20B17F2A229 0x9567392B b323
    pub inline fn ugcHasQueryCreatorsFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x63B406D7884BFA95, .{}); } // 0x63B406D7884BFA95 0xF79FFF3C b323
    pub inline fn ugcDidQueryCreatorsSucceed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4D02279C83BE69FE, .{}); } // 0x4D02279C83BE69FE 0xA7F3F82B b323
    pub inline fn ugcGetCreatorNum() !c_int { return try invoker.invoke(c_int, 0x597F8DBA9B206FC7, .{}); } // 0x597F8DBA9B206FC7 0x410C61D1 b323
    pub inline fn ugcLoadOfflineQuery(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5CAE833B0EE0C500, .{p_0}); } // 0x5CAE833B0EE0C500 0x0D4F845D b323
    pub inline fn ugcClearOfflineQuery() !void { try invoker.invoke(void, 0x61A885D3F7CFEE9A, .{}); } // 0x61A885D3F7CFEE9A 0xE13C1F7F b323
    pub inline fn ugcSetQueryDataFromOffline(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xF98DDE0A8ED09323, .{p_0}); } // 0xF98DDE0A8ED09323 0x213C6D36 b323
    pub inline fn ugcSetUsingOfflineContent(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xFD75DABC0957BF33, .{p_0}); } // 0xFD75DABC0957BF33 0x511E6F50 b323
    pub inline fn ugcIsLanguageSupported(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF53E48461B71EECB, .{p_0}); } // 0xF53E48461B71EECB 0xB4668B23 b323
    pub inline fn facebookPostCompletedHeist(heist_name: [*c]const u8, cash_earned: c_int, xp_earned: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x098AB65B9ED9A9EC, .{heist_name, cash_earned, xp_earned}); } // 0x098AB65B9ED9A9EC 0x30B51753 b323
    pub inline fn facebookPostCreateCharacter() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDC48473142545431, .{}); } // 0xDC48473142545431 0x02DAD93F b323
    pub inline fn facebookPostCompletedMilestone(milestone_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0AE1F1653B554AB9, .{milestone_id}); } // 0x0AE1F1653B554AB9 0x2D947814 b323
    pub inline fn facebookHasPostCompleted() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x62B9FEC9A11F10EF, .{}); } // 0x62B9FEC9A11F10EF 0x37A28C26 b323
    pub inline fn facebookDidPostSucceed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA75E2B6733DA5142, .{}); } // 0xA75E2B6733DA5142 0x11E8B5CD b323
    pub inline fn facebookCanPostToFacebook() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x43865688AE10F0D7, .{}); } // 0x43865688AE10F0D7 0x429AEAB3 b323
    pub inline fn textureDownloadRequest(gamer_handle: [*c]types.Any, file_path: [*c]const u8, name: [*c]const u8, p_3: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x16160DA74A8E74A2, .{gamer_handle, file_path, name, p_3}); } // 0x16160DA74A8E74A2 0xAD546CC3 b323
    pub inline fn titleTextureDownloadRequest(file_path: [*c]const u8, name: [*c]const u8, p_2: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x0B203B4AFDE53A4F, .{file_path, name, p_2}); } // 0x0B203B4AFDE53A4F 0x1856D008 b323
    pub inline fn ugcTextureDownloadRequest(p_0: [*c]const u8, p_1: c_int, p_2: c_int, p_3: c_int, p_4: [*c]const u8, p_5: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x308F96458B7087CC, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x308F96458B7087CC 0x68C9AF69 b323
    pub inline fn textureDownloadRelease(p_0: c_int) !void { try invoker.invoke(void, 0x487EB90B98E9FB19, .{p_0}); } // 0x487EB90B98E9FB19 0xEE8D9E70 b323
    pub inline fn textureDownloadHasFailed(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5776ED562C134687, .{p_0}); } // 0x5776ED562C134687 0xE4547765 b323
    pub inline fn textureDownloadGetName(p_0: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x3448505B6E35262D, .{p_0}); } // 0x3448505B6E35262D 0xA40EF65A b323
    /// 0 = succeeded \
    /// 1 = pending \
    /// 2 = failed
    pub inline fn getStatusOfTextureDownload(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x8BD6C6DEA20E82C6, .{p_0}); } // 0x8BD6C6DEA20E82C6 0x03225BA3 b323
    /// Returns true if profile setting 901 is set to true and sets it to false.
    pub inline fn networkCheckRosLinkWentdownNotNet() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x60EDD13EB3AC1FF3, .{}); } // 0x60EDD13EB3AC1FF3 0x4DEBC227 b323
    /// Returns true if the NAT type is Strict (3) and a certain number of connections have failed.
    pub inline fn networkShouldShowStrictNatWarning() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x82A2B386716608F1, .{}); } // 0x82A2B386716608F1  b393
    pub inline fn networkIsCableConnected() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEFFB25453D8600F9, .{}); } // 0xEFFB25453D8600F9 0x5C065D55 b323
    pub inline fn networkHaveScsPrivateMsgPriv() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x66B59CFFD78467AF, .{}); } // 0x66B59CFFD78467AF 0x0CA1167F b323
    pub inline fn networkHaveRosSocialClubPriv() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x606E4D3E3CCCF3EB, .{}); } // 0x606E4D3E3CCCF3EB 0x424C6E27 b323
    pub inline fn networkHaveRosBannedPriv() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8020A73847E0CA7D, .{}); } // 0x8020A73847E0CA7D 0xD3BBE42F b323
    pub inline fn networkHaveRosCreateTicketPriv() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0AD7E2AF5349F61, .{}); } // 0xA0AD7E2AF5349F61 0xBDBB5948 b323
    pub inline fn networkHaveRosMultiplayerPriv() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5F91D5D0B36AA310, .{}); } // 0x5F91D5D0B36AA310 0x97287D68 b323
    pub inline fn networkHaveRosLeaderboardWritePriv() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x422D396F80A96547, .{}); } // 0x422D396F80A96547 0xC6EA802E b323
    /// index is always 18 in scripts
    pub inline fn networkHasRosPrivilege(index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA699957E60D80214, .{index}); } // 0xA699957E60D80214 0xFD261E30 b323
    pub inline fn networkHasRosPrivilegeEndDate(privilege: c_int, ban_type: [*c]c_int, time_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC22912B1D85F26B1, .{privilege, ban_type, time_data}); } // 0xC22912B1D85F26B1 0x8570DD34 b323
    pub inline fn networkHasRosPrivilegePlayedLastGen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x593570C289A77688, .{}); } // 0x593570C289A77688  b323
    pub inline fn networkHasRosPrivilegeSpecialEditionContent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x91B87C55093DE351, .{}); } // 0x91B87C55093DE351  b323
    /// Checks for privilege 29
    pub inline fn networkHasRosPrivilegeMpTextCommunication_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD9719341663C385F, .{}); } // 0xD9719341663C385F  b3095
    /// Checks for privilege 30
    pub inline fn networkHasRosPrivilegeMpVoiceCommunication_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8956A309BE90057C, .{}); } // 0x8956A309BE90057C  b3095
    /// Checks for privilege 31
    pub inline fn networkHasRosPrivilegeReporting_() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9BA54B3CFB82ADDD, .{}); } // 0x9BA54B3CFB82ADDD  b3258
    /// Always returns -1. Seems to be XB1 specific.
    pub inline fn networkStartUserContentPermissionsCheck(net_handle: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0xDEB2B99A1AF1A2A6, .{net_handle}); } // 0xDEB2B99A1AF1A2A6  b323
    pub inline fn networkSkipRadioResetNextClose() !void { try invoker.invoke(void, 0x9465E683B12D3F6B, .{}); } // 0x9465E683B12D3F6B 0x273C6180 b323
    pub inline fn networkSkipRadioResetNextOpen() !void { try invoker.invoke(void, 0xCA59CCAE5D01E4CE, .{}); } // 0xCA59CCAE5D01E4CE  b1734
    /// Returns true if dinput8.dll is present in the game directory. \
    /// You will get following error message if that is true: "You are attempting to access GTA Online servers with an altered version of the game."
    pub inline fn networkSkipRadioWarning() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x659CF2EF7F550C4F, .{}); } // 0x659CF2EF7F550C4F  b1011
    /// NETWORK_F[I-O]
    pub inline fn networkForceLocalPlayerScarSync() !void { try invoker.invoke(void, 0xB7C7F6AD6424304B, .{}); } // 0xB7C7F6AD6424304B 0x371BBA08 b323
    pub inline fn networkDisableLeaveRemotePedBehind(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC505036A35AFD01B, .{toggle}); } // 0xC505036A35AFD01B 0xA100CC97 b323
    pub inline fn networkAllowRemoteAttachmentModification(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x267C78C60E806B9A, .{entity, toggle}); } // 0x267C78C60E806B9A 0xBB2D33D3 b323
    /// Does nothing (it's a nullsub).
    pub inline fn networkShowChatRestrictionMsc(player: types.Player) !void { try invoker.invoke(void, 0x6BFF5F84102DF80A, .{player}); } // 0x6BFF5F84102DF80A  b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn networkShowPsnUgcRestriction() !void { try invoker.invoke(void, 0x5C497525F803486B, .{}); } // 0x5C497525F803486B  b323
    /// This function is hard-coded to always return 0.
    pub inline fn networkIsTitleUpdateRequired() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6FB7BB3607D27FA2, .{}); } // 0x6FB7BB3607D27FA2  b323
    pub inline fn networkQuitMpToDesktop() !void { try invoker.invoke(void, 0x45A83257ED02D9BC, .{}); } // 0x45A83257ED02D9BC  b323
    pub inline fn networkIsConnectedViaRelay(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x16D3D49902F697BB, .{player}); } // 0x16D3D49902F697BB  b323
    pub inline fn networkGetAverageLatency(player: types.Player) !f32 { return try invoker.invoke(f32, 0xD414BE129BB81B32, .{player}); } // 0xD414BE129BB81B32  b323
    /// Same as NETWORK_GET_AVERAGE_LATENCY
    pub inline fn networkGetAveragePing(player: types.Player) !f32 { return try invoker.invoke(f32, 0x0E3A041ED6AC2B45, .{player}); } // 0x0E3A041ED6AC2B45  b323
    pub inline fn networkGetAveragePacketLoss(player: types.Player) !f32 { return try invoker.invoke(f32, 0x350C23949E43686C, .{player}); } // 0x350C23949E43686C  b323
    pub inline fn networkGetNumUnackedReliables(player: types.Player) !c_int { return try invoker.invoke(c_int, 0xFF8FCF9FFC458A1C, .{player}); } // 0xFF8FCF9FFC458A1C  b323
    pub inline fn networkGetUnreliableResendCount(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x3765C3A3E8192E10, .{player}); } // 0x3765C3A3E8192E10  b323
    pub inline fn networkGetHighestReliableResendCount(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x52C1EADAF7B10302, .{player}); } // 0x52C1EADAF7B10302  b323
    pub inline fn networkReportCodeTamper() !void { try invoker.invoke(void, 0x5626D9D6810730D5, .{}); } // 0x5626D9D6810730D5  b350
    pub inline fn networkGetDumpOfAssetVerifier_(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x69D05E1EAD74B9DD, .{p_0}); } // 0x69D05E1EAD74B9DD  b3717
    pub inline fn networkGetLastEntityPosReceivedOverNetwork(entity: types.Entity) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x64D779659BC37B19, .{entity}); } // 0x64D779659BC37B19  b393
    /// Returns the coordinates of another player. \
    /// Does not work if you enter your own player id as p0 (will return `(0.0, 0.0, 0.0)` in that case).
    pub inline fn networkGetLastPlayerPosReceivedOverNetwork(player: types.Player) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x125E6D638B8605D4, .{player}); } // 0x125E6D638B8605D4  b393
    /// Used by NetBlender
    pub inline fn networkGetLastVelReceivedOverNetwork(entity: types.Entity) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x33DE49EDF4DDE77A, .{entity}); } // 0x33DE49EDF4DDE77A  b1103
    pub inline fn networkGetPredictedVelocity(entity: types.Entity, max_speed_to_predict: f32) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xAA5FAFCD2C5F5E47, .{entity, max_speed_to_predict}); } // 0xAA5FAFCD2C5F5E47  b1103
    /// Does nothing (it's a nullsub).
    pub inline fn networkDumpNetIfConfig() !void { try invoker.invoke(void, 0xAEDF1BC1C133D6E3, .{}); } // 0xAEDF1BC1C133D6E3  b323
    /// Does nothing (it's a nullsub).
    pub inline fn networkGetSignallingInfo(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x2555CF7DA5473794, .{p_0}); } // 0x2555CF7DA5473794  b323
    /// Does nothing (it's a nullsub).
    pub inline fn networkGetNetStatisticsInfo(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x6FD992C4A1C1B986, .{p_0}); } // 0x6FD992C4A1C1B986  b323
    pub inline fn networkGetPlayerAccountId(player: types.Player) !c_int { return try invoker.invoke(c_int, 0xDB663CC9FF3407A9, .{player}); } // 0xDB663CC9FF3407A9  b1734
    pub inline fn networkHasScMembership() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAB286B2192A71E32, .{}); } // 0xAB286B2192A71E32  b3717
    pub inline fn networkUgcNav(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xC1447451DDB512F0, .{p_0, p_1}); } // 0xC1447451DDB512F0  b2372
    /// enum eNetworkGameRestartReason \
    /// { \
    ///     BE_RESTART_SERVICE_NOT_RUNNING = 1,     // BattlEye service not running
    ///     BE_RESTART_SERVICE_NEEDS_UPDATE,         // BattlEye service needs an update
    ///     BE_RESTART_UNKNOWN_REASON,                // Unknown BattlEye reason
    ///     BE_RESTART_EF_DISABLED_WITH_BE,            // BattlEye Enforcement Flag is disabled, but BattlEye is active
    ///     BE_RESTART_EF_ENABLED_NO_BE,            // BattlEye Enforcement Flag is enabled, but BattlEye is not active
    ///     BE_RESTART_BE_MODULES_FAILED_TO_LOAD,    // BattlEye modules failed to load
    ///     NUM_NETWORK_GAME_RESTART_REASONS
    /// };
    pub inline fn networkGetGameRestartReason_() !c_int { return try invoker.invoke(c_int, 0x7F7E8401F81CB65B, .{}); } // 0x7F7E8401F81CB65B  b3323
    /// If the restart reason is 4 (BE_RESTART_EF_DISABLED_WITH_BE), will cause the game to exit with exit code 622011. Otherwise exits with code 622010. Has no effect when a restart hasn't been requested (reason == 0 or reason > 6).
    /// 
    /// Note that this 'confirmation' itself does not restart the game, a call to QUIT_GAME or similar is required afterwards.
    pub inline fn networkConfirmGameRestart_() !void { try invoker.invoke(void, 0x0A141818CA2311AD, .{}); } // 0x0A141818CA2311AD  b3323
    /// Returns the restart reason as a string, see _NETWORK_GET_GAME_RESTART_REASON. Returns a null pointer when a restart hasn't been requested (reason == 0 or reason > 6).
    pub inline fn networkGetGameRestartReasonMessageLabel_() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x47B11D51FC50A259, .{}); } // 0x47B11D51FC50A259  b3323
    /// 0x20211000 = HUD_BE_ERROR_FAILED_UNKNOWN \
    /// 0x20212000 = HUD_BE_ERROR_FAILED_CLIENT_INIT \
    /// 0x20213000 = HUD_BE_ERROR_FAILED_SERVER_INIT \
    /// 0x20214000 = HUD_BE_ERROR_FAILED_AUTH_ATTEMPTS \
    /// 0x20215000 = HUD_BE_ERROR_UNTRUSTED_HOST \
    /// 0x20216000 = HUD_BE_ERROR_KICKED \
    /// 0x20217000 = HUD_BE_ERROR_BANNED \
    /// 0x50140000 = HUD_BE_BLOCK_BANNED
    /// 
    /// Note: an invalid error code returns a null pointer!
    pub inline fn networkGetBattleyeErrorMessageLabel_(error_code: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xCBA50F371E45B90D, .{error_code}); } // 0xCBA50F371E45B90D  b3323
};

pub const Object = struct
{
    /// List of object models that can be created without any additional effort like making sure ytyp is loaded etc: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ObjectList.ini
    pub inline fn createObject(model_hash: types.Hash, vec: types.Vector3, is_network: windows.BOOL, b_script_host_obj: windows.BOOL, dynamic: windows.BOOL) !types.Object { return try invoker.invoke(types.Object, 0x509D5878EB39E842, .{model_hash, vec.x, vec.y, vec.z, is_network, b_script_host_obj, dynamic}); } // 0x509D5878EB39E842 0x2F7AA05C b323
    /// List of object models that can be created without any additional effort like making sure ytyp is loaded etc: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ObjectList.ini
    pub inline fn createObjectNoOffset(model_hash: types.Hash, vec: types.Vector3, is_network: windows.BOOL, b_script_host_obj: windows.BOOL, dynamic: windows.BOOL, p_7: types.Any) !types.Object { return try invoker.invoke(types.Object, 0x9A294B2138ABB884, .{model_hash, vec.x, vec.y, vec.z, is_network, b_script_host_obj, dynamic, p_7}); } // 0x9A294B2138ABB884 0x58040420 b323
    /// Deletes the specified object, then sets the handle pointed to by the pointer to NULL.
    pub inline fn deleteObject(object: [*c]types.Object) !void { try invoker.invoke(void, 0x539E0AE3E6634B9F, .{object}); } // 0x539E0AE3E6634B9F 0xD6EF9DA7 b323
    pub inline fn placeObjectOnGroundProperly(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x58A850EAEE20FAA3, .{object}); } // 0x58A850EAEE20FAA3 0x8F95A20B b323
    pub inline fn placeObjectOnGroundOrObjectProperly(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD76EEEF746057FD6, .{object}); } // 0xD76EEEF746057FD6  b505
    pub inline fn rotateObject(object: types.Object, p_1: f32, p_2: f32, p_3: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAFE24E4D29249E4A, .{object, p_1, p_2, p_3}); } // 0xAFE24E4D29249E4A  b1734
    /// Returns true if the object has finished moving.
    /// 
    /// If false, moves the object towards the specified X, Y and Z coordinates with the specified X, Y and Z speed.
    /// 
    /// See also: https://gtagmodding.com/opcode-database/opcode/034E/ \
    /// Has to be looped until it returns true.
    pub inline fn slideObject(object: types.Object, to__: types.Vector3, speed__: types.Vector3, collision: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2FDFF4107B8C1147, .{object, to__.x, to__.y, to__.z, speed__.x, speed__.y, speed__.z, collision}); } // 0x2FDFF4107B8C1147 0x63BFA7A0 b323
    pub inline fn setObjectTargettable(object: types.Object, targettable: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0x8A7391690F5AFD81, .{object, targettable, p_2}); } // 0x8A7391690F5AFD81 0x3F88CD86 b323
    /// Sets the 34th and 35th object flags related to player peds.
    pub inline fn setObjectTargettableByPlayer_(object: types.Object, set_flag_3_4: windows.BOOL, set_flag_3_5: windows.BOOL) !void { try invoker.invoke(void, 0xB39F03368DB0CAA2, .{object, set_flag_3_4, set_flag_3_5}); } // 0xB39F03368DB0CAA2  b3258
    /// Overrides a flag on the object which determines if the object should be avoided by a vehicle in task CTaskVehicleGoToPointWithAvoidanceAutomobile.
    pub inline fn setObjectForceVehiclesToAvoid(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x77F33F2CCF64B3AA, .{object, toggle}); } // 0x77F33F2CCF64B3AA 0x483C5C88 b323
    /// Has 8 params in the latest patches.
    /// 
    /// isMission - if true doesn't return mission objects
    pub inline fn getClosestObjectOfType(vec: types.Vector3, radius: f32, model_hash: types.Hash, is_mission: windows.BOOL, p_6: windows.BOOL, p_7: windows.BOOL) !types.Object { return try invoker.invoke(types.Object, 0xE143FA2249364369, .{vec.x, vec.y, vec.z, radius, model_hash, is_mission, p_6, p_7}); } // 0xE143FA2249364369 0x45619B33 b323
    pub inline fn hasObjectBeenBroken(object: types.Object, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8ABFB70C49CC43E2, .{object, p_1}); } // 0x8ABFB70C49CC43E2 0xFE21F891 b323
    pub inline fn hasClosestObjectOfTypeBeenBroken(p_0: f32, p_1: f32, p_2: f32, p_3: f32, model_hash: types.Hash, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x761B0E69AC4D007E, .{p_0, p_1, p_2, p_3, model_hash, p_5}); } // 0x761B0E69AC4D007E 0x6FC0353D b323
    pub inline fn hasClosestObjectOfTypeBeenCompletelyDestroyed(vec: types.Vector3, radius: f32, model_hash: types.Hash, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x46494A2475701343, .{vec.x, vec.y, vec.z, radius, model_hash, p_5}); } // 0x46494A2475701343 0x7DB578DD b323
    pub inline fn getHasObjectBeenCompletelyDestroyed(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2542269291C6AC84, .{p_0}); } // 0x2542269291C6AC84  b1180
    pub inline fn getOffsetFromCoordAndHeadingInWorldCoords(pos__: types.Vector3, heading: f32, offset__: types.Vector3) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x163E252DE035A133, .{pos__.x, pos__.y, pos__.z, heading, offset__.x, offset__.y, offset__.z}); } // 0x163E252DE035A133 0x87A42A12 b323
    pub inline fn getCoordsAndRotationOfClosestObjectOfType(vec: types.Vector3, radius: f32, model_hash: types.Hash, out_position: [*c]types.Vector3, out_rotation: [*c]types.Vector3, rotation_order: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x163F8B586BC95F2A, .{vec.x, vec.y, vec.z, radius, model_hash, out_position, out_rotation, rotation_order}); } // 0x163F8B586BC95F2A 0x65213FC3 b323
    /// Hardcoded to not work in multiplayer.
    /// 
    /// 
    /// Used to lock/unlock doors to interior areas of the game.
    /// 
    /// (Possible) Door Types:
    /// 
    /// https://pastebin.com/9S2m3qA4
    /// 
    /// Heading is either 1, 0 or -1 in the scripts. Means default closed(0) or opened either into(1) or out(-1) of the interior. \
    /// Locked means that the heading is locked.   \
    /// p6 is always 0. 
    /// 
    /// 225 door types, model names and coords found in stripclub.c4: \
    /// https://pastebin.com/gywnbzsH
    /// 
    /// get door info: https://pastebin.com/i14rbekD
    pub inline fn setStateOfClosestDoorOfType(@"type": types.Hash, vec: types.Vector3, locked: windows.BOOL, heading: f32, p_6: windows.BOOL) !void { try invoker.invoke(void, 0xF82D8F1926A02C3D, .{@"type", vec.x, vec.y, vec.z, locked, heading, p_6}); } // 0xF82D8F1926A02C3D 0x38C951A4 b323
    /// locked is 0 if no door is found \
    /// locked is 0 if door is unlocked \
    /// locked is 1 if door is found and unlocked.
    /// 
    /// ------------- \
    /// the locked bool is either 0(unlocked)(false) or 1(locked)(true)
    pub inline fn getStateOfClosestDoorOfType(@"type": types.Hash, vec: types.Vector3, locked: [*c]windows.BOOL, heading: [*c]f32) !void { try invoker.invoke(void, 0xEDC1A5B84AEF33FF, .{@"type", vec.x, vec.y, vec.z, locked, heading}); } // 0xEDC1A5B84AEF33FF 0x4B44A83D b323
    /// Hardcoded not to work in multiplayer environments. \
    /// When you set locked to 0 the door open and to 1 the door close \
    /// OBJECT::SET_LOCKED_UNSTREAMED_IN_DOOR_OF_TYPE(${prop_gate_prison_01}, 1845.0, 2605.0, 45.0, 0, 0.0, 50.0, 0);  //door open
    /// 
    /// OBJECT::SET_LOCKED_UNSTREAMED_IN_DOOR_OF_TYPE(${prop_gate_prison_01}, 1845.0, 2605.0, 45.0, 1, 0.0, 50.0, 0);  //door close
    pub inline fn setLockedUnstreamedInDoorOfType(model_hash: types.Hash, vec: types.Vector3, locked: windows.BOOL, rotmult__: types.Vector3) !void { try invoker.invoke(void, 0x9B12F9A24FABEDB0, .{model_hash, vec.x, vec.y, vec.z, locked, rotmult__.x, rotmult__.y, rotmult__.z}); } // 0x9B12F9A24FABEDB0 0x4E0A260B b323
    pub inline fn playObjectAutoStartAnim(p_0: types.Any) !void { try invoker.invoke(void, 0x006E4B040ED37EC3, .{p_0}); } // 0x006E4B040ED37EC3  b1868
    /// doorHash has to be unique. scriptDoor false; relies upon getNetworkGameScriptHandler. isLocal On true disables the creation CRequestDoorEvent's in DOOR_SYSTEM_SET_DOOR_STATE. \
    /// p5 only set to true in single player native scripts. \
    /// If scriptDoor is true, register the door on the script handler host (note: there's a hardcap on the number of script IDs that can be added to the system at a given time). If scriptDoor and isLocal are both false, the door is considered to be in a "Persists w/o netobj" state.
    /// 
    /// door hashes normally look like PROP_[int]_DOOR_[int] for interior doors and PROP_BUILDING_[int]_DOOR_[int] exterior doors but you can just make up your own hash if you want \
    /// All doors need to be registered with ADD_DOOR_TO_SYSTEM before they can be manipulated with the door natives and the easiest way to get door models is just find the door in codewalker.
    /// 
    /// Example: AddDoorToSystem("PROP_43_DOOR_0", "hei_v_ilev_fh_heistdoor2", -1456.818, -520.5037, 69.67043, 0, 0, 0)
    pub inline fn addDoorToSystem(door_hash: types.Hash, model_hash: types.Hash, vec: types.Vector3, p_5: windows.BOOL, script_door: windows.BOOL, is_local: windows.BOOL, p_8: types.Any) !void { try invoker.invoke(void, 0x6F8838D03D1DC226, .{door_hash, model_hash, vec.x, vec.y, vec.z, p_5, script_door, is_local, p_8}); } // 0x6F8838D03D1DC226 0x9D2D778D b323
    /// CDoor and CDoorSystemData still internally allocated (and their associations between doorHash, modelHash, and coordinates). \
    /// Only its NetObj removed and flag ``*(v2 + 192) |= 8u`` (1604 retail) toggled.
    pub inline fn removeDoorFromSystem(door_hash: types.Hash, p_1: types.Any) !void { try invoker.invoke(void, 0x464D8E1427156FE4, .{door_hash, p_1}); } // 0x464D8E1427156FE4 0x00253286 b323
    /// Lockstates not applied and CNetObjDoor's not created until DOOR_SYSTEM_GET_IS_PHYSICS_LOADED returns true. \
    /// `requestDoor` on true, and when door system is configured to, i.e., "persists w/o netobj", generate a CRequestDoorEvent. \
    /// `forceUpdate` on true, forces an update on the door system (same path as netObjDoor_applyDoorStuff) \
    /// Door lock states: \
    /// 0: UNLOCKED \
    /// 1: LOCKED \
    /// 2: DOORSTATE_FORCE_LOCKED_UNTIL_OUT_OF_AREA \
    /// 3: DOORSTATE_FORCE_UNLOCKED_THIS_FRAME \
    /// 4: DOORSTATE_FORCE_LOCKED_THIS_FRAME \
    /// 5: DOORSTATE_FORCE_OPEN_THIS_FRAME \
    /// 6: DOORSTATE_FORCE_CLOSED_THIS_FRAME
    pub inline fn doorSystemSetDoorState(door_hash: types.Hash, state: c_int, request_door: windows.BOOL, force_update: windows.BOOL) !void { try invoker.invoke(void, 0x6BAB9442830C7F53, .{door_hash, state, request_door, force_update}); } // 0x6BAB9442830C7F53 0xDF83DB47 b323
    pub inline fn doorSystemGetDoorState(door_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x160AA1B32F6139B8, .{door_hash}); } // 0x160AA1B32F6139B8 0xD42A41C2 b323
    pub inline fn doorSystemGetDoorPendingState(door_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x4BC2854478F3A749, .{door_hash}); } // 0x4BC2854478F3A749 0xD649B7E1 b323
    /// Includes networking check: ownership vs. or the door itself **isn't** networked. \
    /// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
    pub inline fn doorSystemSetAutomaticRate(door_hash: types.Hash, rate: f32, request_door: windows.BOOL, force_update: windows.BOOL) !void { try invoker.invoke(void, 0x03C27E13B42A0E82, .{door_hash, rate, request_door, force_update}); } // 0x03C27E13B42A0E82 0x4F44AF21 b323
    /// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
    pub inline fn doorSystemSetAutomaticDistance(door_hash: types.Hash, distance: f32, request_door: windows.BOOL, force_update: windows.BOOL) !void { try invoker.invoke(void, 0x9BA001CB45CBF627, .{door_hash, distance, request_door, force_update}); } // 0x9BA001CB45CBF627 0x47531446 b323
    /// Sets the ajar angle of a door. \
    /// Ranges from -1.0 to 1.0, and 0.0 is closed / default. \
    /// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
    pub inline fn doorSystemSetOpenRatio(door_hash: types.Hash, ajar: f32, request_door: windows.BOOL, force_update: windows.BOOL) !void { try invoker.invoke(void, 0xB6E6FBA95C7324AC, .{door_hash, ajar, request_door, force_update}); } // 0xB6E6FBA95C7324AC 0x34883DE3 b323
    pub inline fn doorSystemGetAutomaticDistance(door_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0xE851471AEFC3374F, .{door_hash}); } // 0xE851471AEFC3374F  b1868
    pub inline fn doorSystemGetOpenRatio(door_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x65499865FCA6E5EC, .{door_hash}); } // 0x65499865FCA6E5EC 0xB74C3BD7 b323
    pub inline fn doorSystemGetIsSpringRemoved(door_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8562FD8AB1E94D39, .{door_hash}); } // 0x8562FD8AB1E94D39  b3407
    /// Includes networking check: ownership vs. or the door itself **isn't** networked. \
    /// `forceUpdate` on true invokes DOOR_SYSTEM_SET_DOOR_STATE otherwise requestDoor is unused.
    pub inline fn doorSystemSetSpringRemoved(door_hash: types.Hash, removed: windows.BOOL, request_door: windows.BOOL, force_update: windows.BOOL) !void { try invoker.invoke(void, 0xC485E07E4F0B7958, .{door_hash, removed, request_door, force_update}); } // 0xC485E07E4F0B7958 0xB4A9A558 b323
    /// Includes networking check: ownership vs. or the door itself **isn't** networked.
    pub inline fn doorSystemSetHoldOpen(door_hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD9B71952F78A2640, .{door_hash, toggle}); } // 0xD9B71952F78A2640 0xECE58AE0 b323
    /// Some property related to gates. Native name between ``DOOR_SYSTEM_SET_AUTOMATIC_RATE`` and ``DOOR_SYSTEM_SET_DOOR_STATE``.
    pub inline fn doorSystemSetDoorOpenForRaces(door_hash: types.Hash, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xA85A21582451E951, .{door_hash, p_1}); } // 0xA85A21582451E951 0xF736227C b323
    /// if (OBJECT::IS_DOOR_REGISTERED_WITH_SYSTEM(doorHash))  \
    /// { \
    ///     OBJECT::REMOVE_DOOR_FROM_SYSTEM(doorHash);
    /// }
    pub inline fn isDoorRegisteredWithSystem(door_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC153C43EA202C8C1, .{door_hash}); } // 0xC153C43EA202C8C1 0x5AFCD8A1 b323
    pub inline fn isDoorClosed(door_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC531EE8A1145A149, .{door_hash}); } // 0xC531EE8A1145A149 0x48659CD7 b323
    pub inline fn openAllBarriersForRace(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xC7F29CA00F46350E, .{p_0}); } // 0xC7F29CA00F46350E 0x9BF33E41 b323
    /// Clears the fields sets by 0xC7F29CA00F46350E (1604 retail: 0x1424A7A10, 0x1424A7A11) and iterates over the global CDoor's bucket-list. \
    /// Related to its "Pre-networked state"?
    pub inline fn closeAllBarriersForRace() !void { try invoker.invoke(void, 0x701FDA1E82076BA4, .{}); } // 0x701FDA1E82076BA4 0xF592AD10 b323
    pub inline fn doorSystemGetIsPhysicsLoaded(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDF97CDD4FC08FD34, .{p_0}); } // 0xDF97CDD4FC08FD34 0x17FF9393 b323
    /// Search radius: 0.5
    pub inline fn doorSystemFindExistingDoor(vec: types.Vector3, model_hash: types.Hash, out_door_hash: [*c]types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x589F80B325CC82C5, .{vec.x, vec.y, vec.z, model_hash, out_door_hash}); } // 0x589F80B325CC82C5 0xE9AE494F b323
    pub inline fn isGarageEmpty(garage_hash: types.Hash, p_1: windows.BOOL, p_2: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x90E47239EA1980B8, .{garage_hash, p_1, p_2}); } // 0x90E47239EA1980B8 0xA8B37DEA b323
    pub inline fn isPlayerEntirelyInsideGarage(garage_hash: types.Hash, player: types.Player, p_2: f32, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x024A60DEB0EA69F0, .{garage_hash, player, p_2, p_3}); } // 0x024A60DEB0EA69F0 0xC33ED360 b323
    pub inline fn isPlayerPartiallyInsideGarage(garage_hash: types.Hash, player: types.Player, p_2: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1761DC5D8471CBAA, .{garage_hash, player, p_2}); } // 0x1761DC5D8471CBAA 0x41924877 b323
    pub inline fn areEntitiesEntirelyInsideGarage(garage_hash: types.Hash, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL, p_4: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x85B6C850546FDDE2, .{garage_hash, p_1, p_2, p_3, p_4}); } // 0x85B6C850546FDDE2 0x4BD59750 b323
    pub inline fn isAnyEntityEntirelyInsideGarage(garage_hash: types.Hash, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL, p_4: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x673ED815D6E323B7, .{garage_hash, p_1, p_2, p_3, p_4}); } // 0x673ED815D6E323B7 0x7B44D659 b323
    /// Despite the name, it does work for any entity type.
    pub inline fn isObjectEntirelyInsideGarage(garage_hash: types.Hash, entity: types.Entity, p_2: f32, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x372EF6699146A1E4, .{garage_hash, entity, p_2, p_3}); } // 0x372EF6699146A1E4 0x142C8F76 b323
    /// Despite the name, it does work for any entity type.
    pub inline fn isObjectPartiallyInsideGarage(garage_hash: types.Hash, entity: types.Entity, p_2: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF0EED5A6BC7B237A, .{garage_hash, entity, p_2}); } // 0xF0EED5A6BC7B237A 0x95A9AB2B b323
    pub inline fn clearGarage(garage_hash: types.Hash, is_network: windows.BOOL) !void { try invoker.invoke(void, 0xDA05194260CDCDF9, .{garage_hash, is_network}); } // 0xDA05194260CDCDF9  b678
    pub inline fn clearObjectsInsideGarage(garage_hash: types.Hash, vehicles: windows.BOOL, peds: windows.BOOL, objects: windows.BOOL, is_network: windows.BOOL) !void { try invoker.invoke(void, 0x190428512B240692, .{garage_hash, vehicles, peds, objects, is_network}); } // 0x190428512B240692 0xA565E27E b323
    /// Sets a flag. A valid id is 0x157DC10D
    pub inline fn disableTidyingUpInGarage(id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x659F9D71F52843F8, .{id, toggle}); } // 0x659F9D71F52843F8  b1290
    pub inline fn enableSavingInGarage(garage_hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF2E1A7133DD356A6, .{garage_hash, toggle}); } // 0xF2E1A7133DD356A6 0x43BB7E48 b323
    pub inline fn closeSafehouseGarages() !void { try invoker.invoke(void, 0x66A49D021870FE88, .{}); } // 0x66A49D021870FE88 0x6158959E b323
    /// p5 is usually 0.
    pub inline fn doesObjectOfTypeExistAtCoords(vec: types.Vector3, radius: f32, hash: types.Hash, p_5: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBFA48E2FF417213F, .{vec.x, vec.y, vec.z, radius, hash, p_5}); } // 0xBFA48E2FF417213F 0x23FF2BA4 b323
    /// An angled area is an X-Z oriented rectangle with three parameters: \
    /// 1. origin: the mid-point along a base edge of the rectangle; \
    /// 2. extent: the mid-point of opposite base edge on the other Z; \
    /// 3. width: the length of the base edge; (named derived from logging strings ``CNetworkRoadNodeWorldStateData``).
    /// 
    /// The oriented rectangle can then be derived from the direction of the two points (``norm(origin - extent)``), its orthonormal, and the width, e.g: \
    /// 1. golf_mp https://i.imgur.com/JhsQAK9.png \
    /// 2. am_taxi https://i.imgur.com/TJWCZaT.jpg
    pub inline fn isPointInAngledArea(pos__: types.Vector3, vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, debug: windows.BOOL, include_z: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2A70BAE8883E4C81, .{pos__.x, pos__.y, pos__.z, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, debug, include_z}); } // 0x2A70BAE8883E4C81 0x73BCFFDC b323
    /// Overrides the climbing/blocking flags of the object, used in the native scripts mostly for "prop_dock_bouy_*"
    pub inline fn setObjectAllowLowLodBuoyancy(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4D89D607CB3DD1D2, .{object, toggle}); } // 0x4D89D607CB3DD1D2 0x19B17769 b323
    /// Adjust the physics parameters of a prop, or otherwise known as "object". This is useful for simulated gravity.
    /// 
    /// Other parameters seem to be unknown.
    /// 
    /// p2: seems to be weight and gravity related. Higher value makes the obj fall faster. Very sensitive? \
    /// p3: seems similar to p2 \
    /// p4: makes obj fall slower the higher the value \
    /// p5: similar to p4
    pub inline fn setObjectPhysicsParams(object: types.Object, weight: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, gravity: f32, p_7: f32, p_8: f32, p_9: f32, p_1_0: f32, buoyancy: f32) !void { try invoker.invoke(void, 0xF6DF6E90DE7DF90F, .{object, weight, p_2, p_3, p_4, p_5, gravity, p_7, p_8, p_9, p_1_0, buoyancy}); } // 0xF6DF6E90DE7DF90F 0xE8D11C58 b323
    pub inline fn getObjectFragmentDamageHealth(p_0: types.Any, p_1: windows.BOOL) !f32 { return try invoker.invoke(f32, 0xB6FBFD079B8D0596, .{p_0, p_1}); } // 0xB6FBFD079B8D0596 0xF0B330AD b323
    pub inline fn setActivateObjectPhysicsAsSoonAsItIsUnfrozen(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x406137F8EF90EAF5, .{object, toggle}); } // 0x406137F8EF90EAF5 0x3E263AE1 b323
    pub inline fn isAnyObjectNearPoint(vec: types.Vector3, range: f32, p_4: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x397DC58FF00298D1, .{vec.x, vec.y, vec.z, range, p_4}); } // 0x397DC58FF00298D1 0xE9E46941 b323
    pub inline fn isObjectNearPoint(object_hash: types.Hash, vec: types.Vector3, range: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8C90FE4B381BA60A, .{object_hash, vec.x, vec.y, vec.z, range}); } // 0x8C90FE4B381BA60A 0x50A62C43 b323
    pub inline fn removeObjectHighDetailModel(object: types.Object) !void { try invoker.invoke(void, 0x4A39DB43E47CF3AA, .{object}); } // 0x4A39DB43E47CF3AA 0xE3261B35 b323
    pub inline fn breakObjectFragmentChild(p_0: types.Object, p_1: types.Any, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xE7E4C198B0185900, .{p_0, p_1, p_2}); } // 0xE7E4C198B0185900 0x1E82C2AE b323
    pub inline fn damageObjectFragmentChild(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xE05F6AEEFEB0BB02, .{p_0, p_1, p_2}); } // 0xE05F6AEEFEB0BB02  b1180
    pub inline fn fixObjectFragment(object: types.Object) !void { try invoker.invoke(void, 0xF9C1681347C8BD15, .{object}); } // 0xF9C1681347C8BD15  b323
    pub inline fn trackObjectVisibility(object: types.Object) !void { try invoker.invoke(void, 0xB252BC036B525623, .{object}); } // 0xB252BC036B525623 0x46D06B9A b323
    pub inline fn isObjectVisible(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8B32ACE6326A7546, .{object}); } // 0x8B32ACE6326A7546 0xF4FD8AE4 b323
    pub inline fn setObjectIsSpecialGolfball(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC6033D32241F6FB5, .{object, toggle}); } // 0xC6033D32241F6FB5 0xF4A1A14A b323
    pub inline fn setObjectTakesDamageFromCollidingWithBuildings(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xEB6F1A9B5510A5D2, .{p_0, p_1}); } // 0xEB6F1A9B5510A5D2 0xAF016CC1 b323
    pub inline fn allowDamageEventsForNonNetworkedObjects(value: windows.BOOL) !void { try invoker.invoke(void, 0xABDABF4E1EDECBFA, .{value}); } // 0xABDABF4E1EDECBFA  b1365
    /// Requires a component_at_*_flsh to be attached to the weapon object
    pub inline fn setCutscenesWeaponFlashlightOnThisFrame(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBCE595371A5FBAAF, .{object, toggle}); } // 0xBCE595371A5FBAAF 0x3A68AA46 b323
    /// Example: \
    /// OBJECT::GET_RAYFIRE_MAP_OBJECT(-809.9619750976562, 170.919, 75.7406997680664, 3.0, "des_tvsmash");
    pub inline fn getRayfireMapObject(vec: types.Vector3, radius: f32, name: [*c]const u8) !types.Object { return try invoker.invoke(types.Object, 0xB48FCED898292E52, .{vec.x, vec.y, vec.z, radius, name}); } // 0xB48FCED898292E52 0xA286DE96 b323
    /// Defines the state of a destructible object. \
    /// Use the GET_RAYFIRE_MAP_OBJECT native to find an object's handle with its name / coords. \
    /// State 2 == object just spawned \
    /// State 4 == Beginning of the animation \
    /// State 6 == Start animation \
    /// State 9 == End of the animation
    pub inline fn setStateOfRayfireMapObject(object: types.Object, state: c_int) !void { try invoker.invoke(void, 0x5C29F698D404C5E1, .{object, state}); } // 0x5C29F698D404C5E1 0x21F51560 b323
    /// Get a destructible object's state. \
    /// Substract 1 to get the real state. \
    /// See SET_STATE_OF_RAYFIRE_MAP_OBJECT to see the different states \
    /// For example, if the object just spawned (state 2), the native will return 3.
    pub inline fn getStateOfRayfireMapObject(object: types.Object) !c_int { return try invoker.invoke(c_int, 0x899BA936634A322E, .{object}); } // 0x899BA936634A322E 0xF1B8817A b323
    /// Returns true if a destructible object with this handle exists, false otherwise.  
    pub inline fn doesRayfireMapObjectExist(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x52AF537A0C5B8AAD, .{object}); } // 0x52AF537A0C5B8AAD 0xE08C834D b323
    /// `object`: The des-object handle to get the animation progress from. \
    /// Return value is a float between 0.0 and 1.0, 0.0 is the beginning of the animation, 1.0 is the end. Value resets to 0.0 instantly after reaching 1.0.
    pub inline fn getRayfireMapObjectAnimPhase(object: types.Object) !f32 { return try invoker.invoke(f32, 0x260EE4FDBDF4DB01, .{object}); } // 0x260EE4FDBDF4DB01 0x020497DE b323
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn createPickup(pickup_hash: types.Hash, pos__: types.Vector3, p_4: c_int, value: c_int, p_6: windows.BOOL, model_hash: types.Hash) !types.Pickup { return try invoker.invoke(types.Pickup, 0xFBA08C503DD5FA58, .{pickup_hash, pos__.x, pos__.y, pos__.z, p_4, value, p_6, model_hash}); } // 0xFBA08C503DD5FA58 0x5E14DF68 b323
    /// flags: \
    /// 8 (1 << 3): place on ground \
    /// 512 (1 << 9): spin around
    /// 
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn createPickupRotate(pickup_hash: types.Hash, pos__: types.Vector3, rot__: types.Vector3, flag: c_int, amount: c_int, p_9: types.Any, p_1_0: windows.BOOL, model_hash: types.Hash) !types.Pickup { return try invoker.invoke(types.Pickup, 0x891804727E0A98B7, .{pickup_hash, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, flag, amount, p_9, p_1_0, model_hash}); } // 0x891804727E0A98B7 0xF015BFE2 b323
    pub inline fn forcePickupRotateFaceUp() !void { try invoker.invoke(void, 0x394CD08E31313C28, .{}); } // 0x394CD08E31313C28  b944
    pub inline fn setCustomPickupWeaponHash(pickup_hash: types.Hash, pickup: types.Pickup) !void { try invoker.invoke(void, 0x826D1EE4D1CAFC78, .{pickup_hash, pickup}); } // 0x826D1EE4D1CAFC78  b505
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn createAmbientPickup(pickup_hash: types.Hash, pos__: types.Vector3, flags: c_int, value: c_int, model_hash: types.Hash, p_7: windows.BOOL, p_8: windows.BOOL) !types.Object { return try invoker.invoke(types.Object, 0x673966A0C0FD7171, .{pickup_hash, pos__.x, pos__.y, pos__.z, flags, value, model_hash, p_7, p_8}); } // 0x673966A0C0FD7171 0x17B99CE7 b323
    pub inline fn createNonNetworkedAmbientPickup(pickup_hash: types.Hash, pos__: types.Vector3, flags: c_int, value: c_int, model_hash: types.Hash, p_7: windows.BOOL, p_8: windows.BOOL) !types.Object { return try invoker.invoke(types.Object, 0x9C93764223E29C50, .{pickup_hash, pos__.x, pos__.y, pos__.z, flags, value, model_hash, p_7, p_8}); } // 0x9C93764223E29C50  b2372
    pub inline fn blockPlayersForAmbientPickup(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x1E3F1B1B891A2AAA, .{p_0, p_1}); } // 0x1E3F1B1B891A2AAA  b573
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn createPortablePickup(pickup_hash: types.Hash, vec: types.Vector3, place_on_ground: windows.BOOL, model_hash: types.Hash) !types.Object { return try invoker.invoke(types.Object, 0x2EAF1FDB2FB55698, .{pickup_hash, vec.x, vec.y, vec.z, place_on_ground, model_hash}); } // 0x2EAF1FDB2FB55698 0x8C886BE5 b323
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn createNonNetworkedPortablePickup(pickup_hash: types.Hash, vec: types.Vector3, place_on_ground: windows.BOOL, model_hash: types.Hash) !types.Object { return try invoker.invoke(types.Object, 0x125494B98A21AAF7, .{pickup_hash, vec.x, vec.y, vec.z, place_on_ground, model_hash}); } // 0x125494B98A21AAF7 0x56A02502 b323
    pub inline fn attachPortablePickupToPed(pickup_object: types.Object, ped: types.Ped) !void { try invoker.invoke(void, 0x8DC39368BDD57755, .{pickup_object, ped}); } // 0x8DC39368BDD57755 0x184F6AB3 b323
    pub inline fn detachPortablePickupFromPed(pickup_object: types.Object) !void { try invoker.invoke(void, 0xCF463D1E9A0AECB1, .{pickup_object}); } // 0xCF463D1E9A0AECB1 0x1D094562 b323
    pub inline fn forcePortablePickupLastAccessiblePositionSetting(object: types.Object) !void { try invoker.invoke(void, 0x5CE2E45A5CE2E45A, .{object}); } // 0x5CE2E45A5CE2E45A  b2545
    pub inline fn hidePortablePickupWhenDetached(pickup_object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x867458251D47CCB2, .{pickup_object, toggle}); } // 0x867458251D47CCB2 0x1F63B042 b463
    pub inline fn setMaxNumPortablePickupsCarriedByPlayer(model_hash: types.Hash, number: c_int) !void { try invoker.invoke(void, 0x0BF3B3BD47D79C08, .{model_hash, number}); } // 0x0BF3B3BD47D79C08 0x7EFBA039 b323
    pub inline fn setLocalPlayerCanCollectPortablePickups(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x78857FC65CADB909, .{toggle}); } // 0x78857FC65CADB909 0xA3CDF152 b323
    pub inline fn getSafePickupCoords(vec: types.Vector3, p_3: f32, p_4: f32) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x6E16BC2503FF1FF0, .{vec.x, vec.y, vec.z, p_3, p_4}); } // 0x6E16BC2503FF1FF0 0x618B5F67 b323
    /// Adds an area that seems to be related to pickup physics behavior. \
    /// Max amount of areas is 10. Only works in multiplayer.
    pub inline fn addExtendedPickupProbeArea(vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0xD4A7A435B3710D05, .{vec.x, vec.y, vec.z, radius}); } // 0xD4A7A435B3710D05  b1290
    /// Clears all areas created by ADD_EXTENDED_PICKUP_PROBE_AREA
    pub inline fn clearExtendedPickupProbeAreas() !void { try invoker.invoke(void, 0xB7C6D80FB371659A, .{}); } // 0xB7C6D80FB371659A  b1290
    pub inline fn getPickupCoords(pickup: types.Pickup) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x225B8B35C88029B3, .{pickup}); } // 0x225B8B35C88029B3 0xC2E1E2C5 b323
    pub inline fn suppressPickupSoundForPickup(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x8DCA505A5C196F05, .{p_0, p_1}); } // 0x8DCA505A5C196F05  b1180
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn removeAllPickupsOfType(pickup_hash: types.Hash) !void { try invoker.invoke(void, 0x27F9D613092159CF, .{pickup_hash}); } // 0x27F9D613092159CF 0x40062C53 b323
    pub inline fn hasPickupBeenCollected(pickup: types.Pickup) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x80EC48E6679313F9, .{pickup}); } // 0x80EC48E6679313F9 0x0BE5CCED b323
    pub inline fn removePickup(pickup: types.Pickup) !void { try invoker.invoke(void, 0x3288D8ACAECD2AB2, .{pickup}); } // 0x3288D8ACAECD2AB2 0x64A7A0E0 b323
    /// Spawns one or more money pickups.
    /// 
    /// x: The X-component of the world position to spawn the money pickups at. \
    /// y: The Y-component of the world position to spawn the money pickups at. \
    /// z: The Z-component of the world position to spawn the money pickups at. \
    /// value: The combined value of the pickups (in dollars). \
    /// amount: The number of pickups to spawn. \
    /// model: The model to use, or 0 for default money model.
    /// 
    /// Example: \
    /// CREATE_MONEY_PICKUPS(x, y, z, 1000, 3, 0x684a97ae);
    /// 
    /// Spawns 3 spray cans that'll collectively give $1000 when picked up. (Three spray cans, each giving $334, $334, $332 = $1000).
    /// 
    /// ==============================================
    /// 
    /// Max is 2000 in MP. So if you put the amount to 20, but the value to $400,000 eg. They will only be able to pickup 20 - $2,000 bags. So, $40,000
    pub inline fn createMoneyPickups(vec: types.Vector3, value: c_int, amount: c_int, model: types.Hash) !void { try invoker.invoke(void, 0x0589B5E791CE9B2B, .{vec.x, vec.y, vec.z, value, amount, model}); } // 0x0589B5E791CE9B2B 0x36C9A5EA b323
    pub inline fn doesPickupExist(pickup: types.Pickup) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAFC1CA75AD4074D1, .{pickup}); } // 0xAFC1CA75AD4074D1 0x9C6DA0B3 b323
    pub inline fn doesPickupObjectExist(pickup_object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD9EFB6DBF7DAAEA3, .{pickup_object}); } // 0xD9EFB6DBF7DAAEA3 0xE0B32108 b323
    pub inline fn getPickupObject(pickup: types.Pickup) !types.Object { return try invoker.invoke(types.Object, 0x5099BC55630B25AE, .{pickup}); } // 0x5099BC55630B25AE 0x6052E62E b323
    pub inline fn isObjectAPickup(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFC481C641EBBD27D, .{object}); } // 0xFC481C641EBBD27D 0x93D23399 b1365
    pub inline fn isObjectAPortablePickup(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0378C08504160D0D, .{object}); } // 0x0378C08504160D0D 0x0F0E94FF b323
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn doesPickupOfTypeExistInArea(pickup_hash: types.Hash, vec: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF9C36251F6E48E33, .{pickup_hash, vec.x, vec.y, vec.z, radius}); } // 0xF9C36251F6E48E33 0xF139681B b323
    pub inline fn setPickupRegenerationTime(pickup: types.Pickup, duration: c_int) !void { try invoker.invoke(void, 0x78015C9B4B3ECC9D, .{pickup, duration}); } // 0x78015C9B4B3ECC9D 0xAB11267D b323
    pub inline fn forcePickupRegenerate(p_0: types.Any) !void { try invoker.invoke(void, 0x758A5C1B3B1E1990, .{p_0}); } // 0x758A5C1B3B1E1990  b1011
    /// Disabling/enabling a player from getting pickups. From the scripts:
    /// 
    /// OBJECT::SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 0); \
    /// OBJECT::SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 0); \
    /// OBJECT::SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 1); \
    /// OBJECT::SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE(PLAYER::PLAYER_ID(), ${pickup_portable_package}, 0); \
    /// OBJECT::SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE(PLAYER::PLAYER_ID(), ${pickup_armour_standard}, 0); \
    /// OBJECT::SET_PLAYER_PERMITTED_TO_COLLECT_PICKUPS_OF_TYPE(PLAYER::PLAYER_ID(), ${pickup_armour_standard}, 1);
    /// 
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn setPlayerPermittedToCollectPickupsOfType(player: types.Player, pickup_hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x616093EC6B139DD9, .{player, pickup_hash, toggle}); } // 0x616093EC6B139DD9 0x7FADB4B9 b323
    /// Maximum amount of pickup models that can be disallowed is 30.
    pub inline fn setLocalPlayerPermittedToCollectPickupsWithModel(model_hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x88EAEC617CD26926, .{model_hash, toggle}); } // 0x88EAEC617CD26926 0x3A8F1BF7 b323
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn allowAllPlayersToCollectPickupsOfType(pickup_hash: types.Hash) !void { try invoker.invoke(void, 0xFDC07C58E8AAB715, .{pickup_hash}); } // 0xFDC07C58E8AAB715  b1734
    pub inline fn setTeamPickupObject(object: types.Object, p_1: types.Any, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x53E0DF1A2A3CF0CA, .{object, p_1, p_2}); } // 0x53E0DF1A2A3CF0CA 0x77687DC5 b323
    pub inline fn preventCollectionOfPortablePickup(object: types.Object, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x92AEFB5F6E294023, .{object, p_1, p_2}); } // 0x92AEFB5F6E294023 0xCBB5F9B6 b323
    pub inline fn setPickupObjectGlowWhenUncollectable(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x27F248C3FEBFAAD3, .{pickup, toggle}); } // 0x27F248C3FEBFAAD3  b2372
    pub inline fn setPickupGlowDisabled_(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x08BD8BA5BDE2C2FA, .{pickup, toggle}); } // 0x08BD8BA5BDE2C2FA  b3407
    /// p1 is always 0.51. This native is called before SET_PICKUP_REGENERATION_TIME in all occurances.
    pub inline fn setPickupGlowOffset(pickup: types.Pickup, p_1: f32) !void { try invoker.invoke(void, 0x0596843B34B95CE5, .{pickup, p_1}); } // 0x0596843B34B95CE5  b505
    /// p1 is always -0.2 in scripts and p2 is always true in scripts.
    pub inline fn setPickupObjectGlowOffset(pickup: types.Pickup, p_1: f32, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xA08FE5E49BDC39DD, .{pickup, p_1, p_2}); } // 0xA08FE5E49BDC39DD 0x276A7807 b323
    pub inline fn setObjectGlowInSameTeam(pickup: types.Pickup) !void { try invoker.invoke(void, 0x62454A641B41F3C5, .{pickup}); } // 0x62454A641B41F3C5  b678
    pub inline fn setPickupObjectArrowMarker(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x39A5FB7EAF150840, .{pickup, toggle}); } // 0x39A5FB7EAF150840  b678
    pub inline fn allowPickupArrowMarkerWhenUncollectable(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x834344A414C7C85D, .{pickup, toggle}); } // 0x834344A414C7C85D  b2372
    pub inline fn getDefaultAmmoForWeaponPickup(pickup_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xDB41D07A45A6D4B7, .{pickup_hash}); } // 0xDB41D07A45A6D4B7 0x000E92DC b323
    pub inline fn setPickupGenerationRangeMultiplier(multiplier: f32) !void { try invoker.invoke(void, 0x318516E02DE3ECE2, .{multiplier}); } // 0x318516E02DE3ECE2 0x9879AC51 b323
    pub inline fn getPickupGenerationRangeMultiplier() !f32 { return try invoker.invoke(f32, 0xB3ECA65C7317F174, .{}); } // 0xB3ECA65C7317F174  b944
    pub inline fn setOnlyAllowAmmoCollectionWhenLow(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x31F924B53EADDF65, .{p_0}); } // 0x31F924B53EADDF65 0xDB18FA01 b323
    pub inline fn setPickupUncollectable(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1C1B69FAE509BA97, .{pickup, toggle}); } // 0x1C1B69FAE509BA97  b757
    pub inline fn setPickupTransparentWhenUncollectable(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x858EC9FD25DE04AA, .{pickup, toggle}); } // 0x858EC9FD25DE04AA  b757
    pub inline fn setPickupHiddenWhenUncollectable(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3ED2B83AB2E82799, .{pickup, toggle}); } // 0x3ED2B83AB2E82799  b757
    pub inline fn setPickupObjectTransparentWhenUncollectable(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8881C98A31117998, .{pickup, toggle}); } // 0x8881C98A31117998  b678
    /// p0 is either 0 or 50 in scripts.
    pub inline fn setPickupObjectAlphaWhenTransparent(p_0: c_int) !void { try invoker.invoke(void, 0x8CFF648FBD7330F1, .{p_0}); } // 0x8CFF648FBD7330F1  b757
    pub inline fn setPortablePickupPersist(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x46F3ADD1E2D5BAF2, .{pickup, toggle}); } // 0x46F3ADD1E2D5BAF2  b877
    pub inline fn allowPortablePickupToMigrateToNonParticipants(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x641F272B52E2F0F8, .{pickup, toggle}); } // 0x641F272B52E2F0F8  b877
    pub inline fn forceActivatePhysicsOnUnfixedPickup(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4C134B4DF76025D0, .{pickup, toggle}); } // 0x4C134B4DF76025D0  b1180
    pub inline fn allowPickupByNoneParticipant(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAA059C615DE9DD03, .{pickup, toggle}); } // 0xAA059C615DE9DD03  b1180
    /// enum ePickupRewardType \
    /// { \
    ///     PICKUP_REWARD_TYPE_AMMO = (1 << 0),
    ///     PICKUP_REWARD_TYPE_BULLET_MP = (1 << 1),
    ///     PICKUP_REWARD_TYPE_MISSILE_MP = (1 << 2),
    ///     PICKUP_REWARD_TYPE_GRENADE_LAUNCHER_MP = (1 << 3),
    ///     PICKUP_REWARD_TYPE_ARMOUR = (1 << 4),
    ///     PICKUP_REWARD_TYPE_HEALTH = (1 << 5),
    ///     PICKUP_REWARD_TYPE_HEALTH_VARIABLE = PICKUP_REWARD_TYPE_HEALTH,
    ///     PICKUP_REWARD_TYPE_MONEY_FIXED = (1 << 6),
    ///     PICKUP_REWARD_TYPE_MONEY_VARIABLE = PICKUP_REWARD_TYPE_MONEY_FIXED,
    ///     PICKUP_REWARD_TYPE_WEAPON = (1 << 7),
    ///     PICKUP_REWARD_TYPE_STAT = (1 << 8),
    ///     PICKUP_REWARD_TYPE_STAT_VARIABLE = PICKUP_REWARD_TYPE_STAT,
    ///     PICKUP_REWARD_TYPE_VEHICLE_FIX = (1 << 9),
    ///     PICKUP_REWARD_TYPE_FIREWORK_MP = (1 << 10),
    /// };
    pub inline fn suppressPickupRewardType(reward_type: c_int, suppress: windows.BOOL) !void { try invoker.invoke(void, 0xF92099527DB8E2A7, .{reward_type, suppress}); } // 0xF92099527DB8E2A7 0xA7E936FD b323
    pub inline fn clearAllPickupRewardTypeSuppression() !void { try invoker.invoke(void, 0xA2C1F5E92AFE49ED, .{}); } // 0xA2C1F5E92AFE49ED 0xB241806C b323
    pub inline fn clearPickupRewardTypeSuppression(reward_type: c_int) !void { try invoker.invoke(void, 0x762DB2D380B48D04, .{reward_type}); } // 0x762DB2D380B48D04 0xD1BAAFB7 b323
    /// draws circular marker at pos \
    /// -1 = none \
    /// 0 = red \
    /// 1 = green \
    /// 2 = blue \
    /// 3 = green larger \
    /// 4 = nothing \
    /// 5 = green small
    pub inline fn renderFakePickupGlow(vec: types.Vector3, color_index: c_int) !void { try invoker.invoke(void, 0x3430676B11CDF21D, .{vec.x, vec.y, vec.z, color_index}); } // 0x3430676B11CDF21D 0x63B02FAD b323
    pub inline fn setPickupObjectCollectableInVehicle(pickup: types.Pickup) !void { try invoker.invoke(void, 0x7813E8B8C4AE4799, .{pickup}); } // 0x7813E8B8C4AE4799  b1734
    pub inline fn setPickupTrackDamageEvents(pickup: types.Pickup, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBFFE53AE7E67FCDC, .{pickup, toggle}); } // 0xBFFE53AE7E67FCDC  b1290
    /// Sets entity+38 to C (when false) or 0xFF3f (when true)
    pub inline fn setEntityFlagSuppressShadow(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD05A3241B9A86F19, .{entity, toggle}); } // 0xD05A3241B9A86F19  b1180
    pub inline fn setEntityFlagRenderSmallShadow(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB2D0BDE54F0E8E5A, .{object, toggle}); } // 0xB2D0BDE54F0E8E5A 0x132B6D92 b323
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn getWeaponTypeFromPickupType(pickup_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0x08F96CA6C551AD51, .{pickup_hash}); } // 0x08F96CA6C551AD51 0xEDD01937 b323
    /// Returns the pickup hash for the given weapon hash
    pub inline fn getPickupTypeFromWeaponHash(weapon_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0xD6429A016084F1A5, .{weapon_hash}); } // 0xD6429A016084F1A5  b1290
    pub inline fn isPickupWeaponObjectValid(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x11D1E53A726891FE, .{object}); } // 0x11D1E53A726891FE 0x883DAB2D b323
    pub inline fn getObjectTintIndex(object: types.Object) !c_int { return try invoker.invoke(c_int, 0xE84EB93729C5F36A, .{object}); } // 0xE84EB93729C5F36A  b757
    /// enum ObjectPaintVariants \
    /// { \
    ///  Pacific = 0, \
    ///   Azure = 1,
    ///     Nautical = 2,
    ///  Continental = 3, \
    ///   Battleship = 4,
    ///    Intrepid = 5,
    ///  Uniform = 6, \
    ///   Classico = 7,
    ///  Mediterranean = 8, \
    ///     Command = 9,
    ///   Mariner = 10,
    ///  Ruby = 11, \
    ///     Vintage = 12,
    ///  Pristine = 13, \
    ///     Merchant = 14,
    ///     Voyager = 15
    /// };
    pub inline fn setObjectTintIndex(object: types.Object, texture_variation: c_int) !void { try invoker.invoke(void, 0x971DA0055324D033, .{object, texture_variation}); } // 0x971DA0055324D033  b323
    pub inline fn setTintIndexClosestBuildingOfType(vec: types.Vector3, radius: f32, model_hash: types.Hash, texture_variation: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF12E33034D887F66, .{vec.x, vec.y, vec.z, radius, model_hash, texture_variation}); } // 0xF12E33034D887F66  b1103
    pub inline fn setPropTintIndex(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x31574B1B41268673, .{p_0, p_1}); } // 0x31574B1B41268673  b2189
    pub inline fn setPropLightColor(object: types.Object, p_1: windows.BOOL, r: c_int, g: c_int, b: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5F048334B4A4E774, .{object, p_1, r, g, b}); } // 0x5F048334B4A4E774  b1493
    pub inline fn isPropLightOverriden(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xADF084FB8F075D06, .{object}); } // 0xADF084FB8F075D06  b1604
    pub inline fn setObjectIsVisibleInMirrors(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3B2FD68DB5F8331C, .{object, toggle}); } // 0x3B2FD68DB5F8331C  b757
    pub inline fn setObjectSpeedBoostAmount(object: types.Object, p_1: types.Any) !void { try invoker.invoke(void, 0x96EE0EBA0163DF80, .{object, p_1}); } // 0x96EE0EBA0163DF80  b791
    pub inline fn setObjectSpeedBoostDuration(object: types.Object, duration: f32) !void { try invoker.invoke(void, 0xDF6CA0330F2E737B, .{object, duration}); } // 0xDF6CA0330F2E737B  b791
    /// returns pickup hash.
    /// 
    /// Full list of pickup types by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pickupTypes.json
    pub inline fn convertOldPickupTypeToNew(pickup_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0x5EAAD83F8CFB4575, .{pickup_hash}); } // 0x5EAAD83F8CFB4575 0x6AE36192 b323
    pub inline fn setForceObjectThisFrame(vec: types.Vector3, p_3: f32) !void { try invoker.invoke(void, 0xF538081986E49E9D, .{vec.x, vec.y, vec.z, p_3}); } // 0xF538081986E49E9D 0x3DA41C1A b323
    pub inline fn onlyCleanUpObjectWhenOutOfRange(object: types.Object) !void { try invoker.invoke(void, 0xADBE4809F19F927A, .{object}); } // 0xADBE4809F19F927A 0x2048A7DD b323
    pub inline fn setDisableCollisionsBetweenCarsAndCarParachute(p_0: types.Any) !void { try invoker.invoke(void, 0x8CAAB2BD3EA58BD4, .{p_0}); } // 0x8CAAB2BD3EA58BD4  b1011
    pub inline fn setProjectilesShouldExplodeOnContact(entity: types.Entity, p_1: types.Any) !void { try invoker.invoke(void, 0x63ECF581BC70E363, .{entity, p_1}); } // 0x63ECF581BC70E363  b1365
    /// Activate the physics to: "xs_prop_arena_{flipper,wall,bollard,turntable,pit}"
    pub inline fn setDriveArticulatedJoint(object: types.Object, toggle: windows.BOOL, p_2: c_int) !void { try invoker.invoke(void, 0x911024442F4898F0, .{object, toggle, p_2}); } // 0x911024442F4898F0  b1604
    pub inline fn setDriveArticulatedJointWithInflictor(object: types.Object, toggle: windows.BOOL, p_2: c_int, ped: types.Ped) !void { try invoker.invoke(void, 0xB20834A7DD3D8896, .{object, toggle, p_2, ped}); } // 0xB20834A7DD3D8896  b1604
    pub inline fn setObjectIsAPressurePlate(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x734E1714D077DA9A, .{object, toggle}); } // 0x734E1714D077DA9A  b1604
    pub inline fn setWeaponImpactsApplyGreaterForce(object: types.Object, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x1A6CBB06E2D0D79D, .{object, p_1}); } // 0x1A6CBB06E2D0D79D  b1604
    pub inline fn getIsArticulatedJointAtMinAngle(object: types.Object, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x43C677F1E1158005, .{object, p_1}); } // 0x43C677F1E1158005  b1604
    pub inline fn getIsArticulatedJointAtMaxAngle(p_0: types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3BD770D281982DB5, .{p_0, p_1}); } // 0x3BD770D281982DB5  b1604
    pub inline fn setIsObjectArticulated(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1C57C94A6446492A, .{object, toggle}); } // 0x1C57C94A6446492A  b1604
    pub inline fn setIsObjectBall(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB5B7742424BD4445, .{object, toggle}); } // 0xB5B7742424BD4445  b1604
};

pub const Pad = struct
{
    /// control: 0: PLAYER_CONTROL, 1: CAMERA_CONTROL, 2: FRONTEND_CONTROL \
    /// For more info, see https://docs.fivem.net/docs/game-references/controls/
    pub inline fn isControlEnabled(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1CEA6BFDF248E5D9, .{control, action}); } // 0x1CEA6BFDF248E5D9 0x9174AF84 b323
    /// Returns whether a control is currently pressed. \
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isControlPressed(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF3A21BCD95725A4A, .{control, action}); } // 0xF3A21BCD95725A4A 0x517A4384 b323
    /// Returns whether a control is currently _not_ pressed. \
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isControlReleased(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x648EE3E7F38877DD, .{control, action}); } // 0x648EE3E7F38877DD 0x1F91A06E b323
    /// Returns whether a control was newly pressed since the last check. \
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isControlJustPressed(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x580417101DDB492F, .{control, action}); } // 0x580417101DDB492F 0x4487F579 b323
    /// Returns whether a control was newly released since the last check. \
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isControlJustReleased(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x50F940259D3841E6, .{control, action}); } // 0x50F940259D3841E6 0x2314444B b323
    pub inline fn isControlHeldDown_(control: c_int, action: c_int, duration: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE9CB8C56E90D5079, .{control, action, duration}); } // 0xE9CB8C56E90D5079  b3407
    /// control: see IS_CONTROL_ENABLED
    pub inline fn getControlValue(control: c_int, action: c_int) !c_int { return try invoker.invoke(c_int, 0xD95E79E8686D2C27, .{control, action}); } // 0xD95E79E8686D2C27 0xC526F3C6 b323
    /// Returns the value of GET_CONTROL_VALUE normalized (i.e. a real number value between -1 and 1)
    /// 
    /// control: see IS_CONTROL_ENABLED
    pub inline fn getControlNormal(control: c_int, action: c_int) !f32 { return try invoker.invoke(f32, 0xEC3C9B8D5327B563, .{control, action}); } // 0xEC3C9B8D5327B563 0x5DE226A5 b323
    pub inline fn setUseAdjustedMouseCoords(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5B73C77D9EB66E24, .{toggle}); } // 0x5B73C77D9EB66E24  b323
    /// Seems to return values between -1 and 1 for controls like gas and steering.
    /// 
    /// control: see IS_CONTROL_ENABLED
    pub inline fn getControlUnboundNormal(control: c_int, action: c_int) !f32 { return try invoker.invoke(f32, 0x5B84D09CEC5209C5, .{control, action}); } // 0x5B84D09CEC5209C5 0xC49343BB b323
    /// This is for simulating player input. \
    /// value is a float value from 0 - 1
    /// 
    /// control: see IS_CONTROL_ENABLED
    pub inline fn setControlValueNextFrame(control: c_int, action: c_int, value: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE8A25867FBA3B05E, .{control, action, value}); } // 0xE8A25867FBA3B05E  b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isDisabledControlPressed(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE2587F8CBBD87B1D, .{control, action}); } // 0xE2587F8CBBD87B1D 0x32A93544 b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isDisabledControlReleased(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFB6C4072E9A32E92, .{control, action}); } // 0xFB6C4072E9A32E92  b757
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isDisabledControlJustPressed(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x91AEF906BCA88877, .{control, action}); } // 0x91AEF906BCA88877 0xEE6ABD32 b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isDisabledControlJustReleased(control: c_int, action: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x305C8DCD79DA8B0F, .{control, action}); } // 0x305C8DCD79DA8B0F 0xD6A679E1 b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn getDisabledControlNormal(control: c_int, action: c_int) !f32 { return try invoker.invoke(f32, 0x11E65974A982637C, .{control, action}); } // 0x11E65974A982637C 0x66FF4FAA b323
    /// The "disabled" variant of GET_CONTROL_UNBOUND_NORMAL.
    /// 
    /// control: see IS_CONTROL_ENABLED
    pub inline fn getDisabledControlUnboundNormal(control: c_int, action: c_int) !f32 { return try invoker.invoke(f32, 0x4F8A26A890FD62FB, .{control, action}); } // 0x4F8A26A890FD62FB 0xF2A65A4C b323
    /// Returns time in ms since last input.
    /// 
    /// control: see IS_CONTROL_ENABLED
    pub inline fn getControlHowLongAgo(control: c_int) !c_int { return try invoker.invoke(c_int, 0xD7D22F5592AED8BA, .{control}); } // 0xD7D22F5592AED8BA 0x0E8EF929 b323
    /// control: unused parameter
    pub inline fn isUsingKeyboardAndMouse(control: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA571D46727E2B718, .{control}); } // 0xA571D46727E2B718  b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn isUsingCursor(control: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x13337B38DB572509, .{control}); } // 0x13337B38DB572509  b323
    pub inline fn setCursorPosition(vec: types.Vector2) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFC695459D4D0E219, .{vec.x, vec.y}); } // 0xFC695459D4D0E219  b323
    /// control: see IS_CONTROL_ENABLED
    /// 
    /// Hardcoded to return false.
    pub inline fn isUsingRemotePlay(control: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x23F09EADC01449D6, .{control}); } // 0x23F09EADC01449D6  b323
    /// control: unused parameter
    pub inline fn haveControlsChanged(control: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6CD79468A1E595C6, .{control}); } // 0x6CD79468A1E595C6  b323
    /// allowXOSwap appears to always be true.
    /// 
    /// EG: \
    /// GET_CONTROL_INSTRUCTIONAL_BUTTON (2, 201, 1) /*INPUT_FRONTEND_ACCEPT (e.g. Enter button)*/ \
    /// GET_CONTROL_INSTRUCTIONAL_BUTTON (2, 202, 1) /*INPUT_FRONTEND_CANCEL (e.g. ESC button)*/ \
    /// GET_CONTROL_INSTRUCTIONAL_BUTTON (2, 51, 1) /*INPUT_CONTEXT (e.g. E button)*/
    /// 
    /// gtaforums.com/topic/819070-c-draw-instructional-buttons-scaleform-movie/#entry1068197378
    /// 
    /// control: unused parameter
    pub inline fn getControlInstructionalButtonsString(control: c_int, action: c_int, allow_x_o_swap: windows.BOOL) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x0499D7B09FC9B407, .{control, action, allow_x_o_swap}); } // 0x0499D7B09FC9B407  b323
    /// control: unused parameter
    pub inline fn getControlGroupInstructionalButtonsString(control: c_int, control_group: c_int, allow_x_o_swap: windows.BOOL) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x80C2FD58D720C801, .{control, control_group, allow_x_o_swap}); } // 0x80C2FD58D720C801  b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn setControlLightEffectColor(control: c_int, red: c_int, green: c_int, blue: c_int) !void { try invoker.invoke(void, 0x8290252FFF36ACB5, .{control, red, green, blue}); } // 0x8290252FFF36ACB5  b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn clearControlLightEffect(control: c_int) !void { try invoker.invoke(void, 0xCB0360EFEFB2580D, .{control}); } // 0xCB0360EFEFB2580D  b323
    /// control: see IS_CONTROL_ENABLED \
    /// duration in milliseconds  \
    /// frequency should range from about 10 (slow vibration) to 255 (very fast)
    /// 
    /// example: \
    /// SET_CONTROL_SHAKE(PLAYER_CONTROL, 100, 200);
    pub inline fn setControlShake(control: c_int, duration: c_int, frequency: c_int) !void { try invoker.invoke(void, 0x48B3886C1358D0D5, .{control, duration, frequency}); } // 0x48B3886C1358D0D5  b323
    /// Does nothing (it's a nullsub).
    pub inline fn setControlTriggerShake(control: c_int, left_duration: c_int, left_frequency: c_int, right_duration: c_int, right_frequency: c_int) !void { try invoker.invoke(void, 0x14D29BB12D47F68C, .{control, left_duration, left_frequency, right_duration, right_frequency}); } // 0x14D29BB12D47F68C  b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn stopControlShake(control: c_int) !void { try invoker.invoke(void, 0x38C16A305E8CDC8D, .{control}); } // 0x38C16A305E8CDC8D  b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn setControlShakeSuppressedId(control: c_int, unique_id: c_int) !void { try invoker.invoke(void, 0xF239400E16C23E08, .{control, unique_id}); } // 0xF239400E16C23E08  b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn clearControlShakeSuppressedId(control: c_int) !void { try invoker.invoke(void, 0xA0CEFCEA390AAB9B, .{control}); } // 0xA0CEFCEA390AAB9B  b323
    pub inline fn isLookInverted() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x77B612531280010D, .{}); } // 0x77B612531280010D 0x313434B2 b323
    /// Used with IS_LOOK_INVERTED() and negates its affect.
    /// 
    /// --
    /// 
    /// Not sure how the person above got that description, but here's an actual example:
    /// 
    /// if (PAD::IS_USING_KEYBOARD_AND_MOUSE(2)) { \
    ///     if (a_5) {
    ///         if (PAD::IS_LOOK_INVERTED()) {
    ///             a_3 *= -1;
    ///         }
    ///         if (PAD::IS_MOUSE_LOOK_INVERTED()) {
    ///             a_3 *= -1;
    ///         }
    ///     }
    /// }
    pub inline fn isMouseLookInverted() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE1615EC03B3BB4FD, .{}); } // 0xE1615EC03B3BB4FD  b323
    /// Hard-coded to return 3 if using KBM, otherwise same behavior as GET_LOCAL_PLAYER_GAMEPAD_AIM_STATE.
    pub inline fn getLocalPlayerAimState() !c_int { return try invoker.invoke(c_int, 0xBB41AFBBBC0A0287, .{}); } // 0xBB41AFBBBC0A0287 0x81802053 b323
    /// Returns the local player's targeting mode. See PLAYER::SET_PLAYER_TARGETING_MODE.
    pub inline fn getLocalPlayerGamepadAimState() !c_int { return try invoker.invoke(c_int, 0x59B9A7AF4C95133C, .{}); } // 0x59B9A7AF4C95133C  b323
    pub inline fn getIsUsingAlternateHandbrake() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x25AAA32BDC98F2A3, .{}); } // 0x25AAA32BDC98F2A3  b1365
    /// Returns profile setting 225.
    pub inline fn getIsUsingAlternateDriveby() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0F70731BACCFBB96, .{}); } // 0x0F70731BACCFBB96 0xC1AFABD5 b323
    /// Returns profile setting 17.
    pub inline fn getAllowMovementWhileZoomed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFC859E2374407556, .{}); } // 0xFC859E2374407556 0xC0823820 b323
    pub inline fn setPlayerpadShakesWhenControllerDisabled(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x798FDEB5B1575088, .{toggle}); } // 0x798FDEB5B1575088 0xA86BD91F b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn setInputExclusive(control: c_int, action: c_int) !void { try invoker.invoke(void, 0xEDE476E5EE29EDB1, .{control, action}); } // 0xEDE476E5EE29EDB1 0x4E8E29E6 b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn disableControlAction(control: c_int, action: c_int, disable_related_actions: windows.BOOL) !void { try invoker.invoke(void, 0xFE99B66D079CF6BC, .{control, action, disable_related_actions}); } // 0xFE99B66D079CF6BC 0x3800C0DC b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn enableControlAction(control: c_int, action: c_int, enable_related_actions: windows.BOOL) !void { try invoker.invoke(void, 0x351220255D64C155, .{control, action, enable_related_actions}); } // 0x351220255D64C155 0xD2753551 b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn disableAllControlActions(control: c_int) !void { try invoker.invoke(void, 0x5F4B6931816E599B, .{control}); } // 0x5F4B6931816E599B 0x16753CF4 b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn enableAllControlActions(control: c_int) !void { try invoker.invoke(void, 0xA5FFE9B05F199DE7, .{control}); } // 0xA5FFE9B05F199DE7 0xFC2F119F b323
    /// Used in carsteal3 script with schemeName = "Carsteal4_spycar".
    pub inline fn initPcScriptedControls(scheme_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3D42B92563939375, .{scheme_name}); } // 0x3D42B92563939375 0xD2C80B2E b323
    /// Same as INIT_PC_SCRIPTED_CONTROLS
    pub inline fn switchPcScriptedControls(scheme_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4683149ED1DDE7A1, .{scheme_name}); } // 0x4683149ED1DDE7A1 0xBBFC9050 b323
    pub inline fn shutdownPcScriptedControls() !void { try invoker.invoke(void, 0x643ED62D5EA3BEBD, .{}); } // 0x643ED62D5EA3BEBD 0x42140FF9 b323
    /// control: see IS_CONTROL_ENABLED
    pub inline fn allowAlternativeScriptControlsLayout(control: c_int) !void { try invoker.invoke(void, 0x7F4724035FDCA1DD, .{control}); } // 0x7F4724035FDCA1DD 0x2CEDE6C5 b323
    /// Always returns zero.
    pub inline fn getGamepadType_() !c_int { return try invoker.invoke(c_int, 0x18E474F40EF05F10, .{}); } // 0x18E474F40EF05F10  b3570
};

pub const Pathfind = struct
{
    /// When nodeEnabled is set to false, all nodes in the area get disabled. \
    /// `GET_VEHICLE_NODE_IS_SWITCHED_OFF` returns true afterwards. \
    /// If it's true, `GET_VEHICLE_NODE_IS_SWITCHED_OFF` returns false.
    pub inline fn setRoadsInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, node_enabled: windows.BOOL, unknown_2: windows.BOOL) !void { try invoker.invoke(void, 0xBF1A602B5BA52FEE, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, node_enabled, unknown_2}); } // 0xBF1A602B5BA52FEE 0xEBC7B918 b323
    /// unknown3 is related to `SEND_SCRIPT_WORLD_STATE_EVENT > CNetworkRoadNodeWorldStateData` in networked environments. \
    /// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area.
    pub inline fn setRoadsInAngledArea(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, unknown_1: windows.BOOL, unknown_2: windows.BOOL, unknown_3: windows.BOOL) !void { try invoker.invoke(void, 0x1A5AA1208AF5DB59, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, unknown_1, unknown_2, unknown_3}); } // 0x1A5AA1208AF5DB59 0xBD088F4B b323
    pub inline fn setPedPathsInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, p_6: windows.BOOL, p_7: types.Any) !void { try invoker.invoke(void, 0x34F060F4BF92E018, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_6, p_7}); } // 0x34F060F4BF92E018 0x2148EA84 b323
    /// Flags are: \
    /// 1 = 1 = B02_IsFootpath \
    /// 2 = 4 = !B15_InteractionUnk \
    /// 4 = 0x20 = !B14_IsInterior \
    /// 8 = 0x40 = !B07_IsWater \
    /// 16 = 0x200 = B17_IsFlatGround \
    /// When onGround == true outPosition is a position located on the nearest pavement.
    /// 
    /// When a safe coord could not be found the result of a function is false and outPosition == Vector3.Zero.
    /// 
    /// In the scripts these flags are used: 0, 14, 12, 16, 20, 21, 28. 0 is most commonly used, then 16. 
    /// 
    /// 16 works for me, 0 crashed the script.
    pub inline fn getSafeCoordForPed(vec: types.Vector3, on_ground: windows.BOOL, out_position: [*c]types.Vector3, flags: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB61C8E878A4199CA, .{vec.x, vec.y, vec.z, on_ground, out_position, flags}); } // 0xB61C8E878A4199CA 0xB370270A b323
    /// https://gtaforums.com/topic/843561-pathfind-node-types
    pub inline fn getClosestVehicleNode(vec: types.Vector3, out_position: [*c]types.Vector3, node_flags: c_int, p_5: f32, p_6: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x240A18690AE96513, .{vec.x, vec.y, vec.z, out_position, node_flags, p_5, p_6}); } // 0x240A18690AE96513 0x6F5F1E6C b323
    /// Get the closest vehicle node to a given position.
    pub inline fn getClosestMajorVehicleNode(vec: types.Vector3, out_position: [*c]types.Vector3, unknown_1: f32, unknown_2: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2EABE3B06F58C1BE, .{vec.x, vec.y, vec.z, out_position, unknown_1, unknown_2}); } // 0x2EABE3B06F58C1BE 0x04B5F15B b323
    /// p5, p6 and p7 seems to be about the same as p4, p5 and p6 for GET_CLOSEST_VEHICLE_NODE. p6 and/or p7 has something to do with finding a node on the same path/road and same direction(at least for this native, something to do with the heading maybe). Edit this when you find out more.
    /// 
    /// nodeType: 0 = main roads, 1 = any dry path, 3 = water \
    /// p6 is always 3.0 \
    /// p7 is always 0
    /// 
    /// gtaforums.com/topic/843561-pathfind-node-types
    /// 
    /// Example of usage, moving vehicle to closest path/road: \
    /// Vector3 coords = ENTITY::GET_ENTITY_COORDS(playerVeh, true); \
    /// Vector3 closestVehicleNodeCoords;  \
    /// float roadHeading;  \
    /// PATHFIND::GET_CLOSEST_VEHICLE_NODE_WITH_HEADING(coords.x, coords.y, coords.z, &closestVehicleNodeCoords, &roadHeading, 1, 3, 0);  \
    /// ENTITY::SET_ENTITY_HEADING(playerVeh, roadHeading); \
    /// ENTITY::SET_ENTITY_COORDS(playerVeh, closestVehicleNodeCoords.x, closestVehicleNodeCoords.y, closestVehicleNodeCoords.z, 1, 0, 0, 1); \
    /// VEHICLE::SET_VEHICLE_ON_GROUND_PROPERLY(playerVeh);
    /// 
    /// ------------------------------------------------------------------ \
    /// C# Example (ins1de) : https://pastebin.com/fxtMWAHD
    pub inline fn getClosestVehicleNodeWithHeading(vec: types.Vector3, out_position: [*c]types.Vector3, out_heading: [*c]f32, node_type: c_int, p_6: f32, p_7: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFF071FB798B803B0, .{vec.x, vec.y, vec.z, out_position, out_heading, node_type, p_6, p_7}); } // 0xFF071FB798B803B0 0x8BD5759B b323
    pub inline fn getNthClosestVehicleNode(vec: types.Vector3, nth_closest: c_int, out_position: [*c]types.Vector3, node_flags: c_int, unknown_1: f32, unknown_2: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE50E52416CCF948B, .{vec.x, vec.y, vec.z, nth_closest, out_position, node_flags, unknown_1, unknown_2}); } // 0xE50E52416CCF948B 0xF125BFCC b323
    /// Returns the id.
    pub inline fn getNthClosestVehicleNodeId(vec: types.Vector3, nth: c_int, node_flags: c_int, p_5: f32, p_6: f32) !c_int { return try invoker.invoke(c_int, 0x22D7275A79FE8215, .{vec.x, vec.y, vec.z, nth, node_flags, p_5, p_6}); } // 0x22D7275A79FE8215 0x3F358BEA b323
    /// Get the nth closest vehicle node and its heading.
    pub inline fn getNthClosestVehicleNodeWithHeading(vec: types.Vector3, nth_closest: c_int, out_position: [*c]types.Vector3, out_heading: [*c]f32, out_num_lanes: [*c]c_int, node_flags: c_int, unknown_3: f32, unknown_4: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x80CA6A8B6C094CC4, .{vec.x, vec.y, vec.z, nth_closest, out_position, out_heading, out_num_lanes, node_flags, unknown_3, unknown_4}); } // 0x80CA6A8B6C094CC4 0x7349C856 b323
    pub inline fn getNthClosestVehicleNodeIdWithHeading(vec: types.Vector3, nth_closest: c_int, out_position: [*c]types.Vector3, out_heading: [*c]f32, node_flags: c_int, p_7: f32, p_8: f32) !c_int { return try invoker.invoke(c_int, 0x6448050E9C2A7207, .{vec.x, vec.y, vec.z, nth_closest, out_position, out_heading, node_flags, p_7, p_8}); } // 0x6448050E9C2A7207 0xC1AEB88D b323
    /// See gtaforums.com/topic/843561-pathfind-node-types for node type info. 0 = paved road only, 1 = any road, 3 = water
    /// 
    /// p10 always equals 3.0 \
    /// p11 always equals 0
    pub inline fn getNthClosestVehicleNodeFavourDirection(vec: types.Vector3, desired__: types.Vector3, nth_closest: c_int, out_position: [*c]types.Vector3, out_heading: [*c]f32, node_flags: c_int, p_1_0: f32, p_1_1: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x45905BE8654AE067, .{vec.x, vec.y, vec.z, desired__.x, desired__.y, desired__.z, nth_closest, out_position, out_heading, node_flags, p_1_0, p_1_1}); } // 0x45905BE8654AE067 0x928A4DEC b323
    /// Gets the density and flags of the closest node to the specified position. \
    /// Density is a value between 0 and 15, indicating how busy the road is. \
    /// Flags is a bit field.
    pub inline fn getVehicleNodeProperties(vec: types.Vector3, density: [*c]c_int, flags: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0568566ACBB5DEDC, .{vec.x, vec.y, vec.z, density, flags}); } // 0x0568566ACBB5DEDC 0xCC90110B b323
    /// Returns true if the id is non zero.
    pub inline fn isVehicleNodeIdValid(vehicle_node_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1EAF30FCFBF5AF74, .{vehicle_node_id}); } // 0x1EAF30FCFBF5AF74 0x57DFB1EF b323
    /// Calling this with an invalid node id, will crash the game. \
    /// Note that IS_VEHICLE_NODE_ID_VALID simply checks if nodeId is not zero. It does not actually ensure that the id is valid. \
    /// Eg. IS_VEHICLE_NODE_ID_VALID(1) will return true, but will crash when calling GET_VEHICLE_NODE_POSITION().
    pub inline fn getVehicleNodePosition(node_id: c_int, out_position: [*c]types.Vector3) !void { try invoker.invoke(void, 0x703123E5E7D429C2, .{node_id, out_position}); } // 0x703123E5E7D429C2 0xE38E252D b323
    /// Returns false for nodes that aren't used for GPS routes. \
    /// Example: \
    /// Nodes in Fort Zancudo and LSIA are false
    pub inline fn getVehicleNodeIsGpsAllowed(node_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA2AE5C478B96E3B6, .{node_i_d}); } // 0xA2AE5C478B96E3B6 0xEE4B1219 b323
    /// Returns true when the node is Offroad. Alleys, some dirt roads, and carparks return true. \
    /// Normal roads where plenty of Peds spawn will return false
    pub inline fn getVehicleNodeIsSwitchedOff(node_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4F5070AA58F69279, .{node_i_d}); } // 0x4F5070AA58F69279 0x56737A3C b323
    /// p1 seems to be always 1.0f in the scripts
    pub inline fn getClosestRoad(vec: types.Vector3, p_3: f32, p_4: c_int, p_5: [*c]types.Vector3, p_6: [*c]types.Vector3, p_7: [*c]types.Any, p_8: [*c]types.Any, p_9: [*c]f32, p_1_0: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x132F52BBA570FE92, .{vec.x, vec.y, vec.z, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0}); } // 0x132F52BBA570FE92 0x567B0E11 b323
    pub inline fn loadAllPathNodes(set: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC2AB6BFE34E92F8B, .{set}); } // 0xC2AB6BFE34E92F8B  b2802
    pub inline fn setAllowStreamPrologueNodes(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x228E5C6AD4D74BFD, .{toggle}); } // 0x228E5C6AD4D74BFD 0xD6A3B458 b323
    /// Activates Cayo Perico path nodes if passed `1`. GPS navigation will start working, maybe more stuff will change, not sure. It seems if you try to unload (pass `0`) when close to the island, your game might crash.
    pub inline fn setAllowStreamHeistIslandNodes(@"type": c_int) !void { try invoker.invoke(void, 0xF74B1FFA4A15FBEA, .{@"type"}); } // 0xF74B1FFA4A15FBEA  b2189
    pub inline fn areNodesLoadedForArea(vec_1__: types.Vector2, vec_2__: types.Vector2) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF7B79A50B905A30D, .{vec_1__.x, vec_1__.y, vec_2__.x, vec_2__.y}); } // 0xF7B79A50B905A30D 0x86E80A17 b323
    /// Used internally for long range tasks
    pub inline fn requestPathNodesInAreaThisFrame(vec_1__: types.Vector2, vec_2__: types.Vector2) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x07FB139B592FA687, .{vec_1__.x, vec_1__.y, vec_2__.x, vec_2__.y}); } // 0x07FB139B592FA687 0x2CDA5012 b323
    pub inline fn setRoadsBackToOriginal(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: types.Any) !void { try invoker.invoke(void, 0x1EE7063B80FFC77C, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x1EE7063B80FFC77C 0x86AC4A85 b323
    /// See IS_POINT_IN_ANGLED_AREA for the definition of an angled area. \
    /// bool p7 - always 1
    pub inline fn setRoadsBackToOriginalInAngledArea(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, p_7: types.Any) !void { try invoker.invoke(void, 0x0027501B9F3B407E, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, p_7}); } // 0x0027501B9F3B407E 0x9DB5D209 b323
    pub inline fn setAmbientPedRangeMultiplierThisFrame(multiplier: f32) !void { try invoker.invoke(void, 0x0B919E1FB47CC4E0, .{multiplier}); } // 0x0B919E1FB47CC4E0 0x3C5085E4 b323
    pub inline fn adjustAmbientPedSpawnDensitiesThisFrame(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !void { try invoker.invoke(void, 0xAA76052DDA9BFC3E, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0xAA76052DDA9BFC3E 0xD0F51299 b323
    /// p6 is always 0
    pub inline fn setPedPathsBackToOriginal(vec_1__: types.Vector3, vec_2__: types.Vector3, p_6: types.Any) !void { try invoker.invoke(void, 0xE04B48F2CC926253, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_6}); } // 0xE04B48F2CC926253 0x3F1ABDA4 b323
    pub inline fn getRandomVehicleNode(vec: types.Vector3, radius: f32, p_4: windows.BOOL, p_5: windows.BOOL, p_6: windows.BOOL, out_position: [*c]types.Vector3, node_id: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x93E0DB8440B73A7D, .{vec.x, vec.y, vec.z, radius, p_4, p_5, p_6, out_position, node_id}); } // 0x93E0DB8440B73A7D 0xAD1476EA b323
    pub inline fn getSpawnCoordsForVehicleNode(node_address: c_int, towardscoors__: types.Vector3, centre_point: [*c]types.Vector3, heading: [*c]f32) !void { try invoker.invoke(void, 0x809549AFC7AEC597, .{node_address, towardscoors__.x, towardscoors__.y, towardscoors__.z, centre_point, heading}); } // 0x809549AFC7AEC597  b2944
    /// Determines the name of the street which is the closest to the given coordinates.
    /// 
    /// x,y,z - the coordinates of the street \
    /// streetName - returns a hash to the name of the street the coords are on \
    /// crossingRoad - if the coordinates are on an intersection, a hash to the name of the crossing road
    /// 
    /// Note: the names are returned as hashes, the strings can be returned using the function HUD::GET_STREET_NAME_FROM_HASH_KEY.
    pub inline fn getStreetNameAtCoord(vec: types.Vector3, street_name: [*c]types.Hash, crossing_road: [*c]types.Hash) !void { try invoker.invoke(void, 0x2EB41072B4C1E4C0, .{vec.x, vec.y, vec.z, street_name, crossing_road}); } // 0x2EB41072B4C1E4C0 0xDEBEEFCF b323
    /// p3 is 0 in the only game script occurrence (trevor3) but 1 doesn't seem to make a difference
    /// 
    /// distToNxJunction seems to be the distance in metres * 10.0f
    /// 
    /// direction: \
    /// 0 = This happens randomly during the drive for seemingly no reason but if you consider that this native is only used in trevor3, it seems to mean "Next frame, stop whatever's being said and tell the player the direction." \
    /// 1 = Route is being calculated or the player is going in the wrong direction \
    /// 2 = Please Proceed the Highlighted Route \
    /// 3 = In (distToNxJunction) Turn Left \
    /// 4 = In (distToNxJunction) Turn Right \
    /// 5 = In (distToNxJunction) Keep Straight \
    /// 6 = In (distToNxJunction) Turn Sharply To The Left \
    /// 7 = In (distToNxJunction) Turn Sharply To The Right \
    /// 8 = Route is being recalculated or the navmesh is confusing. This happens randomly during the drive but consistently at {2044.0358, 2996.6116, 44.9717} if you face towards the bar and the route needs you to turn right. In that particular case, it could be a bug with how the turn appears to be 270 deg. CCW instead of "right." Either way, this seems to be the engine saying "I don't know the route right now."
    /// 
    /// return value set to 0 always
    pub inline fn generateDirectionsToCoord(vec: types.Vector3, p_3: windows.BOOL, direction: [*c]c_int, p_5: [*c]f32, dist_to_nx_junction: [*c]f32) !c_int { return try invoker.invoke(c_int, 0xF90125F1F79ECDF8, .{vec.x, vec.y, vec.z, p_3, direction, p_5, dist_to_nx_junction}); } // 0xF90125F1F79ECDF8 0xED35C094 b323
    pub inline fn setIgnoreNoGpsFlag(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x72751156E7678833, .{toggle}); } // 0x72751156E7678833 0xB72CF194 b323
    /// See: SET_BLIP_ROUTE
    pub inline fn setIgnoreNoGpsFlagUntilFirstNormalNode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1FC289A0C3FF470F, .{toggle}); } // 0x1FC289A0C3FF470F 0x90DF7A4C b323
    pub inline fn setGpsDisabledZone(vec_1__: types.Vector3, vec_2__: types.Vector2, z_3: f32) !void { try invoker.invoke(void, 0xDC20483CD3DD5201, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, z_3}); } // 0xDC20483CD3DD5201 0x720B8073 b323
    pub inline fn getGpsBlipRouteLength() !c_int { return try invoker.invoke(c_int, 0xBBB45C3CF5C8AA85, .{}); } // 0xBBB45C3CF5C8AA85 0x4B770634 b323
    /// p3 can be 0, 1 or 2.
    pub inline fn getPosAlongGpsTypeRoute(result: [*c]types.Vector3, p_1: windows.BOOL, p_2: f32, p_3: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF3162836C28F9DA5, .{result, p_1, p_2, p_3}); } // 0xF3162836C28F9DA5  b505
    pub inline fn getGpsBlipRouteFound() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x869DAACBBE9FA006, .{}); } // 0x869DAACBBE9FA006 0x286F82CC b323
    pub inline fn getRoadBoundaryUsingHeading(vec: types.Vector3, heading: f32, out_position: [*c]types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0F8A7517A273C05, .{vec.x, vec.y, vec.z, heading, out_position}); } // 0xA0F8A7517A273C05 0x5E440AC7 b463
    pub inline fn getPositionBySideOfRoad(vec: types.Vector3, p_3: c_int, out_position: [*c]types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x16F46FB18C8009E4, .{vec.x, vec.y, vec.z, p_3, out_position}); } // 0x16F46FB18C8009E4 0xF6422F9A b323
    /// Gets a value indicating whether the specified position is on a road. \
    /// The vehicle parameter is not implemented (ignored).
    pub inline fn isPointOnRoad(vec: types.Vector3, vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x125BF4ABFC536B09, .{vec.x, vec.y, vec.z, vehicle}); } // 0x125BF4ABFC536B09 0xCF198055 b323
    /// Gets the next zone that has been disabled using SET_GPS_DISABLED_ZONE_AT_INDEX.
    pub inline fn getNextGpsDisabledZoneIndex() !c_int { return try invoker.invoke(c_int, 0xD3A6A0EF48823A8C, .{}); } // 0xD3A6A0EF48823A8C 0xBE92551F b323
    /// Disables the GPS route displayed on the minimap while within a certain zone (area). When in a disabled zone and creating a waypoint, the GPS route is not shown on the minimap until you are outside of the zone. When disabled, the direct distance is shown on minimap opposed to distance to travel. Seems to only work before setting a waypoint. \
    /// You can clear the disabled zone with CLEAR_GPS_DISABLED_ZONE_AT_INDEX.
    /// 
    /// **Setting a waypoint at the same coordinate:** \
    /// Disabled Zone: https://i.imgur.com/P9VUuxM.png \
    /// Enabled Zone (normal): https://i.imgur.com/BPi24aw.png
    pub inline fn setGpsDisabledZoneAtIndex(vec_1__: types.Vector3, vec_2__: types.Vector3, index: c_int) !void { try invoker.invoke(void, 0xD0BC1C6FB18EE154, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, index}); } // 0xD0BC1C6FB18EE154 0x98BDB311 b323
    /// Clears a disabled GPS route area from a certain index previously set using `SET_GPS_DISABLED_ZONE_AT_INDEX`.
    pub inline fn clearGpsDisabledZoneAtIndex(index: c_int) !void { try invoker.invoke(void, 0x2801D0012266DF07, .{index}); } // 0x2801D0012266DF07 0x59090745 b323
    pub inline fn addNavmeshRequiredRegion(vec: types.Vector2, radius: f32) !void { try invoker.invoke(void, 0x387EAD7EE42F6685, .{vec.x, vec.y, radius}); } // 0x387EAD7EE42F6685 0x12B086EA b323
    pub inline fn removeNavmeshRequiredRegions() !void { try invoker.invoke(void, 0x916F0A3CDEC3445E, .{}); } // 0x916F0A3CDEC3445E 0x637BB680 b323
    pub inline fn isNavmeshRequiredRegionInUse() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x705A844002B39DC0, .{}); } // 0x705A844002B39DC0  b944
    /// Set toggle true to disable navmesh. \
    /// Set toggle false to enable navmesh.
    pub inline fn disableNavmeshInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4C8872D8CDBE1B8B, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, toggle}); } // 0x4C8872D8CDBE1B8B 0x6E37F132 b323
    pub inline fn areAllNavmeshRegionsLoaded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8415D95B194A3AEA, .{}); } // 0x8415D95B194A3AEA 0x34C4E789 b323
    /// Returns whether navmesh for the region is loaded. The region is a rectangular prism defined by it's top left deepest corner to it's bottom right shallowest corner.
    /// 
    /// If you can re-word this so it makes more sense, please do. I'm horrible with words sometimes...
    pub inline fn isNavmeshLoadedInArea(vec_1__: types.Vector3, vec_2__: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF813C7E63F9062A5, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0xF813C7E63F9062A5 0x4C2BA99E b323
    pub inline fn getNumNavmeshesExistingInArea(vec_1__: types.Vector3, vec_2__: types.Vector3) !c_int { return try invoker.invoke(c_int, 0x01708E8DD3FF8C65, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x01708E8DD3FF8C65 0x76AFFBB5 b323
    pub inline fn addNavmeshBlockingObject(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: windows.BOOL, p_8: types.Any) !c_int { return try invoker.invoke(c_int, 0xFCD5C8E06E502F5A, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0xFCD5C8E06E502F5A 0x2952BA56 b323
    pub inline fn updateNavmeshBlockingObject(p_0: types.Any, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: types.Any) !void { try invoker.invoke(void, 0x109E99373F290687, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0x109E99373F290687 0x4E9776D0 b323
    pub inline fn removeNavmeshBlockingObject(p_0: types.Any) !void { try invoker.invoke(void, 0x46399A7895957C0E, .{p_0}); } // 0x46399A7895957C0E 0x098602B0 b323
    pub inline fn doesNavmeshBlockingObjectExist(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0EAEB0DB4B132399, .{p_0}); } // 0x0EAEB0DB4B132399 0x4B67D7EE b323
    /// Returns CGameWorldHeightMap's maximum Z value at specified point (grid node).
    pub inline fn getApproxHeightForPoint(vec: types.Vector2) !f32 { return try invoker.invoke(f32, 0x29C24BFBED8AB8FB, .{vec.x, vec.y}); } // 0x29C24BFBED8AB8FB 0x3FE8C5A0 b323
    /// Returns CGameWorldHeightMap's maximum Z among all grid nodes that intersect with the specified rectangle.
    pub inline fn getApproxHeightForArea(vec_1__: types.Vector2, vec_2__: types.Vector2) !f32 { return try invoker.invoke(f32, 0x8ABE8608576D9CE3, .{vec_1__.x, vec_1__.y, vec_2__.x, vec_2__.y}); } // 0x8ABE8608576D9CE3 0x3ED21C90 b323
    /// Returns CGameWorldHeightMap's minimum Z value at specified point (grid node).
    pub inline fn getApproxFloorForPoint(vec: types.Vector2) !f32 { return try invoker.invoke(f32, 0x336511A34F2E5185, .{vec.x, vec.y}); } // 0x336511A34F2E5185 0xA07C5B7D b323
    /// Returns CGameWorldHeightMap's minimum Z among all grid nodes that intersect with the specified rectangle.
    pub inline fn getApproxFloorForArea(vec_1__: types.Vector2, vec_2__: types.Vector2) !f32 { return try invoker.invoke(f32, 0x3599D741C9AC6310, .{vec_1__.x, vec_1__.y, vec_2__.x, vec_2__.y}); } // 0x3599D741C9AC6310 0x76751DD4 b323
    /// Calculates the travel distance between a set of points.
    /// 
    /// Doesn't seem to correlate with distance on gps sometimes. \
    /// This function returns the value 100000.0 over long distances, seems to be a failure mode result, potentially occurring when not all path nodes are loaded into pathfind.
    pub inline fn calculateTravelDistanceBetweenPoints(vec_1__: types.Vector3, vec_2__: types.Vector3) !f32 { return try invoker.invoke(f32, 0xADD95C7005C4A197, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0xADD95C7005C4A197 0xB114489B b323
};

pub const Ped = struct
{
    /// https://alloc8or.re/gta5/doc/enums/ePedType.txt
    /// 
    /// Full list of peds by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/peds.json
    pub inline fn createPed(ped_type: c_int, model_hash: types.Hash, vec: types.Vector3, heading: f32, is_network: windows.BOOL, b_script_host_ped: windows.BOOL) !types.Ped { return try invoker.invoke(types.Ped, 0xD49F9B0955C367DE, .{ped_type, model_hash, vec.x, vec.y, vec.z, heading, is_network, b_script_host_ped}); } // 0xD49F9B0955C367DE 0x0389EF71 b323
    /// Deletes the specified ped, then sets the handle pointed to by the pointer to NULL.
    pub inline fn deletePed(ped: [*c]types.Ped) !void { try invoker.invoke(void, 0x9614299DCB53E54B, .{ped}); } // 0x9614299DCB53E54B 0x13EFB9A0 b323
    pub inline fn clonePed(ped: types.Ped, is_network: windows.BOOL, b_script_host_ped: windows.BOOL, copy_head_blend_flag: windows.BOOL) !types.Ped { return try invoker.invoke(types.Ped, 0xEF29A16337FACADB, .{ped, is_network, b_script_host_ped, copy_head_blend_flag}); } // 0xEF29A16337FACADB 0x8C8A8D6E b323
    pub inline fn clonePedAlt(ped: types.Ped, is_network: windows.BOOL, b_script_host_ped: windows.BOOL, copy_head_blend_flag: windows.BOOL, p_4: windows.BOOL) !types.Ped { return try invoker.invoke(types.Ped, 0x668FD40BCBA5DE48, .{ped, is_network, b_script_host_ped, copy_head_blend_flag, p_4}); } // 0x668FD40BCBA5DE48  b463
    /// Copies ped's components and props to targetPed.
    pub inline fn clonePedToTarget(ped: types.Ped, target_ped: types.Ped) !void { try invoker.invoke(void, 0xE952D6431689AD9A, .{ped, target_ped}); } // 0xE952D6431689AD9A 0xFC70EEC7 b323
    pub inline fn clonePedToTargetAlt(ped: types.Ped, target_ped: types.Ped, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x148B08C2D2ACB884, .{ped, target_ped, p_2}); } // 0x148B08C2D2ACB884  b463
    /// Gets a value indicating whether the specified ped is in the specified vehicle.
    /// 
    /// If 'atGetIn' is false, the function will not return true until the ped is sitting in the vehicle and is about to close the door. If it's true, the function returns true the moment the ped starts to get onto the seat (after opening the door). Eg. if false, and the ped is getting into a submersible, the function will not return true until the ped has descended down into the submersible and gotten into the seat, while if it's true, it'll return true the moment the hatch has been opened and the ped is about to descend into the submersible.
    pub inline fn isPedInVehicle(ped: types.Ped, vehicle: types.Vehicle, at_get_in: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA3EE4A07279BB9DB, .{ped, vehicle, at_get_in}); } // 0xA3EE4A07279BB9DB 0x7DA6BC83 b323
    pub inline fn isPedInModel(ped: types.Ped, model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x796D90EFB19AA332, .{ped, model_hash}); } // 0x796D90EFB19AA332 0xA6438D4B b323
    /// Gets a value indicating whether the specified ped is in any vehicle.
    /// 
    /// If 'atGetIn' is false, the function will not return true until the ped is sitting in the vehicle and is about to close the door. If it's true, the function returns true the moment the ped starts to get onto the seat (after opening the door). Eg. if false, and the ped is getting into a submersible, the function will not return true until the ped has descended down into the submersible and gotten into the seat, while if it's true, it'll return true the moment the hatch has been opened and the ped is about to descend into the submersible.
    pub inline fn isPedInAnyVehicle(ped: types.Ped, at_get_in: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x997ABD671D25CA0B, .{ped, at_get_in}); } // 0x997ABD671D25CA0B 0x3B0171EE b323
    /// xyz - relative to the world origin.
    pub inline fn isCopPedInArea3d(vec_1__: types.Vector3, vec_2__: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x16EC4839969F9F5E, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x16EC4839969F9F5E 0xB98DB96B b323
    /// Gets a value indicating whether this ped's health is below its injured threshold.
    /// 
    /// The default threshold is 100.
    pub inline fn isPedInjured(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x84A2DD9AC37C35C1, .{ped}); } // 0x84A2DD9AC37C35C1 0x2530A087 b323
    /// Returns whether the specified ped is hurt.
    pub inline fn isPedHurt(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5983BB449D7FDB12, .{ped}); } // 0x5983BB449D7FDB12 0x69DFA0AF b323
    /// Gets a value indicating whether this ped's health is below its fatally injured threshold. The default threshold is 100. \
    /// If the handle is invalid, the function returns true.
    pub inline fn isPedFatallyInjured(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD839450756ED5A80, .{ped}); } // 0xD839450756ED5A80 0xBADA0093 b323
    /// Seems to consistently return true if the ped is dead.
    /// 
    /// p1 is always passed 1 in the scripts.
    /// 
    /// I suggest to remove "OR_DYING" part, because it does not detect dying phase.
    /// 
    /// That's what the devs call it, cry about it.
    /// 
    /// lol
    pub inline fn isPedDeadOrDying(ped: types.Ped, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3317DEDB88C95038, .{ped, p_1}); } // 0x3317DEDB88C95038 0xCBDB7739 b323
    pub inline fn isConversationPedDead(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE0A0AEC214B1FABA, .{ped}); } // 0xE0A0AEC214B1FABA 0x1FA39EFE b323
    pub inline fn isPedAimingFromCover(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3998B1276A3300E5, .{ped}); } // 0x3998B1276A3300E5 0xDEBAB2AF b323
    /// Returns whether the specified ped is reloading.
    pub inline fn isPedReloading(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x24B100C68C645951, .{ped}); } // 0x24B100C68C645951 0x961E1745 b323
    /// Returns true if the given ped has a valid pointer to CPlayerInfo in its CPed class. That's all.
    pub inline fn isPedAPlayer(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x12534C348C6CB68B, .{ped}); } // 0x12534C348C6CB68B 0x404794CA b323
    /// pedType: see CREATE_PED
    /// 
    /// Full list of peds by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/peds.json
    pub inline fn createPedInsideVehicle(vehicle: types.Vehicle, ped_type: c_int, model_hash: types.Hash, seat: c_int, is_network: windows.BOOL, b_script_host_ped: windows.BOOL) !types.Ped { return try invoker.invoke(types.Ped, 0x7DD959874C1FD534, .{vehicle, ped_type, model_hash, seat, is_network, b_script_host_ped}); } // 0x7DD959874C1FD534 0x3000F092 b323
    pub inline fn setPedDesiredHeading(ped: types.Ped, heading: f32) !void { try invoker.invoke(void, 0xAA5A7ECE2AA8FE70, .{ped, heading}); } // 0xAA5A7ECE2AA8FE70 0x961458F9 b323
    pub inline fn forceAllHeadingValuesToAlign(ped: types.Ped) !void { try invoker.invoke(void, 0xFF287323B0E2C69A, .{ped}); } // 0xFF287323B0E2C69A 0x290421BE b323
    /// angle is ped's view cone
    pub inline fn isPedFacingPed(ped: types.Ped, other_ped: types.Ped, angle: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD71649DB0A545AA3, .{ped, other_ped, angle}); } // 0xD71649DB0A545AA3 0x0B775838 b323
    /// Notes: The function only returns true while the ped is:  \
    /// A.) Swinging a random melee attack (including pistol-whipping)
    /// 
    /// B.) Reacting to being hit by a melee attack (including pistol-whipping)
    /// 
    /// C.) Is locked-on to an enemy (arms up, strafing/skipping in the default fighting-stance, ready to dodge+counter). 
    /// 
    /// You don't have to be holding the melee-targetting button to be in this stance; you stay in it by default for a few seconds after swinging at someone. If you do a sprinting punch, it returns true for the duration of the punch animation and then returns false again, even if you've punched and made-angry many peds
    pub inline fn isPedInMeleeCombat(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4E209B2C1EAD5159, .{ped}); } // 0x4E209B2C1EAD5159 0xFD7814A5 b323
    /// Returns true if the ped doesn't do any movement. If the ped is being pushed forwards by using APPLY_FORCE_TO_ENTITY for example, the function returns false.
    pub inline fn isPedStopped(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x530944F6F4B8A214, .{ped}); } // 0x530944F6F4B8A214 0xA0DC0B87 b323
    pub inline fn isPedShootingInArea(ped: types.Ped, vec_1__: types.Vector3, vec_2__: types.Vector3, p_7: windows.BOOL, p_8: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7E9DFE24AC1E58EF, .{ped, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_7, p_8}); } // 0x7E9DFE24AC1E58EF 0x741BF04F b323
    pub inline fn isAnyPedShootingInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, p_6: windows.BOOL, p_7: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0D3D71EA1086C55, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_6, p_7}); } // 0xA0D3D71EA1086C55 0x91833867 b323
    /// Returns whether the specified ped is shooting.
    pub inline fn isPedShooting(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x34616828CD07F1A1, .{ped}); } // 0x34616828CD07F1A1 0xE7C3405E b323
    /// accuracy = 0-100, 100 being perfectly accurate
    pub inline fn setPedAccuracy(ped: types.Ped, accuracy: c_int) !void { try invoker.invoke(void, 0x7AEFB85C1D49DEB6, .{ped, accuracy}); } // 0x7AEFB85C1D49DEB6 0x6C17122E b323
    pub inline fn getPedAccuracy(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x37F4AD56ECBC0CD6, .{ped}); } // 0x37F4AD56ECBC0CD6 0x0A2A0AA0 b323
    pub inline fn setAmbientLawPedAccuracyModifier(multiplier: f32) !void { try invoker.invoke(void, 0x87DDEB611B329A9C, .{multiplier}); } // 0x87DDEB611B329A9C  b1103
    pub inline fn isPedModel(ped: types.Ped, model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC9D55B1A358A5BF7, .{ped, model_hash}); } // 0xC9D55B1A358A5BF7 0x5F1DDFCB b323
    /// Forces the ped to fall back and kills it.
    /// 
    /// It doesn't really explode the ped's head but it kills the ped
    pub inline fn explodePedHead(ped: types.Ped, weapon_hash: types.Hash) !void { try invoker.invoke(void, 0x2D05CED3A38D0F3A, .{ped, weapon_hash}); } // 0x2D05CED3A38D0F3A 0x05CC1380 b323
    /// Judging purely from a quick disassembly, if the ped is in a vehicle, the ped will be deleted immediately. If not, it'll be marked as no longer needed. - very elegant..
    pub inline fn removePedElegantly(ped: [*c]types.Ped) !void { try invoker.invoke(void, 0xAC6D445B994DF95E, .{ped}); } // 0xAC6D445B994DF95E 0x4FFB8C6C b323
    /// Same as SET_PED_ARMOUR, but ADDS 'amount' to the armor the Ped already has.
    pub inline fn addArmourToPed(ped: types.Ped, amount: c_int) !void { try invoker.invoke(void, 0x5BA652A0CD14DF2F, .{ped, amount}); } // 0x5BA652A0CD14DF2F 0xF686B26E b323
    /// Sets the armor of the specified ped.
    /// 
    /// ped: The Ped to set the armor of. \
    /// amount: A value between 0 and 100 indicating the value to set the Ped's armor to.
    pub inline fn setPedArmour(ped: types.Ped, amount: c_int) !void { try invoker.invoke(void, 0xCEA04D83135264CC, .{ped, amount}); } // 0xCEA04D83135264CC 0x4E3A0CC4 b323
    /// Ped: The ped to warp. \
    /// vehicle: The vehicle to warp the ped into. \
    /// Seat_Index: [-1 is driver seat, -2 first free passenger seat]
    /// 
    /// Moreinfo of Seat Index \
    /// DriverSeat = -1 \
    /// Passenger = 0 \
    /// Left Rear = 1 \
    /// RightRear = 2
    pub inline fn setPedIntoVehicle(ped: types.Ped, vehicle: types.Vehicle, seat_index: c_int) !void { try invoker.invoke(void, 0xF75B0D629E1C063D, .{ped, vehicle, seat_index}); } // 0xF75B0D629E1C063D 0x07500C79 b323
    pub inline fn setPedAllowVehiclesOverride(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3C028C636A414ED9, .{ped, toggle}); } // 0x3C028C636A414ED9 0x58A80BD5 b323
    pub inline fn canCreateRandomPed(p_0: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3E8349C08E4B82E4, .{p_0}); } // 0x3E8349C08E4B82E4 0xF9ABE88F b323
    /// vb.net \
    /// Dim ped_handle As Integer \
    ///                     With Game.Player.Character
    ///                         Dim pos As Vector3 = .Position + .ForwardVector * 3
    ///                         ped_handle = Native.Function.Call(Of Integer)(Hash.CREATE_RANDOM_PED, pos.X, pos.Y, pos.Z)
    ///                     End With
    /// 
    /// Creates a Ped at the specified location, returns the Ped Handle.   \
    /// Ped will not act until SET_PED_AS_NO_LONGER_NEEDED is called.
    pub inline fn createRandomPed(pos__: types.Vector3) !types.Ped { return try invoker.invoke(types.Ped, 0xB4AC7D0CF06BFE8F, .{pos__.x, pos__.y, pos__.z}); } // 0xB4AC7D0CF06BFE8F 0x5A949543 b323
    pub inline fn createRandomPedAsDriver(vehicle: types.Vehicle, return_handle: windows.BOOL) !types.Ped { return try invoker.invoke(types.Ped, 0x9B62392B474F44A0, .{vehicle, return_handle}); } // 0x9B62392B474F44A0 0xB927CE9A b323
    pub inline fn canCreateRandomDriver() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB8EB95E5B4E56978, .{}); } // 0xB8EB95E5B4E56978 0x99861609 b323
    pub inline fn canCreateRandomBikeRider() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEACEEDA81751915C, .{}); } // 0xEACEEDA81751915C 0x7018BE31 b323
    pub inline fn setPedMoveAnimsBlendOut(ped: types.Ped) !void { try invoker.invoke(void, 0x9E8C908F41584ECD, .{ped}); } // 0x9E8C908F41584ECD 0x20E01957 b323
    pub inline fn setPedCanBeDraggedOut(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC1670E958EEE24E5, .{ped, toggle}); } // 0xC1670E958EEE24E5 0xAA7F1131 b323
    /// ntoggle was always false except in one instance (b678).
    /// 
    /// The one time this is set to true seems to do with when you fail the mission.
    pub inline fn setPedAllowHurtCombatForAllMissionPeds(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF2BEBCDFAFDAA19E, .{toggle}); } // 0xF2BEBCDFAFDAA19E 0x6CD58238 b323
    /// Returns true/false if the ped is/isn't male.
    pub inline fn isPedMale(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6D9F5FAA7488BA46, .{ped}); } // 0x6D9F5FAA7488BA46 0x90950455 b323
    /// Returns true/false if the ped is/isn't humanoid.
    pub inline fn isPedHuman(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB980061DA992779D, .{ped}); } // 0xB980061DA992779D 0x194BB7B0 b323
    /// Gets the vehicle the specified Ped is in. Returns 0 if the ped is/was not in a vehicle.
    pub inline fn getVehiclePedIsIn(ped: types.Ped, include_entering: windows.BOOL) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x9A9112A0FE9A4713, .{ped, include_entering}); } // 0x9A9112A0FE9A4713 0xAFE92319 b323
    /// Resets the value for the last vehicle driven by the Ped.
    pub inline fn resetPedLastVehicle(ped: types.Ped) !void { try invoker.invoke(void, 0xBB8DE8CF6A8DD8BB, .{ped}); } // 0xBB8DE8CF6A8DD8BB 0x5E3B5942 b323
    pub inline fn setPedDensityMultiplierThisFrame(multiplier: f32) !void { try invoker.invoke(void, 0x95E3D6257B166CF2, .{multiplier}); } // 0x95E3D6257B166CF2 0x039C82BB b323
    pub inline fn setScenarioPedDensityMultiplierThisFrame(p_0: f32, p_1: f32) !void { try invoker.invoke(void, 0x7A556143A1C03898, .{p_0, p_1}); } // 0x7A556143A1C03898 0x2909ABF0 b323
    pub inline fn suppressAmbientPedAggressiveCleanupThisFrame() !void { try invoker.invoke(void, 0x5A7F62FDA59759BD, .{}); } // 0x5A7F62FDA59759BD 0xB48C0C04 b323
    pub inline fn setScriptedConversionCoordThisFrame(vec: types.Vector3) !void { try invoker.invoke(void, 0x5086C7843552CF85, .{vec.x, vec.y, vec.z}); } // 0x5086C7843552CF85 0x25EA2AA5 b323
    /// The distance between these points, is the diagonal of a box (remember it's 3D).
    pub inline fn setPedNonCreationArea(vec_1__: types.Vector3, vec_2__: types.Vector3) !void { try invoker.invoke(void, 0xEE01041D559983EA, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0xEE01041D559983EA 0x7A97283F b323
    pub inline fn clearPedNonCreationArea() !void { try invoker.invoke(void, 0x2E05208086BA0651, .{}); } // 0x2E05208086BA0651 0x6F7043A3 b323
    pub inline fn instantlyFillPedPopulation() !void { try invoker.invoke(void, 0x4759CC730F947C81, .{}); } // 0x4759CC730F947C81 0x8C555ADD b323
    /// Same function call as PED::GET_MOUNT, aka just returns 0
    pub inline fn isPedOnMount(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x460BC76A0E10655E, .{ped}); } // 0x460BC76A0E10655E 0x43103006 b323
    /// 
    /// Function just returns 0 \
    /// void __fastcall ped__get_mount(NativeContext *a1) \
    /// { \
    ///   NativeContext *v1; // rbx@1
    /// 
    ///   v1 = a1;
    ///   GetAddressOfPedFromScriptHandle(a1->Args->Arg1);
    ///   v1->Returns->Item1= 0;
    /// }
    pub inline fn getMount(ped: types.Ped) !types.Ped { return try invoker.invoke(types.Ped, 0xE7E11B8DCBED1058, .{ped}); } // 0xE7E11B8DCBED1058 0xDD31EC4E b323
    /// Gets a value indicating whether the specified ped is on top of any vehicle.
    /// 
    /// Return 1 when ped is on vehicle. \
    /// Return 0 when ped is not on a vehicle.
    /// 
    pub inline fn isPedOnVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x67722AEB798E5FAB, .{ped}); } // 0x67722AEB798E5FAB 0xA1AE7CC7 b323
    pub inline fn isPedOnSpecificVehicle(ped: types.Ped, vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEC5F66E459AF3BB2, .{ped, vehicle}); } // 0xEC5F66E459AF3BB2 0x63CB4603 b323
    /// Maximum possible amount of money on MP is 2000. ~JX
    /// 
    /// -----------------------------------------------------------------------------
    /// 
    /// Maximum amount that a ped can theoretically have is 65535 (0xFFFF) since the amount is stored as an unsigned short (uint16_t) value.
    pub inline fn setPedMoney(ped: types.Ped, amount: c_int) !void { try invoker.invoke(void, 0xA9C8960E8684C1B5, .{ped, amount}); } // 0xA9C8960E8684C1B5 0x40D90BF2 b323
    pub inline fn getPedMoney(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x3F69145BBA87BAE7, .{ped}); } // 0x3F69145BBA87BAE7 0xEB3C4C7E b323
    /// Related to Peds dropping pickup_health_snack; p0 is a value between [0.0, 1.0] that corresponds to drop rate
    pub inline fn setHealthSnacksCarriedByAllNewPeds(p_0: f32, p_1: types.Any) !void { try invoker.invoke(void, 0xFF4803BC019852D9, .{p_0, p_1}); } // 0xFF4803BC019852D9 0xD41C9AED b323
    pub inline fn setAmbientPedsDropMoney(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x6B0E6172C9A4D902, .{p_0}); } // 0x6B0E6172C9A4D902 0x30B98369 b323
    pub inline fn setBlockAmbientPedsFromDroppingWeaponsThisFrame_() !void { try invoker.invoke(void, 0xC73EFFC5E043A8BA, .{}); } // 0xC73EFFC5E043A8BA  b3258
    pub inline fn setBlockingOfNonTemporaryEventsForAmbientPedsThisFrame(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x9911F4A24485F653, .{p_0}); } // 0x9911F4A24485F653 0x02A080C8 b323
    /// Ped no longer takes critical damage modifiers if set to FALSE. \
    /// Example: Headshotting a player no longer one shots them. Instead they will take the same damage as a torso shot.
    pub inline fn setPedSuffersCriticalHits(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEBD76F2359F190AC, .{ped, toggle}); } // 0xEBD76F2359F190AC 0x6F6FC7E6 b323
    pub inline fn setPedUpperBodyDamageOnly(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAFC976FD0580C7B3, .{ped, toggle}); } // 0xAFC976FD0580C7B3 0x1572022A b323
    /// Detect if ped is sitting in the specified vehicle \
    /// [True/False]
    pub inline fn isPedSittingInVehicle(ped: types.Ped, vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA808AA1D79230FC2, .{ped, vehicle}); } // 0xA808AA1D79230FC2 0xDDDE26FA b323
    /// Detect if ped is in any vehicle \
    /// [True/False]
    pub inline fn isPedSittingInAnyVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x826AA586EDB9FEF8, .{ped}); } // 0x826AA586EDB9FEF8 0x0EA9CA03 b323
    pub inline fn isPedOnFoot(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x01FEE67DB37F59B2, .{ped}); } // 0x01FEE67DB37F59B2 0xC60D0785 b323
    pub inline fn isPedOnAnyBike(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x94495889E22C6479, .{ped}); } // 0x94495889E22C6479 0x4D885B2E b323
    pub inline fn isPedPlantingBomb(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC70B5FAE151982D8, .{ped}); } // 0xC70B5FAE151982D8 0x0EDAC574 b323
    pub inline fn getDeadPedPickupCoords(ped: types.Ped, p_1: f32, p_2: f32) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xCD5003B097200F36, .{ped, p_1, p_2}); } // 0xCD5003B097200F36 0x129F9DC1 b323
    pub inline fn isPedInAnyBoat(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E0E1C2B4F6CB339, .{ped}); } // 0x2E0E1C2B4F6CB339 0x1118A947 b323
    pub inline fn isPedInAnySub(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFBFC01CCFB35D99E, .{ped}); } // 0xFBFC01CCFB35D99E 0xE65F8059 b323
    pub inline fn isPedInAnyHeli(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x298B91AE825E5705, .{ped}); } // 0x298B91AE825E5705 0x7AB5523B b323
    pub inline fn isPedInAnyPlane(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5FFF4CFC74D8FB80, .{ped}); } // 0x5FFF4CFC74D8FB80 0x51BBCE7E b323
    pub inline fn isPedInFlyingVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9134873537FA419C, .{ped}); } // 0x9134873537FA419C 0xCA072485 b323
    pub inline fn setPedDiesInWater(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x56CEF0AC79073BDE, .{ped, toggle}); } // 0x56CEF0AC79073BDE 0x604C872B b323
    pub inline fn getPedDiesInWater(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x65671A4FB8218930, .{ped}); } // 0x65671A4FB8218930  b2699
    pub inline fn setPedDiesInSinkingVehicle(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD718A22995E2B4BC, .{ped, toggle}); } // 0xD718A22995E2B4BC 0x8D4D9ABB b323
    pub inline fn getPedArmour(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x9483AF821605B1D8, .{ped}); } // 0x9483AF821605B1D8 0x2CE311A7 b323
    pub inline fn setPedStayInVehicleWhenJacked(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEDF4079F9D54C9A1, .{ped, toggle}); } // 0xEDF4079F9D54C9A1 0xB014A09C b323
    pub inline fn setPedCanBeShotInVehicle(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC7EF1BA83230BA07, .{ped, toggle}); } // 0xC7EF1BA83230BA07 0x5DB7B3A9 b323
    pub inline fn getPedLastDamageBone(ped: types.Ped, out_bone: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD75960F6BD9EA49C, .{ped, out_bone}); } // 0xD75960F6BD9EA49C 0xAB933841 b323
    pub inline fn clearPedLastDamageBone(ped: types.Ped) !void { try invoker.invoke(void, 0x8EF6B7AC68E2F01B, .{ped}); } // 0x8EF6B7AC68E2F01B 0x56CB715E b323
    pub inline fn setAiWeaponDamageModifier(value: f32) !void { try invoker.invoke(void, 0x1B1E2A40A65B8521, .{value}); } // 0x1B1E2A40A65B8521 0x516E30EE b323
    pub inline fn resetAiWeaponDamageModifier() !void { try invoker.invoke(void, 0xEA16670E7BA4743C, .{}); } // 0xEA16670E7BA4743C 0x6E965420 b323
    pub inline fn setAiMeleeWeaponDamageModifier(modifier: f32) !void { try invoker.invoke(void, 0x66460DEDDD417254, .{modifier}); } // 0x66460DEDDD417254 0x0F9A401F b323
    pub inline fn resetAiMeleeWeaponDamageModifier() !void { try invoker.invoke(void, 0x46E56A7CD1D63C3F, .{}); } // 0x46E56A7CD1D63C3F 0x97886238 b323
    pub inline fn setTreatAsAmbientPedForDriverLockon(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x2F3C3D9F50681DE4, .{ped, p_1}); } // 0x2F3C3D9F50681DE4 0xCC9D7F1A b323
    pub inline fn setPedCanBeTargetted(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x63F58F7C80513AAD, .{ped, toggle}); } // 0x63F58F7C80513AAD 0x75C49F74 b323
    pub inline fn setPedCanBeTargettedByTeam(ped: types.Ped, team: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBF1CA77833E58F2C, .{ped, team, toggle}); } // 0xBF1CA77833E58F2C 0xB103A8E1 b323
    pub inline fn setPedCanBeTargettedByPlayer(ped: types.Ped, player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x66B57B72E0836A76, .{ped, player, toggle}); } // 0x66B57B72E0836A76 0xD050F490 b323
    pub inline fn setAllowLockonToPedIfFriendly(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x061CB768363D6424, .{ped, toggle}); } // 0x061CB768363D6424 0x7DA12905 b323
    pub inline fn setUseCameraHeadingForDesiredDirectionLockOnTest(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFD325494792302D7, .{ped, toggle}); } // 0xFD325494792302D7 0x7F67671D b323
    pub inline fn isPedInAnyPoliceVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0BD04E29640C9C12, .{ped}); } // 0x0BD04E29640C9C12 0x84FA790D b323
    pub inline fn forcePedToOpenParachute(ped: types.Ped) !void { try invoker.invoke(void, 0x16E42E800B472221, .{ped}); } // 0x16E42E800B472221 0xA819680B b323
    pub inline fn isPedInParachuteFreeFall(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7DCE8BDA0F1C1200, .{ped}); } // 0x7DCE8BDA0F1C1200 0xCD71F11B b323
    pub inline fn isPedFalling(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFB92A102F1C4DFA3, .{ped}); } // 0xFB92A102F1C4DFA3 0xABF77334 b323
    pub inline fn isPedJumping(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCEDABC5900A0BF97, .{ped}); } // 0xCEDABC5900A0BF97 0x07E5BC0E b323
    pub inline fn isPedLanding(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x412F1364FA066CFB, .{p_0}); } // 0x412F1364FA066CFB  b573
    pub inline fn isPedDoingABeastJump(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x451D05012CCEC234, .{p_0}); } // 0x451D05012CCEC234  b573
    pub inline fn isPedClimbing(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x53E8CB4F48BFE623, .{ped}); } // 0x53E8CB4F48BFE623 0xBCE03D35 b323
    pub inline fn isPedVaulting(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x117C70D1F5730B5E, .{ped}); } // 0x117C70D1F5730B5E 0xC3169BDA b323
    pub inline fn isPedDiving(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5527B8246FEF9B11, .{ped}); } // 0x5527B8246FEF9B11 0x7BC5BF3C b323
    pub inline fn isPedJumpingOutOfVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x433DDFFE2044B636, .{ped}); } // 0x433DDFFE2044B636 0xB19215F6 b323
    /// Returns true if the ped is currently opening a door (CTaskOpenDoor).
    pub inline fn isPedOpeningDoor(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x26AF0E8E30BD2A2C, .{ped}); } // 0x26AF0E8E30BD2A2C  b323
    /// Returns:
    /// 
    /// -1: Normal \
    /// 0: Wearing parachute on back \
    /// 1: Parachute opening \
    /// 2: Parachute open \
    /// 3: Falling to doom (e.g. after exiting parachute)
    /// 
    /// Normal means no parachute?
    pub inline fn getPedParachuteState(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x79CFD9827CC979B6, .{ped}); } // 0x79CFD9827CC979B6 0x7D4BC475 b323
    /// -1: no landing \
    /// 0: landing on both feet \
    /// 1: stumbling \
    /// 2: rolling \
    /// 3: ragdoll
    pub inline fn getPedParachuteLandingType(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x8B9F1FC6AE8166C0, .{ped}); } // 0x8B9F1FC6AE8166C0 0x01F3B035 b323
    pub inline fn setPedParachuteTintIndex(ped: types.Ped, tint_index: c_int) !void { try invoker.invoke(void, 0x333FC8DB079B7186, .{ped, tint_index}); } // 0x333FC8DB079B7186 0x5AEFEC3A b323
    pub inline fn getPedParachuteTintIndex(ped: types.Ped, out_tint_index: [*c]c_int) !void { try invoker.invoke(void, 0xEAF5F7E5AE7C6C9D, .{ped, out_tint_index}); } // 0xEAF5F7E5AE7C6C9D 0xE9E7FAC5 b323
    pub inline fn setPedReserveParachuteTintIndex(ped: types.Ped, p_1: types.Any) !void { try invoker.invoke(void, 0xE88DA0751C22A2AD, .{ped, p_1}); } // 0xE88DA0751C22A2AD 0x177EFC79 b323
    pub inline fn createParachuteBagObject(ped: types.Ped, p_1: windows.BOOL, p_2: windows.BOOL) !types.Object { return try invoker.invoke(types.Object, 0x8C4F3BF23B6237DB, .{ped, p_1, p_2}); } // 0x8C4F3BF23B6237DB 0x19198A16 b323
    /// This is the SET_CHAR_DUCKING from GTA IV, that makes Peds duck. This function does nothing in GTA V. It cannot set the ped as ducking in vehicles, and IS_PED_DUCKING will always return false.
    pub inline fn setPedDucking(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x030983CA930B692D, .{ped, toggle}); } // 0x030983CA930B692D 0xB90353D7 b323
    pub inline fn isPedDucking(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD125AE748725C6BC, .{ped}); } // 0xD125AE748725C6BC 0x9199C77D b323
    pub inline fn isPedInAnyTaxi(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6E575D6A898AB852, .{ped}); } // 0x6E575D6A898AB852 0x16FD386C b323
    pub inline fn setPedIdRange(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0xF107E836A70DCE05, .{ped, value}); } // 0xF107E836A70DCE05 0xEF3B4ED9 b323
    pub inline fn setPedHighlyPerceptive(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x52D59AB61DDC05DD, .{ped, toggle}); } // 0x52D59AB61DDC05DD 0x9A2180FF b323
    pub inline fn setCopPerceptionOverrides(seeing_range: f32, seeing_range_peripheral: f32, hearing_range: f32, visual_field_min_azimuth_angle: f32, visual_field_max_azimuth_angle: f32, field_of_gaze_max_angle: f32, p_6: f32) !void { try invoker.invoke(void, 0x2F074C904D85129E, .{seeing_range, seeing_range_peripheral, hearing_range, visual_field_min_azimuth_angle, visual_field_max_azimuth_angle, field_of_gaze_max_angle, p_6}); } // 0x2F074C904D85129E  b393
    pub inline fn setPedInjuredOnGroundBehaviour(ped: types.Ped, p_1: f32) !void { try invoker.invoke(void, 0xEC4B4B3B9908052A, .{ped, p_1}); } // 0xEC4B4B3B9908052A 0xF30658D2 b323
    pub inline fn disablePedInjuredOnGroundBehaviour(ped: types.Ped) !void { try invoker.invoke(void, 0x733C87D4CE22BEA2, .{ped}); } // 0x733C87D4CE22BEA2 0x43709044 b323
    pub inline fn setPedSeeingRange(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0xF29CF591C4BF6CEE, .{ped, value}); } // 0xF29CF591C4BF6CEE 0x4BD72FE8 b323
    pub inline fn setPedHearingRange(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x33A8F7F7D5F7F33C, .{ped, value}); } // 0x33A8F7F7D5F7F33C 0xB32087E0 b323
    pub inline fn setPedVisualFieldMinAngle(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x2DB492222FB21E26, .{ped, value}); } // 0x2DB492222FB21E26 0x72E2E18B b323
    pub inline fn setPedVisualFieldMaxAngle(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x70793BDCA1E854D4, .{ped, value}); } // 0x70793BDCA1E854D4 0x0CEA0F9A b323
    /// This native refers to the field of vision the ped has below them, starting at 0 degrees. The angle value should be negative. \
    /// -90f should let the ped see 90 degrees below them, for example.
    pub inline fn setPedVisualFieldMinElevationAngle(ped: types.Ped, angle: f32) !void { try invoker.invoke(void, 0x7A276EB2C224D70F, .{ped, angle}); } // 0x7A276EB2C224D70F 0x5CC2F1B8 b323
    /// This native refers to the field of vision the ped has above them, starting at 0 degrees. 90f would let the ped see enemies directly above of them.
    pub inline fn setPedVisualFieldMaxElevationAngle(ped: types.Ped, angle: f32) !void { try invoker.invoke(void, 0x78D0B67629D75856, .{ped, angle}); } // 0x78D0B67629D75856 0x39D9102F b323
    pub inline fn setPedVisualFieldPeripheralRange(ped: types.Ped, range: f32) !void { try invoker.invoke(void, 0x9C74B0BC831B753A, .{ped, range}); } // 0x9C74B0BC831B753A 0xFDF2F7C2 b323
    pub inline fn setPedVisualFieldCenterAngle(ped: types.Ped, angle: f32) !void { try invoker.invoke(void, 0x3B6405E8AB34A907, .{ped, angle}); } // 0x3B6405E8AB34A907 0xE57202A1 b323
    pub inline fn getPedVisualFieldCenterAngle(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0xEF2C71A32CAD5FBD, .{ped}); } // 0xEF2C71A32CAD5FBD  b1493
    /// p1 is usually 0 in the scripts. action is either 0 or a pointer to "DEFAULT_ACTION".
    pub inline fn setPedStealthMovement(ped: types.Ped, p_1: windows.BOOL, action: [*c]const u8) !void { try invoker.invoke(void, 0x88CBB5CEB96B7BD2, .{ped, p_1, action}); } // 0x88CBB5CEB96B7BD2 0x67E28E1D b323
    /// Returns whether the entity is in stealth mode
    pub inline fn getPedStealthMovement(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7C2AC9CA66575FBF, .{ped}); } // 0x7C2AC9CA66575FBF 0x40321B83 b323
    /// Creates a new ped group. \
    /// Groups can contain up to 8 peds.
    /// 
    /// The parameter is unused.
    /// 
    /// Returns a handle to the created group, or 0 if a group couldn't be created.
    pub inline fn createGroup(unused: c_int) !c_int { return try invoker.invoke(c_int, 0x90370EBE0FEE1A3D, .{unused}); } // 0x90370EBE0FEE1A3D 0x8DC0368D b323
    pub inline fn setPedAsGroupLeader(ped: types.Ped, group_id: c_int) !void { try invoker.invoke(void, 0x2A7819605465FBCE, .{ped, group_id}); } // 0x2A7819605465FBCE 0x7265BEA2 b323
    pub inline fn setPedAsGroupMember(ped: types.Ped, group_id: c_int) !void { try invoker.invoke(void, 0x9F3480FE65DB31B5, .{ped, group_id}); } // 0x9F3480FE65DB31B5 0x0EE13F92 b323
    /// This only will teleport the ped to the group leader if the group leader teleports (sets coords).
    /// 
    /// Only works in singleplayer
    pub inline fn setPedCanTeleportToGroupLeader(ped_handle: types.Ped, group_handle: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2E2F4240B3F24647, .{ped_handle, group_handle, toggle}); } // 0x2E2F4240B3F24647 0xD0D8BDBC b323
    pub inline fn removeGroup(group_id: c_int) !void { try invoker.invoke(void, 0x8EB2F69076AF7053, .{group_id}); } // 0x8EB2F69076AF7053 0x48D72B88 b323
    pub inline fn removePedFromGroup(ped: types.Ped) !void { try invoker.invoke(void, 0xED74007FFB146BC2, .{ped}); } // 0xED74007FFB146BC2 0x82697713 b323
    pub inline fn isPedGroupMember(ped: types.Ped, group_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9BB01E3834671191, .{ped, group_id}); } // 0x9BB01E3834671191 0x876D5363 b323
    pub inline fn isPedHangingOnToVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1C86D8AEF8254B78, .{ped}); } // 0x1C86D8AEF8254B78 0x9678D4FF b323
    /// Sets the range at which members will automatically leave the group.
    pub inline fn setGroupSeparationRange(group_handle: c_int, separation_range: f32) !void { try invoker.invoke(void, 0x4102C7858CFEE4E4, .{group_handle, separation_range}); } // 0x4102C7858CFEE4E4 0x7B820CD5 b323
    /// Ped will stay on the ground after being stunned for at lest ms time. (in milliseconds)
    pub inline fn setPedMinGroundTimeForStungun(ped: types.Ped, ms: c_int) !void { try invoker.invoke(void, 0xFA0675AB151073FA, .{ped, ms}); } // 0xFA0675AB151073FA 0x2F0D0973 b323
    pub inline fn isPedProne(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD6A86331A537A7B9, .{ped}); } // 0xD6A86331A537A7B9 0x02C2A6C3 b323
    /// Checks to see if ped and target are in combat with eachother. Only goes one-way: if target is engaged in combat with ped but ped has not yet reacted, the function will return false until ped starts fighting back.
    /// 
    /// p1 is usually 0 in the scripts because it gets the ped id during the task sequence. For instance: PED::IS_PED_IN_COMBAT(l_42E[4/*14*/], PLAYER::PLAYER_PED_ID()) // armenian2.ct4: 43794
    pub inline fn isPedInCombat(ped: types.Ped, target: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4859F1FC66A6278E, .{ped, target}); } // 0x4859F1FC66A6278E 0xFE027CB5 b323
    pub inline fn getPedTargetFromCombatPed(ped: types.Ped, p_1: types.Any) !types.Entity { return try invoker.invoke(types.Entity, 0x32C27A11307B01CC, .{ped, p_1}); } // 0x32C27A11307B01CC  b2372
    pub inline fn canPedInCombatSeeTarget(ped: types.Ped, target: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEAD42DE3610D0721, .{ped, target}); } // 0xEAD42DE3610D0721 0xCCD525E1 b323
    pub inline fn isPedDoingDriveby(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB2C086CC1BF8F2BF, .{ped}); } // 0xB2C086CC1BF8F2BF 0xAC3CEB9C b323
    pub inline fn isPedJacking(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4AE4FF911DFB61DA, .{ped}); } // 0x4AE4FF911DFB61DA 0x3B321816 b323
    pub inline fn isPedBeingJacked(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9A497FE2DF198913, .{ped}); } // 0x9A497FE2DF198913 0xD45D605C b323
    /// p1 is always 0
    pub inline fn isPedBeingStunned(ped: types.Ped, p_1: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4FBACCE3B4138EE8, .{ped, p_1}); } // 0x4FBACCE3B4138EE8 0x0A66CE30 b323
    pub inline fn getPedsJacker(ped: types.Ped) !types.Ped { return try invoker.invoke(types.Ped, 0x9B128DC36C1E04CF, .{ped}); } // 0x9B128DC36C1E04CF 0xDE1DBB59 b323
    pub inline fn getJackTarget(ped: types.Ped) !types.Ped { return try invoker.invoke(types.Ped, 0x5486A79D9FBD342D, .{ped}); } // 0x5486A79D9FBD342D 0x1D196361 b323
    pub inline fn isPedFleeing(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBBCCE00B381F8482, .{ped}); } // 0xBBCCE00B381F8482 0x85D813C6 b323
    /// p1 is nearly always 0 in the scripts. 
    pub inline fn isPedInCover(ped: types.Ped, except_use_weapon: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x60DFD0691A170B88, .{ped, except_use_weapon}); } // 0x60DFD0691A170B88 0x972C5A8B b323
    pub inline fn isPedInCoverFacingLeft(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x845333B3150583AB, .{ped}); } // 0x845333B3150583AB 0xB89DBB80 b323
    pub inline fn isPedInHighCover(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6A03BF943D767C93, .{ped}); } // 0x6A03BF943D767C93 0xDD5D08A7 b323
    pub inline fn isPedGoingIntoCover(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9F65DBC537E59AD5, .{ped}); } // 0x9F65DBC537E59AD5 0xA3589628 b323
    /// i could be time. Only example in the decompiled scripts uses it as -1.
    pub inline fn setPedPinnedDown(ped: types.Ped, pinned: windows.BOOL, i: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAAD6D1ACF08F4612, .{ped, pinned, i}); } // 0xAAD6D1ACF08F4612 0xCC78999D b323
    pub inline fn hasPedClearLosToEntity_(ped: types.Ped, entity: types.Entity, vec: types.Vector3, p_5: c_int, p_6: windows.BOOL, p_7: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA32ABFEB2A03B306, .{ped, entity, vec.x, vec.y, vec.z, p_5, p_6, p_7}); } // 0xA32ABFEB2A03B306  b3095
    pub inline fn getSeatPedIsTryingToEnter(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x6F4C85ACD641BCD2, .{ped}); } // 0x6F4C85ACD641BCD2 0xACF162E0 b323
    pub inline fn getVehiclePedIsTryingToEnter(ped: types.Ped) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x814FA8BE5449445D, .{ped}); } // 0x814FA8BE5449445D 0x99968B37 b323
    /// Returns the Entity (Ped, Vehicle, or ?Object?) that killed the 'ped'
    /// 
    /// Is best to check if the Ped is dead before asking for its killer.
    pub inline fn getPedSourceOfDeath(ped: types.Ped) !types.Entity { return try invoker.invoke(types.Entity, 0x93C8B64DEB84728C, .{ped}); } // 0x93C8B64DEB84728C 0x84ADF9EB b323
    /// Returns the hash of the weapon/model/object that killed the ped.
    pub inline fn getPedCauseOfDeath(ped: types.Ped) !types.Hash { return try invoker.invoke(types.Hash, 0x16FFE42AB2D2DC59, .{ped}); } // 0x16FFE42AB2D2DC59 0x63458C27 b323
    pub inline fn getPedTimeOfDeath(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x1E98817B311AE98A, .{ped}); } // 0x1E98817B311AE98A 0xDF6D5D54 b323
    pub inline fn countPedsInCombatWithTarget(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x5407B7288D0478B7, .{ped}); } // 0x5407B7288D0478B7 0xEF0B78E6 b323
    pub inline fn countPedsInCombatWithTargetWithinRadius(ped: types.Ped, vec: types.Vector3, radius: f32) !c_int { return try invoker.invoke(c_int, 0x336B3D200AB007CB, .{ped, vec.x, vec.y, vec.z, radius}); } // 0x336B3D200AB007CB 0xFB18CB19 b323
    pub inline fn setPedRelationshipGroupDefaultHash(ped: types.Ped, hash: types.Hash) !void { try invoker.invoke(void, 0xADB3F206518799E8, .{ped, hash}); } // 0xADB3F206518799E8 0x423B7BA2 b323
    pub inline fn setPedRelationshipGroupHash(ped: types.Ped, hash: types.Hash) !void { try invoker.invoke(void, 0xC80A74AC829DDD92, .{ped, hash}); } // 0xC80A74AC829DDD92 0x79F8C18C b323
    /// Sets the relationship between two groups. This should be called twice (once for each group).
    /// 
    /// Relationship types: \
    /// 0 = Companion \
    /// 1 = Respect \
    /// 2 = Like \
    /// 3 = Neutral \
    /// 4 = Dislike \
    /// 5 = Hate \
    /// 255 = Pedestrians
    /// 
    /// Example: \
    /// PED::SET_RELATIONSHIP_BETWEEN_GROUPS(2, l_1017, 0xA49E591C); \
    /// PED::SET_RELATIONSHIP_BETWEEN_GROUPS(2, 0xA49E591C, l_1017);
    pub inline fn setRelationshipBetweenGroups(relationship: c_int, group_1: types.Hash, group_2: types.Hash) !void { try invoker.invoke(void, 0xBF25EB89375A37AD, .{relationship, group_1, group_2}); } // 0xBF25EB89375A37AD 0xD4A215BA b323
    /// Clears the relationship between two groups. This should be called twice (once for each group).
    /// 
    /// Relationship types: \
    /// 0 = Companion \
    /// 1 = Respect \
    /// 2 = Like \
    /// 3 = Neutral \
    /// 4 = Dislike \
    /// 5 = Hate \
    /// 255 = Pedestrians \
    /// (Credits: Inco)
    /// 
    /// Example: \
    /// PED::CLEAR_RELATIONSHIP_BETWEEN_GROUPS(2, l_1017, 0xA49E591C); \
    /// PED::CLEAR_RELATIONSHIP_BETWEEN_GROUPS(2, 0xA49E591C, l_1017);
    pub inline fn clearRelationshipBetweenGroups(relationship: c_int, group_1: types.Hash, group_2: types.Hash) !void { try invoker.invoke(void, 0x5E29243FB56FC6D4, .{relationship, group_1, group_2}); } // 0x5E29243FB56FC6D4 0x994B8C2D b323
    /// Can't select void. This function returns nothing. The hash of the created relationship group is output in the second parameter.
    pub inline fn addRelationshipGroup(name: [*c]const u8, group_hash: [*c]types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF372BC22FCB88606, .{name, group_hash}); } // 0xF372BC22FCB88606 0x8B635546 b323
    pub inline fn removeRelationshipGroup(group_hash: types.Hash) !void { try invoker.invoke(void, 0xB6BA2444AB393DA2, .{group_hash}); } // 0xB6BA2444AB393DA2 0x4A1DC59A b323
    pub inline fn doesRelationshipGroupExist(group_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCC6E3B6BB69501F1, .{group_hash}); } // 0xCC6E3B6BB69501F1  b505
    /// Gets the relationship between two peds. This should be called twice (once for each ped).
    /// 
    /// Relationship types: \
    /// 0 = Companion \
    /// 1 = Respect \
    /// 2 = Like \
    /// 3 = Neutral \
    /// 4 = Dislike \
    /// 5 = Hate \
    /// 255 = Pedestrians \
    /// (Credits: Inco)
    /// 
    /// Example: \
    /// PED::GET_RELATIONSHIP_BETWEEN_PEDS(2, l_1017, 0xA49E591C); \
    /// PED::GET_RELATIONSHIP_BETWEEN_PEDS(2, 0xA49E591C, l_1017);
    pub inline fn getRelationshipBetweenPeds(ped_1: types.Ped, ped_2: types.Ped) !c_int { return try invoker.invoke(c_int, 0xEBA5AD3A0EAF7121, .{ped_1, ped_2}); } // 0xEBA5AD3A0EAF7121 0xE254C39C b323
    pub inline fn getPedRelationshipGroupDefaultHash(ped: types.Ped) !types.Hash { return try invoker.invoke(types.Hash, 0x42FDD0F017B1E38E, .{ped}); } // 0x42FDD0F017B1E38E 0x714BD6E4 b323
    pub inline fn getPedRelationshipGroupHash(ped: types.Ped) !types.Hash { return try invoker.invoke(types.Hash, 0x7DBDD04862D95F04, .{ped}); } // 0x7DBDD04862D95F04 0x354F283C b323
    /// Gets the relationship between two groups. This should be called twice (once for each group).
    /// 
    /// Relationship types: \
    /// 0 = Companion \
    /// 1 = Respect \
    /// 2 = Like \
    /// 3 = Neutral \
    /// 4 = Dislike \
    /// 5 = Hate \
    /// 255 = Pedestrians
    /// 
    /// Example: \
    /// PED::GET_RELATIONSHIP_BETWEEN_GROUPS(l_1017, 0xA49E591C); \
    /// PED::GET_RELATIONSHIP_BETWEEN_GROUPS(0xA49E591C, l_1017);
    pub inline fn getRelationshipBetweenGroups(group_1: types.Hash, group_2: types.Hash) !c_int { return try invoker.invoke(c_int, 0x9E6B70061662AE5C, .{group_1, group_2}); } // 0x9E6B70061662AE5C 0x4E372FE2 b323
    pub inline fn setRelationshipGroupAffectsWantedLevel(group: types.Hash, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x5615E0C5EB2BC6E2, .{group, p_1}); } // 0x5615E0C5EB2BC6E2  b877
    pub inline fn tellGroupPedsInAreaToAttack(ped: types.Ped, p_1: types.Any, p_2: f32, hash: types.Hash, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0xAD27D957598E49E9, .{ped, p_1, p_2, hash, p_4, p_5}); } // 0xAD27D957598E49E9  b1290
    pub inline fn setPedCanBeTargetedWithoutLos(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4328652AE5769C71, .{ped, toggle}); } // 0x4328652AE5769C71 0x7FDDC0A6 b323
    pub inline fn setPedToInformRespectedFriends(ped: types.Ped, radius: f32, max_friends: c_int) !void { try invoker.invoke(void, 0x112942C6E708F70B, .{ped, radius, max_friends}); } // 0x112942C6E708F70B 0xD78AC46C b323
    pub inline fn isPedRespondingToEvent(ped: types.Ped, event: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x625B774D75C87068, .{ped, event}); } // 0x625B774D75C87068 0x7A877554 b323
    pub inline fn getPosFromFiredEvent(ped: types.Ped, event_type: c_int, out_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBA656A3BB01BDEA3, .{ped, event_type, out_data}); } // 0xBA656A3BB01BDEA3  b2189
    /// FIRING_PATTERN_BURST_FIRE = 0xD6FF6D61 ( 1073727030 ) \
    /// FIRING_PATTERN_BURST_FIRE_IN_COVER = 0x026321F1 ( 40051185 ) \
    /// FIRING_PATTERN_BURST_FIRE_DRIVEBY = 0xD31265F2 ( -753768974 ) \
    /// FIRING_PATTERN_FROM_GROUND = 0x2264E5D6 ( 577037782 ) \
    /// FIRING_PATTERN_DELAY_FIRE_BY_ONE_SEC = 0x7A845691 ( 2055493265 ) \
    /// FIRING_PATTERN_FULL_AUTO = 0xC6EE6B4C ( -957453492 ) \
    /// FIRING_PATTERN_SINGLE_SHOT = 0x5D60E4E0 ( 1566631136 ) \
    /// FIRING_PATTERN_BURST_FIRE_PISTOL = 0xA018DB8A ( -1608983670 ) \
    /// FIRING_PATTERN_BURST_FIRE_SMG = 0xD10DADEE ( 1863348768 ) \
    /// FIRING_PATTERN_BURST_FIRE_RIFLE = 0x9C74B406 ( -1670073338 ) \
    /// FIRING_PATTERN_BURST_FIRE_MG = 0xB573C5B4 ( -1250703948 ) \
    /// FIRING_PATTERN_BURST_FIRE_PUMPSHOTGUN = 0x00BAC39B ( 12239771 ) \
    /// FIRING_PATTERN_BURST_FIRE_HELI = 0x914E786F ( -1857128337 ) \
    /// FIRING_PATTERN_BURST_FIRE_MICRO = 0x42EF03FD ( 1122960381 ) \
    /// FIRING_PATTERN_SHORT_BURSTS = 0x1A92D7DF ( 445831135 ) \
    /// FIRING_PATTERN_SLOW_FIRE_TANK = 0xE2CA3A71 ( -490063247 )
    /// 
    /// Firing pattern info: https://pastebin.com/Px036isB
    pub inline fn setPedFiringPattern(ped: types.Ped, pattern_hash: types.Hash) !void { try invoker.invoke(void, 0x9AC577F5A12AD8A9, .{ped, pattern_hash}); } // 0x9AC577F5A12AD8A9 0xB4629D66 b323
    /// shootRate 0-1000
    pub inline fn setPedShootRate(ped: types.Ped, shoot_rate: c_int) !void { try invoker.invoke(void, 0x614DA022990752DC, .{ped, shoot_rate}); } // 0x614DA022990752DC 0xFB301746 b323
    /// combatType can be between 0-14. See GET_COMBAT_FLOAT below for a list of possible parameters.
    pub inline fn setCombatFloat(ped: types.Ped, combat_type: c_int, p_2: f32) !void { try invoker.invoke(void, 0xFF41B4B141ED981C, .{ped, combat_type, p_2}); } // 0xFF41B4B141ED981C 0xD8B7637C b323
    /// p0: Ped Handle \
    /// p1: int i | 0 <= i <= 27
    /// 
    /// p1 probably refers to the attributes configured in combatbehavior.meta. There are 13. Example:
    /// 
    /// <BlindFireChance value="0.1"/> \
    /// <WeaponShootRateModifier value="1.0"/> \
    /// <TimeBetweenBurstsInCover value="1.25"/> \
    /// <BurstDurationInCover value="2.0"/> \
    /// <TimeBetweenPeeks value="10.0"/> \
    /// <WeaponAccuracy value="0.18"/> \
    /// <FightProficiency value="0.8"/> \
    /// <StrafeWhenMovingChance value="1.0"/> \
    /// <WalkWhenStrafingChance value="0.0"/> \
    /// <AttackWindowDistanceForCover value="55.0"/> \
    /// <TimeToInvalidateInjuredTarget value="9.0"/> \
    /// <TriggerChargeTime_Near value="4.0"/> \
    /// <TriggerChargeTime_Far value="10.0"/>
    /// 
    /// -------------Confirmed by editing combatbehavior.meta: \
    /// p1: \
    /// 0=BlindFireChance \
    /// 1=BurstDurationInCover \
    /// 3=TimeBetweenBurstsInCover \
    /// 4=TimeBetweenPeeks \
    /// 5=StrafeWhenMovingChance \
    /// 8=WalkWhenStrafingChance \
    /// 11=AttackWindowDistanceForCover \
    /// 12=TimeToInvalidateInjuredTarget \
    /// 16=OptimalCoverDistance
    /// 
    pub inline fn getCombatFloat(ped: types.Ped, p_1: c_int) !f32 { return try invoker.invoke(f32, 0x52DFF8A10508090A, .{ped, p_1}); } // 0x52DFF8A10508090A 0x511D7EF8 b323
    /// p1 may be a BOOL representing whether or not the group even exists
    pub inline fn getGroupSize(group_i_d: c_int, p_1: [*c]types.Any, size_in_members: [*c]c_int) !void { try invoker.invoke(void, 0x8DE69FE35CA09A45, .{group_i_d, p_1, size_in_members}); } // 0x8DE69FE35CA09A45 0xF7E1A691 b323
    pub inline fn doesGroupExist(group_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7C6B0C22F9F40BBE, .{group_id}); } // 0x7C6B0C22F9F40BBE 0x935C978D b323
    /// Returns the group id of which the specified ped is a member of.
    pub inline fn getPedGroupIndex(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0xF162E133B4E7A675, .{ped}); } // 0xF162E133B4E7A675 0x134E0785 b323
    pub inline fn isPedInGroup(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5891CAC5D4ACFF74, .{ped}); } // 0x5891CAC5D4ACFF74 0x836D9795 b323
    pub inline fn getPlayerPedIsFollowing(ped: types.Ped) !types.Player { return try invoker.invoke(types.Player, 0x6A3975DEA89F9A17, .{ped}); } // 0x6A3975DEA89F9A17 0xDE7442EE b323
    /// 0: Default \
    /// 1: Circle Around Leader \
    /// 2: Alternative Circle Around Leader \
    /// 3: Line, with Leader at center
    pub inline fn setGroupFormation(group_id: c_int, formation_type: c_int) !void { try invoker.invoke(void, 0xCE2F5FC3AF7E8C1E, .{group_id, formation_type}); } // 0xCE2F5FC3AF7E8C1E 0x08FAC739 b323
    pub inline fn setGroupFormationSpacing(group_id: c_int, vec: types.Vector3) !void { try invoker.invoke(void, 0x1D9D45004C28C916, .{group_id, vec.x, vec.y, vec.z}); } // 0x1D9D45004C28C916 0xB1E086FF b323
    pub inline fn resetGroupFormationDefaultSpacing(group_handle: c_int) !void { try invoker.invoke(void, 0x63DAB4CCB3273205, .{group_handle}); } // 0x63DAB4CCB3273205 0x267FCEAD b323
    /// Gets ID of vehicle player using. It means it can get ID at any interaction with vehicle. Enter\exit for example. And that means it is faster than GET_VEHICLE_PED_IS_IN but less safe.
    pub inline fn getVehiclePedIsUsing(ped: types.Ped) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x6094AD011A2EA87D, .{ped}); } // 0x6094AD011A2EA87D 0x6DE3AADA b323
    pub inline fn getVehiclePedIsEntering(ped: types.Ped) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0xF92691AED837A5FC, .{ped}); } // 0xF92691AED837A5FC 0x56E0C163 b323
    /// enable or disable the gravity of a ped
    /// 
    /// Examples: \
    /// PED::SET_PED_GRAVITY(PLAYER::PLAYER_PED_ID(), 0x00000001); \
    /// PED::SET_PED_GRAVITY(Local_289[iVar0 /*20*/], 0x00000001);
    pub inline fn setPedGravity(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9FF447B6B6AD960A, .{ped, toggle}); } // 0x9FF447B6B6AD960A 0x3CA16652 b323
    pub inline fn setPedSurvivesBeingOutOfWater_(ped: types.Ped, toggle: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x100CD221F572F6E1, .{ped, toggle}); } // 0x100CD221F572F6E1  b3407
    /// damages a ped with the given amount
    pub inline fn applyDamageToPed(ped: types.Ped, damage_amount: c_int, p_2: windows.BOOL, p_3: types.Any, weapon_type: types.Hash) !void { try invoker.invoke(void, 0x697157CED63F18D4, .{ped, damage_amount, p_2, p_3, weapon_type}); } // 0x697157CED63F18D4 0x4DC27FCF b323
    pub inline fn getTimePedDamagedByWeapon(ped: types.Ped, weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x36B77BB84687C318, .{ped, weapon_hash}); } // 0x36B77BB84687C318 0x0170C6E1 b323
    pub inline fn setPedAllowedToDuck(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDA1F1B7BE1A8766F, .{ped, toggle}); } // 0xDA1F1B7BE1A8766F 0xC4D122F8 b323
    pub inline fn setPedNeverLeavesGroup(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3DBFC55D5C9BB447, .{ped, toggle}); } // 0x3DBFC55D5C9BB447 0x0E038813 b323
    /// https://alloc8or.re/gta5/doc/enums/ePedType.txt
    pub inline fn getPedType(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0xFF059E1E4C01E63C, .{ped}); } // 0xFF059E1E4C01E63C 0xB1460D43 b323
    /// Turns the desired ped into a cop. If you use this on the player ped, you will become almost invisible to cops dispatched for you. You will also report your own crimes, get a generic cop voice, get a cop-vision-cone on the radar, and you will be unable to shoot at other cops. SWAT and Army will still shoot at you. Toggling ped as "false" has no effect; you must change p0's ped model to disable the effect.
    pub inline fn setPedAsCop(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBB03C38DD3FB7FFD, .{ped, toggle}); } // 0xBB03C38DD3FB7FFD 0x84E7DE9F b323
    pub inline fn setPedHealthPendingLastDamageEventOverrideFlag(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB3352E018D6F89DF, .{toggle}); } // 0xB3352E018D6F89DF  b2699
    /// Sets the maximum health of a ped.
    pub inline fn setPedMaxHealth(ped: types.Ped, value: c_int) !void { try invoker.invoke(void, 0xF5F6378C4F3419D3, .{ped, value}); } // 0xF5F6378C4F3419D3 0x5533F60B b323
    pub inline fn getPedMaxHealth(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x4700A416E8324EF3, .{ped}); } // 0x4700A416E8324EF3 0xA45B6C8D b323
    pub inline fn setPedMaxTimeInWater(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x43C851690662113D, .{ped, value}); } // 0x43C851690662113D 0xFE0A106B b323
    pub inline fn setPedMaxTimeUnderwater(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x6BA428C528D9E522, .{ped, value}); } // 0x6BA428C528D9E522 0x082EF240 b323
    pub inline fn setCorpseRagdollFriction(ped: types.Ped, p_1: f32) !void { try invoker.invoke(void, 0x2735233A786B1BEF, .{ped, p_1}); } // 0x2735233A786B1BEF 0x373CC405 b323
    /// seatIndex must be <= 2
    pub inline fn setPedVehicleForcedSeatUsage(ped: types.Ped, vehicle: types.Vehicle, seat_index: c_int, flags: c_int, p_4: types.Any) !void { try invoker.invoke(void, 0x952F06BEECD775CC, .{ped, vehicle, seat_index, flags, p_4}); } // 0x952F06BEECD775CC 0x79CA237B b323
    pub inline fn clearAllPedVehicleForcedSeatUsage(ped: types.Ped) !void { try invoker.invoke(void, 0xE6CA85E7259CE16B, .{ped}); } // 0xE6CA85E7259CE16B 0xCC1D8F66 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn setPedCanBeKnockedOffBike(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xB282749D5E028163, .{p_0, p_1}); } // 0xB282749D5E028163  b877
    /// state: https://alloc8or.re/gta5/doc/enums/eKnockOffVehicle.txt
    pub inline fn setPedCanBeKnockedOffVehicle(ped: types.Ped, state: c_int) !void { try invoker.invoke(void, 0x7A6535691B477C48, .{ped, state}); } // 0x7A6535691B477C48 0x8A251612 b323
    pub inline fn canKnockPedOffVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x51AC07A44D4F5B8A, .{ped}); } // 0x51AC07A44D4F5B8A 0xC9D098B3 b323
    pub inline fn knockPedOffVehicle(ped: types.Ped) !void { try invoker.invoke(void, 0x45BBCBA77C29A841, .{ped}); } // 0x45BBCBA77C29A841 0xACDD0674 b323
    pub inline fn setPedCoordsNoGang(ped: types.Ped, pos__: types.Vector3) !void { try invoker.invoke(void, 0x87052FE446E07247, .{ped, pos__.x, pos__.y, pos__.z}); } // 0x87052FE446E07247 0x9561AD98 b323
    /// from fm_mission_controller.c4 (variable names changed for clarity):
    /// 
    /// int groupID = PLAYER::GET_PLAYER_GROUP(PLAYER::PLAYER_ID()); \
    /// PED::GET_GROUP_SIZE(group, &unused, &groupSize); \
    /// if (groupSize >= 1) { \
    /// . . . . for (int memberNumber = 0; memberNumber < groupSize; memberNumber++) { \
    /// . . . . . . . . Ped ped1 = PED::GET_PED_AS_GROUP_MEMBER(groupID, memberNumber); \
    /// . . . . . . . . //and so on
    pub inline fn getPedAsGroupMember(group_i_d: c_int, member_number: c_int) !types.Ped { return try invoker.invoke(types.Ped, 0x51455483CF23ED97, .{group_i_d, member_number}); } // 0x51455483CF23ED97 0x9AA3CC8C b323
    pub inline fn getPedAsGroupLeader(group_i_d: c_int) !types.Ped { return try invoker.invoke(types.Ped, 0x5CCE68DBD5FE93EC, .{group_i_d}); } // 0x5CCE68DBD5FE93EC 0x52873C6A b323
    pub inline fn setPedKeepTask(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x971D38760FBC02EF, .{ped, toggle}); } // 0x971D38760FBC02EF 0xA7EC79CE b323
    pub inline fn setPedAllowMinorReactionsAsMissionPed(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x49E50BDB8BA4DAB2, .{ped, toggle}); } // 0x49E50BDB8BA4DAB2 0x397F06E3 b323
    pub inline fn isPedSwimming(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9DE327631295B4C2, .{ped}); } // 0x9DE327631295B4C2 0x7AB43DB8 b323
    pub inline fn isPedSwimmingUnderWater(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC024869A53992F34, .{ped}); } // 0xC024869A53992F34 0x0E8D524F b323
    /// teleports ped to coords along with the vehicle ped is in
    pub inline fn setPedCoordsKeepVehicle(ped: types.Ped, pos__: types.Vector3) !void { try invoker.invoke(void, 0x9AFEFF481A85AB2E, .{ped, pos__.x, pos__.y, pos__.z}); } // 0x9AFEFF481A85AB2E 0xD66AE1D3 b323
    pub inline fn setPedDiesInVehicle(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2A30922C90C9B42C, .{ped, toggle}); } // 0x2A30922C90C9B42C 0x6FE1E440 b323
    pub inline fn setCreateRandomCops(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x102E68B2024D536D, .{toggle}); } // 0x102E68B2024D536D 0x23441648 b323
    pub inline fn setCreateRandomCopsNotOnScenarios(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8A4986851C4EF6E7, .{toggle}); } // 0x8A4986851C4EF6E7 0x82E548CC b323
    pub inline fn setCreateRandomCopsOnScenarios(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x444CB7D7DBE6973D, .{toggle}); } // 0x444CB7D7DBE6973D 0xEDC31475 b323
    pub inline fn canCreateRandomCops() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5EE2CAFF7F17770D, .{}); } // 0x5EE2CAFF7F17770D 0xAA73DAD9 b323
    pub inline fn setPedAsEnemy(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x02A0C9720B854BFA, .{ped, toggle}); } // 0x02A0C9720B854BFA 0xAE620A1B b323
    pub inline fn setPedCanSmashGlass(ped: types.Ped, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x1CCE141467FF42A2, .{ped, p_1, p_2}); } // 0x1CCE141467FF42A2 0x149C60A8 b323
    pub inline fn isPedInAnyTrain(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6F972C1AB75A1ED0, .{ped}); } // 0x6F972C1AB75A1ED0 0x759EF63A b323
    pub inline fn isPedGettingIntoAVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBB062B2B5722478E, .{ped}); } // 0xBB062B2B5722478E 0x90E805AC b323
    pub inline fn isPedTryingToEnterALockedVehicle(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x44D28D5DDFE5F68C, .{ped}); } // 0x44D28D5DDFE5F68C 0x46828B4E b323
    /// ped can not pull out a weapon when true
    pub inline fn setEnableHandcuffs(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDF1AF8B5D56542FA, .{ped, toggle}); } // 0xDF1AF8B5D56542FA 0xAC9BBA23 b323
    /// Used with SET_ENABLE_HANDCUFFS in decompiled scripts. From my observations, I have noticed that while being ragdolled you are not able to get up but you can still run. Your legs can also bend.
    pub inline fn setEnableBoundAnkles(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC52E0F855C58FC2E, .{ped, toggle}); } // 0xC52E0F855C58FC2E 0x9208D689 b323
    /// Enables diving motion when underwater.
    pub inline fn setEnableScuba(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF99F62004024D506, .{ped, toggle}); } // 0xF99F62004024D506 0x7BF61471 b323
    /// Setting ped to true allows the ped to shoot "friendlies".
    /// 
    /// p2 set to true when toggle is also true seams to make peds permanently unable to aim at, even if you set p2 back to false.
    /// 
    /// p1 = false & p2 = false for unable to aim at. \
    /// p1 = true & p2 = false for able to aim at. 
    pub inline fn setCanAttackFriendly(ped: types.Ped, toggle: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xB3B1CB349FF9C75D, .{ped, toggle, p_2}); } // 0xB3B1CB349FF9C75D 0x47C60963 b323
    /// Returns the ped's alertness (0-3).
    /// 
    /// Values : 
    /// 
    /// 0 : Neutral \
    /// 1 : Heard something (gun shot, hit, etc) \
    /// 2 : Knows (the origin of the event) \
    /// 3 : Fully alerted (is facing the event?)
    /// 
    /// If the Ped does not exist, returns -1.
    pub inline fn getPedAlertness(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0xF6AA118530443FD2, .{ped}); } // 0xF6AA118530443FD2 0xF83E4DAF b323
    /// value ranges from 0 to 3.
    pub inline fn setPedAlertness(ped: types.Ped, value: c_int) !void { try invoker.invoke(void, 0xDBA71115ED9941A6, .{ped, value}); } // 0xDBA71115ED9941A6 0x2C32D9AE b323
    pub inline fn setPedGetOutUpsideDownVehicle(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBC0ED94165A48BC2, .{ped, toggle}); } // 0xBC0ED94165A48BC2 0x89AD49FF b323
    /// transitionSpeed is the time in seconds it takes to transition from one movement clipset to another.    ransitionSpeed is usually 1.0f
    /// 
    /// List of movement clipsets: \
    /// Thanks to elsewhat for list.
    /// 
    ///  "ANIM_GROUP_MOVE_BALLISTIC" \
    ///  "ANIM_GROUP_MOVE_LEMAR_ALLEY" \
    ///  "clipset@move@trash_fast_turn" \
    ///  "FEMALE_FAST_RUNNER" \
    ///  "missfbi4prepp1_garbageman" \
    ///  "move_characters@franklin@fire" \
    ///  "move_characters@Jimmy@slow@" \
    ///  "move_characters@michael@fire" \
    ///  "move_f@flee@a" \
    ///  "move_f@scared" \
    ///  "move_f@sexy@a" \
    ///  "move_heist_lester" \
    ///  "move_injured_generic" \
    ///  "move_lester_CaneUp" \
    ///  "move_m@bag" \
    ///  "MOVE_M@BAIL_BOND_NOT_TAZERED" \
    ///  "MOVE_M@BAIL_BOND_TAZERED" \
    ///  "move_m@brave" \
    ///  "move_m@casual@d" \
    ///  "move_m@drunk@moderatedrunk" \
    ///  "MOVE_M@DRUNK@MODERATEDRUNK" \
    ///  "MOVE_M@DRUNK@MODERATEDRUNK_HEAD_UP" \
    ///  "MOVE_M@DRUNK@SLIGHTLYDRUNK" \
    ///  "MOVE_M@DRUNK@VERYDRUNK" \
    ///  "move_m@fire" \
    ///  "move_m@gangster@var_e" \
    ///  "move_m@gangster@var_f" \
    ///  "move_m@gangster@var_i" \
    ///  "move_m@JOG@" \
    ///  "MOVE_M@PRISON_GAURD" \
    ///  "MOVE_P_M_ONE" \
    ///  "MOVE_P_M_ONE_BRIEFCASE" \
    ///  "move_p_m_zero_janitor" \
    ///  "move_p_m_zero_slow" \
    ///  "move_ped_bucket" \
    ///  "move_ped_crouched" \
    ///  "move_ped_mop" \
    ///  "MOVE_M@FEMME@" \
    ///  "MOVE_F@FEMME@" \
    ///  "MOVE_M@GANGSTER@NG" \
    ///  "MOVE_F@GANGSTER@NG" \
    ///  "MOVE_M@POSH@" \
    ///  "MOVE_F@POSH@" \
    ///  "MOVE_M@TOUGH_GUY@" \
    ///  "MOVE_F@TOUGH_GUY@"
    /// 
    /// ~ NotCrunchyTaco
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn setPedMovementClipset(ped: types.Ped, clip_set: [*c]const u8, transition_speed: f32) !void { try invoker.invoke(void, 0xAF8A94EDE7712BEF, .{ped, clip_set, transition_speed}); } // 0xAF8A94EDE7712BEF 0xA817CDEB b323
    /// If p1 is 0.0, I believe you are back to normal.  \
    /// If p1 is 1.0, it looks like you can only rotate the ped, not walk.
    /// 
    /// Using the following code to reset back to normal \
    /// PED::RESET_PED_MOVEMENT_CLIPSET(PLAYER::PLAYER_PED_ID(), 0.0);
    pub inline fn resetPedMovementClipset(ped: types.Ped, p_1: f32) !void { try invoker.invoke(void, 0xAA74EC0CB0AAEA2C, .{ped, p_1}); } // 0xAA74EC0CB0AAEA2C 0xB83CEE93 b323
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn setPedStrafeClipset(ped: types.Ped, clip_set: [*c]const u8) !void { try invoker.invoke(void, 0x29A28F3F8CF6D854, .{ped, clip_set}); } // 0x29A28F3F8CF6D854 0x0BACF010 b323
    pub inline fn resetPedStrafeClipset(ped: types.Ped) !void { try invoker.invoke(void, 0x20510814175EA477, .{ped}); } // 0x20510814175EA477 0xF1967A12 b323
    pub inline fn setPedWeaponMovementClipset(ped: types.Ped, clip_set: [*c]const u8) !void { try invoker.invoke(void, 0x2622E35B77D3ACA2, .{ped, clip_set}); } // 0x2622E35B77D3ACA2 0xF8BE54DC b323
    pub inline fn resetPedWeaponMovementClipset(ped: types.Ped) !void { try invoker.invoke(void, 0x97B0DB5B4AA74E77, .{ped}); } // 0x97B0DB5B4AA74E77 0xC60C9ACD b323
    pub inline fn setPedDriveByClipsetOverride(ped: types.Ped, clipset: [*c]const u8) !void { try invoker.invoke(void, 0xED34AB6C5CB36520, .{ped, clipset}); } // 0xED34AB6C5CB36520 0xD4C73595 b323
    pub inline fn clearPedDriveByClipsetOverride(ped: types.Ped) !void { try invoker.invoke(void, 0x4AFE3690D7E0B5AC, .{ped}); } // 0x4AFE3690D7E0B5AC 0xAEC9163B b323
    /// Found in the b617d scripts: \
    /// PED::SET_PED_MOTION_IN_COVER_CLIPSET_OVERRIDE(v_7, "trevor_heist_cover_2h");
    pub inline fn setPedMotionInCoverClipsetOverride(ped: types.Ped, p_1: [*c]const u8) !void { try invoker.invoke(void, 0x9DBA107B4937F809, .{ped, p_1}); } // 0x9DBA107B4937F809  b323
    pub inline fn clearPedMotionInCoverClipsetOverride(ped: types.Ped) !void { try invoker.invoke(void, 0xC79196DCB36F6121, .{ped}); } // 0xC79196DCB36F6121  b323
    pub inline fn clearPedFallUpperBodyClipsetOverride(ped: types.Ped) !void { try invoker.invoke(void, 0x80054D7FCC70EEC6, .{ped}); } // 0x80054D7FCC70EEC6  b323
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(l_128, MISC::GET_HASH_KEY("MINI_PROSTITUTE_LOW_PASSENGER")); \
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(l_128, MISC::GET_HASH_KEY("MINI_PROSTITUTE_LOW_RESTRICTED_PASSENGER")); \
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(l_3212, MISC::GET_HASH_KEY("MISS_FAMILY1_JIMMY_SIT")); \
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(l_3212, MISC::GET_HASH_KEY("MISS_FAMILY1_JIMMY_SIT_REAR")); \
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(l_95, MISC::GET_HASH_KEY("MISS_FAMILY2_JIMMY_BICYCLE")); \
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(num3, MISC::GET_HASH_KEY("MISSFBI2_MICHAEL_DRIVEBY")); \
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("MISS_ARMENIAN3_FRANKLIN_TENSE")); \
    /// PED::SET_PED_IN_VEHICLE_CONTEXT(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("MISSFBI5_TREVOR_DRIVING"));
    pub inline fn setPedInVehicleContext(ped: types.Ped, context: types.Hash) !void { try invoker.invoke(void, 0x530071295899A8C6, .{ped, context}); } // 0x530071295899A8C6 0x27F25C0E b323
    pub inline fn resetPedInVehicleContext(ped: types.Ped) !void { try invoker.invoke(void, 0x22EF8FF8778030EB, .{ped}); } // 0x22EF8FF8778030EB 0x3C94D88A b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn isScriptedScenarioPedUsingConditionalAnim(ped: types.Ped, anim_dict: [*c]const u8, anim: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6EC47A344923E1ED, .{ped, anim_dict, anim}); } // 0x6EC47A344923E1ED 0x3C30B447 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn setPedAlternateWalkAnim(ped: types.Ped, anim_dict: [*c]const u8, anim_name: [*c]const u8, p_3: f32, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x6C60394CB4F75E9A, .{ped, anim_dict, anim_name, p_3, p_4}); } // 0x6C60394CB4F75E9A 0x895E1D67 b323
    pub inline fn clearPedAlternateWalkAnim(ped: types.Ped, p_1: f32) !void { try invoker.invoke(void, 0x8844BBFCE30AA9E9, .{ped, p_1}); } // 0x8844BBFCE30AA9E9 0x5736FB23 b323
    /// stance: \
    /// 0 = idle \
    /// 1 = walk \
    /// 2 = running
    /// 
    /// p5 = usually set to true
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn setPedAlternateMovementAnim(ped: types.Ped, stance: c_int, anim_dictionary: [*c]const u8, animation_name: [*c]const u8, p_4: f32, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x90A43CC281FFAB46, .{ped, stance, anim_dictionary, animation_name, p_4, p_5}); } // 0x90A43CC281FFAB46 0xBA84FD8C b323
    pub inline fn clearPedAlternateMovementAnim(ped: types.Ped, stance: c_int, p_2: f32) !void { try invoker.invoke(void, 0xD8D19675ED5FBDCE, .{ped, stance, p_2}); } // 0xD8D19675ED5FBDCE 0x7A7F5BC3 b323
    /// From the scripts: \
    /// PED::SET_PED_GESTURE_GROUP(PLAYER::PLAYER_PED_ID(), \
    /// "ANIM_GROUP_GESTURE_MISS_FRA0"); \
    /// PED::SET_PED_GESTURE_GROUP(PLAYER::PLAYER_PED_ID(), \
    /// "ANIM_GROUP_GESTURE_MISS_DocksSetup1");
    pub inline fn setPedGestureGroup(ped: types.Ped, anim_group_gesture: [*c]const u8) !void { try invoker.invoke(void, 0xDDF803377F94AAA8, .{ped, anim_group_gesture}); } // 0xDDF803377F94AAA8 0x170DA109 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn getAnimInitialOffsetPosition(anim_dict: [*c]const u8, anim_name: [*c]const u8, vec: types.Vector3, rot__: types.Vector3, p_8: f32, p_9: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xBE22B26DD764C040, .{anim_dict, anim_name, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, p_8, p_9}); } // 0xBE22B26DD764C040 0xC59D4268 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn getAnimInitialOffsetRotation(anim_dict: [*c]const u8, anim_name: [*c]const u8, vec: types.Vector3, rot__: types.Vector3, p_8: f32, p_9: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x4B805E6046EE9E47, .{anim_dict, anim_name, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, p_8, p_9}); } // 0x4B805E6046EE9E47 0x5F7789E6 b323
    /// Ids \
    /// 0 - Head \
    /// 1 - Beard \
    /// 2 - Hair \
    /// 3 - Torso \
    /// 4 - Legs \
    /// 5 - Hands \
    /// 6 - Foot \
    /// 7 - ------ \
    /// 8 - Accessories 1 \
    /// 9 - Accessories 2 \
    /// 10- Decals \
    /// 11 - Auxiliary parts for torso
    pub inline fn getPedDrawableVariation(ped: types.Ped, component_id: c_int) !c_int { return try invoker.invoke(c_int, 0x67F3780DD425D4FC, .{ped, component_id}); } // 0x67F3780DD425D4FC 0x29850FE2 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getNumberOfPedDrawableVariations(ped: types.Ped, component_id: c_int) !c_int { return try invoker.invoke(c_int, 0x27561561732A7842, .{ped, component_id}); } // 0x27561561732A7842 0x9754C27D b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getPedTextureVariation(ped: types.Ped, component_id: c_int) !c_int { return try invoker.invoke(c_int, 0x04A355E041E004E6, .{ped, component_id}); } // 0x04A355E041E004E6 0xC0A8590A b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getNumberOfPedTextureVariations(ped: types.Ped, component_id: c_int, drawable_id: c_int) !c_int { return try invoker.invoke(c_int, 0x8F7156A3142A6BAD, .{ped, component_id, drawable_id}); } // 0x8F7156A3142A6BAD 0x83D9FBE7 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getNumberOfPedPropDrawableVariations(ped: types.Ped, prop_id: c_int) !c_int { return try invoker.invoke(c_int, 0x5FAF9754E789FB47, .{ped, prop_id}); } // 0x5FAF9754E789FB47 0xC9780B95 b323
    /// Need to check behavior when drawableId = -1
    /// 
    /// - Doofy.Ass \
    /// Why this function doesn't work and return nill value? \
    /// GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS(PLAYER.PLAYER_PED_ID(), 0, 5)
    /// 
    /// tick: scripts/addins/menu_execute.lua:51: attempt to call field 'GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS' (a nil value)
    /// 
    /// 
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getNumberOfPedPropTextureVariations(ped: types.Ped, prop_id: c_int, drawable_id: c_int) !c_int { return try invoker.invoke(c_int, 0xA6E7F1CEB523E171, .{ped, prop_id, drawable_id}); } // 0xA6E7F1CEB523E171 0x4892B882 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getPedPaletteVariation(ped: types.Ped, component_id: c_int) !c_int { return try invoker.invoke(c_int, 0xE3DD5F2A84B42281, .{ped, component_id}); } // 0xE3DD5F2A84B42281 0xEF1BC082 b323
    pub inline fn getMpOutfitDataFromMetadata(p_0: [*c]types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9E30E91FB03A2CAF, .{p_0, p_1}); } // 0x9E30E91FB03A2CAF 0x52559BB6 b323
    pub inline fn getFmMaleShopPedApparelItemIndex(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x1E77FA7A62EE6C4C, .{p_0}); } // 0x1E77FA7A62EE6C4C 0x021F5B36 b323
    pub inline fn getFmFemaleShopPedApparelItemIndex(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0xF033419D1B81FAE8, .{p_0}); } // 0xF033419D1B81FAE8 0x8FDDB5DB b323
    /// Checks if the component variation is valid, this works great for randomizing components using loops.
    /// 
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    /// 
    /// Full list of ped components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedComponentVariations.json
    pub inline fn isPedComponentVariationValid(ped: types.Ped, component_id: c_int, drawable_id: c_int, texture_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE825F6B6CEA7671D, .{ped, component_id, drawable_id, texture_id}); } // 0xE825F6B6CEA7671D 0x952ABD9A b323
    /// paletteId: 0 to 3.
    /// 
    /// componentId: \
    /// enum ePedVarComp \
    /// { \
    ///     PV_COMP_INVALID = -1,
    ///     PV_COMP_HEAD,
    ///     PV_COMP_BERD,
    ///     PV_COMP_HAIR,
    ///     PV_COMP_UPPR,
    ///     PV_COMP_LOWR,
    ///     PV_COMP_HAND,
    ///     PV_COMP_FEET,
    ///     PV_COMP_TEEF,
    ///     PV_COMP_ACCS,
    ///     PV_COMP_TASK,
    ///     PV_COMP_DECL,
    ///     PV_COMP_JBIB,
    ///     PV_COMP_MAX
    /// };
    /// 
    /// Examples: https://gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    /// 
    /// Full list of ped components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedComponentVariations.json
    pub inline fn setPedComponentVariation(ped: types.Ped, component_id: c_int, drawable_id: c_int, texture_id: c_int, palette_id: c_int) !void { try invoker.invoke(void, 0x262B14F48D29DE80, .{ped, component_id, drawable_id, texture_id, palette_id}); } // 0x262B14F48D29DE80 0xD4F7B05C b323
    /// p1 is always 0 in R* scripts.
    /// 
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn setPedRandomComponentVariation(ped: types.Ped, p_1: c_int) !void { try invoker.invoke(void, 0xC8A9481A01E63C28, .{ped, p_1}); } // 0xC8A9481A01E63C28 0x4111BA46 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn setPedRandomProps(ped: types.Ped) !void { try invoker.invoke(void, 0xC44AA05345C992C6, .{ped}); } // 0xC44AA05345C992C6 0xE3318E0E b323
    /// Sets Ped Default Clothes
    pub inline fn setPedDefaultComponentVariation(ped: types.Ped) !void { try invoker.invoke(void, 0x45EEE61580806D63, .{ped}); } // 0x45EEE61580806D63 0xC866A984 b323
    pub inline fn setPedBlendFromParents(ped: types.Ped, p_1: types.Any, p_2: types.Any, p_3: f32, p_4: f32) !void { try invoker.invoke(void, 0x137BBD05230DB22D, .{ped, p_1, p_2, p_3, p_4}); } // 0x137BBD05230DB22D 0x837BD370 b323
    /// The "shape" parameters control the shape of the ped's face. The "skin" parameters control the skin tone. ShapeMix and skinMix control how much the first and second IDs contribute,(typically mother and father.) ThirdMix overrides the others in favor of the third IDs. IsParent is set for "children" of the player character's grandparents during old-gen character creation. It has unknown effect otherwise.
    /// 
    /// The IDs start at zero and go Male Non-DLC, Female Non-DLC, Male DLC, and Female DLC.
    /// 
    /// !!!Can someone add working example for this???
    /// 
    /// try this: \
    ///        headBlendData headData;
    ///        GET_PED_HEAD_BLEND_DATA(PLAYER_PED_ID(), &headData);
    /// 
    ///        SET_PED_HEAD_BLEND_DATA(PLAYER_PED_ID(), headData.shapeFirst, headData.shapeSecond, headData.shapeThird, headData.skinFirst, headData.skinSecond
    ///           , headData.skinThird, headData.shapeMix, headData.skinMix, headData.skinThird, 0);
    /// 
    /// 
    /// For more info please refer to this topic.  \
    /// gtaforums.com/topic/858970-all-gtao-face-ids-pedset-ped-head-blend-data-explained
    pub inline fn setPedHeadBlendData(ped: types.Ped, shape_first_i_d: c_int, shape_second_i_d: c_int, shape_third_i_d: c_int, skin_first_i_d: c_int, skin_second_i_d: c_int, skin_third_i_d: c_int, shape_mix: f32, skin_mix: f32, third_mix: f32, is_parent: windows.BOOL) !void { try invoker.invoke(void, 0x9414E18B9434C2FE, .{ped, shape_first_i_d, shape_second_i_d, shape_third_i_d, skin_first_i_d, skin_second_i_d, skin_third_i_d, shape_mix, skin_mix, third_mix, is_parent}); } // 0x9414E18B9434C2FE 0x60746B88 b323
    /// The pointer is to a padded struct that matches the arguments to SET_PED_HEAD_BLEND_DATA(...). There are 4 bytes of padding after each field. \
    /// pass this struct in the second parameter  \
    /// struct headBlendData \
    /// { \
    ///     int shapeFirst;
    ///     int padding1;
    ///     int shapeSecond;
    ///     int padding2;
    ///     int shapeThird;
    ///     int padding3;
    ///     int skinFirst;
    ///     int padding4;
    ///     int skinSecond;
    ///     int padding5;
    ///     int skinThird;
    ///     int padding6;
    ///     float shapeMix;
    ///     int padding7;
    ///     float skinMix;
    ///     int padding8;
    ///     float thirdMix;
    ///     int padding9;
    ///     bool isParent;
    /// };
    pub inline fn getPedHeadBlendData(ped: types.Ped, head_blend_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2746BD9D88C5C5D0, .{ped, head_blend_data}); } // 0x2746BD9D88C5C5D0 0x44E1680C b323
    /// See SET_PED_HEAD_BLEND_DATA().
    pub inline fn updatePedHeadBlendData(ped: types.Ped, shape_mix: f32, skin_mix: f32, third_mix: f32) !void { try invoker.invoke(void, 0x723538F61C647C5A, .{ped, shape_mix, skin_mix, third_mix}); } // 0x723538F61C647C5A 0x5CB76219 b323
    /// Used for freemode (online) characters.
    /// 
    /// For some reason, the scripts use a rounded float for the index. \
    /// Indexes: \
    /// 1. black \
    /// 2. very light blue/green \
    /// 3. dark blue \
    /// 4. brown \
    /// 5. darker brown \
    /// 6. light brown \
    /// 7. blue \
    /// 8. light blue \
    /// 9. pink \
    /// 10. yellow \
    /// 11. purple \
    /// 12. black \
    /// 13. dark green \
    /// 14. light brown \
    /// 15. yellow/black pattern \
    /// 16. light colored spiral pattern \
    /// 17. shiny red \
    /// 18. shiny half blue/half red \
    /// 19. half black/half light blue \
    /// 20. white/red perimter \
    /// 21. green snake \
    /// 22. red snake \
    /// 23. dark blue snake \
    /// 24. dark yellow \
    /// 25. bright yellow \
    /// 26. all black \
    /// 28. red small pupil \
    /// 29. devil blue/black \
    /// 30. white small pupil \
    /// 31. glossed over
    pub inline fn setHeadBlendEyeColor(ped: types.Ped, index: c_int) !void { try invoker.invoke(void, 0x50B56988B170AFDF, .{ped, index}); } // 0x50B56988B170AFDF  b323
    /// A getter for _SET_PED_EYE_COLOR. Returns -1 if fails to get.
    pub inline fn getHeadBlendEyeColor(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x76BBA2CEE66D47E9, .{ped}); } // 0x76BBA2CEE66D47E9  b1011
    /// OverlayID ranges from 0 to 12, index from 0 to _GET_NUM_OVERLAY_VALUES(overlayID)-1, and opacity from 0.0 to 1.0. 
    /// 
    /// overlayID       Part                  Index, to disable \
    /// 0               Blemishes             0 - 23, 255 \
    /// 1               Facial Hair           0 - 28, 255 \
    /// 2               Eyebrows              0 - 33, 255 \
    /// 3               Ageing                0 - 14, 255 \
    /// 4               Makeup                0 - 74, 255 \
    /// 5               Blush                 0 - 6, 255 \
    /// 6               Complexion            0 - 11, 255 \
    /// 7               Sun Damage            0 - 10, 255 \
    /// 8               Lipstick              0 - 9, 255 \
    /// 9               Moles/Freckles        0 - 17, 255 \
    /// 10              Chest Hair            0 - 16, 255 \
    /// 11              Body Blemishes        0 - 11, 255 \
    /// 12              Add Body Blemishes    0 - 1, 255
    pub inline fn setPedHeadOverlay(ped: types.Ped, overlay_i_d: c_int, index: c_int, opacity: f32) !void { try invoker.invoke(void, 0x48F44967FA05CC1E, .{ped, overlay_i_d, index, opacity}); } // 0x48F44967FA05CC1E 0xD28DBA90 b323
    /// Likely a char, if that overlay is not set, e.i. "None" option, returns 255;
    /// 
    /// This might be the once removed native GET_PED_HEAD_OVERLAY.
    pub inline fn getPedHeadOverlay(ped: types.Ped, overlay_i_d: c_int) !c_int { return try invoker.invoke(c_int, 0xA60EF3B6461A4D43, .{ped, overlay_i_d}); } // 0xA60EF3B6461A4D43  b323
    pub inline fn getPedHeadOverlayNum(overlay_i_d: c_int) !c_int { return try invoker.invoke(c_int, 0xCF1CE768BB43480E, .{overlay_i_d}); } // 0xCF1CE768BB43480E 0xFF43C18D b323
    /// 
    /// 
    /// ColorType is 1 for eyebrows, beards, and chest hair; 2 for blush and lipstick; and 0 otherwise, though not called in those cases.
    /// 
    /// Called after SET_PED_HEAD_OVERLAY().
    pub inline fn setPedHeadOverlayTint(ped: types.Ped, overlay_i_d: c_int, color_type: c_int, color_i_d: c_int, second_color_i_d: c_int) !void { try invoker.invoke(void, 0x497BF74A7B9CB952, .{ped, overlay_i_d, color_type, color_i_d, second_color_i_d}); } // 0x497BF74A7B9CB952  b323
    pub inline fn setPedHairTint(ped: types.Ped, color_i_d: c_int, highlight_color_i_d: c_int) !void { try invoker.invoke(void, 0x4CFFC65454C93A49, .{ped, color_i_d, highlight_color_i_d}); } // 0x4CFFC65454C93A49  b323
    pub inline fn getNumPedHairTints() !c_int { return try invoker.invoke(c_int, 0xE5C0CF872C2AD150, .{}); } // 0xE5C0CF872C2AD150  b323
    pub inline fn getNumPedMakeupTints() !c_int { return try invoker.invoke(c_int, 0xD1F7CA1535D22818, .{}); } // 0xD1F7CA1535D22818  b323
    /// Input: Haircolor index, value between 0 and 63 (inclusive). \
    /// Output: RGB values for the haircolor specified in the input.
    /// 
    /// This is used with the hair color swatches scaleform. \
    /// Use `GET_PED_MAKEUP_TINT_COLOR` to get the makeup colors.
    pub inline fn getPedHairTintColor(hair_color_index: c_int, out_r: [*c]c_int, out_g: [*c]c_int, out_b: [*c]c_int) !void { try invoker.invoke(void, 0x4852FC386E2E1BB5, .{hair_color_index, out_r, out_g, out_b}); } // 0x4852FC386E2E1BB5  b323
    /// Input: Makeup color index, value between 0 and 63 (inclusive). \
    /// Output: RGB values for the makeup color specified in the input.
    /// 
    /// This is used with the makeup color swatches scaleform. \
    /// Use `GET_PED_HAIR_TINT_COLOR` to get the hair colors.
    pub inline fn getPedMakeupTintColor(makeup_color_index: c_int, out_r: [*c]c_int, out_g: [*c]c_int, out_b: [*c]c_int) !void { try invoker.invoke(void, 0x013E5CFC38CD5387, .{makeup_color_index, out_r, out_g, out_b}); } // 0x013E5CFC38CD5387  b323
    pub inline fn isPedHairTintForCreator(color_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xED6D8E27A43B8CDE, .{color_id}); } // 0xED6D8E27A43B8CDE  b323
    pub inline fn getDefaultSecondaryTintForCreator(color_id: c_int) !c_int { return try invoker.invoke(c_int, 0xEA9960D07DADCF10, .{color_id}); } // 0xEA9960D07DADCF10  b323
    pub inline fn isPedLipstickTintForCreator(color_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3E802F11FBE27674, .{color_id}); } // 0x3E802F11FBE27674  b323
    pub inline fn isPedBlushTintForCreator(color_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF41B5D290C99A3D6, .{color_id}); } // 0xF41B5D290C99A3D6  b323
    pub inline fn isPedHairTintForBarber(color_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE0D36E5D9E99CC21, .{color_i_d}); } // 0xE0D36E5D9E99CC21  b323
    pub inline fn getDefaultSecondaryTintForBarber(color_i_d: c_int) !c_int { return try invoker.invoke(c_int, 0xAAA6A3698A69E048, .{color_i_d}); } // 0xAAA6A3698A69E048  b323
    pub inline fn isPedLipstickTintForBarber(color_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0525A2C2562F3CD4, .{color_i_d}); } // 0x0525A2C2562F3CD4  b323
    pub inline fn isPedBlushTintForBarber(color_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x604E810189EE3A59, .{color_i_d}); } // 0x604E810189EE3A59  b323
    pub inline fn isPedBlushFacepaintTintForBarber(color_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x09E7ECA981D9B210, .{color_id}); } // 0x09E7ECA981D9B210  b1290
    pub inline fn getTintIndexForLastGenHairTexture(model_hash: types.Hash, drawable_id: c_int, texture_id: c_int) !c_int { return try invoker.invoke(c_int, 0xC56FBF2F228E1DAC, .{model_hash, drawable_id, texture_id}); } // 0xC56FBF2F228E1DAC  b323
    /// Sets the various freemode face features, e.g. nose length, chin shape. Scale ranges from -1.0 to 1.0.
    /// 
    /// 
    /// 
    /// 0 - Nose Width (Thin/Wide)
    /// 
    /// 1 - Nose Peak (Up/Down)
    /// 
    /// 2 - Nose Length (Long/Short)
    /// 
    /// 3 - Nose Bone Curveness (Crooked/Curved)
    /// 
    /// 4 - Nose Tip (Up/Down)
    /// 
    /// 5 - Nose Bone Twist (Left/Right)
    /// 
    /// 6 - Eyebrow (Up/Down)
    /// 
    /// 7 - Eyebrow (In/Out)
    /// 
    /// 8 - Cheek Bones (Up/Down)
    /// 
    /// 9 - Cheek Sideways Bone Size (In/Out)
    /// 
    /// 10 - Cheek Bones Width (Puffed/Gaunt)
    /// 
    /// 11 - Eye Opening (Both) (Wide/Squinted)
    /// 
    /// 12 - Lip Thickness (Both) (Fat/Thin)
    /// 
    /// 13 - Jaw Bone Width (Narrow/Wide)
    /// 
    /// 14 - Jaw Bone Shape (Round/Square)
    /// 
    /// 15 - Chin Bone (Up/Down)
    /// 
    /// 16 - Chin Bone Length (In/Out or Backward/Forward)
    /// 
    /// 17 - Chin Bone Shape (Pointed/Square)
    /// 
    /// 18 - Chin Hole (Chin Bum)
    /// 
    /// 19 - Neck Thickness (Thin/Thick)
    pub inline fn setPedMicroMorph(ped: types.Ped, index: c_int, scale: f32) !void { try invoker.invoke(void, 0x71A5C1DBA060049E, .{ped, index, scale}); } // 0x71A5C1DBA060049E  b323
    pub inline fn hasPedHeadBlendFinished(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x654CD0A825161131, .{ped}); } // 0x654CD0A825161131 0x2B1BD9C5 b323
    pub inline fn finalizeHeadBlend(ped: types.Ped) !void { try invoker.invoke(void, 0x4668D80430D6C299, .{ped}); } // 0x4668D80430D6C299 0x894314A4 b323
    /// p4 seems to vary from 0 to 3. \
    /// Preview: https://gfycat.com/MaleRareAmazonparrot
    pub inline fn setHeadBlendPaletteColor(ped: types.Ped, r: c_int, g: c_int, b: c_int, id: c_int) !void { try invoker.invoke(void, 0xCC9682B8951C5229, .{ped, r, g, b, id}); } // 0xCC9682B8951C5229 0x57E5B3F9 b323
    pub inline fn disableHeadBlendPaletteColor(ped: types.Ped) !void { try invoker.invoke(void, 0xA21C118553BBDF02, .{ped}); } // 0xA21C118553BBDF02 0xC6F36292 b323
    /// Type equals 0 for male non-dlc, 1 for female non-dlc, 2 for male dlc, and 3 for female dlc.
    /// 
    /// Used when calling SET_PED_HEAD_BLEND_DATA.
    pub inline fn getPedHeadBlendFirstIndex(@"type": c_int) !c_int { return try invoker.invoke(c_int, 0x68D353AB88B97E0C, .{@"type"}); } // 0x68D353AB88B97E0C 0x211DEFEC b323
    /// Type equals 0 for male non-dlc, 1 for female non-dlc, 2 for male dlc, and 3 for female dlc.
    pub inline fn getPedHeadBlendNumHeads(@"type": c_int) !c_int { return try invoker.invoke(c_int, 0x5EF37013A6539C9D, .{@"type"}); } // 0x5EF37013A6539C9D 0x095D3BD8 b323
    /// from extreme3.c4 \
    /// PED::SET_PED_PRELOAD_VARIATION_DATA(PLAYER::PLAYER_PED_ID(), 8, PED::GET_PED_DRAWABLE_VARIATION(PLAYER::PLAYER_PED_ID(), 8), PED::GET_PED_TEXTURE_VARIATION(PLAYER::PLAYER_PED_ID(), 8));
    /// 
    /// p1 is probably componentId
    pub inline fn setPedPreloadVariationData(ped: types.Ped, slot: c_int, drawable_id: c_int, texture_id: c_int) !c_int { return try invoker.invoke(c_int, 0x39D55A620FCB6A3A, .{ped, slot, drawable_id, texture_id}); } // 0x39D55A620FCB6A3A 0x45F3BDFB b323
    pub inline fn hasPedPreloadVariationDataFinished(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x66680A92700F43DF, .{ped}); } // 0x66680A92700F43DF 0xC6517D52 b323
    pub inline fn releasePedPreloadVariationData(ped: types.Ped) !void { try invoker.invoke(void, 0x5AAB586FFEC0FD96, .{ped}); } // 0x5AAB586FFEC0FD96 0x6435F67F b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn setPedPreloadPropData(ped: types.Ped, component_id: c_int, drawable_id: c_int, _texture_id: c_int) !c_int { return try invoker.invoke(c_int, 0x2B16A3BFF1FBCE49, .{ped, component_id, drawable_id, _texture_id}); } // 0x2B16A3BFF1FBCE49 0xC0E23671 b323
    pub inline fn hasPedPreloadPropDataFinished(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x784002A632822099, .{ped}); } // 0x784002A632822099 0x3B0CA391 b323
    pub inline fn releasePedPreloadPropData(ped: types.Ped) !void { try invoker.invoke(void, 0xF79F9DEF0AADE61A, .{ped}); } // 0xF79F9DEF0AADE61A 0xFD103BA7 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getPedPropIndex(ped: types.Ped, component_id: c_int, p_2: types.Any) !c_int { return try invoker.invoke(c_int, 0x898CC20EA75BACD8, .{ped, component_id, p_2}); } // 0x898CC20EA75BACD8 0x746DDAC0 b323
    /// ComponentId can be set to various things based on what category you're wanting to set \
    /// enum PedPropsData \
    /// { \
    ///     PED_PROP_HATS = 0,
    ///     PED_PROP_GLASSES = 1,
    ///  PED_PROP_EARS = 2, \
    ///     PED_PROP_WATCHES = 3,
    /// }; \
    /// Usage: SET_PED_PROP_INDEX(playerPed, PED_PROP_HATS, GET_NUMBER_OF_PED_PROP_DRAWABLE_VARIATIONS(playerPed, PED_PROP_HATS), GET_NUMBER_OF_PED_PROP_TEXTURE_VARIATIONS(playerPed, PED_PROP_HATS, 0), TRUE);
    /// 
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn setPedPropIndex(ped: types.Ped, component_id: c_int, drawable_id: c_int, _texture_id: c_int, attach: windows.BOOL, p_5: types.Any) !void { try invoker.invoke(void, 0x93376B65A266EB5F, .{ped, component_id, drawable_id, _texture_id, attach, p_5}); } // 0x93376B65A266EB5F 0x0829F2E2 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn knockOffPedProp(ped: types.Ped, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x6FD7816A36615F48, .{ped, p_1, p_2, p_3, p_4}); } // 0x6FD7816A36615F48 0x08D8B180 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn clearPedProp(ped: types.Ped, prop_id: c_int, p_2: types.Any) !void { try invoker.invoke(void, 0x0943E5B8E078E76E, .{ped, prop_id, p_2}); } // 0x0943E5B8E078E76E 0x2D23D743 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn clearAllPedProps(ped: types.Ped, p_1: types.Any) !void { try invoker.invoke(void, 0xCD8A7537A9B52F06, .{ped, p_1}); } // 0xCD8A7537A9B52F06 0x81DF8B43 b323
    pub inline fn dropAmbientProp(ped: types.Ped) !void { try invoker.invoke(void, 0xAFF4710E2A0A6C12, .{ped}); } // 0xAFF4710E2A0A6C12 0x728D3D53 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn getPedPropTextureIndex(ped: types.Ped, component_id: c_int) !c_int { return try invoker.invoke(c_int, 0xE131A28626F81AB2, .{ped, component_id}); } // 0xE131A28626F81AB2 0x922A6653 b323
    pub inline fn clearPedParachutePackVariation(ped: types.Ped) !void { try invoker.invoke(void, 0x1280804F7CFD2D6C, .{ped}); } // 0x1280804F7CFD2D6C 0x7BCD8991 b323
    /// This native sets a scuba mask for freemode models and an oxygen bottle for player_* models. It works on freemode and player_* models.
    pub inline fn setPedScubaGearVariation(ped: types.Ped) !void { try invoker.invoke(void, 0x36C6984C3ED0C911, .{ped}); } // 0x36C6984C3ED0C911  b323
    /// Removes the scubagear (for mp male: component id: 8, drawableId: 123, textureId: any) from peds. Does not play the 'remove scuba gear' animation, but instantly removes it.
    pub inline fn clearPedScubaGearVariation(ped: types.Ped) !void { try invoker.invoke(void, 0xB50EB4CCB29704AC, .{ped}); } // 0xB50EB4CCB29704AC 0x080275EE b323
    pub inline fn isUsingPedScubaGearVariation(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFEC9A3B1820F3331, .{p_0}); } // 0xFEC9A3B1820F3331  b323
    /// works with TASK::TASK_SET_BLOCKING_OF_NON_TEMPORARY_EVENTS to make a ped completely oblivious to all events going on around him
    pub inline fn setBlockingOfNonTemporaryEvents(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9F8AA94D6D97DBF4, .{ped, toggle}); } // 0x9F8AA94D6D97DBF4 0xDFE34E4A b323
    pub inline fn setPedBoundsOrientation(ped: types.Ped, p_1: f32, p_2: f32, vec: types.Vector3) !void { try invoker.invoke(void, 0x4F5F651ACCC9C4CF, .{ped, p_1, p_2, vec.x, vec.y, vec.z}); } // 0x4F5F651ACCC9C4CF 0xCFA20D68 b323
    /// PED::REGISTER_TARGET(l_216, PLAYER::PLAYER_PED_ID()); from re_prisonbreak.txt.
    /// 
    /// l_216 = RECSBRobber1
    pub inline fn registerTarget(ped: types.Ped, target: types.Ped) !void { try invoker.invoke(void, 0x2F25D9AEFA34FBA2, .{ped, target}); } // 0x2F25D9AEFA34FBA2 0x50A95442 b323
    /// Based on TASK_COMBAT_HATED_TARGETS_AROUND_PED, the parameters are likely similar (PedHandle, and area to attack in).
    pub inline fn registerHatedTargetsAroundPed(ped: types.Ped, radius: f32) !void { try invoker.invoke(void, 0x9222F300BF8354FE, .{ped, radius}); } // 0x9222F300BF8354FE 0x7F87559E b323
    /// Gets a random ped in the x/y/zRadius near the x/y/z coordinates passed. 
    /// 
    /// Ped Types: \
    /// Any = -1 \
    /// Player = 1 \
    /// Male = 4  \
    /// Female = 5  \
    /// Cop = 6 \
    /// Human = 26 \
    /// SWAT = 27  \
    /// Animal = 28 \
    /// Army = 29
    pub inline fn getRandomPedAtCoord(vec: types.Vector3, radius__: types.Vector3, ped_type: c_int) !types.Ped { return try invoker.invoke(types.Ped, 0x876046A8E3A4B71C, .{vec.x, vec.y, vec.z, radius__.x, radius__.y, radius__.z, ped_type}); } // 0x876046A8E3A4B71C 0xDC8239EB b323
    /// Gets the closest ped in a radius.
    /// 
    /// Ped Types: \
    /// Any ped = -1 \
    /// Player = 1 \
    /// Male = 4  \
    /// Female = 5  \
    /// Cop = 6 \
    /// Human = 26 \
    /// SWAT = 27  \
    /// Animal = 28 \
    /// Army = 29
    /// 
    /// ------------------ \
    /// P4 P5 P7 P8 \
    /// 1  0  x  x  = return nearest walking Ped \
    /// 1  x  0  x  = return nearest walking Ped \
    /// x  1  1  x  = return Ped you are using \
    /// 0  0  x  x  = no effect \
    /// 0  x  0  x  = no effect
    /// 
    /// x = can be 1 or 0. Does not have any obvious changes.
    /// 
    /// This function does not return ped who is: \
    /// 1. Standing still \
    /// 2. Driving \
    /// 3. Fleeing \
    /// 4. Attacking
    /// 
    /// This function only work if the ped is: \
    /// 1. walking normally. \
    /// 2. waiting to cross a road.
    /// 
    /// Note: PED::GET_PED_NEARBY_PEDS works for more peds.
    pub inline fn getClosestPed(vec: types.Vector3, radius: f32, p_4: windows.BOOL, p_5: windows.BOOL, out_ped: [*c]types.Ped, p_7: windows.BOOL, p_8: windows.BOOL, ped_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC33AB876A77F8164, .{vec.x, vec.y, vec.z, radius, p_4, p_5, out_ped, p_7, p_8, ped_type}); } // 0xC33AB876A77F8164 0x8F6C1F55 b323
    /// Sets a value indicating whether scenario peds should be returned by the next call to a command that returns peds. Eg. GET_CLOSEST_PED.
    pub inline fn setScenarioPedsToBeReturnedByNextCommand(value: windows.BOOL) !void { try invoker.invoke(void, 0x14F19A8782C8071E, .{value}); } // 0x14F19A8782C8071E 0x85615FD0 b323
    pub inline fn getCanPedBeGrabbedByScript(ped: types.Ped, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL, p_4: windows.BOOL, p_5: windows.BOOL, p_6: windows.BOOL, p_7: windows.BOOL, p_8: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x03EA03AF85A85CB7, .{ped, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0x03EA03AF85A85CB7 0x18DD76A1 b323
    /// Scripts use 0.2, 0.5 and 1.0. Value must be >= 0.0 && <= 1.0
    pub inline fn setDriverRacingModifier(driver: types.Ped, modifier: f32) !void { try invoker.invoke(void, 0xDED5AF5A0EA4B297, .{driver, modifier}); } // 0xDED5AF5A0EA4B297 0x6D55B3B3 b323
    /// The function specifically verifies the value is equal to, or less than 1.0f. If it is greater than 1.0f, the function does nothing at all.
    pub inline fn setDriverAbility(driver: types.Ped, ability: f32) !void { try invoker.invoke(void, 0xB195FFA8042FC5C3, .{driver, ability}); } // 0xB195FFA8042FC5C3 0xAAD4012C b323
    /// range 0.0f - 1.0f
    pub inline fn setDriverAggressiveness(driver: types.Ped, aggressiveness: f32) !void { try invoker.invoke(void, 0xA731F608CA104E3C, .{driver, aggressiveness}); } // 0xA731F608CA104E3C 0x8B02A8FB b323
    /// Prevents the ped from going limp.
    /// 
    /// [Example: Can prevent peds from falling when standing on moving vehicles.]
    pub inline fn canPedRagdoll(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x128F79EDCECE4FD5, .{ped}); } // 0x128F79EDCECE4FD5 0xC0EFB7A3 b323
    /// p4/p5: Unused in TU27 \
    /// Ragdoll Types: \
    /// **0**: CTaskNMRelax \
    /// **1**: CTaskNMScriptControl: Hardcoded not to work in networked environments. \
    /// **Else**: CTaskNMBalance \
    /// time1- Time(ms) Ped is in ragdoll mode; only applies to ragdoll types 0 and not 1.
    /// 
    /// time2- Unknown time, in milliseconds
    /// 
    /// ragdollType- \
    /// 0 : Normal ragdoll \
    /// 1 : Falls with stiff legs/body \
    /// 2 : Narrow leg stumble(may not fall) \
    /// 3 : Wide leg stumble(may not fall)
    /// 
    /// p4, p5, p6- No idea. In R*'s scripts they are usually either "true, true, false" or "false, false, false".
    /// 
    /// 
    /// 
    /// 
    /// EDIT 3/11/16: unclear what 'mircoseconds' mean-- a microsecond is 1000x a ms, so time2 must be 1000x time1?  more testing needed.  -sob
    /// 
    /// Edit Mar 21, 2017: removed part about time2 being the microseconds version of time1. this just isn't correct. time2 is in milliseconds, and time1 and time2 don't seem to be connected in any way.
    pub inline fn setPedToRagdoll(ped: types.Ped, time_1: c_int, time_2: c_int, ragdoll_type: c_int, p_4: windows.BOOL, p_5: windows.BOOL, p_6: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAE99FB955581844A, .{ped, time_1, time_2, ragdoll_type, p_4, p_5, p_6}); } // 0xAE99FB955581844A 0x83CB5052 b323
    /// Return variable is never used in R*'s scripts.
    /// 
    /// Not sure what p2 does. It seems like it would be a time judging by it's usage in R*'s scripts, but didn't seem to affect anything in my testings.
    /// 
    /// enum eRagdollType \
    /// { \
    ///  RD_MALE=0, \
    ///  RD_FEMALE = 1, \
    ///  RD_MALE_LARGE = 2, \
    ///  RD_CUSTOM = 3, \
    /// }
    /// 
    /// x, y, and z are coordinates, most likely to where the ped will fall.
    /// 
    /// p8 to p13 are always 0f in R*'s scripts.
    /// 
    /// (Simplified) Example of the usage of the function from R*'s scripts: \
    /// ped::set_ped_to_ragdoll_with_fall(ped, 1500, 2000, 1, -entity::get_entity_forward_vector(ped), 1f, 0f, 0f, 0f, 0f, 0f, 0f);
    /// 
    pub inline fn setPedToRagdollWithFall(ped: types.Ped, time: c_int, p_2: c_int, ragdoll_type: c_int, vec: types.Vector3, velocity: f32, p_8: f32, p_9: f32, p_1_0: f32, p_1_1: f32, p_1_2: f32, p_1_3: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD76632D99E4966C8, .{ped, time, p_2, ragdoll_type, vec.x, vec.y, vec.z, velocity, p_8, p_9, p_1_0, p_1_1, p_1_2, p_1_3}); } // 0xD76632D99E4966C8 0xFA12E286 b323
    /// Causes Ped to ragdoll on collision with any object (e.g Running into trashcan). If applied to player you will sometimes trip on the sidewalk.
    pub inline fn setPedRagdollOnCollision(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF0A4F1BBF4FA7497, .{ped, toggle}); } // 0xF0A4F1BBF4FA7497 0x2654A0F4 b323
    /// If the ped handle passed through the parenthesis is in a ragdoll state this will return true.
    pub inline fn isPedRagdoll(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x47E4E977581C5B55, .{ped}); } // 0x47E4E977581C5B55 0xC833BBE1 b323
    pub inline fn isPedRunningRagdollTask(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE3B6097CC25AA69E, .{ped}); } // 0xE3B6097CC25AA69E 0x44A153F2 b323
    pub inline fn setPedRagdollForceFall(ped: types.Ped) !void { try invoker.invoke(void, 0x01F6594B923B9251, .{ped}); } // 0x01F6594B923B9251 0x20A5BDE0 b323
    pub inline fn resetPedRagdollTimer(ped: types.Ped) !void { try invoker.invoke(void, 0x9FA4664CF62E47E8, .{ped}); } // 0x9FA4664CF62E47E8 0xF2865370 b323
    pub inline fn setPedCanRagdoll(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB128377056A54E2A, .{ped, toggle}); } // 0xB128377056A54E2A 0xCF1384C4 b323
    pub inline fn isPedRunningMeleeTask(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD1871251F3B5ACD7, .{ped}); } // 0xD1871251F3B5ACD7 0xBD4236F6 b323
    pub inline fn isPedRunningMobilePhoneTask(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2AFE52F782F25775, .{ped}); } // 0x2AFE52F782F25775 0xFB2AFED1 b323
    pub inline fn isMobilePhoneToPedEar(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA3F3564A5B3646C0, .{ped}); } // 0xA3F3564A5B3646C0 0x97353375 b323
    /// Works for both player and peds,
    /// 
    /// enum eRagdollBlockingFlags \
    /// { \
    ///  RBF_BULLET_IMPACT = 0, \
    ///  RBF_VEHICLE_IMPACT = 1, \
    ///  RBF_FIRE = 2, \
    ///  RBF_ELECTROCUTION = 3, \
    ///  RBF_PLAYER_IMPACT = 4, \
    ///  RBF_EXPLOSION = 5,0 \
    ///  RBF_IMPACT_OBJECT = 6, \
    ///  RBF_MELEE = 7, \
    ///  RBF_RUBBER_BULLET = 8, \
    ///  RBF_FALLING = 9, \
    ///  RBF_WATER_JET = 10, \
    ///  RBF_DROWNING = 11, \
    ///  _0x9F52E2C4 = 12, \
    ///  RBF_PLAYER_BUMP = 13, \
    ///  RBF_PLAYER_RAGDOLL_BUMP = 14, \
    ///  RBF_PED_RAGDOLL_BUMP = 15, \
    ///  RBF_VEHICLE_GRAB = 16, \
    ///  RBF_SMOKE_GRENADE = 17, \
    /// };
    /// 
    /// 
    pub inline fn setRagdollBlockingFlags(ped: types.Ped, blocking_flag: c_int) !void { try invoker.invoke(void, 0x26695EC767728D84, .{ped, blocking_flag}); } // 0x26695EC767728D84 0x9C8F830D b323
    /// See SET_RAGDOLL_BLOCKING_FLAGS for flags
    pub inline fn clearRagdollBlockingFlags(ped: types.Ped, blocking_flag: c_int) !void { try invoker.invoke(void, 0xD86D101FCFD00A4B, .{ped, blocking_flag}); } // 0xD86D101FCFD00A4B 0x77CBA290 b323
    pub inline fn setPedAngledDefensiveArea(ped: types.Ped, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: windows.BOOL, p_9: windows.BOOL) !void { try invoker.invoke(void, 0xC7F76DF27A5045A1, .{ped, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9}); } // 0xC7F76DF27A5045A1 0x3EFBDD9B b323
    pub inline fn setPedSphereDefensiveArea(ped: types.Ped, vec: types.Vector3, radius: f32, p_5: windows.BOOL, p_6: windows.BOOL) !void { try invoker.invoke(void, 0x9D3151A373974804, .{ped, vec.x, vec.y, vec.z, radius, p_5, p_6}); } // 0x9D3151A373974804 0xBD96D8E8 b323
    pub inline fn setPedDefensiveSphereAttachedToPed(ped: types.Ped, target: types.Ped, offset__: types.Vector3, radius: f32, p_6: windows.BOOL) !void { try invoker.invoke(void, 0xF9B8F91AAD3B953E, .{ped, target, offset__.x, offset__.y, offset__.z, radius, p_6}); } // 0xF9B8F91AAD3B953E 0x40638BDC b323
    pub inline fn setPedDefensiveSphereAttachedToVehicle(ped: types.Ped, target: types.Vehicle, offset__: types.Vector3, radius: f32, p_6: windows.BOOL) !void { try invoker.invoke(void, 0xE4723DB6E736CCFF, .{ped, target, offset__.x, offset__.y, offset__.z, radius, p_6}); } // 0xE4723DB6E736CCFF 0x4763B2C6 b323
    pub inline fn setPedDefensiveAreaAttachedToPed(ped: types.Ped, attach_ped: types.Ped, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: f32, p_9: windows.BOOL, p_1_0: windows.BOOL) !void { try invoker.invoke(void, 0x4EF47FE21698A8B6, .{ped, attach_ped, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0}); } // 0x4EF47FE21698A8B6 0x74BDA7CE b323
    pub inline fn setPedDefensiveAreaDirection(ped: types.Ped, p_1: f32, p_2: f32, p_3: f32, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x413C6C763A4AFFAD, .{ped, p_1, p_2, p_3, p_4}); } // 0x413C6C763A4AFFAD 0xB66B0C9A b323
    /// Ped will no longer get angry when you stay near him.
    pub inline fn removePedDefensiveArea(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x74D4E028107450A9, .{ped, toggle}); } // 0x74D4E028107450A9 0x34AAAFA5 b323
    pub inline fn getPedDefensiveAreaPosition(ped: types.Ped, p_1: windows.BOOL) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x3C06B8786DD94CD1, .{ped, p_1}); } // 0x3C06B8786DD94CD1 0xCB65198D b323
    pub inline fn isPedDefensiveAreaActive(ped: types.Ped, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBA63D9FE45412247, .{ped, p_1}); } // 0xBA63D9FE45412247 0x6D88BCD3 b323
    pub inline fn setPedPreferredCoverSet(ped: types.Ped, item_set: types.Any) !void { try invoker.invoke(void, 0x8421EB4DA7E391B9, .{ped, item_set}); } // 0x8421EB4DA7E391B9 0xF3B7EFBF b323
    pub inline fn removePedPreferredCoverSet(ped: types.Ped) !void { try invoker.invoke(void, 0xFDDB234CF74073D9, .{ped}); } // 0xFDDB234CF74073D9 0xA0134498 b323
    /// It will revive/cure the injured ped. The condition is ped must not be dead.
    /// 
    /// Upon setting and converting the health int, found, if health falls below 5, the ped will lay on the ground in pain(Maximum default health is 100).
    /// 
    /// This function is well suited there.
    pub inline fn reviveInjuredPed(ped: types.Ped) !void { try invoker.invoke(void, 0x8D8ACD8388CD99CE, .{ped}); } // 0x8D8ACD8388CD99CE 0x14D3E6E3 b323
    /// This function will simply bring the dead person back to life.
    /// 
    /// Try not to use it alone, since using this function alone, will make peds fall through ground in hell(well for the most of the times).
    /// 
    /// Instead, before calling this function, you may want to declare the position, where your Resurrected ped to be spawn at.(For instance, Around 2 floats of Player's current position.) 
    /// 
    /// Also, disabling any assigned task immediately helped in the number of scenarios, where If you want peds to perform certain decided tasks.
    pub inline fn resurrectPed(ped: types.Ped) !void { try invoker.invoke(void, 0x71BC8E838B9C6035, .{ped}); } // 0x71BC8E838B9C6035 0xA4B82097 b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    /// 
    /// *untested but char *name could also be a hash for a localized string
    pub inline fn setPedNameDebug(ped: types.Ped, name: [*c]const u8) !void { try invoker.invoke(void, 0x98EFA132A4117BE1, .{ped, name}); } // 0x98EFA132A4117BE1 0x20D6273E b323
    /// Gets the offset the specified ped has moved since the previous tick.
    /// 
    /// If worldSpace is false, the returned offset is relative to the ped. That is, if the ped has moved 1 meter right and 5 meters forward, it'll return 1,5,0.
    /// 
    /// If worldSpace is true, the returned offset is relative to the world. That is, if the ped has moved 1 meter on the X axis and 5 meters on the Y axis, it'll return 1,5,0.
    pub inline fn getPedExtractedDisplacement(ped: types.Ped, world_space: windows.BOOL) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xE0AF41401ADF87E3, .{ped, world_space}); } // 0xE0AF41401ADF87E3 0x5231F901 b323
    pub inline fn setPedDiesWhenInjured(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5BA7919BED300023, .{ped, toggle}); } // 0x5BA7919BED300023 0xE94E24D4 b323
    pub inline fn setPedEnableWeaponBlocking(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x97A790315D3831FD, .{ped, toggle}); } // 0x97A790315D3831FD 0x4CAD1A4A b323
    /// p1 was always 1 (true).
    /// 
    /// Kicks the ped from the current vehicle and keeps the rendering-focus on this ped (also disables its collision). If doing this for your player ped, you'll still be able to drive the vehicle.
    pub inline fn specialFunctionDoNotUse(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xF9ACF4A08098EA25, .{ped, p_1}); } // 0xF9ACF4A08098EA25 0x141CC936 b323
    pub inline fn resetPedVisibleDamage(ped: types.Ped) !void { try invoker.invoke(void, 0x3AC1F7B898F30C05, .{ped}); } // 0x3AC1F7B898F30C05 0xC4BC4841 b323
    pub inline fn applyPedBloodDamageByZone(ped: types.Ped, p_1: types.Any, p_2: f32, p_3: f32, p_4: types.Any) !void { try invoker.invoke(void, 0x816F6981C60BF53B, .{ped, p_1, p_2, p_3, p_4}); } // 0x816F6981C60BF53B 0x1E54DB12 b323
    /// woundTypes: \
    /// - soak_splat \
    /// - wound_sheet \
    /// - BulletSmall \
    /// - BulletLarge \
    /// - ShotgunSmall \
    /// - ShotgunSmallMonolithic \
    /// - ShotgunLarge \
    /// - ShotgunLargeMonolithic \
    /// - NonFatalHeadshot \
    /// - stab \
    /// - BasicSlash \
    /// - Scripted_Ped_Splash_Back \
    /// - BackSplash
    pub inline fn applyPedBlood(ped: types.Ped, bone_index: c_int, rot__: types.Vector3, wound_type: [*c]const u8) !void { try invoker.invoke(void, 0x83F7E01C7B769A26, .{ped, bone_index, rot__.x, rot__.y, rot__.z, wound_type}); } // 0x83F7E01C7B769A26 0x376CE3C0 b323
    pub inline fn applyPedBloodByZone(ped: types.Ped, p_1: c_int, p_2: f32, p_3: f32, p_4: [*c]const u8) !void { try invoker.invoke(void, 0x3311E47B91EDCBBC, .{ped, p_1, p_2, p_3, p_4}); } // 0x3311E47B91EDCBBC 0x8F3F3A9C b323
    pub inline fn applyPedBloodSpecific(ped: types.Ped, p_1: c_int, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: c_int, p_7: f32, p_8: [*c]const u8) !void { try invoker.invoke(void, 0xEF0D582CBF2D9B0F, .{ped, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0xEF0D582CBF2D9B0F 0xFC13CE80 b323
    /// enum eDamageZone \
    /// { \
    ///     DZ_Torso = 0,
    ///     DZ_Head,
    ///     DZ_LeftArm,
    ///     DZ_RightArm,
    ///     DZ_LeftLeg,
    ///     DZ_RightLeg,
    /// };
    /// 
    /// Decal Names: \
    /// scar \
    /// blushing \
    /// cs_flush_anger \
    /// cs_flush_anger_face \
    /// bruise \
    /// bruise_large \
    /// herpes \
    /// ArmorBullet \
    /// basic_dirt_cloth \
    /// basic_dirt_skin \
    /// cs_trev1_dirt
    /// 
    /// APPLY_PED_DAMAGE_DECAL(ped, 1, 0.5f, 0.513f, 0f, 1f, unk, 0, 0, "blushing");
    pub inline fn applyPedDamageDecal(ped: types.Ped, damage_zone: c_int, offset__: types.Vector2, heading: f32, scale: f32, alpha: f32, variation: c_int, fade_in: windows.BOOL, decal_name: [*c]const u8) !void { try invoker.invoke(void, 0x397C38AA7B4A5F83, .{ped, damage_zone, offset__.x, offset__.y, heading, scale, alpha, variation, fade_in, decal_name}); } // 0x397C38AA7B4A5F83 0x8A13A41F b323
    /// Damage Packs:
    /// 
    /// "SCR_TrevorTreeBang" \
    /// "HOSPITAL_0" \
    /// "HOSPITAL_1" \
    /// "HOSPITAL_2" \
    /// "HOSPITAL_3" \
    /// "HOSPITAL_4" \
    /// "HOSPITAL_5" \
    /// "HOSPITAL_6" \
    /// "HOSPITAL_7" \
    /// "HOSPITAL_8" \
    /// "HOSPITAL_9" \
    /// "SCR_Dumpster" \
    /// "BigHitByVehicle" \
    /// "SCR_Finale_Michael_Face" \
    /// "SCR_Franklin_finb" \
    /// "SCR_Finale_Michael" \
    /// "SCR_Franklin_finb2" \
    /// "Explosion_Med" \
    /// "SCR_Torture" \
    /// "SCR_TracySplash" \
    /// "Skin_Melee_0"
    /// 
    /// Additional damage packs:
    /// 
    /// gist.github.com/alexguirre/f3f47f75ddcf617f416f3c8a55ae2227 \
    /// Full list of ped damage packs by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedDamagePacks.json
    pub inline fn applyPedDamagePack(ped: types.Ped, damage_pack: [*c]const u8, damage: f32, mult: f32) !void { try invoker.invoke(void, 0x46DF918788CB093F, .{ped, damage_pack, damage, mult}); } // 0x46DF918788CB093F 0x208D0CB8 b323
    pub inline fn clearPedBloodDamage(ped: types.Ped) !void { try invoker.invoke(void, 0x8FE22675A5A45817, .{ped}); } // 0x8FE22675A5A45817 0xF7ADC960 b323
    /// Somehow related to changing ped's clothes.
    pub inline fn clearPedBloodDamageByZone(ped: types.Ped, p_1: c_int) !void { try invoker.invoke(void, 0x56E3B78C5408D9F4, .{ped, p_1}); } // 0x56E3B78C5408D9F4 0xF210BE69 b323
    pub inline fn hidePedBloodDamageByZone(ped: types.Ped, p_1: types.Any, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x62AB793144DE75DC, .{ped, p_1, p_2}); } // 0x62AB793144DE75DC 0x0CB6C4ED b323
    /// p1: from 0 to 5 in the b617d scripts. \
    /// p2: "blushing" and "ALL" found in the b617d scripts.
    pub inline fn clearPedDamageDecalByZone(ped: types.Ped, p_1: c_int, p_2: [*c]const u8) !void { try invoker.invoke(void, 0x523C79AEEFCC4A2A, .{ped, p_1, p_2}); } // 0x523C79AEEFCC4A2A 0x70AA5B7D b323
    pub inline fn getPedDecorationsState(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x71EAB450D86954A1, .{ped}); } // 0x71EAB450D86954A1 0x47187F7F b323
    pub inline fn markPedDecorationsAsClonedFromLocalPlayer(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x2B694AFCF64E6994, .{ped, p_1}); } // 0x2B694AFCF64E6994  b323
    /// It clears the wetness of the selected Ped/Player. Clothes have to be wet to notice the difference.
    pub inline fn clearPedWetness(ped: types.Ped) !void { try invoker.invoke(void, 0x9C720776DAA43E7E, .{ped}); } // 0x9C720776DAA43E7E 0x629F15BD b323
    /// It adds the wetness level to the player clothing/outfit. As if player just got out from water surface.
    /// 
    /// 
    pub inline fn setPedWetnessHeight(ped: types.Ped, height: f32) !void { try invoker.invoke(void, 0x44CB6447D2571AA0, .{ped, height}); } // 0x44CB6447D2571AA0 0x7B33289A b323
    /// combined with PED::SET_PED_WETNESS_HEIGHT(), this native makes the ped drenched in water up to the height specified in the other function
    pub inline fn setPedWetnessEnabledThisFrame(ped: types.Ped) !void { try invoker.invoke(void, 0xB5485E4907B53019, .{ped}); } // 0xB5485E4907B53019 0xBDE749F7 b323
    pub inline fn setPedWetness(ped: types.Ped, wet_level: f32) !void { try invoker.invoke(void, 0xAC0BB4D87777CAE2, .{ped, wet_level}); } // 0xAC0BB4D87777CAE2  b2802
    pub inline fn clearPedEnvDirt(ped: types.Ped) !void { try invoker.invoke(void, 0x6585D955A68452A5, .{ped}); } // 0x6585D955A68452A5 0xA993915F b323
    /// Sweat is set to 100.0 or 0.0 in the decompiled scripts.
    pub inline fn setPedSweat(ped: types.Ped, sweat: f32) !void { try invoker.invoke(void, 0x27B0405F59637D1F, .{ped, sweat}); } // 0x27B0405F59637D1F 0x76A1DB9F b323
    /// Applies an Item from a PedDecorationCollection to a ped. These include tattoos and shirt decals.
    /// 
    /// collection - PedDecorationCollection filename hash \
    /// overlay - Item name hash
    /// 
    /// Example: \
    /// Entry inside "mpbeach_overlays.xml" - \
    /// <Item> \
    ///   <uvPos x="0.500000" y="0.500000" />
    ///   <scale x="0.600000" y="0.500000" />
    ///   <rotation value="0.000000" />
    ///   <nameHash>FM_Hair_Fuzz</nameHash>
    ///   <txdHash>mp_hair_fuzz</txdHash>
    ///   <txtHash>mp_hair_fuzz</txtHash>
    ///   <zone>ZONE_HEAD</zone>
    ///   <type>TYPE_TATTOO</type>
    ///   <faction>FM</faction>
    ///   <garment>All</garment>
    ///   <gender>GENDER_DONTCARE</gender>
    ///   <award />
    ///   <awardLevel />
    /// </Item>
    /// 
    /// Code: \
    /// PED::ADD_PED_DECORATION_FROM_HASHES(PLAYER::PLAYER_PED_ID(), MISC::GET_HASH_KEY("mpbeach_overlays"), MISC::GET_HASH_KEY("fm_hair_fuzz"))
    /// 
    /// Full list of ped overlays / decorations by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedOverlayCollections.json
    pub inline fn addPedDecorationFromHashes(ped: types.Ped, collection: types.Hash, overlay: types.Hash) !void { try invoker.invoke(void, 0x5F5D1665E352A839, .{ped, collection, overlay}); } // 0x5F5D1665E352A839 0x70559AC7 b323
    /// Full list of ped overlays / decorations by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedOverlayCollections.json
    pub inline fn addPedDecorationFromHashesInCorona(ped: types.Ped, collection: types.Hash, overlay: types.Hash) !void { try invoker.invoke(void, 0x5619BFA07CFD7833, .{ped, collection, overlay}); } // 0x5619BFA07CFD7833 0x8CD3E487 b323
    /// Returns the zoneID for the overlay if it is a member of collection. \
    /// enum ePedDecorationZone \
    /// { \
    ///     ZONE_TORSO = 0,
    ///     ZONE_HEAD = 1,
    ///     ZONE_LEFT_ARM = 2,
    ///     ZONE_RIGHT_ARM = 3,
    ///     ZONE_LEFT_LEG = 4,
    ///     ZONE_RIGHT_LEG = 5,
    ///     ZONE_MEDALS = 6,
    ///     ZONE_INVALID = 7
    /// };
    /// 
    /// Full list of ped overlays / decorations by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/pedOverlayCollections.json
    pub inline fn getPedDecorationZoneFromHashes(collection: types.Hash, overlay: types.Hash) !c_int { return try invoker.invoke(c_int, 0x9FD452BFBE7A7A8B, .{collection, overlay}); } // 0x9FD452BFBE7A7A8B 0x3543019E b323
    pub inline fn clearPedDecorations(ped: types.Ped) !void { try invoker.invoke(void, 0x0E5173C163976E38, .{ped}); } // 0x0E5173C163976E38 0xD4496BF3 b323
    pub inline fn clearPedDecorationsLeaveScars(ped: types.Ped) !void { try invoker.invoke(void, 0xE3B27E70CEAB9F0C, .{ped}); } // 0xE3B27E70CEAB9F0C 0xEFD58EB9 b323
    /// Despite this function's name, it simply returns whether the specified handle is a Ped.
    pub inline fn wasPedSkeletonUpdated(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x11B499C1E0FF8559, .{ped}); } // 0x11B499C1E0FF8559 0xF7E2FBAD b323
    /// Gets the position of the specified bone of the specified ped.
    /// 
    /// ped: The ped to get the position of a bone from. \
    /// boneId: The ID of the bone to get the position from. This is NOT the index. \
    /// offsetX: The X-component of the offset to add to the position relative to the bone's rotation. \
    /// offsetY: The Y-component of the offset to add to the position relative to the bone's rotation. \
    /// offsetZ: The Z-component of the offset to add to the position relative to the bone's rotation.
    pub inline fn getPedBoneCoords(ped: types.Ped, bone_id: c_int, offset__: types.Vector3) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x17C07FC640E86B4E, .{ped, bone_id, offset__.x, offset__.y, offset__.z}); } // 0x17C07FC640E86B4E 0x4579CAB1 b323
    /// Creates a new NaturalMotion message.
    /// 
    /// startImmediately: If set to true, the character will perform the message the moment it receives it by GIVE_PED_NM_MESSAGE. If false, the Ped will get the message but won't perform it yet. While it's a boolean value, if negative, the message will not be initialized. \
    /// messageId: The ID of the NaturalMotion message.
    /// 
    /// If a message already exists, this function does nothing. A message exists until the point it has been successfully dispatched by GIVE_PED_NM_MESSAGE.
    pub inline fn createNmMessage(start_immediately: windows.BOOL, message_id: c_int) !void { try invoker.invoke(void, 0x418EF2A1BCE56685, .{start_immediately, message_id}); } // 0x418EF2A1BCE56685 0x1CFBFD4B b323
    /// Sends the message that was created by a call to CREATE_NM_MESSAGE to the specified Ped.
    /// 
    /// If a message hasn't been created already, this function does nothing. \
    /// If the Ped is not ragdolled with Euphoria enabled, this function does nothing. \
    /// The following call can be used to ragdoll the Ped with Euphoria enabled: SET_PED_TO_RAGDOLL(ped, 4000, 5000, 1, 1, 1, 0);
    /// 
    /// Call order: \
    /// SET_PED_TO_RAGDOLL \
    /// CREATE_NM_MESSAGE \
    /// GIVE_PED_NM_MESSAGE
    /// 
    /// Multiple messages can be chained. Eg. to make the ped stagger and swing his arms around, the following calls can be made: \
    /// SET_PED_TO_RAGDOLL(ped, 4000, 5000, 1, 1, 1, 0); \
    /// CREATE_NM_MESSAGE(true, 0); // stopAllBehaviours - Stop all other behaviours, in case the Ped is already doing some Euphoria stuff. \
    /// GIVE_PED_NM_MESSAGE(ped); // Dispatch message to Ped. \
    /// CREATE_NM_MESSAGE(true, 1151); // staggerFall - Attempt to walk while falling. \
    /// GIVE_PED_NM_MESSAGE(ped); // Dispatch message to Ped. \
    /// CREATE_NM_MESSAGE(true, 372); // armsWindmill - Swing arms around. \
    /// GIVE_PED_NM_MESSAGE(ped); // Dispatch message to Ped.
    pub inline fn givePedNmMessage(ped: types.Ped) !void { try invoker.invoke(void, 0xB158DFCCC56E5C5B, .{ped}); } // 0xB158DFCCC56E5C5B 0x737C3689 b323
    pub inline fn addScenarioBlockingArea(vec_1__: types.Vector3, vec_2__: types.Vector3, p_6: windows.BOOL, p_7: windows.BOOL, p_8: windows.BOOL, p_9: windows.BOOL, p_1_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x1B5C85C612E5256E, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_6, p_7, p_8, p_9, p_1_0}); } // 0x1B5C85C612E5256E 0xA38C0234 b323
    pub inline fn removeScenarioBlockingAreas() !void { try invoker.invoke(void, 0xD37401D78A929A49, .{}); } // 0xD37401D78A929A49 0x4DDF845F b323
    pub inline fn removeScenarioBlockingArea(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x31D16B74C6E29D66, .{p_0, p_1}); } // 0x31D16B74C6E29D66 0x4483EF06 b323
    pub inline fn setScenarioPedsSpawnInSphereArea(vec: types.Vector3, range: f32, p_4: c_int) !void { try invoker.invoke(void, 0x28157D43CF600981, .{vec.x, vec.y, vec.z, range, p_4}); } // 0x28157D43CF600981 0x80EAD297 b323
    pub inline fn doesScenarioBlockingAreaExists(vec_1__: types.Vector3, vec_2__: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8A24B067D175A7BD, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0x8A24B067D175A7BD  b678
    /// Full list of ped scenarios by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenariosCompact.json
    pub inline fn isPedUsingScenario(ped: types.Ped, scenario: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1BF094736DD62C2E, .{ped, scenario}); } // 0x1BF094736DD62C2E 0x0F65B0D4 b323
    pub inline fn isPedUsingAnyScenario(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57AB4A3080F85143, .{ped}); } // 0x57AB4A3080F85143 0x195EF5B7 b323
    pub inline fn setPedPanicExitScenario(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFE07FF6495D52E2A, .{p_0, p_1, p_2, p_3}); } // 0xFE07FF6495D52E2A 0x59DE73AC b323
    pub inline fn toggleScenarioPedCowerInPlace(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9A77DFD295E29B09, .{ped, toggle}); } // 0x9A77DFD295E29B09 0xC08FE5F6 b323
    pub inline fn triggerPedScenarioPanicexittoflee(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x25361A96E0F7E419, .{p_0, p_1, p_2, p_3}); } // 0x25361A96E0F7E419 0x58C0F6CF b323
    pub inline fn setPedShouldPlayDirectedNormalScenarioExit(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEC6935EBE0847B90, .{p_0, p_1, p_2, p_3}); } // 0xEC6935EBE0847B90  b323
    pub inline fn setPedShouldPlayNormalScenarioExit(ped: types.Ped) !void { try invoker.invoke(void, 0xA3A9299C4F2ADB98, .{ped}); } // 0xA3A9299C4F2ADB98 0x033F43FA b323
    pub inline fn setPedShouldPlayImmediateScenarioExit(ped: types.Ped) !void { try invoker.invoke(void, 0xF1C03A5352243A30, .{ped}); } // 0xF1C03A5352243A30 0x4C684C81 b323
    pub inline fn setPedShouldPlayFleeScenarioExit(ped: types.Ped, p_1: types.Any, p_2: types.Any, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEEED8FAFEC331A70, .{ped, p_1, p_2, p_3}); } // 0xEEED8FAFEC331A70 0x7B4C3E6F b323
    pub inline fn setPedShouldIgnoreScenarioExitCollisionChecks(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x425AECF167663F48, .{ped, p_1}); } // 0x425AECF167663F48 0x5BC276AE b323
    pub inline fn setPedShouldIgnoreScenarioNavChecks(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x5B6010B3CBC29095, .{p_0, p_1}); } // 0x5B6010B3CBC29095  b323
    pub inline fn setPedShouldProbeForScenarioExitsInOneFrame(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xCEDA60A74219D064, .{p_0, p_1}); } // 0xCEDA60A74219D064  b323
    pub inline fn isPedGesturing(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC30BDAEE47256C13, .{p_0}); } // 0xC30BDAEE47256C13  b1868
    pub inline fn resetFacialIdleAnim(ped: types.Ped) !void { try invoker.invoke(void, 0x007FDE5A7897E426, .{ped}); } // 0x007FDE5A7897E426  b2802
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn playFacialAnim(ped: types.Ped, anim_name: [*c]const u8, anim_dict: [*c]const u8) !void { try invoker.invoke(void, 0xE1E65CA8AC9C00ED, .{ped, anim_name, anim_dict}); } // 0xE1E65CA8AC9C00ED 0x1F6CCDDE b323
    /// Clipsets: \
    /// facials@gen_female@base \
    /// facials@gen_male@base \
    /// facials@p_m_zero@base
    /// 
    /// Typically followed with SET_FACIAL_IDLE_ANIM_OVERRIDE: \
    /// mood_drunk_1 \
    /// mood_stressed_1 \
    /// mood_happy_1 \
    /// mood_talking_1
    /// 
    pub inline fn setFacialClipset(ped: types.Ped, anim_dict: [*c]const u8) !void { try invoker.invoke(void, 0x5687C7F05B39E401, .{ped, anim_dict}); } // 0x5687C7F05B39E401  b1493
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn setFacialIdleAnimOverride(ped: types.Ped, anim_name: [*c]const u8, anim_dict: [*c]const u8) !void { try invoker.invoke(void, 0xFFC24B988B938B38, .{ped, anim_name, anim_dict}); } // 0xFFC24B988B938B38 0x9BA19C13 b323
    pub inline fn clearFacialIdleAnimOverride(ped: types.Ped) !void { try invoker.invoke(void, 0x726256CC1EEB182F, .{ped}); } // 0x726256CC1EEB182F 0x5244F4E2 b323
    pub inline fn setPedCanPlayGestureAnims(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBAF20C5432058024, .{ped, toggle}); } // 0xBAF20C5432058024 0xE131E3B3 b323
    /// p2 usually 0
    pub inline fn setPedCanPlayVisemeAnims(ped: types.Ped, toggle: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xF833DDBA3B104D43, .{ped, toggle, p_2}); } // 0xF833DDBA3B104D43 0xA2FDAF27 b323
    pub inline fn setPedIsIgnoredByAutoOpenDoors(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x33A60D8BDD6E508C, .{ped, p_1}); } // 0x33A60D8BDD6E508C 0xADB2511A b323
    pub inline fn setPedCanPlayAmbientAnims(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6373D1349925A70E, .{ped, toggle}); } // 0x6373D1349925A70E 0xF8053081 b323
    pub inline fn setPedCanPlayAmbientBaseAnims(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0EB0585D15254740, .{ped, toggle}); } // 0x0EB0585D15254740 0x5720A5DD b323
    pub inline fn triggerIdleAnimationOnPed(ped: types.Ped) !void { try invoker.invoke(void, 0xC2EE020F5FB4DB53, .{ped}); } // 0xC2EE020F5FB4DB53 0xB7CD0A49 b323
    pub inline fn setPedCanArmIk(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6C3B4D6D13B4C841, .{ped, toggle}); } // 0x6C3B4D6D13B4C841 0x343B4DE0 b323
    pub inline fn setPedCanBodyRecoilIk(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE84EC1735FB39663, .{ped, toggle}); } // 0xE84EC1735FB39663  b3717
    pub inline fn setPedCanHeadIk(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC11C18092C5530DC, .{ped, toggle}); } // 0xC11C18092C5530DC 0xD3B04476 b323
    pub inline fn setPedCanLegIk(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x73518ECE2485412B, .{ped, toggle}); } // 0x73518ECE2485412B 0x9955BC6F b323
    pub inline fn setPedCanTorsoIk(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF2B7106D37947CE0, .{ped, toggle}); } // 0xF2B7106D37947CE0 0x8E5D4EAB b323
    pub inline fn setPedCanTorsoReactIk(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xF5846EDB26A98A24, .{ped, p_1}); } // 0xF5846EDB26A98A24 0x7B0040A8 b323
    pub inline fn setPedCanTorsoVehicleIk(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x6647C5F6F5792496, .{ped, p_1}); } // 0x6647C5F6F5792496 0x0FDA62DE b323
    pub inline fn setPedCanUseAutoConversationLookat(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEC4686EC06434678, .{ped, toggle}); } // 0xEC4686EC06434678 0x584C5178 b323
    pub inline fn isPedHeadtrackingPed(ped_1: types.Ped, ped_2: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5CD3CB88A7F8850D, .{ped_1, ped_2}); } // 0x5CD3CB88A7F8850D 0x2A5DF721 b323
    pub inline fn isPedHeadtrackingEntity(ped: types.Ped, entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x813A0A7C9D2E831F, .{ped, entity}); } // 0x813A0A7C9D2E831F 0x233C9ACF b323
    /// This is only called once in the scripts.
    /// 
    /// sub_1CD9(&l_49, 0, getElem(3, &l_34, 4), "MICHAEL", 0, 1); \
    ///                     sub_1CA8("WORLD_HUMAN_SMOKING", 2);
    ///                     PED::SET_PED_PRIMARY_LOOKAT(getElem(3, &l_34, 4), PLAYER::PLAYER_PED_ID());
    pub inline fn setPedPrimaryLookat(ped: types.Ped, look_at: types.Ped) !void { try invoker.invoke(void, 0xCD17B554996A8D9E, .{ped, look_at}); } // 0xCD17B554996A8D9E 0x6DEF6F1C b323
    pub inline fn setPedClothPinFrames(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x78C4E9961DB3EB5B, .{p_0, p_1}); } // 0x78C4E9961DB3EB5B  b323
    pub inline fn setPedClothPackageIndex(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x82A3D6D9CC2CB8E3, .{p_0, p_1}); } // 0x82A3D6D9CC2CB8E3  b323
    pub inline fn setPedClothProne(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xA660FAF550EB37E5, .{p_0, p_1}); } // 0xA660FAF550EB37E5  b323
    /// enum ePedConfigFlags \
    /// { \
    ///     _CPED_CONFIG_FLAG_0xC63DE95E = 1,
    ///     CPED_CONFIG_FLAG_NoCriticalHits = 2,
    ///     CPED_CONFIG_FLAG_DrownsInWater = 3,
    ///     CPED_CONFIG_FLAG_DisableReticuleFixedLockon = 4,
    ///     _CPED_CONFIG_FLAG_0x37D196F4 = 5,
    ///     _CPED_CONFIG_FLAG_0xE2462399 = 6,
    ///     CPED_CONFIG_FLAG_UpperBodyDamageAnimsOnly = 7,
    ///     _CPED_CONFIG_FLAG_0xEDDEB838 = 8,
    ///     _CPED_CONFIG_FLAG_0xB398B6FD = 9,
    ///     _CPED_CONFIG_FLAG_0xF6664E68 = 10,
    ///     _CPED_CONFIG_FLAG_0xA05E7CA3 = 11,
    ///     _CPED_CONFIG_FLAG_0xCE394045 = 12,
    ///     CPED_CONFIG_FLAG_NeverLeavesGroup = 13,
    ///     _CPED_CONFIG_FLAG_0xCD8D1411 = 14,
    ///     _CPED_CONFIG_FLAG_0xB031F1A9 = 15,
    ///     _CPED_CONFIG_FLAG_0xFE65BEE3 = 16,
    ///     CPED_CONFIG_FLAG_BlockNonTemporaryEvents = 17,
    ///     _CPED_CONFIG_FLAG_0x380165BD = 18,
    ///     _CPED_CONFIG_FLAG_0x07C045C7 = 19,
    ///     _CPED_CONFIG_FLAG_0x583B5E2D = 20,
    ///     _CPED_CONFIG_FLAG_0x475EDA58 = 21,
    ///     _CPED_CONFIG_FLAG_0x8629D05B = 22,
    ///     _CPED_CONFIG_FLAG_0x1522968B = 23,
    ///     CPED_CONFIG_FLAG_IgnoreSeenMelee = 24,
    ///     _CPED_CONFIG_FLAG_0x4CC09C4B = 25,
    ///     _CPED_CONFIG_FLAG_0x034F3053 = 26,
    ///     _CPED_CONFIG_FLAG_0xD91BA7CC = 27,
    ///     _CPED_CONFIG_FLAG_0x5C8DC66E = 28,
    ///     CPED_CONFIG_FLAG_GetOutUndriveableVehicle = 29,
    ///     _CPED_CONFIG_FLAG_0x6580B9D2 = 30,
    ///     _CPED_CONFIG_FLAG_0x0EF7A297 = 31,
    ///     CPED_CONFIG_FLAG_WillFlyThruWindscreen = 32,
    ///     CPED_CONFIG_FLAG_DieWhenRagdoll = 33,
    ///     CPED_CONFIG_FLAG_HasHelmet = 34,
    ///     CPED_CONFIG_FLAG_UseHelmet = 35,
    ///     CPED_CONFIG_FLAG_DontTakeOffHelmet = 36,
    ///     _CPED_CONFIG_FLAG_0xB130D17B = 37,
    ///     _CPED_CONFIG_FLAG_0x5F071200 = 38,
    ///     CPED_CONFIG_FLAG_DisableEvasiveDives = 39,
    ///     _CPED_CONFIG_FLAG_0xC287AAFF = 40,
    ///     _CPED_CONFIG_FLAG_0x203328CC = 41,
    ///     CPED_CONFIG_FLAG_DontInfluenceWantedLevel = 42,
    ///     CPED_CONFIG_FLAG_DisablePlayerLockon = 43,
    ///     CPED_CONFIG_FLAG_DisableLockonToRandomPeds = 44,
    ///     CPED_CONFIG_FLAG_AllowLockonToFriendlyPlayers = 45,
    ///     _CPED_CONFIG_FLAG_0xDB115BFA = 46,
    ///     CPED_CONFIG_FLAG_PedBeingDeleted = 47,
    ///     CPED_CONFIG_FLAG_BlockWeaponSwitching = 48,
    ///     _CPED_CONFIG_FLAG_0xF8E99565 = 49,
    ///     _CPED_CONFIG_FLAG_0xDD17FEE6 = 50,
    ///     _CPED_CONFIG_FLAG_0x7ED9B2C9 = 51,
    ///     _CPED_CONFIG_FLAG_NoCollison = 52,
    ///     _CPED_CONFIG_FLAG_0x5A6C1F6E = 53,
    ///     _CPED_CONFIG_FLAG_0xD749FC41 = 54,
    ///     _CPED_CONFIG_FLAG_0x357F63F3 = 55,
    ///     _CPED_CONFIG_FLAG_0xC5E60961 = 56,
    ///     _CPED_CONFIG_FLAG_0x29275C3E = 57,
    ///     CPED_CONFIG_FLAG_IsFiring = 58,
    ///     CPED_CONFIG_FLAG_WasFiring = 59,
    ///     CPED_CONFIG_FLAG_IsStanding = 60,
    ///     CPED_CONFIG_FLAG_WasStanding = 61,
    ///     CPED_CONFIG_FLAG_InVehicle = 62,
    ///     CPED_CONFIG_FLAG_OnMount = 63,
    ///     CPED_CONFIG_FLAG_AttachedToVehicle = 64,
    ///     CPED_CONFIG_FLAG_IsSwimming = 65,
    ///     CPED_CONFIG_FLAG_WasSwimming = 66,
    ///     CPED_CONFIG_FLAG_IsSkiing = 67,
    ///     CPED_CONFIG_FLAG_IsSitting = 68,
    ///     CPED_CONFIG_FLAG_KilledByStealth = 69,
    ///     CPED_CONFIG_FLAG_KilledByTakedown = 70,
    ///     CPED_CONFIG_FLAG_Knockedout = 71,
    ///     _CPED_CONFIG_FLAG_0x3E3C4560 = 72,
    ///     _CPED_CONFIG_FLAG_0x2994C7B7 = 73,
    ///     _CPED_CONFIG_FLAG_0x6D59D275 = 74,
    ///     CPED_CONFIG_FLAG_UsingCoverPoint = 75,
    ///     CPED_CONFIG_FLAG_IsInTheAir = 76,
    ///     _CPED_CONFIG_FLAG_0x2D493FB7 = 77,
    ///     CPED_CONFIG_FLAG_IsAimingGun = 78,
    ///     _CPED_CONFIG_FLAG_0x14D69875 = 79,
    ///     _CPED_CONFIG_FLAG_0x40B05311 = 80,
    ///     _CPED_CONFIG_FLAG_0x8B230BC5 = 81,
    ///     _CPED_CONFIG_FLAG_0xC74E5842 = 82,
    ///     _CPED_CONFIG_FLAG_0x9EA86147 = 83,
    ///     _CPED_CONFIG_FLAG_0x674C746C = 84,
    ///     _CPED_CONFIG_FLAG_0x3E56A8C2 = 85,
    ///     _CPED_CONFIG_FLAG_0xC144A1EF = 86,
    ///     _CPED_CONFIG_FLAG_0x0548512D = 87,
    ///     _CPED_CONFIG_FLAG_0x31C93909 = 88,
    ///     _CPED_CONFIG_FLAG_0xA0269315 = 89,
    ///     _CPED_CONFIG_FLAG_0xD4D59D4D = 90,
    ///     _CPED_CONFIG_FLAG_0x411D4420 = 91,
    ///     _CPED_CONFIG_FLAG_0xDF4AEF0D = 92,
    ///     CPED_CONFIG_FLAG_ForcePedLoadCover = 93,
    ///     _CPED_CONFIG_FLAG_0x300E4CD3 = 94,
    ///     _CPED_CONFIG_FLAG_0xF1C5BF04 = 95,
    ///     _CPED_CONFIG_FLAG_0x89C2EF13 = 96,
    ///     CPED_CONFIG_FLAG_VaultFromCover = 97,
    ///     _CPED_CONFIG_FLAG_0x02A852C8 = 98,
    ///     _CPED_CONFIG_FLAG_0x3D9407F1 = 99,
    ///     _CPED_CONFIG_FLAG_IsDrunk = 100, // 0x319B4558
    ///     CPED_CONFIG_FLAG_ForcedAim = 101,
    ///     _CPED_CONFIG_FLAG_0xB942D71A = 102,
    ///     _CPED_CONFIG_FLAG_0xD26C55A8 = 103,
    ///     CPED_CONFIG_FLAG_OpenDoorArmIK = 104,
    ///     CPED_CONFIG_FLAG_ForceReload = 105,
    ///     CPED_CONFIG_FLAG_DontActivateRagdollFromVehicleImpact = 106,
    ///     CPED_CONFIG_FLAG_DontActivateRagdollFromBulletImpact = 107,
    ///     CPED_CONFIG_FLAG_DontActivateRagdollFromExplosions = 108,
    ///     CPED_CONFIG_FLAG_DontActivateRagdollFromFire = 109,
    ///     CPED_CONFIG_FLAG_DontActivateRagdollFromElectrocution = 110,
    ///     _CPED_CONFIG_FLAG_0x83C0A4BF = 111,
    ///     _CPED_CONFIG_FLAG_0x0E0FAF8C = 112,
    ///     CPED_CONFIG_FLAG_KeepWeaponHolsteredUnlessFired = 113,
    ///     _CPED_CONFIG_FLAG_0x43B80B79 = 114,
    ///     _CPED_CONFIG_FLAG_0x0D2A9309 = 115,
    ///     CPED_CONFIG_FLAG_GetOutBurningVehicle = 116,
    ///     CPED_CONFIG_FLAG_BumpedByPlayer = 117,
    ///     CPED_CONFIG_FLAG_RunFromFiresAndExplosions = 118,
    ///     CPED_CONFIG_FLAG_TreatAsPlayerDuringTargeting = 119,
    ///     CPED_CONFIG_FLAG_IsHandCuffed = 120,
    ///     CPED_CONFIG_FLAG_IsAnkleCuffed = 121,
    ///     CPED_CONFIG_FLAG_DisableMelee = 122,
    ///     CPED_CONFIG_FLAG_DisableUnarmedDrivebys = 123,
    ///     CPED_CONFIG_FLAG_JustGetsPulledOutWhenElectrocuted = 124,
    ///     _CPED_CONFIG_FLAG_0x5FED6BFD = 125,
    ///     CPED_CONFIG_FLAG_WillNotHotwireLawEnforcementVehicle = 126,
    ///     CPED_CONFIG_FLAG_WillCommandeerRatherThanJack = 127,
    ///     CPED_CONFIG_FLAG_CanBeAgitated = 128,
    ///     CPED_CONFIG_FLAG_ForcePedToFaceLeftInCover = 129,
    ///     CPED_CONFIG_FLAG_ForcePedToFaceRightInCover = 130,
    ///     CPED_CONFIG_FLAG_BlockPedFromTurningInCover = 131,
    ///     CPED_CONFIG_FLAG_KeepRelationshipGroupAfterCleanUp = 132,
    ///     CPED_CONFIG_FLAG_ForcePedToBeDragged = 133,
    ///     CPED_CONFIG_FLAG_PreventPedFromReactingToBeingJacked = 134,
    ///     CPED_CONFIG_FLAG_IsScuba = 135,
    ///     CPED_CONFIG_FLAG_WillArrestRatherThanJack = 136,
    ///     CPED_CONFIG_FLAG_RemoveDeadExtraFarAway = 137,
    ///     CPED_CONFIG_FLAG_RidingTrain = 138,
    ///     CPED_CONFIG_FLAG_ArrestResult = 139,
    ///     CPED_CONFIG_FLAG_CanAttackFriendly = 140,
    ///     CPED_CONFIG_FLAG_WillJackAnyPlayer = 141,
    ///     _CPED_CONFIG_FLAG_0x6901E731 = 142,
    ///     _CPED_CONFIG_FLAG_0x9EC9BF6C = 143,
    ///     CPED_CONFIG_FLAG_WillJackWantedPlayersRatherThanStealCar = 144,
    ///     CPED_CONFIG_FLAG_ShootingAnimFlag = 145,
    ///     CPED_CONFIG_FLAG_DisableLadderClimbing = 146,
    ///     CPED_CONFIG_FLAG_StairsDetected = 147,
    ///     CPED_CONFIG_FLAG_SlopeDetected = 148,
    ///     _CPED_CONFIG_FLAG_0x1A15670B = 149,
    ///     CPED_CONFIG_FLAG_CowerInsteadOfFlee = 150,
    ///     CPED_CONFIG_FLAG_CanActivateRagdollWhenVehicleUpsideDown = 151,
    ///     CPED_CONFIG_FLAG_AlwaysRespondToCriesForHelp = 152,
    ///     CPED_CONFIG_FLAG_DisableBloodPoolCreation = 153,
    ///     CPED_CONFIG_FLAG_ShouldFixIfNoCollision = 154,
    ///     CPED_CONFIG_FLAG_CanPerformArrest = 155,
    ///     CPED_CONFIG_FLAG_CanPerformUncuff = 156,
    ///     CPED_CONFIG_FLAG_CanBeArrested = 157,
    ///     _CPED_CONFIG_FLAG_0xF7960FF5 = 158,
    ///     CPED_CONFIG_FLAG_PlayerPreferFrontSeatMP = 159,
    ///     _CPED_CONFIG_FLAG_0x0C6C3099 = 160,
    ///     _CPED_CONFIG_FLAG_0x645F927A = 161,
    ///     _CPED_CONFIG_FLAG_0xA86549B9 = 162,
    ///     _CPED_CONFIG_FLAG_0x8AAF337A = 163,
    ///     _CPED_CONFIG_FLAG_0x13BAA6E7 = 164,
    ///     _CPED_CONFIG_FLAG_0x5FB9D1F5 = 165,
    ///     CPED_CONFIG_FLAG_IsInjured = 166,
    ///     CPED_CONFIG_FLAG_DontEnterVehiclesInPlayersGroup = 167,
    ///     _CPED_CONFIG_FLAG_0xD8072639 = 168,
    ///     CPED_CONFIG_FLAG_PreventAllMeleeTaunts = 169,
    ///     CPED_CONFIG_FLAG_ForceDirectEntry = 170,
    ///     CPED_CONFIG_FLAG_AlwaysSeeApproachingVehicles = 171,
    ///     CPED_CONFIG_FLAG_CanDiveAwayFromApproachingVehicles = 172,
    ///     CPED_CONFIG_FLAG_AllowPlayerToInterruptVehicleEntryExit = 173,
    ///     CPED_CONFIG_FLAG_OnlyAttackLawIfPlayerIsWanted = 174,
    ///     _CPED_CONFIG_FLAG_0x90008BFA = 175,
    ///     _CPED_CONFIG_FLAG_0x07C7A910 = 176,
    ///     CPED_CONFIG_FLAG_PedsJackingMeDontGetIn = 177,
    ///     _CPED_CONFIG_FLAG_0xCE4E8BE2 = 178,
    ///     CPED_CONFIG_FLAG_PedIgnoresAnimInterruptEvents = 179,
    ///     CPED_CONFIG_FLAG_IsInCustody = 180,
    ///     CPED_CONFIG_FLAG_ForceStandardBumpReactionThresholds = 181,
    ///     CPED_CONFIG_FLAG_LawWillOnlyAttackIfPlayerIsWanted = 182,
    ///     CPED_CONFIG_FLAG_IsAgitated = 183,
    ///     CPED_CONFIG_FLAG_PreventAutoShuffleToDriversSeat = 184,
    ///     CPED_CONFIG_FLAG_UseKinematicModeWhenStationary = 185,
    ///     CPED_CONFIG_FLAG_EnableWeaponBlocking = 186,
    ///     CPED_CONFIG_FLAG_HasHurtStarted = 187,
    ///     CPED_CONFIG_FLAG_DisableHurt = 188,
    ///     CPED_CONFIG_FLAG_PlayerIsWeird = 189,
    ///     _CPED_CONFIG_FLAG_0x32FC208B = 190,
    ///     _CPED_CONFIG_FLAG_0x0C296E5A = 191,
    ///     _CPED_CONFIG_FLAG_0xE63B73EC = 192,
    ///     CPED_CONFIG_FLAG_DoNothingWhenOnFootByDefault = 193,
    ///     CPED_CONFIG_FLAG_UsingScenario = 194,
    ///     CPED_CONFIG_FLAG_VisibleOnScreen = 195,
    ///     _CPED_CONFIG_FLAG_0xD88C58A1 = 196,
    ///     _CPED_CONFIG_FLAG_0x5A3DCF43 = 197,
    ///     _CPED_CONFIG_FLAG_0xEA02B420 = 198,
    ///     CPED_CONFIG_FLAG_DontActivateRagdollOnVehicleCollisionWhenDead = 199,
    ///     CPED_CONFIG_FLAG_HasBeenInArmedCombat = 200,
    ///     _CPED_CONFIG_FLAG_0x5E6466F6 = 201,
    ///     CPED_CONFIG_FLAG_Avoidance_Ignore_All = 202,
    ///     CPED_CONFIG_FLAG_Avoidance_Ignored_by_All = 203,
    ///     CPED_CONFIG_FLAG_Avoidance_Ignore_Group1 = 204,
    ///     CPED_CONFIG_FLAG_Avoidance_Member_of_Group1 = 205,
    ///     CPED_CONFIG_FLAG_ForcedToUseSpecificGroupSeatIndex = 206,
    ///     _CPED_CONFIG_FLAG_0x415B26B9 = 207,
    ///     CPED_CONFIG_FLAG_DisableExplosionReactions = 208,
    ///     CPED_CONFIG_FLAG_DodgedPlayer = 209,
    ///     CPED_CONFIG_FLAG_WaitingForPlayerControlInterrupt = 210,
    ///     CPED_CONFIG_FLAG_ForcedToStayInCover = 211,
    ///     CPED_CONFIG_FLAG_GeneratesSoundEvents = 212,
    ///     CPED_CONFIG_FLAG_ListensToSoundEvents = 213,
    ///     CPED_CONFIG_FLAG_AllowToBeTargetedInAVehicle = 214,
    ///     CPED_CONFIG_FLAG_WaitForDirectEntryPointToBeFreeWhenExiting = 215,
    ///     CPED_CONFIG_FLAG_OnlyRequireOnePressToExitVehicle = 216,
    ///     CPED_CONFIG_FLAG_ForceExitToSkyDive = 217,
    ///     _CPED_CONFIG_FLAG_0x3C7DF9DF = 218,
    ///     _CPED_CONFIG_FLAG_0x848FFEF2 = 219,
    ///     CPED_CONFIG_FLAG_DontEnterLeadersVehicle = 220,
    ///     CPED_CONFIG_FLAG_DisableExitToSkyDive = 221,
    ///     _CPED_CONFIG_FLAG_0x84F722FA = 222,
    ///     _CPED_CONFIG_FLAG_Shrink = 223, // 0xD1B87B1F
    ///     _CPED_CONFIG_FLAG_0x728AA918 = 224,
    ///     CPED_CONFIG_FLAG_DisablePotentialToBeWalkedIntoResponse = 225,
    ///     CPED_CONFIG_FLAG_DisablePedAvoidance = 226,
    ///     CPED_CONFIG_FLAG_ForceRagdollUponDeath = 227,
    ///     _CPED_CONFIG_FLAG_0x1EA7225F = 228,
    ///     CPED_CONFIG_FLAG_DisablePanicInVehicle = 229,
    ///     CPED_CONFIG_FLAG_AllowedToDetachTrailer = 230,
    ///     _CPED_CONFIG_FLAG_0xFC3E572D = 231,
    ///     _CPED_CONFIG_FLAG_0x08E9F9CF = 232,
    ///     _CPED_CONFIG_FLAG_0x2D3BA52D = 233,
    ///     _CPED_CONFIG_FLAG_0xFD2F53EA = 234,
    ///     _CPED_CONFIG_FLAG_0x31A1B03B = 235,
    ///     CPED_CONFIG_FLAG_IsHoldingProp = 236,
    ///     CPED_CONFIG_FLAG_BlocksPathingWhenDead = 237,
    ///     _CPED_CONFIG_FLAG_0xCE57C9A3 = 238,
    ///     _CPED_CONFIG_FLAG_0x26149198 = 239,
    ///     CPED_CONFIG_FLAG_ForceSkinCharacterCloth = 240,
    ///     CPED_CONFIG_FLAG_LeaveEngineOnWhenExitingVehicles = 241,
    ///     CPED_CONFIG_FLAG_PhoneDisableTextingAnimations = 242,
    ///     CPED_CONFIG_FLAG_PhoneDisableTalkingAnimations = 243,
    ///     CPED_CONFIG_FLAG_PhoneDisableCameraAnimations = 244,
    ///     CPED_CONFIG_FLAG_DisableBlindFiringInShotReactions = 245,
    ///     CPED_CONFIG_FLAG_AllowNearbyCoverUsage = 246,
    ///     _CPED_CONFIG_FLAG_0x0C754ACA = 247,
    ///     CPED_CONFIG_FLAG_CanPlayInCarIdles = 248,
    ///     CPED_CONFIG_FLAG_CanAttackNonWantedPlayerAsLaw = 249,
    ///     CPED_CONFIG_FLAG_WillTakeDamageWhenVehicleCrashes = 250,
    ///     CPED_CONFIG_FLAG_AICanDrivePlayerAsRearPassenger = 251,
    ///     CPED_CONFIG_FLAG_PlayerCanJackFriendlyPlayers = 252,
    ///     CPED_CONFIG_FLAG_OnStairs = 253,
    ///     _CPED_CONFIG_FLAG_0xE1A2F73F = 254,
    ///     CPED_CONFIG_FLAG_AIDriverAllowFriendlyPassengerSeatEntry = 255,
    ///     _CPED_CONFIG_FLAG_0xF1EB20A9 = 256,
    ///     CPED_CONFIG_FLAG_AllowMissionPedToUseInjuredMovement = 257,
    ///     _CPED_CONFIG_FLAG_0x329DCF1A = 258,
    ///     _CPED_CONFIG_FLAG_0x8D90DD1B = 259,
    ///     _CPED_CONFIG_FLAG_0xB8A292B7 = 260,
    ///     CPED_CONFIG_FLAG_PreventUsingLowerPrioritySeats = 261,
    ///     _CPED_CONFIG_FLAG_0x2AF558F0 = 262,
    ///     _CPED_CONFIG_FLAG_0x82251455 = 263,
    ///     _CPED_CONFIG_FLAG_0x30CF498B = 264,
    ///     _CPED_CONFIG_FLAG_0xE1CD50AF = 265,
    ///     _CPED_CONFIG_FLAG_0x72E4AE48 = 266,
    ///     _CPED_CONFIG_FLAG_0xC2657EA1 = 267,
    ///     CPED_CONFIG_FLAG_TeleportToLeaderVehicle = 268,
    ///     CPED_CONFIG_FLAG_Avoidance_Ignore_WeirdPedBuffer = 269,
    ///     CPED_CONFIG_FLAG_OnStairSlope = 270,
    ///     _CPED_CONFIG_FLAG_0xA0897933 = 271,
    ///     CPED_CONFIG_FLAG_DontBlipCop = 272,
    ///     CPED_CONFIG_FLAG_ClimbedShiftedFence = 273,
    ///     _CPED_CONFIG_FLAG_0xF7823618 = 274,
    ///     CPED_CONFIG_FLAG_KillWhenTrapped = 275,
    ///     CPED_CONFIG_FLAG_EdgeDetected = 276,
    ///     _CPED_CONFIG_FLAG_0x92B67896 = 277,
    ///     _CPED_CONFIG_FLAG_0xCAD677C9 = 278,
    ///     CPED_CONFIG_FLAG_AvoidTearGas = 279,
    ///     _CPED_CONFIG_FLAG_0x5276AC7B = 280,
    ///     CPED_CONFIG_FLAG_DisableGoToWritheWhenInjured = 281,
    ///     CPED_CONFIG_FLAG_OnlyUseForcedSeatWhenEnteringHeliInGroup = 282,
    ///     _CPED_CONFIG_FLAG_0x9139724D = 283,
    ///     _CPED_CONFIG_FLAG_0xA1457461 = 284,
    ///     CPED_CONFIG_FLAG_DisableWeirdPedEvents = 285,
    ///     CPED_CONFIG_FLAG_ShouldChargeNow = 286,
    ///     CPED_CONFIG_FLAG_RagdollingOnBoat = 287,
    ///     CPED_CONFIG_FLAG_HasBrandishedWeapon = 288,
    ///     _CPED_CONFIG_FLAG_0x1B9EE8A1 = 289,
    ///     _CPED_CONFIG_FLAG_0xF3F5758C = 290,
    ///     _CPED_CONFIG_FLAG_0x2A9307F1 = 291,
    ///     _CPED_CONFIG_FLAG_FreezePosition = 292, // 0x7403D216
    ///     _CPED_CONFIG_FLAG_0xA06A3C6C = 293,
    ///     CPED_CONFIG_FLAG_DisableShockingEvents = 294,
    ///     _CPED_CONFIG_FLAG_0xF8DA25A5 = 295,
    ///     CPED_CONFIG_FLAG_NeverReactToPedOnRoof = 296,
    ///     _CPED_CONFIG_FLAG_0xB31F1187 = 297,
    ///     _CPED_CONFIG_FLAG_0x84315402 = 298,
    ///     CPED_CONFIG_FLAG_DisableShockingDrivingOnPavementEvents = 299,
    ///     _CPED_CONFIG_FLAG_0xC7829B67 = 300,
    ///     CPED_CONFIG_FLAG_DisablePedConstraints = 301,
    ///     CPED_CONFIG_FLAG_ForceInitialPeekInCover = 302,
    ///     _CPED_CONFIG_FLAG_0x2ADA871B = 303,
    ///     _CPED_CONFIG_FLAG_0x47BC8A58 = 304,
    ///     CPED_CONFIG_FLAG_DisableJumpingFromVehiclesAfterLeader = 305,
    ///     _CPED_CONFIG_FLAG_0x4A133C50 = 306,
    ///     _CPED_CONFIG_FLAG_0xC58099C3 = 307,
    ///     _CPED_CONFIG_FLAG_0xF3D76D41 = 308,
    ///     _CPED_CONFIG_FLAG_0xB0EEE9F2 = 309,
    ///     CPED_CONFIG_FLAG_IsInCluster = 310,
    ///     CPED_CONFIG_FLAG_ShoutToGroupOnPlayerMelee = 311,
    ///     CPED_CONFIG_FLAG_IgnoredByAutoOpenDoors = 312,
    ///     _CPED_CONFIG_FLAG_0xD4136C22 = 313,
    ///     CPED_CONFIG_FLAG_ForceIgnoreMeleeActiveCombatant = 314,
    ///     CPED_CONFIG_FLAG_CheckLoSForSoundEvents = 315,
    ///     _CPED_CONFIG_FLAG_0xD5C98277 = 316,
    ///     CPED_CONFIG_FLAG_CanSayFollowedByPlayerAudio = 317,
    ///     CPED_CONFIG_FLAG_ActivateRagdollFromMinorPlayerContact = 318,
    ///     _CPED_CONFIG_FLAG_0xD8BE1D54 = 319,
    ///     CPED_CONFIG_FLAG_ForcePoseCharacterCloth = 320,
    ///     CPED_CONFIG_FLAG_HasClothCollisionBounds = 321,
    ///     CPED_CONFIG_FLAG_HasHighHeels = 322,
    ///     _CPED_CONFIG_FLAG_0x86B01E54 = 323,
    ///     CPED_CONFIG_FLAG_DontBehaveLikeLaw = 324,
    ///     _CPED_CONFIG_FLAG_0xC03B736C = 325, // SpawnedAtScenario?
    ///     CPED_CONFIG_FLAG_DisablePoliceInvestigatingBody = 326,
    ///     CPED_CONFIG_FLAG_DisableWritheShootFromGround = 327,
    ///     CPED_CONFIG_FLAG_LowerPriorityOfWarpSeats = 328,
    ///     CPED_CONFIG_FLAG_DisableTalkTo = 329,
    ///     CPED_CONFIG_FLAG_DontBlip = 330,
    ///     CPED_CONFIG_FLAG_IsSwitchingWeapon = 331,
    ///     CPED_CONFIG_FLAG_IgnoreLegIkRestrictions = 332,
    ///     _CPED_CONFIG_FLAG_0x150468FD = 333,
    ///     _CPED_CONFIG_FLAG_0x914EBD6B = 334,
    ///     _CPED_CONFIG_FLAG_0x79AF3B6D = 335,
    ///     _CPED_CONFIG_FLAG_0x75C7A632 = 336,
    ///     _CPED_CONFIG_FLAG_0x52D530E2 = 337,
    ///     _CPED_CONFIG_FLAG_0xDB2A90E0 = 338,
    ///     CPED_CONFIG_FLAG_AllowTaskDoNothingTimeslicing = 339,
    ///     _CPED_CONFIG_FLAG_0x12ADB567 = 340,
    ///     _CPED_CONFIG_FLAG_0x105C8518 = 341,
    ///     CPED_CONFIG_FLAG_NotAllowedToJackAnyPlayers = 342,
    ///     _CPED_CONFIG_FLAG_0xED152C3E = 343,
    ///     _CPED_CONFIG_FLAG_0xA0EFE6A8 = 344,
    ///     CPED_CONFIG_FLAG_AlwaysLeaveTrainUponArrival = 345,
    ///     _CPED_CONFIG_FLAG_0xCDDFE830 = 346,
    ///     CPED_CONFIG_FLAG_OnlyWritheFromWeaponDamage = 347,
    ///     CPED_CONFIG_FLAG_UseSloMoBloodVfx = 348,
    ///     CPED_CONFIG_FLAG_EquipJetpack = 349,
    ///     CPED_CONFIG_FLAG_PreventDraggedOutOfCarThreatResponse = 350,
    ///     _CPED_CONFIG_FLAG_0xE13D1F7C = 351,
    ///     _CPED_CONFIG_FLAG_0x40E25FB9 = 352,
    ///     _CPED_CONFIG_FLAG_0x930629D9 = 353,
    ///     _CPED_CONFIG_FLAG_0xECCF0C7F = 354,
    ///     _CPED_CONFIG_FLAG_0xB6E9613B = 355,
    ///     CPED_CONFIG_FLAG_ForceDeepSurfaceCheck = 356,
    ///     CPED_CONFIG_FLAG_DisableDeepSurfaceAnims = 357,
    ///     CPED_CONFIG_FLAG_DontBlipNotSynced = 358,
    ///     CPED_CONFIG_FLAG_IsDuckingInVehicle = 359,
    ///     CPED_CONFIG_FLAG_PreventAutoShuffleToTurretSeat = 360,
    ///     CPED_CONFIG_FLAG_DisableEventInteriorStatusCheck = 361,
    ///     CPED_CONFIG_FLAG_HasReserveParachute = 362,
    ///     CPED_CONFIG_FLAG_UseReserveParachute = 363,
    ///     CPED_CONFIG_FLAG_TreatDislikeAsHateWhenInCombat = 364,
    ///     CPED_CONFIG_FLAG_OnlyUpdateTargetWantedIfSeen = 365,
    ///     CPED_CONFIG_FLAG_AllowAutoShuffleToDriversSeat = 366,
    ///     _CPED_CONFIG_FLAG_0xD7E07D37 = 367,
    ///     _CPED_CONFIG_FLAG_0x03C4FD24 = 368,
    ///     _CPED_CONFIG_FLAG_0x7675789A = 369,
    ///     _CPED_CONFIG_FLAG_0xB7288A88 = 370,
    ///     _CPED_CONFIG_FLAG_0xC06B6291 = 371,
    ///     CPED_CONFIG_FLAG_PreventReactingToSilencedCloneBullets = 372,
    ///     CPED_CONFIG_FLAG_DisableInjuredCryForHelpEvents = 373,
    ///     CPED_CONFIG_FLAG_NeverLeaveTrain = 374,
    ///     CPED_CONFIG_FLAG_DontDropJetpackOnDeath = 375,
    ///     _CPED_CONFIG_FLAG_0x147F1FFB = 376,
    ///     _CPED_CONFIG_FLAG_0x4376DD79 = 377,
    ///     _CPED_CONFIG_FLAG_0xCD3DB518 = 378,
    ///     _CPED_CONFIG_FLAG_0xFE4BA4B6 = 379,
    ///     CPED_CONFIG_FLAG_DisableAutoEquipHelmetsInBikes = 380,
    ///     _CPED_CONFIG_FLAG_0xBCD816CD = 381,
    ///     _CPED_CONFIG_FLAG_0xCF02DD69 = 382,
    ///     _CPED_CONFIG_FLAG_0xF73AFA2E = 383,
    ///     _CPED_CONFIG_FLAG_0x80B9A9D0 = 384,
    ///     _CPED_CONFIG_FLAG_0xF601F7EE = 385,
    ///     _CPED_CONFIG_FLAG_0xA91350FC = 386,
    ///     _CPED_CONFIG_FLAG_0x3AB23B96 = 387,
    ///     CPED_CONFIG_FLAG_IsClimbingLadder = 388,
    ///     CPED_CONFIG_FLAG_HasBareFeet = 389,
    ///     CPED_CONFIG_FLAG_UNUSED_REPLACE_ME_2 = 390,
    ///     CPED_CONFIG_FLAG_GoOnWithoutVehicleIfItIsUnableToGetBackToRoad = 391,
    ///     CPED_CONFIG_FLAG_BlockDroppingHealthSnacksOnDeath = 392,
    ///     _CPED_CONFIG_FLAG_0xC11D3E8F = 393,
    ///     CPED_CONFIG_FLAG_ForceThreatResponseToNonFriendToFriendMeleeActions = 394,
    ///     CPED_CONFIG_FLAG_DontRespondToRandomPedsDamage = 395,
    ///     CPED_CONFIG_FLAG_AllowContinuousThreatResponseWantedLevelUpdates = 396,
    ///     CPED_CONFIG_FLAG_KeepTargetLossResponseOnCleanup = 397,
    ///     CPED_CONFIG_FLAG_PlayersDontDragMeOutOfCar = 398,
    ///     CPED_CONFIG_FLAG_BroadcastRepondedToThreatWhenGoingToPointShooting = 399,
    ///     CPED_CONFIG_FLAG_IgnorePedTypeForIsFriendlyWith = 400,
    ///     CPED_CONFIG_FLAG_TreatNonFriendlyAsHateWhenInCombat = 401,
    ///     CPED_CONFIG_FLAG_DontLeaveVehicleIfLeaderNotInVehicle = 402,
    ///     _CPED_CONFIG_FLAG_0x5E5B9591 = 403,
    ///     CPED_CONFIG_FLAG_AllowMeleeReactionIfMeleeProofIsOn = 404,
    ///     _CPED_CONFIG_FLAG_0x77840177 = 405,
    ///     _CPED_CONFIG_FLAG_0x1C7ACAC4 = 406,
    ///     CPED_CONFIG_FLAG_UseNormalExplosionDamageWhenBlownUpInVehicle = 407,
    ///     CPED_CONFIG_FLAG_DisableHomingMissileLockForVehiclePedInside = 408,
    ///     CPED_CONFIG_FLAG_DisableTakeOffScubaGear = 409,
    ///     CPED_CONFIG_FLAG_IgnoreMeleeFistWeaponDamageMult = 410,
    ///     CPED_CONFIG_FLAG_LawPedsCanFleeFromNonWantedPlayer = 411,
    ///     CPED_CONFIG_FLAG_ForceBlipSecurityPedsIfPlayerIsWanted = 412,
    ///     CPED_CONFIG_FLAG_IsHolsteringWeapon = 413,
    ///     CPED_CONFIG_FLAG_UseGoToPointForScenarioNavigation = 414,
    ///     CPED_CONFIG_FLAG_DontClearLocalPassengersWantedLevel = 415,
    ///     CPED_CONFIG_FLAG_BlockAutoSwapOnWeaponPickups = 416,
    ///     CPED_CONFIG_FLAG_ThisPedIsATargetPriorityForAI = 417,
    ///     CPED_CONFIG_FLAG_IsSwitchingHelmetVisor = 418,
    ///     CPED_CONFIG_FLAG_ForceHelmetVisorSwitch = 419,
    ///     _CPED_CONFIG_FLAG_0xCFF5F6DE = 420,
    ///     CPED_CONFIG_FLAG_UseOverrideFootstepPtFx = 421,
    ///     CPED_CONFIG_FLAG_DisableVehicleCombat = 422,
    ///     _CPED_CONFIG_FLAG_0xFE401D26 = 423,
    ///     CPED_CONFIG_FLAG_FallsLikeAircraft = 424,
    ///     _CPED_CONFIG_FLAG_0x2B42AE82 = 425,
    ///     CPED_CONFIG_FLAG_UseLockpickVehicleEntryAnimations = 426,
    ///     CPED_CONFIG_FLAG_IgnoreInteriorCheckForSprinting = 427,
    ///     CPED_CONFIG_FLAG_SwatHeliSpawnWithinLastSpottedLocation = 428,
    ///     CPED_CONFIG_FLAG_DisableStartEngine = 429,
    ///     CPED_CONFIG_FLAG_IgnoreBeingOnFire = 430,
    ///     CPED_CONFIG_FLAG_DisableTurretOrRearSeatPreference = 431,
    ///     CPED_CONFIG_FLAG_DisableWantedHelicopterSpawning = 432,
    ///     CPED_CONFIG_FLAG_UseTargetPerceptionForCreatingAimedAtEvents = 433,
    ///     CPED_CONFIG_FLAG_DisableHomingMissileLockon = 434,
    ///     CPED_CONFIG_FLAG_ForceIgnoreMaxMeleeActiveSupportCombatants = 435,
    ///     CPED_CONFIG_FLAG_StayInDefensiveAreaWhenInVehicle = 436,
    ///     CPED_CONFIG_FLAG_DontShoutTargetPosition = 437,
    ///     CPED_CONFIG_FLAG_DisableHelmetArmor = 438,
    ///     _CPED_CONFIG_FLAG_0xCB7F3A1E = 439,
    ///     _CPED_CONFIG_FLAG_0x50178878 = 440,
    ///     CPED_CONFIG_FLAG_PreventVehExitDueToInvalidWeapon = 441,
    ///     CPED_CONFIG_FLAG_IgnoreNetSessionFriendlyFireCheckForAllowDamage = 442,
    ///     CPED_CONFIG_FLAG_DontLeaveCombatIfTargetPlayerIsAttackedByPolice = 443,
    ///     CPED_CONFIG_FLAG_CheckLockedBeforeWarp = 444,
    ///     CPED_CONFIG_FLAG_DontShuffleInVehicleToMakeRoom = 445,
    ///     CPED_CONFIG_FLAG_GiveWeaponOnGetup = 446,
    ///     CPED_CONFIG_FLAG_DontHitVehicleWithProjectiles = 447,
    ///     CPED_CONFIG_FLAG_DisableForcedEntryForOpenVehiclesFromTryLockedDoor = 448,
    ///     CPED_CONFIG_FLAG_FiresDummyRockets = 449,
    ///     CPED_CONFIG_FLAG_PedIsArresting = 450,
    ///     CPED_CONFIG_FLAG_IsDecoyPed = 451,
    ///     CPED_CONFIG_FLAG_HasEstablishedDecoy = 452,
    ///     CPED_CONFIG_FLAG_BlockDispatchedHelicoptersFromLanding = 453,
    ///     CPED_CONFIG_FLAG_DontCryForHelpOnStun = 454,
    ///     _CPED_CONFIG_FLAG_0xB68D3EAB = 455,
    ///     CPED_CONFIG_FLAG_CanBeIncapacitated = 456,
    ///     _CPED_CONFIG_FLAG_0x4BD5EBAD = 457,
    ///     CPED_CONFIG_FLAG_DontChangeTargetFromMelee = 458,
    /// };
    pub inline fn setPedConfigFlag(ped: types.Ped, flag_id: c_int, value: windows.BOOL) !void { try invoker.invoke(void, 0x1913FE4CBF41C463, .{ped, flag_id, value}); } // 0x1913FE4CBF41C463 0x9CFBE10D b323
    /// PED::SET_PED_RESET_FLAG(PLAYER::PLAYER_PED_ID(), 240, 1); \
    /// Known values: \
    /// PRF_PreventGoingIntoStillInVehicleState = 236 *(fanatic2.c)*
    pub inline fn setPedResetFlag(ped: types.Ped, flag_id: c_int, do_reset: windows.BOOL) !void { try invoker.invoke(void, 0xC1E8A365BF3B29F2, .{ped, flag_id, do_reset}); } // 0xC1E8A365BF3B29F2 0xCFF6FF66 b323
    /// See SET_PED_CONFIG_FLAG
    pub inline fn getPedConfigFlag(ped: types.Ped, flag_id: c_int, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7EE53118C892B513, .{ped, flag_id, p_2}); } // 0x7EE53118C892B513 0xABE98267 b323
    pub inline fn getPedResetFlag(ped: types.Ped, flag_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAF9E59B1B1FBF2A0, .{ped, flag_id}); } // 0xAF9E59B1B1FBF2A0 0x2FC10D11 b323
    pub inline fn setPedGroupMemberPassengerIndex(ped: types.Ped, index: c_int) !void { try invoker.invoke(void, 0x0BDDB8D9EC6BCF3C, .{ped, index}); } // 0x0BDDB8D9EC6BCF3C 0x2AB3670B b323
    pub inline fn setPedCanEvasiveDive(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6B7A646C242A7059, .{ped, toggle}); } // 0x6B7A646C242A7059 0x542FEB4D b323
    /// Presumably returns the Entity that the Ped is currently diving out of the way of.
    /// 
    /// var num3; \
    ///     if (PED::IS_PED_EVASIVE_DIVING(A_0, &num3) != 0)
    ///         if (ENTITY::IS_ENTITY_A_VEHICLE(num3) != 0)
    pub inline fn isPedEvasiveDiving(ped: types.Ped, evading_entity: [*c]types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x414641C26E105898, .{ped, evading_entity}); } // 0x414641C26E105898 0xD82829DC b323
    pub inline fn setPedShootsAtCoord(ped: types.Ped, vec: types.Vector3, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x96A05E4FB321B1BA, .{ped, vec.x, vec.y, vec.z, toggle}); } // 0x96A05E4FB321B1BA 0xFD64EAE5 b323
    /// Full list of peds by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/peds.json
    pub inline fn setPedModelIsSuppressed(model_hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE163A4BCE4DE6F11, .{model_hash, toggle}); } // 0xE163A4BCE4DE6F11 0x7820CA43 b323
    pub inline fn stopAnyPedModelBeingSuppressed() !void { try invoker.invoke(void, 0xB47BD05FA66B40CF, .{}); } // 0xB47BD05FA66B40CF 0x5AD7DC55 b323
    pub inline fn setPedCanBeTargetedWhenInjured(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x638C03B0F9878F57, .{ped, toggle}); } // 0x638C03B0F9878F57 0x6FD9A7CD b323
    pub inline fn setPedGeneratesDeadBodyEvents(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7FB17BA2E7DECA5B, .{ped, toggle}); } // 0x7FB17BA2E7DECA5B 0xE9B97A2B b323
    pub inline fn blockPedFromGeneratingDeadBodyEventsWhenDead(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE43A13C9E4CCCBCF, .{ped, toggle}); } // 0xE43A13C9E4CCCBCF 0xFF1F6AEB b323
    pub inline fn setPedWillOnlyAttackWantedPlayer(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x3E9679C1DFCF422C, .{p_0, p_1}); } // 0x3E9679C1DFCF422C  b877
    pub inline fn setPedCanRagdollFromPlayerImpact(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDF993EE5E90ABA25, .{ped, toggle}); } // 0xDF993EE5E90ABA25 0xE9BD733A b323
    /// PoliceMotorcycleHelmet   1024     \
    /// RegularMotorcycleHelmet   4096     \
    /// FiremanHelmet 16384    \
    /// PilotHeadset  32768    \
    /// PilotHelmet   65536 \
    /// -- \
    /// p2 is generally 4096 or 16384 in the scripts. p1 varies between 1 and 0.
    pub inline fn givePedHelmet(ped: types.Ped, cannot_remove: windows.BOOL, helmet_flag: c_int, texture_index: c_int) !void { try invoker.invoke(void, 0x54C7C4A94367717E, .{ped, cannot_remove, helmet_flag, texture_index}); } // 0x54C7C4A94367717E 0x1862A461 b323
    pub inline fn removePedHelmet(ped: types.Ped, instantly: windows.BOOL) !void { try invoker.invoke(void, 0xA7B2458D0AD6DED8, .{ped, instantly}); } // 0xA7B2458D0AD6DED8 0x2086B1F0 b323
    pub inline fn isPedTakingOffHelmet(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x14590DDBEDB1EC85, .{ped}); } // 0x14590DDBEDB1EC85 0xA1008E0E b323
    pub inline fn setPedHelmet(ped: types.Ped, can_wear_helmet: windows.BOOL) !void { try invoker.invoke(void, 0x560A43136EB58105, .{ped, can_wear_helmet}); } // 0x560A43136EB58105 0xED366E53 b323
    pub inline fn setPedHelmetFlag(ped: types.Ped, helmet_flag: c_int) !void { try invoker.invoke(void, 0xC0E78D5C2CE3EB25, .{ped, helmet_flag}); } // 0xC0E78D5C2CE3EB25 0x12677780 b323
    /// List of component/props ID \
    /// gtaxscripting.blogspot.com/2016/04/gta-v-peds-component-and-props.html
    pub inline fn setPedHelmetPropIndex(ped: types.Ped, prop_index: c_int, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x26D83693ED99291C, .{ped, prop_index, p_2}); } // 0x26D83693ED99291C 0xA316D13F b323
    pub inline fn setPedHelmetVisorPropIndices(ped: types.Ped, p_1: windows.BOOL, p_2: c_int, p_3: c_int) !void { try invoker.invoke(void, 0x3F7325574E41B44D, .{ped, p_1, p_2, p_3}); } // 0x3F7325574E41B44D  b791
    pub inline fn isPedHelmetVisorUp(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB9496CE47546DB2C, .{ped}); } // 0xB9496CE47546DB2C  b791
    pub inline fn setPedHelmetTextureIndex(ped: types.Ped, texture_index: c_int) !void { try invoker.invoke(void, 0xF1550C4BD22582E2, .{ped, texture_index}); } // 0xF1550C4BD22582E2 0x5F6C3328 b323
    /// Returns true if the ped passed through the parenthesis is wearing a helmet.
    pub inline fn isPedWearingHelmet(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF33BDFE19B309B19, .{ped}); } // 0xF33BDFE19B309B19 0x0D680D49 b323
    pub inline fn clearPedStoredHatProp(ped: types.Ped) !void { try invoker.invoke(void, 0x687C0B594907D2E8, .{ped}); } // 0x687C0B594907D2E8 0x24A1284E b323
    pub inline fn getPedHelmetStoredHatPropIndex(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x451294E859ECC018, .{ped}); } // 0x451294E859ECC018 0x8A3A3116 b323
    pub inline fn getPedHelmetStoredHatTexIndex(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x9D728C1E12BF5518, .{ped}); } // 0x9D728C1E12BF5518 0x74EB662D b323
    pub inline fn isCurrentHeadPropAHelmet(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF2385935BFFD4D92, .{p_0}); } // 0xF2385935BFFD4D92 0xFFF149FE b323
    pub inline fn setPedToLoadCover(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x332B562EEDA62399, .{ped, toggle}); } // 0x332B562EEDA62399 0xCF94BA97 b323
    /// It simply makes the said ped to cower behind cover object(wall, desk, car)
    /// 
    /// Peds flee attributes must be set to not to flee, first. Else, most of the peds, will just flee from gunshot sounds or any other panic situations.
    pub inline fn setPedCanCowerInCover(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCB7553CDCEF4A735, .{ped, toggle}); } // 0xCB7553CDCEF4A735 0x5194658B b323
    pub inline fn setPedCanPeekInCover(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC514825C507E3736, .{ped, toggle}); } // 0xC514825C507E3736 0xC1DAE216 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn setPedPlaysHeadOnHornAnimWhenDiesInVehicle(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x94D94BF1A75AED3D, .{ped, toggle}); } // 0x94D94BF1A75AED3D 0x7C563CD2 b323
    /// "IK" stands for "Inverse kinematics." I assume this has something to do with how the ped uses his legs to balance. In the scripts, the second parameter is always an int with a value of 2, 0, or sometimes 1
    pub inline fn setPedLegIkMode(ped: types.Ped, mode: c_int) !void { try invoker.invoke(void, 0xC396F5B86FF9FEBD, .{ped, mode}); } // 0xC396F5B86FF9FEBD 0xFDDB042E b323
    pub inline fn setPedMotionBlur(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0A986918B102B448, .{ped, toggle}); } // 0x0A986918B102B448 0xA211A128 b323
    pub inline fn setPedCanSwitchWeapon(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xED7F7EFE9FABF340, .{ped, toggle}); } // 0xED7F7EFE9FABF340 0xB5F8BA28 b323
    pub inline fn setPedDiesInstantlyInWater(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEEB64139BA29A7CF, .{ped, toggle}); } // 0xEEB64139BA29A7CF 0xFE2554FC b323
    /// Only appears in lamar1 script.
    pub inline fn setLadderClimbInputState(ped: types.Ped, p_1: c_int) !void { try invoker.invoke(void, 0x1A330D297AAC6BC1, .{ped, p_1}); } // 0x1A330D297AAC6BC1 0x77BB7CB8 b323
    pub inline fn stopPedWeaponFiringWhenDropped(ped: types.Ped) !void { try invoker.invoke(void, 0xC158D28142A34608, .{ped}); } // 0xC158D28142A34608 0x4AC3421E b323
    pub inline fn setScriptedAnimSeatOffset(ped: types.Ped, p_1: f32) !void { try invoker.invoke(void, 0x5917BBA32D06C230, .{ped, p_1}); } // 0x5917BBA32D06C230 0x7CEFFA45 b323
    /// enum eCombatMovement // 0x4F456B61 \
    /// { \
    ///     CM_Stationary,
    ///     CM_Defensive,
    ///     CM_WillAdvance,
    ///     CM_WillRetreat
    /// };
    pub inline fn setPedCombatMovement(ped: types.Ped, combat_movement: c_int) !void { try invoker.invoke(void, 0x4D9CA1009AFBD057, .{ped, combat_movement}); } // 0x4D9CA1009AFBD057 0x12E62F9E b323
    /// See SET_PED_COMBAT_MOVEMENT
    pub inline fn getPedCombatMovement(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0xDEA92412FCAEB3F5, .{ped}); } // 0xDEA92412FCAEB3F5 0xF3E7730E b323
    /// enum eCombatAbility // 0xE793438C \
    /// { \
    ///     CA_Poor,
    ///     CA_Average,
    ///     CA_Professional,
    ///     CA_NumTypes
    /// };
    pub inline fn setPedCombatAbility(ped: types.Ped, ability_level: c_int) !void { try invoker.invoke(void, 0xC7622C0D36B2FDA8, .{ped, ability_level}); } // 0xC7622C0D36B2FDA8 0x6C23D329 b323
    /// enum eCombatRange // 0xB69160F5 \
    /// { \
    ///     CR_Near,
    ///     CR_Medium,
    ///     CR_Far,
    ///     CR_VeryFar,
    ///     CR_NumRanges
    /// };
    pub inline fn setPedCombatRange(ped: types.Ped, combat_range: c_int) !void { try invoker.invoke(void, 0x3C606747B23E497B, .{ped, combat_range}); } // 0x3C606747B23E497B 0x8818A959 b323
    /// See SET_PED_COMBAT_RANGE
    pub inline fn getPedCombatRange(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0xF9D9F7F2DB8E2FA0, .{ped}); } // 0xF9D9F7F2DB8E2FA0 0x9B9B7163 b323
    /// enum eCombatAttributes // 0x0E8E7201 \
    /// { \
    ///     BF_CanUseCover = 0,
    ///     BF_CanUseVehicles = 1,
    ///     BF_CanDoDrivebys = 2,
    ///     BF_CanLeaveVehicle = 3,
    ///     BF_CanUseDynamicStrafeDecisions = 4,
    ///     BF_AlwaysFight = 5,
    ///     BF_0x66BB9FCC = 6,
    ///     BF_0x6837DA41 = 7,
    ///     BF_0xB4A13A5A = 8,
    ///     BF_0xEE326AAD = 9,
    ///     BF_0x7DF2CCFA = 10,
    ///     BF_0x0036D422 = 11,
    ///     BF_BlindFireWhenInCover = 12,
    ///     BF_Aggressive = 13,
    ///     BF_CanInvestigate = 14,
    ///     BF_HasRadio = 15,
    ///     BF_0x6BDE28D1 = 16,
    ///     BF_AlwaysFlee = 17,
    ///     BF_0x7852797D = 18,
    ///     BF_0x33497B95 = 19,
    ///     BF_CanTauntInVehicle = 20,
    ///     BF_CanChaseTargetOnFoot = 21,
    ///     BF_WillDragInjuredPedsToSafety = 22,
    ///     BF_0xCD7168B8 = 23,
    ///     BF_UseProximityFiringRate = 24,
    ///     BF_0x48F914F8 = 25,
    ///     BF_0x2EA543D0 = 26,
    ///     BF_PerfectAccuracy = 27,
    ///     BF_CanUseFrustratedAdvance = 28,
    ///     BF_0x3D131AC1 = 29,
    ///     BF_0x3AD95F27 = 30,
    ///     BF_MaintainMinDistanceToTarget = 31,
    ///     BF_0xEAD68AD2 = 32,
    ///     BF_0xA206C2E0 = 33,
    ///     BF_CanUsePeekingVariations = 34,
    ///     BF_0xA5715184 = 35,
    ///     BF_0xD5265533 = 36,
    ///     BF_0x2B84C2BF = 37,
    ///     BF_DisableBulletReactions = 38,
    ///     BF_CanBust = 39,
    ///     BF_0xAA525726 = 40,
    ///     BF_CanCommandeerVehicles = 41,
    ///     BF_CanFlank = 42,
    ///     BF_SwitchToAdvanceIfCantFindCover = 43,
    ///     BF_SwitchToDefensiveIfInCover = 44,
    ///     BF_0xEB4786A0 = 45,
    ///     BF_CanFightArmedPedsWhenNotArmed = 46,
    ///     BF_0xA08E9402 = 47,
    ///     BF_0x952EAD7D = 48,
    ///     BF_UseEnemyAccuracyScaling = 49,
    ///     BF_CanCharge = 50,
    ///     BF_0xDA8C2BD3 = 51,
    ///     BF_0x6562F017 = 52,
    ///     BF_0xA2C3D53B = 53,
    ///     BF_AlwaysEquipBestWeapon = 54,
    ///     BF_CanSeeUnderwaterPeds = 55,
    ///     BF_0xF619486B = 56,
    ///     BF_0x61EB63A3 = 57,
    ///     BF_DisableFleeFromCombat = 58,
    ///     BF_0x8976D12B = 59,
    ///     BF_CanThrowSmokeGrenade = 60,
    ///     BF_NonMissionPedsFleeFromThisPedUnlessArmed = 61,
    ///     BF_0x5452A10C = 62,
    ///     BF_FleesFromInvincibleOpponents = 63,
    ///     BF_DisableBlockFromPursueDuringVehicleChase = 64,
    ///     BF_DisableSpinOutDuringVehicleChase = 65,
    ///     BF_DisableCruiseInFrontDuringBlockDuringVehicleChase = 66,
    ///     BF_0x0B404731 = 67,
    ///     BF_DisableReactToBuddyShot = 68,
    ///     BF_0x7FFD6AEB = 69,
    ///     BF_0x51F4AEF8 = 70,
    ///     BF_PermitChargeBeyondDefensiveArea = 71,
    ///     BF_0x63E0A8E2 = 72,
    ///     BF_0xDF974436 = 73,
    ///     BF_0x556C080B = 74,
    ///     BF_0xA4D50035 = 75,
    ///     BF_SetDisableShoutTargetPositionOnCombatStart = 76,
    ///     BF_DisableRespondedToThreatBroadcast = 77,
    ///     BF_0xCBB01765 = 78,
    ///     BF_0x4F862ED4 = 79,
    ///     BF_0xEF9C7C40 = 80,
    ///     BF_0xE51B494F = 81,
    ///     BF_0x054D0199 = 82,
    ///     BF_0xD36BCE94 = 83,
    ///     BF_0xFB11F690 = 84,
    ///     BF_0xD208A9AD = 85,
    ///     BF_AllowDogFighting = 86,
    ///     BF_0x07A6E531 = 87,
    ///     BF_0x34F9317B = 88,
    ///     BF_0x4240F5A9 = 89,
    ///     BF_0xEE129DBD = 90,
    ///     BF_0x053AEAD9 = 91
    /// };
    pub inline fn setPedCombatAttributes(ped: types.Ped, attribute_id: c_int, enabled: windows.BOOL) !void { try invoker.invoke(void, 0x9F7794730795E019, .{ped, attribute_id, enabled}); } // 0x9F7794730795E019 0x81D64248 b323
    /// enum eTargetLossResponseType \
    /// { \
    ///     TLR_ExitTask,
    ///     TLR_NeverLoseTarget,
    ///     TLR_SearchForTarget
    /// };
    pub inline fn setPedTargetLossResponse(ped: types.Ped, response_type: c_int) !void { try invoker.invoke(void, 0x0703B9079823DA4A, .{ped, response_type}); } // 0x0703B9079823DA4A 0xCFA613FF b323
    pub inline fn isPedPerformingMeleeAction(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDCCA191DF9980FD7, .{ped}); } // 0xDCCA191DF9980FD7 0x139C0875 b323
    pub inline fn isPedPerformingStealthKill(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFD4CCDBCC59941B7, .{ped}); } // 0xFD4CCDBCC59941B7 0x9ADD7B21 b323
    pub inline fn isPedPerformingACounterAttack(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEBD0EDBA5BE957CF, .{ped}); } // 0xEBD0EDBA5BE957CF 0x9BE7C860 b323
    pub inline fn isPedBeingStealthKilled(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x863B23EFDE9C5DF2, .{ped}); } // 0x863B23EFDE9C5DF2 0xD044C8AF b323
    pub inline fn getMeleeTargetForPed(ped: types.Ped) !types.Ped { return try invoker.invoke(types.Ped, 0x18A3E9EE1297FD39, .{ped}); } // 0x18A3E9EE1297FD39 0xAFEC26A4 b323
    pub inline fn wasPedKilledByStealth(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF9800AA1A771B000, .{ped}); } // 0xF9800AA1A771B000 0x2EA4B54E b323
    pub inline fn wasPedKilledByTakedown(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7F08E26039C7347C, .{ped}); } // 0x7F08E26039C7347C 0xBDD3CE69 b323
    pub inline fn wasPedKnockedOut(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x61767F73EACEED21, .{ped}); } // 0x61767F73EACEED21 0x3993092B b323
    /// bit 1 (0x2) = use vehicle \
    /// bit 15 (0x8000) = force cower
    pub inline fn setPedFleeAttributes(ped: types.Ped, attribute_flags: c_int, enable: windows.BOOL) !void { try invoker.invoke(void, 0x70A2D1137C8ED7C9, .{ped, attribute_flags, enable}); } // 0x70A2D1137C8ED7C9 0xA717A875 b323
    /// p1: Only "CODE_HUMAN_STAND_COWER" found in the b617d scripts.
    pub inline fn setPedCowerHash(ped: types.Ped, p_1: [*c]const u8) !void { try invoker.invoke(void, 0xA549131166868ED3, .{ped, p_1}); } // 0xA549131166868ED3 0x16F30DF4 b323
    pub inline fn setPedSteersAroundDeadBodies(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2016C603D6B8987C, .{ped, toggle}); } // 0x2016C603D6B8987C 0xA6F2C057 b323
    pub inline fn setPedSteersAroundPeds(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x46F2193B3AD1D891, .{ped, toggle}); } // 0x46F2193B3AD1D891 0x797CAE4F b323
    pub inline fn setPedSteersAroundObjects(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1509C089ADC208BF, .{ped, toggle}); } // 0x1509C089ADC208BF 0x3BD9B0A6 b323
    pub inline fn setPedSteersAroundVehicles(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEB6FB9D48DDE23EC, .{ped, toggle}); } // 0xEB6FB9D48DDE23EC 0x533C0651 b323
    pub inline fn setPedIsAvoidedByOthers(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xA9B61A329BFDCBEA, .{p_0, p_1}); } // 0xA9B61A329BFDCBEA 0x2276DE0D b323
    pub inline fn setPedIncreasedAvoidanceRadius(ped: types.Ped) !void { try invoker.invoke(void, 0x570389D1C3DE3C6B, .{ped}); } // 0x570389D1C3DE3C6B 0x59C52BE6 b323
    pub inline fn setPedBlocksPathingWhenDead(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x576594E8D64375E2, .{ped, toggle}); } // 0x576594E8D64375E2 0x1D87DDC1 b323
    pub inline fn setPedNoTimeDelayBeforeShot(p_0: types.Any) !void { try invoker.invoke(void, 0xA52D5247A4227E14, .{p_0}); } // 0xA52D5247A4227E14 0xB52BA5F5 b323
    pub inline fn isAnyPedNearPoint(vec: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x083961498679DC9F, .{vec.x, vec.y, vec.z, radius}); } // 0x083961498679DC9F 0xFBD9B050 b323
    pub inline fn forcePedAiAndAnimationUpdate(ped: types.Ped, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x2208438012482A1A, .{ped, p_1, p_2}); } // 0x2208438012482A1A 0x187B9070 b323
    pub inline fn isPedHeadingTowardsPosition(ped: types.Ped, vec: types.Vector3, p_4: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFCF37A457CB96DC0, .{ped, vec.x, vec.y, vec.z, p_4}); } // 0xFCF37A457CB96DC0 0x45037B9B b323
    pub inline fn requestPedVisibilityTracking(ped: types.Ped) !void { try invoker.invoke(void, 0x7D7A2E43E74E2EB8, .{ped}); } // 0x7D7A2E43E74E2EB8 0x840D24D3 b323
    pub inline fn requestPedVehicleVisibilityTracking(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x2BC338A7B21F4608, .{ped, p_1}); } // 0x2BC338A7B21F4608 0x31C31DAA b323
    pub inline fn requestPedRestrictedVehicleVisibilityTracking(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xCD018C591F94CB43, .{ped, p_1}); } // 0xCD018C591F94CB43  b323
    pub inline fn requestPedUseSmallBboxVisibilityTracking(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x75BA1CB3B7D40CAF, .{ped, p_1}); } // 0x75BA1CB3B7D40CAF 0x9194DB71 b323
    /// returns whether or not a ped is visible within your FOV, not this check auto's to false after a certain distance.
    /// 
    /// 
    /// Target needs to be tracked.. won't work otherwise.
    pub inline fn isTrackedPedVisible(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x91C8E617F64188AC, .{ped}); } // 0x91C8E617F64188AC 0x33248CC1 b323
    pub inline fn getTrackedPedPixelcount(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x511F1A683387C7E2, .{ped}); } // 0x511F1A683387C7E2 0x5B1B70AA b323
    pub inline fn isPedTracked(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C5E1F087CD10BB7, .{ped}); } // 0x4C5E1F087CD10BB7 0x7EB613D9 b323
    pub inline fn hasPedReceivedEvent(ped: types.Ped, event_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8507BCB710FA6DC0, .{ped, event_id}); } // 0x8507BCB710FA6DC0 0xECD73DB0 b323
    pub inline fn canPedSeeHatedPed(ped_1: types.Ped, ped_2: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6CD5A433374D4CFB, .{ped_1, ped_2}); } // 0x6CD5A433374D4CFB 0x74A0F291 b323
    pub inline fn canPedShuffleToOrFromTurretSeat(ped: types.Ped, p_1: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9C6A6C19B6C0C496, .{ped, p_1}); } // 0x9C6A6C19B6C0C496  b323
    pub inline fn canPedShuffleToOrFromExtraSeat(ped: types.Ped, p_1: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2DFC81C9B9608549, .{ped, p_1}); } // 0x2DFC81C9B9608549  b944
    /// no bone= -1
    /// 
    /// boneIds: \
    ///         SKEL_ROOT = 0x0,
    ///    SKEL_Pelvis = 0x2e28,
    ///  SKEL_L_Thigh = 0xe39f, \
    ///     SKEL_L_Calf = 0xf9bb,
    ///  SKEL_L_Foot = 0x3779, \
    ///  SKEL_L_Toe0 = 0x83c, \
    ///   IK_L_Foot = 0xfedd,
    ///    PH_L_Foot = 0xe175,
    ///    MH_L_Knee = 0xb3fe,
    ///    SKEL_R_Thigh = 0xca72,
    ///     SKEL_R_Calf = 0x9000,
    ///  SKEL_R_Foot = 0xcc4d, \
    ///  SKEL_R_Toe0 = 0x512d, \
    ///  IK_R_Foot = 0x8aae, \
    ///    PH_R_Foot = 0x60e6,
    ///    MH_R_Knee = 0x3fcf,
    ///    RB_L_ThighRoll = 0x5c57,
    ///   RB_R_ThighRoll = 0x192a,
    ///   SKEL_Spine_Root = 0xe0fd,
    ///  SKEL_Spine0 = 0x5c01, \
    ///  SKEL_Spine1 = 0x60f0, \
    ///  SKEL_Spine2 = 0x60f1, \
    ///  SKEL_Spine3 = 0x60f2, \
    ///  SKEL_L_Clavicle = 0xfcd9, \
    ///  SKEL_L_UpperArm = 0xb1c5, \
    ///  SKEL_L_Forearm = 0xeeeb, \
    ///   SKEL_L_Hand = 0x49d9,
    ///  SKEL_L_Finger00 = 0x67f2, \
    ///  SKEL_L_Finger01 = 0xff9, \
    ///   SKEL_L_Finger02 = 0xffa,
    ///   SKEL_L_Finger10 = 0x67f3,
    ///  SKEL_L_Finger11 = 0x1049, \
    ///  SKEL_L_Finger12 = 0x104a, \
    ///  SKEL_L_Finger20 = 0x67f4, \
    ///  SKEL_L_Finger21 = 0x1059, \
    ///  SKEL_L_Finger22 = 0x105a, \
    ///  SKEL_L_Finger30 = 0x67f5, \
    ///  SKEL_L_Finger31 = 0x1029, \
    ///  SKEL_L_Finger32 = 0x102a, \
    ///  SKEL_L_Finger40 = 0x67f6, \
    ///  SKEL_L_Finger41 = 0x1039, \
    ///  SKEL_L_Finger42 = 0x103a, \
    ///  PH_L_Hand = 0xeb95, \
    ///    IK_L_Hand = 0x8cbd,
    ///    RB_L_ForeArmRoll = 0xee4f,
    ///     RB_L_ArmRoll = 0x1470,
    ///     MH_L_Elbow = 0x58b7,
    ///   SKEL_R_Clavicle = 0x29d2,
    ///  SKEL_R_UpperArm = 0x9d4d, \
    ///  SKEL_R_Forearm = 0x6e5c, \
    ///   SKEL_R_Hand = 0xdead,
    ///  SKEL_R_Finger00 = 0xe5f2, \
    ///  SKEL_R_Finger01 = 0xfa10, \
    ///  SKEL_R_Finger02 = 0xfa11, \
    ///  SKEL_R_Finger10 = 0xe5f3, \
    ///  SKEL_R_Finger11 = 0xfa60, \
    ///  SKEL_R_Finger12 = 0xfa61, \
    ///  SKEL_R_Finger20 = 0xe5f4, \
    ///  SKEL_R_Finger21 = 0xfa70, \
    ///  SKEL_R_Finger22 = 0xfa71, \
    ///  SKEL_R_Finger30 = 0xe5f5, \
    ///  SKEL_R_Finger31 = 0xfa40, \
    ///  SKEL_R_Finger32 = 0xfa41, \
    ///  SKEL_R_Finger40 = 0xe5f6, \
    ///  SKEL_R_Finger41 = 0xfa50, \
    ///  SKEL_R_Finger42 = 0xfa51, \
    ///  PH_R_Hand = 0x6f06, \
    ///    IK_R_Hand = 0x188e,
    ///    RB_R_ForeArmRoll = 0xab22,
    ///     RB_R_ArmRoll = 0x90ff,
    ///     MH_R_Elbow = 0xbb0,
    ///    SKEL_Neck_1 = 0x9995,
    ///  SKEL_Head = 0x796e, \
    ///    IK_Head = 0x322c,
    ///  FACIAL_facialRoot = 0xfe2c, \
    ///    FB_L_Brow_Out_000 = 0xe3db,
    ///    FB_L_Lid_Upper_000 = 0xb2b6,
    ///   FB_L_Eye_000 = 0x62ac,
    ///     FB_L_CheekBone_000 = 0x542e,
    ///   FB_L_Lip_Corner_000 = 0x74ac,
    ///  FB_R_Lid_Upper_000 = 0xaa10, \
    ///   FB_R_Eye_000 = 0x6b52,
    ///     FB_R_CheekBone_000 = 0x4b88,
    ///   FB_R_Brow_Out_000 = 0x54c,
    ///     FB_R_Lip_Corner_000 = 0x2ba6,
    ///  FB_Brow_Centre_000 = 0x9149, \
    ///   FB_UpperLipRoot_000 = 0x4ed2,
    ///  FB_UpperLip_000 = 0xf18f, \
    ///  FB_L_Lip_Top_000 = 0x4f37, \
    ///     FB_R_Lip_Top_000 = 0x4537,
    ///     FB_Jaw_000 = 0xb4a0,
    ///   FB_LowerLipRoot_000 = 0x4324,
    ///  FB_LowerLip_000 = 0x508f, \
    ///  FB_L_Lip_Bot_000 = 0xb93b, \
    ///     FB_R_Lip_Bot_000 = 0xc33b,
    ///     FB_Tongue_000 = 0xb987,
    ///    RB_Neck_1 = 0x8b93,
    ///    IK_Root = 0xdd1c
    pub inline fn getPedBoneIndex(ped: types.Ped, bone_id: c_int) !c_int { return try invoker.invoke(c_int, 0x3F428D08BE5AAE31, .{ped, bone_id}); } // 0x3F428D08BE5AAE31 0x259C6BA2 b323
    pub inline fn getPedRagdollBoneIndex(ped: types.Ped, bone: c_int) !c_int { return try invoker.invoke(c_int, 0x2057EF813397A772, .{ped, bone}); } // 0x2057EF813397A772 0x849F0716 b323
    /// Values look to be between 0.0 and 1.0 \
    /// From decompiled scripts: 0.0, 0.6, 0.65, 0.8, 1.0
    /// 
    /// You are correct, just looked in IDA it breaks from the function if it's less than 0.0f or greater than 1.0f.
    pub inline fn setPedEnveffScale(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0xBF29516833893561, .{ped, value}); } // 0xBF29516833893561 0xFC1CFC27 b323
    pub inline fn getPedEnveffScale(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0x9C14D30395A51A3C, .{ped}); } // 0x9C14D30395A51A3C 0xA3421E39 b323
    pub inline fn setEnablePedEnveffScale(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD2C5AA0C0E8D0F1E, .{ped, toggle}); } // 0xD2C5AA0C0E8D0F1E 0xC70F4A84 b323
    /// In agency_heist3b.c4, its like this 90% of the time:
    /// 
    /// PED::SET_PED_ENVEFF_CPV_ADD(ped, 0.099); \
    /// PED::SET_PED_ENVEFF_SCALE(ped, 1.0); \
    /// PED::SET_PED_ENVEFF_CPV_ADD(ped, 87, 81, 68); \
    /// PED::SET_ENABLE_PED_ENVEFF_SCALE(ped, 1);
    /// 
    /// and its like this 10% of the time:
    /// 
    /// PED::SET_PED_ENVEFF_CPV_ADD(ped, 0.2); \
    /// PED::SET_PED_ENVEFF_SCALE(ped, 0.65); \
    /// PED::SET_PED_ENVEFF_COLOR_MODULATOR(ped, 74, 69, 60); \
    /// PED::SET_ENABLE_PED_ENVEFF_SCALE(ped, 1);
    pub inline fn setPedEnveffCpvAdd(ped: types.Ped, p_1: f32) !void { try invoker.invoke(void, 0x110F526AB784111F, .{ped, p_1}); } // 0x110F526AB784111F 0x3B882533 b323
    /// Something related to the environmental effects natives. \
    /// In the "agency_heist3b" script, p1 - p3 are always under 100 - usually they are {87, 81, 68}. If SET_PED_ENVEFF_SCALE is set to 0.65 (instead of the usual 1.0), they use {74, 69, 60}
    pub inline fn setPedEnveffColorModulator(ped: types.Ped, p_1: c_int, p_2: c_int, p_3: c_int) !void { try invoker.invoke(void, 0xD69411AA0CEBF9E9, .{ped, p_1, p_2, p_3}); } // 0xD69411AA0CEBF9E9 0x87A0C174 b323
    /// intensity: 0.0f - 1.0f
    /// 
    /// This native sets the emissive intensity for the given ped. It is used for different 'glow' levels on illuminated clothing.
    pub inline fn setPedEmissiveScale(ped: types.Ped, intensity: f32) !void { try invoker.invoke(void, 0x4E90D746056E273D, .{ped, intensity}); } // 0x4E90D746056E273D  b944
    /// Use 0x4E90D746056E273D to set the illuminated clothing glow intensity for a specific ped. \
    /// Returns a float between 0.0 and 1.0 representing the current illuminated clothing glow intensity.
    pub inline fn getPedEmissiveScale(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0x1461B28A06717D68, .{ped}); } // 0x1461B28A06717D68  b944
    pub inline fn isPedShaderReady(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x81AA517FBBA05D39, .{ped}); } // 0x81AA517FBBA05D39  b944
    pub inline fn setPedEnableCrewEmblem(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE906EC930F5FE7C8, .{ped, toggle}); } // 0xE906EC930F5FE7C8  b791
    /// This native does absolutely nothing, just a nullsub
    pub inline fn requestRagdollBoundsUpdate(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x1216E0BFA72CC703, .{p_0, p_1}); } // 0x1216E0BFA72CC703 0x7BD26837 b323
    /// Enable/disable ped shadow (ambient occlusion). https://gfycat.com/thankfulesteemedgecko
    pub inline fn setPedAoBlobRendering(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2B5AA717A181FB4C, .{ped, toggle}); } // 0x2B5AA717A181FB4C 0x98E29ED0 b323
    pub inline fn isPedSheltered(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB8B52E498014F5B0, .{ped}); } // 0xB8B52E498014F5B0  b323
    /// p6 always 2 (but it doesnt seem to matter...)
    /// 
    /// roll and pitch 0 \
    /// yaw to Ped.rotation
    pub inline fn createSynchronizedScene(vec: types.Vector3, roll: f32, pitch: f32, yaw: f32, p_6: c_int) !c_int { return try invoker.invoke(c_int, 0x8C18E0F9080ADD73, .{vec.x, vec.y, vec.z, roll, pitch, yaw, p_6}); } // 0x8C18E0F9080ADD73 0xFFDDF8FA b323
    pub inline fn createSynchronizedSceneAtMapObject(vec: types.Vector3, radius: f32, object: types.Hash) !c_int { return try invoker.invoke(c_int, 0x62EC273D00187DCA, .{vec.x, vec.y, vec.z, radius, object}); } // 0x62EC273D00187DCA 0xF3876894 b323
    /// Returns true if a synchronized scene is running
    pub inline fn isSynchronizedSceneRunning(scene_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x25D39B935A038A26, .{scene_id}); } // 0x25D39B935A038A26 0x57A282F1 b323
    pub inline fn setSynchronizedSceneOrigin(scene_i_d: c_int, vec: types.Vector3, roll: f32, pitch: f32, yaw: f32, p_7: windows.BOOL) !void { try invoker.invoke(void, 0x6ACF6B7225801CD7, .{scene_i_d, vec.x, vec.y, vec.z, roll, pitch, yaw, p_7}); } // 0x6ACF6B7225801CD7 0x2EC2A0B2 b323
    pub inline fn setSynchronizedScenePhase(scene_i_d: c_int, phase: f32) !void { try invoker.invoke(void, 0x734292F4F0ABF6D0, .{scene_i_d, phase}); } // 0x734292F4F0ABF6D0 0xF5AB0D98 b323
    pub inline fn getSynchronizedScenePhase(scene_i_d: c_int) !f32 { return try invoker.invoke(f32, 0xE4A310B1D7FA73CC, .{scene_i_d}); } // 0xE4A310B1D7FA73CC 0xB0B2C852 b323
    pub inline fn setSynchronizedSceneRate(scene_i_d: c_int, rate: f32) !void { try invoker.invoke(void, 0xB6C49F8A5E295A5D, .{scene_i_d, rate}); } // 0xB6C49F8A5E295A5D 0xF10112FD b323
    pub inline fn getSynchronizedSceneRate(scene_i_d: c_int) !f32 { return try invoker.invoke(f32, 0xD80932D577274D40, .{scene_i_d}); } // 0xD80932D577274D40 0x89365F0D b323
    pub inline fn setSynchronizedSceneLooped(scene_i_d: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD9A897A4C6C2974F, .{scene_i_d, toggle}); } // 0xD9A897A4C6C2974F 0x32ED9F82 b323
    pub inline fn isSynchronizedSceneLooped(scene_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x62522002E0C391BA, .{scene_i_d}); } // 0x62522002E0C391BA 0x47D87A84 b323
    pub inline fn setSynchronizedSceneHoldLastFrame(scene_i_d: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x394B9CD12435C981, .{scene_i_d, toggle}); } // 0x394B9CD12435C981 0x2DE48DA1 b323
    pub inline fn isSynchronizedSceneHoldLastFrame(scene_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7F2F4F13AC5257EF, .{scene_i_d}); } // 0x7F2F4F13AC5257EF 0x72CF2514 b323
    pub inline fn attachSynchronizedSceneToEntity(scene_i_d: c_int, entity: types.Entity, bone_index: c_int) !void { try invoker.invoke(void, 0x272E4723B56A3B96, .{scene_i_d, entity, bone_index}); } // 0x272E4723B56A3B96 0xE9BA6189 b323
    pub inline fn detachSynchronizedScene(scene_i_d: c_int) !void { try invoker.invoke(void, 0x6D38F1F04CBB37EA, .{scene_i_d}); } // 0x6D38F1F04CBB37EA 0x52A1CAB2 b323
    pub inline fn takeOwnershipOfSynchronizedScene(scene: c_int) !void { try invoker.invoke(void, 0xCD9CC7E200A52A6F, .{scene}); } // 0xCD9CC7E200A52A6F 0xBF7F9035 b323
    /// Regarding p2, p3 and p4: Most common is 0, 0, 0); followed by 0, 1, 0); and 1, 1, 0); in R* scripts. p4 is very rarely something other than 0.
    /// 
    /// enum eMotionState // 0x92A659FE \
    /// { \
    ///     MotionState_None = 0xEE717723,
    ///     MotionState_Idle = 0x9072A713,
    ///     MotionState_Walk = 0xD827C3DB,
    ///     MotionState_Run = 0xFFF7E7A4,
    ///     MotionState_Sprint = 0xBD8817DB,
    ///     MotionState_Crouch_Idle = 0x43FB099E,
    ///     MotionState_Crouch_Walk = 0x08C31A98,
    ///     MotionState_Crouch_Run = 0x3593CF09,
    ///     MotionState_DoNothing = 0x0EC17E58,
    ///     MotionState_AnimatedVelocity = 0x551AAC43,
    ///     MotionState_InVehicle = 0x94D9D58D,
    ///     MotionState_Aiming = 0x3F67C6AF,
    ///     MotionState_Diving_Idle = 0x4848CDED,
    ///     MotionState_Diving_Swim = 0x916E828C,
    ///     MotionState_Swimming_TreadWater = 0xD1BF11C7,
    ///     MotionState_Dead = 0x0DBB071C,
    ///     MotionState_Stealth_Idle = 0x422D7A25,
    ///     MotionState_Stealth_Walk = 0x042AB6A2,
    ///     MotionState_Stealth_Run = 0xFB0B79E1,
    ///     MotionState_Parachuting = 0xBAC0F10B,
    ///     MotionState_ActionMode_Idle = 0xDA40A0DC,
    ///     MotionState_ActionMode_Walk = 0xD2905EA7,
    ///     MotionState_ActionMode_Run = 0x31BADE14,
    ///     MotionState_Jetpack = 0x535E6A5E
    /// };
    pub inline fn forcePedMotionState(ped: types.Ped, motion_state_hash: types.Hash, p_2: windows.BOOL, p_3: c_int, p_4: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF28965D04F570DCA, .{ped, motion_state_hash, p_2, p_3, p_4}); } // 0xF28965D04F570DCA 0x164DDEFF b323
    pub inline fn getPedCurrentMoveBlendRatio(ped: types.Ped, speed_x: [*c]f32, speed_y: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF60165E1D2C5370B, .{ped, speed_x, speed_y}); } // 0xF60165E1D2C5370B  b323
    pub inline fn setPedMaxMoveBlendRatio(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x433083750C5E064A, .{ped, value}); } // 0x433083750C5E064A 0xEAD0269A b323
    pub inline fn setPedMinMoveBlendRatio(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x01A898D26E2333DD, .{ped, value}); } // 0x01A898D26E2333DD 0x383EC364 b323
    /// Min: 0.00 \
    /// Max: 10.00
    /// 
    /// Can be used in combo with fast run cheat.
    /// 
    /// When value is set to 10.00: \
    /// Sprinting without fast run cheat: 66 m/s \
    /// Sprinting with fast run cheat: 77 m/s
    /// 
    /// Needs to be looped!
    /// 
    /// Note: According to IDA for the Xbox360 xex, when they check bgt they seem to have the min to 0.0f, but the max set to 1.15f not 10.0f.
    pub inline fn setPedMoveRateOverride(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x085BF80FA50A39D1, .{ped, value}); } // 0x085BF80FA50A39D1 0x900008C6 b323
    pub inline fn setPedMoveRateInWaterOverride(ped: types.Ped, p_1: f32) !void { try invoker.invoke(void, 0x0B3E35AC043707D9, .{ped, p_1}); } // 0x0B3E35AC043707D9  b573
    /// Checks if the specified sexiness flag is set
    /// 
    /// enum eSexinessFlags \
    /// { \
    ///  SF_JEER_AT_HOT_PED = 0, \
    ///  SF_HURRIEDFEMALES_SEXY = 1, \
    ///  SF_HOT_PERSON = 2, \
    ///  };
    pub inline fn pedHasSexinessFlagSet(ped: types.Ped, sexiness_flag: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x46B05BCAE43856B0, .{ped, sexiness_flag}); } // 0x46B05BCAE43856B0 0x79543043 b323
    /// Returns size of array, passed into the second variable.
    /// 
    /// See below for usage information.
    /// 
    /// This function actually requires a struct, where the first value is the maximum number of elements to return.  Here is a sample of how I was able to get it to work correctly, without yet knowing the struct format.
    /// 
    /// //Setup the array \
    ///  const int numElements = 10; \
    ///    const int arrSize = numElements * 2 + 2;
    ///   Any veh[arrSize];
    ///  //0 index is the size of the array \
    ///     veh[0] = numElements;
    /// 
    ///    int count = PED::GET_PED_NEARBY_VEHICLES(PLAYER::PLAYER_PED_ID(), veh);
    /// 
    ///  if (veh != NULL) \
    ///   {
    ///      //Simple loop to go through results
    ///        for (int i = 0; i < count; i++)
    ///         {
    ///          int offsettedID = i * 2 + 2;
    ///           //Make sure it exists
    ///          if (veh[offsettedID] != NULL && ENTITY::DOES_ENTITY_EXIST(veh[offsettedID]))
    ///           {
    ///              //Do something
    ///             }
    ///      }
    ///  }  
    pub inline fn getPedNearbyVehicles(ped: types.Ped, size_and_vehs: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0xCFF869CBFA210D82, .{ped, size_and_vehs}); } // 0xCFF869CBFA210D82 0xCB716F68 b323
    /// sizeAndPeds - is a pointer to an array. The array is filled with peds found nearby the ped supplied to the first argument. \
    /// ignore - ped type to ignore
    /// 
    /// Return value is the number of peds found and added to the array passed.
    /// 
    /// -----------------------------------
    /// 
    /// To make this work in most menu bases at least in C++ do it like so,
    /// 
    ///  Formatted Example: https://pastebin.com/D8an9wwp
    /// 
    /// -----------------------------------
    /// 
    /// Example: gtaforums.com/topic/789788-function-args-to-pedget-ped-nearby-peds/?p=1067386687
    pub inline fn getPedNearbyPeds(ped: types.Ped, size_and_peds: [*c]types.Any, ignore: c_int) !c_int { return try invoker.invoke(c_int, 0x23F8F5FC7E8C4A6B, .{ped, size_and_peds, ignore}); } // 0x23F8F5FC7E8C4A6B 0x4D3325F4 b323
    pub inline fn haveAllStreamingRequestsCompleted(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7350823473013C02, .{ped}); } // 0x7350823473013C02 0xF9FB4B71 b323
    pub inline fn isPedUsingActionMode(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x00E73468D085F745, .{ped}); } // 0x00E73468D085F745 0x5AE7EDA2 b323
    /// p2 is usually -1 in the scripts. action is either 0 or "DEFAULT_ACTION".
    pub inline fn setPedUsingActionMode(ped: types.Ped, p_1: windows.BOOL, p_2: c_int, action: [*c]const u8) !void { try invoker.invoke(void, 0xD75ACCF5E0FB5367, .{ped, p_1, p_2, action}); } // 0xD75ACCF5E0FB5367 0x8802F696 b323
    /// name: "MP_FEMALE_ACTION" found multiple times in the b617d scripts.
    pub inline fn setMovementModeOverride(ped: types.Ped, name: [*c]const u8) !void { try invoker.invoke(void, 0x781DE8FA214E87D2, .{ped, name}); } // 0x781DE8FA214E87D2 0x83BAE814 b323
    /// Overrides the ped's collision capsule radius for the current tick. \
    /// Must be called every tick to be effective.
    /// 
    /// Setting this to 0.001 will allow warping through some objects.
    pub inline fn setPedCapsule(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x364DF566EC833DE2, .{ped, value}); } // 0x364DF566EC833DE2 0xB153E1B9 b323
    /// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
    pub inline fn registerPedheadshot(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x4462658788425076, .{ped}); } // 0x4462658788425076 0xFFE2667B b323
    pub inline fn registerPedheadshotHires(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0xBA8805A1108A2515, .{ped}); } // 0xBA8805A1108A2515  b877
    /// Similar to REGISTER_PEDHEADSHOT but creates a transparent background instead of black. Example: https://i.imgur.com/iHz8ztn.png
    pub inline fn registerPedheadshotTransparent(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x953563CE563143AF, .{ped}); } // 0x953563CE563143AF 0x4DD03628 b323
    /// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
    pub inline fn unregisterPedheadshot(id: c_int) !void { try invoker.invoke(void, 0x96B1361D9B24C2FF, .{id}); } // 0x96B1361D9B24C2FF 0x0879AE45 b323
    /// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
    pub inline fn isPedheadshotValid(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0A9668F158129A2, .{id}); } // 0xA0A9668F158129A2 0x0B1080C4 b323
    /// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
    pub inline fn isPedheadshotReady(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7085228842B13A67, .{id}); } // 0x7085228842B13A67 0x761CD02E b323
    /// gtaforums.com/topic/885580-ped-headshotmugshot-txd/
    pub inline fn getPedheadshotTxdString(id: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xDB4EACD4AD0A5D6B, .{id}); } // 0xDB4EACD4AD0A5D6B 0x76D28E96 b323
    pub inline fn requestPedheadshotImgUpload(id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF0DAEF2F545BEE25, .{id}); } // 0xF0DAEF2F545BEE25 0x10F2C023 b323
    pub inline fn releasePedheadshotImgUpload(id: c_int) !void { try invoker.invoke(void, 0x5D517B27CF6ECD04, .{id}); } // 0x5D517B27CF6ECD04 0x0DBB2FA7 b323
    pub inline fn isPedheadshotImgUploadAvailable() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEBB376779A760AA8, .{}); } // 0xEBB376779A760AA8 0x810158F8 b323
    pub inline fn hasPedheadshotImgUploadFailed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x876928DDDFCCC9CD, .{}); } // 0x876928DDDFCCC9CD 0x05023F8F b323
    pub inline fn hasPedheadshotImgUploadSucceeded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE8A169E666CBC541, .{}); } // 0xE8A169E666CBC541 0xAA39FD6C b323
    pub inline fn setPedHeatscaleOverride(ped: types.Ped, heat_scale: f32) !void { try invoker.invoke(void, 0xC1F6EBF9A3D55538, .{ped, heat_scale}); } // 0xC1F6EBF9A3D55538 0xEF9142DB b323
    pub inline fn disablePedHeatscaleOverride(ped: types.Ped) !void { try invoker.invoke(void, 0x600048C60D5C2C51, .{ped}); } // 0x600048C60D5C2C51 0x0688DE64 b323
    pub inline fn spawnpointsStartSearch(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, interior_flags: c_int, scale: f32, duration: c_int) !void { try invoker.invoke(void, 0x2DF9038C90AD5264, .{p_0, p_1, p_2, p_3, p_4, interior_flags, scale, duration}); } // 0x2DF9038C90AD5264 0x909A1D76 b323
    pub inline fn spawnpointsStartSearchInAngledArea(vec_1__: types.Vector3, vec_2__: types.Vector3, width: f32, interior_flags: c_int, scale: f32, duration: c_int) !void { try invoker.invoke(void, 0xB2AFF10216DEFA2F, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, width, interior_flags, scale, duration}); } // 0xB2AFF10216DEFA2F 0x4AAD0ECB b323
    pub inline fn spawnpointsCancelSearch() !void { try invoker.invoke(void, 0xFEE4A5459472A9F8, .{}); } // 0xFEE4A5459472A9F8 0x492C9E46 b323
    pub inline fn spawnpointsIsSearchActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3C67506996001F5E, .{}); } // 0x3C67506996001F5E 0x814A28F4 b323
    pub inline fn spawnpointsIsSearchComplete() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA586FBEB32A53DBB, .{}); } // 0xA586FBEB32A53DBB 0x0B60D2BA b323
    pub inline fn spawnpointsIsSearchFailed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF445DE8DA80A1792, .{}); } // 0xF445DE8DA80A1792 0x6B83ABDF b323
    pub inline fn spawnpointsGetNumSearchResults() !c_int { return try invoker.invoke(c_int, 0xA635C11B8C44AFC2, .{}); } // 0xA635C11B8C44AFC2 0xF46B4DC8 b323
    pub inline fn spawnpointsGetSearchResult(random_int: c_int, x: [*c]f32, y: [*c]f32, z: [*c]f32) !void { try invoker.invoke(void, 0x280C7E3AC7F56E90, .{random_int, x, y, z}); } // 0x280C7E3AC7F56E90 0x36A4AC65 b323
    pub inline fn spawnpointsGetSearchResultFlags(p_0: c_int, p_1: [*c]c_int) !void { try invoker.invoke(void, 0xB782F8238512BAD5, .{p_0, p_1}); } // 0xB782F8238512BAD5 0xBA699DDF b323
    pub inline fn setIkTarget(ped: types.Ped, ik_index: c_int, entity_look_at: types.Entity, bone_look_at: c_int, offset__: types.Vector3, p_7: types.Any, blend_in_duration: c_int, blend_out_duration: c_int) !void { try invoker.invoke(void, 0xC32779C16FCEECD9, .{ped, ik_index, entity_look_at, bone_look_at, offset__.x, offset__.y, offset__.z, p_7, blend_in_duration, blend_out_duration}); } // 0xC32779C16FCEECD9 0x6FE5218C b323
    pub inline fn forceInstantLegIkSetup(ped: types.Ped) !void { try invoker.invoke(void, 0xED3C76ADFA6D07C4, .{ped}); } // 0xED3C76ADFA6D07C4 0xFB4000DC b323
    pub inline fn requestActionModeAsset(asset: [*c]const u8) !void { try invoker.invoke(void, 0x290E2780BB7AA598, .{asset}); } // 0x290E2780BB7AA598 0x572BA553 b323
    pub inline fn hasActionModeAssetLoaded(asset: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE4B5F4BF2CB24E65, .{asset}); } // 0xE4B5F4BF2CB24E65 0xF7EB2BF1 b323
    pub inline fn removeActionModeAsset(asset: [*c]const u8) !void { try invoker.invoke(void, 0x13E940F88470FA51, .{asset}); } // 0x13E940F88470FA51 0x3F480F92 b323
    pub inline fn requestStealthModeAsset(asset: [*c]const u8) !void { try invoker.invoke(void, 0x2A0A62FCDEE16D4F, .{asset}); } // 0x2A0A62FCDEE16D4F 0x280A004A b323
    pub inline fn hasStealthModeAssetLoaded(asset: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE977FC5B08AF3441, .{asset}); } // 0xE977FC5B08AF3441 0x39245667 b323
    pub inline fn removeStealthModeAsset(asset: [*c]const u8) !void { try invoker.invoke(void, 0x9219857D21F0E842, .{asset}); } // 0x9219857D21F0E842 0x8C0B243A b323
    pub inline fn setPedLodMultiplier(ped: types.Ped, multiplier: f32) !void { try invoker.invoke(void, 0xDC2C5C242AAC342B, .{ped, multiplier}); } // 0xDC2C5C242AAC342B 0x1D2B5C70 b323
    pub inline fn setPedCanLosePropsOnDamage(ped: types.Ped, toggle: windows.BOOL, p_2: c_int) !void { try invoker.invoke(void, 0xE861D0B05C7662B8, .{ped, toggle, p_2}); } // 0xE861D0B05C7662B8 0x2F9550C2 b323
    pub inline fn setForceFootstepUpdate(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x129466ED55140F8D, .{ped, toggle}); } // 0x129466ED55140F8D 0x37DBC2AD b323
    pub inline fn setForceStepType(ped: types.Ped, p_1: windows.BOOL, @"type": c_int, p_3: c_int) !void { try invoker.invoke(void, 0xCB968B53FC7F916D, .{ped, p_1, @"type", p_3}); } // 0xCB968B53FC7F916D 0xC0F1BC91 b323
    pub inline fn isAnyHostilePedNearPoint(ped: types.Ped, vec: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x68772DB2B2526F9F, .{ped, vec.x, vec.y, vec.z, radius}); } // 0x68772DB2B2526F9F 0x1A464167 b323
    /// Toggles config flag CPED_CONFIG_FLAG_CanPlayInCarIdles.
    pub inline fn setPedCanPlayInCarIdles(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x820E9892A77E97CD, .{ped, toggle}); } // 0x820E9892A77E97CD  b877
    pub inline fn isTargetPedInPerceptionArea(ped: types.Ped, target_ped: types.Ped, p_2: f32, p_3: f32, p_4: f32, p_5: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x06087579E7AA85A9, .{ped, target_ped, p_2, p_3, p_4, p_5}); } // 0x06087579E7AA85A9 0xD0567D41 b323
    /// Min and max are usually 100.0 and 200.0
    pub inline fn setPopControlSphereThisFrame(vec: types.Vector3, min: f32, max: f32) !void { try invoker.invoke(void, 0xD8C3BE3EE94CAF2D, .{vec.x, vec.y, vec.z, min, max}); } // 0xD8C3BE3EE94CAF2D 0x4BBE5E2C b323
    pub inline fn forceZeroMassInCollisions(ped: types.Ped) !void { try invoker.invoke(void, 0xD33DAA36272177C4, .{ped}); } // 0xD33DAA36272177C4 0xA89A53F2 b323
    pub inline fn setDisableHighFallDeath(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x711794453CFD692B, .{ped, toggle}); } // 0x711794453CFD692B  b463
    pub inline fn setPedPhonePaletteIdx(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x83A169EABCDB10A2, .{p_0, p_1}); } // 0x83A169EABCDB10A2  b323
    pub inline fn setPedSteerBias(ped: types.Ped, value: f32) !void { try invoker.invoke(void, 0x288DF530C92DAD6F, .{ped, value}); } // 0x288DF530C92DAD6F  b323
    pub inline fn isPedSwitchingWeapon(_ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3795688A307E1EB6, .{_ped}); } // 0x3795688A307E1EB6  b505
    pub inline fn setPedTreatedAsFriendly(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x0F62619393661D6E, .{p_0, p_1, p_2}); } // 0x0F62619393661D6E  b877
    pub inline fn setDisablePedMapCollision(ped: types.Ped) !void { try invoker.invoke(void, 0xDFE68C4B787E1BFB, .{ped}); } // 0xDFE68C4B787E1BFB  b1180
    pub inline fn enableMpLight(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEE2476B9EE4A094F, .{ped, toggle}); } // 0xEE2476B9EE4A094F  b1493
    pub inline fn getMpLightEnabled(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x88274C11CF0D866D, .{ped}); } // 0x88274C11CF0D866D  b1493
    pub inline fn clearCoverPointForPed(ped: types.Ped) !void { try invoker.invoke(void, 0x637822DC2AFEEBF8, .{ped}); } // 0x637822DC2AFEEBF8  b1493
    pub inline fn setAllowStuntJumpCamera(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFAB944D4D481ACCB, .{ped, toggle}); } // 0xFAB944D4D481ACCB  b1734
};

pub const Physics = struct
{
    /// Creates a rope at the specific position, that extends in the specified direction when not attached to any entities. \
    /// __
    /// 
    /// Add_Rope(pos.x,pos.y,pos.z,0.0,0.0,0.0,20.0,4,20.0,1.0,0.0,false,false,false,5.0,false,NULL)
    /// 
    /// When attached, Position<vector> does not matter \
    /// When attached, Angle<vector> does not matter
    /// 
    /// Rope Type: \
    /// 4 and bellow is a thick rope \
    /// 5 and up are small metal wires \
    /// 0 crashes the game
    /// 
    /// Max_length - Rope is forced to this length, generally best to keep this the same as your rope length.
    /// 
    /// windingSpeed - Speed the Rope is being winded, using native START_ROPE_WINDING. Set positive for winding and negative for unwinding.
    /// 
    /// Rigid - If max length is zero, and this is set to false the rope will become rigid (it will force a specific distance, what ever length is, between the objects).
    /// 
    /// breakable - Whether or not shooting the rope will break it.
    /// 
    /// unkPtr - unknown ptr, always 0 in orig scripts \
    /// __
    /// 
    /// Lengths can be calculated like so:
    /// 
    /// float distance = abs(x1 - x2) + abs(y1 - y2) + abs(z1 - z2); // Rope length
    /// 
    /// 
    /// NOTES:
    /// 
    /// Rope does NOT interact with anything you attach it to, in some cases it make interact with the world AFTER it breaks (seems to occur if you set the type to -1).
    /// 
    /// Rope will sometimes contract and fall to the ground like you'd expect it to, but since it doesn't interact with the world the effect is just jaring.
    pub inline fn addRope(vec: types.Vector3, rot__: types.Vector3, length: f32, rope_type: c_int, max_length: f32, min_length: f32, winding_speed: f32, p_1_1: windows.BOOL, p_1_2: windows.BOOL, rigid: windows.BOOL, p_1_4: f32, break_when_shot: windows.BOOL, unk_ptr: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0xE832D760399EB220, .{vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, length, rope_type, max_length, min_length, winding_speed, p_1_1, p_1_2, rigid, p_1_4, break_when_shot, unk_ptr}); } // 0xE832D760399EB220 0xA592EC74 b323
    pub inline fn deleteRope(rope_id: [*c]c_int) !void { try invoker.invoke(void, 0x52B4829281364649, .{rope_id}); } // 0x52B4829281364649 0x748D72AF b323
    pub inline fn deleteChildRope(rope_id: c_int) !void { try invoker.invoke(void, 0xAA5D6B1888E4DB20, .{rope_id}); } // 0xAA5D6B1888E4DB20 0xB19B4706 b323
    pub inline fn doesRopeExist(rope_id: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFD5448BE3111ED96, .{rope_id}); } // 0xFD5448BE3111ED96 0x66E4A3AC b323
    pub inline fn ropeDrawEnabled(rope_id: [*c]c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xA1AE736541B0FCA3, .{rope_id, p_1}); } // 0xA1AE736541B0FCA3  b1868
    pub inline fn ropeDrawShadowEnabled(rope_id: [*c]c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF159A63806BB5BA8, .{rope_id, toggle}); } // 0xF159A63806BB5BA8 0x51523B8C b323
    /// Rope presets can be found in the gamefiles. One example is "ropeFamily3", it is NOT a hash but rather a string.
    pub inline fn loadRopeData(rope_id: c_int, rope__preset: [*c]const u8) !void { try invoker.invoke(void, 0xCBB203C04D1ABD27, .{rope_id, rope__preset}); } // 0xCBB203C04D1ABD27 0x9E8F1644 b323
    pub inline fn pinRopeVertex(rope_id: c_int, vertex: c_int, vec: types.Vector3) !void { try invoker.invoke(void, 0x2B320CF14146B69A, .{rope_id, vertex, vec.x, vec.y, vec.z}); } // 0x2B320CF14146B69A 0xAE1D101B b323
    pub inline fn unpinRopeVertex(rope_id: c_int, vertex: c_int) !void { try invoker.invoke(void, 0x4B5AE2EEE4A8F180, .{rope_id, vertex}); } // 0x4B5AE2EEE4A8F180 0xB30B552F b323
    pub inline fn getRopeVertexCount(rope_id: c_int) !c_int { return try invoker.invoke(c_int, 0x3655F544CD30F0B5, .{rope_id}); } // 0x3655F544CD30F0B5 0x5131CD2C b323
    /// Attaches entity 1 to entity 2.
    pub inline fn attachEntitiesToRope(rope_id: c_int, ent_1: types.Entity, ent_2: types.Entity, ent_1__: types.Vector3, ent_2__: types.Vector3, length: f32, p_1_0: windows.BOOL, p_1_1: windows.BOOL, p_1_2: [*c]types.Any, p_1_3: [*c]types.Any) !void { try invoker.invoke(void, 0x3D95EC8B6D940AC3, .{rope_id, ent_1, ent_2, ent_1__.x, ent_1__.y, ent_1__.z, ent_2__.x, ent_2__.y, ent_2__.z, length, p_1_0, p_1_1, p_1_2, p_1_3}); } // 0x3D95EC8B6D940AC3 0x7508668F b323
    /// The position supplied can be anywhere, and the entity should anchor relative to that point from it's origin.
    pub inline fn attachRopeToEntity(rope_id: c_int, entity: types.Entity, vec: types.Vector3, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x4B490A6832559A65, .{rope_id, entity, vec.x, vec.y, vec.z, p_5}); } // 0x4B490A6832559A65 0xB25D9536 b323
    pub inline fn detachRopeFromEntity(rope_id: c_int, entity: types.Entity) !void { try invoker.invoke(void, 0xBCF3026912A8647D, .{rope_id, entity}); } // 0xBCF3026912A8647D 0x3E720BEE b323
    pub inline fn ropeSetUpdatePinverts(rope_id: c_int) !void { try invoker.invoke(void, 0xC8D667EE52114ABA, .{rope_id}); } // 0xC8D667EE52114ABA 0xEAF291A0 b323
    pub inline fn ropeSetUpdateOrder(rope_id: c_int, p_1: types.Any) !void { try invoker.invoke(void, 0xDC57A637A20006ED, .{rope_id, p_1}); } // 0xDC57A637A20006ED 0x80DB77A7 b323
    pub inline fn ropeSetSmoothReelin(rope_id: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x36CCB9BE67B970FD, .{rope_id, p_1}); } // 0x36CCB9BE67B970FD 0xC67D5CF6 b323
    pub inline fn isRopeAttachedAtBothEnds(rope_id: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x84DE3B5FB3E666F0, .{rope_id}); } // 0x84DE3B5FB3E666F0 0x7A18BB9C b323
    pub inline fn getRopeLastVertexCoord(rope_id: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x21BB0FBD3E217C2D, .{rope_id}); } // 0x21BB0FBD3E217C2D 0x91F6848B b323
    pub inline fn getRopeVertexCoord(rope_id: c_int, vertex: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xEA61CA8E80F09E4D, .{rope_id, vertex}); } // 0xEA61CA8E80F09E4D 0x84374452 b323
    pub inline fn startRopeWinding(rope_id: c_int) !void { try invoker.invoke(void, 0x1461C72C889E343E, .{rope_id}); } // 0x1461C72C889E343E 0x5187BED3 b323
    pub inline fn stopRopeWinding(rope_id: c_int) !void { try invoker.invoke(void, 0xCB2D4AB84A19AA7C, .{rope_id}); } // 0xCB2D4AB84A19AA7C 0x46826B53 b323
    pub inline fn startRopeUnwindingFront(rope_id: c_int) !void { try invoker.invoke(void, 0x538D1179EC1AA9A9, .{rope_id}); } // 0x538D1179EC1AA9A9 0xFC0DB4C3 b323
    pub inline fn stopRopeUnwindingFront(rope_id: c_int) !void { try invoker.invoke(void, 0xFFF3A50779EFBBB3, .{rope_id}); } // 0xFFF3A50779EFBBB3 0x2EEDB18F b323
    pub inline fn ropeConvertToSimple(rope_id: c_int) !void { try invoker.invoke(void, 0x5389D48EFA2F079A, .{rope_id}); } // 0x5389D48EFA2F079A 0x43E92628 b323
    /// Loads rope textures for all ropes in the current scene.
    pub inline fn ropeLoadTextures() !void { try invoker.invoke(void, 0x9B9039DBF2D258C1, .{}); } // 0x9B9039DBF2D258C1 0xBA97CE91 b323
    pub inline fn ropeAreTexturesLoaded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF2D0E6A75CC05597, .{}); } // 0xF2D0E6A75CC05597 0x5FDC1047 b323
    /// Unloads rope textures for all ropes in the current scene.
    pub inline fn ropeUnloadTextures() !void { try invoker.invoke(void, 0x6CE36C35C1AC8163, .{}); } // 0x6CE36C35C1AC8163 0x584463E0 b323
    pub inline fn doesScriptOwnRope(rope_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x271C9D3ACA5D6409, .{rope_id}); } // 0x271C9D3ACA5D6409  b323
    pub inline fn ropeAttachVirtualBoundGeom(rope_id: c_int, p_1: c_int, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: f32, p_9: f32, p_1_0: f32, p_1_1: f32, p_1_2: f32, p_1_3: f32) !void { try invoker.invoke(void, 0xBC0CE682D4D05650, .{rope_id, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2, p_1_3}); } // 0xBC0CE682D4D05650 0x106BA127 b323
    pub inline fn ropeChangeScriptOwner(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xB1B6216CA2E7B55E, .{p_0, p_1, p_2}); } // 0xB1B6216CA2E7B55E 0x7C6F7668 b323
    pub inline fn ropeSetRefframevelocityColliderorder(rope_id: c_int, p_1: c_int) !void { try invoker.invoke(void, 0xB743F735C03D7810, .{rope_id, p_1}); } // 0xB743F735C03D7810 0x686672DD b323
    pub inline fn ropeGetDistanceBetweenEnds(rope_id: c_int) !f32 { return try invoker.invoke(f32, 0x73040398DFF9A4A6, .{rope_id}); } // 0x73040398DFF9A4A6 0xFD309DC8 b323
    /// Forces a rope to a certain length.
    pub inline fn ropeForceLength(rope_id: c_int, length: f32) !void { try invoker.invoke(void, 0xD009F759A723DB1B, .{rope_id, length}); } // 0xD009F759A723DB1B 0xABF3130F b323
    /// Reset a rope to a certain length.
    pub inline fn ropeResetLength(rope_id: c_int, length: f32) !void { try invoker.invoke(void, 0xC16DE94D9BEA14A0, .{rope_id, length}); } // 0xC16DE94D9BEA14A0 0xC8A423A3 b323
    pub inline fn applyImpulseToCloth(pos__: types.Vector3, vec__: types.Vector3, impulse: f32) !void { try invoker.invoke(void, 0xE37F721824571784, .{pos__.x, pos__.y, pos__.z, vec__.x, vec__.y, vec__.z, impulse}); } // 0xE37F721824571784 0xA2A5C9FE b323
    pub inline fn setDamping(entity: types.Entity, vertex: c_int, value: f32) !void { try invoker.invoke(void, 0xEEA3B200A6FEB65B, .{entity, vertex, value}); } // 0xEEA3B200A6FEB65B 0xCFB37773 b323
    pub inline fn getDamping(entity: types.Entity, @"type": c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x8C520A929415BCD2, .{entity, @"type"}); } // 0x8C520A929415BCD2  b3407
    pub inline fn activatePhysics(entity: types.Entity) !void { try invoker.invoke(void, 0x710311ADF0E20730, .{entity}); } // 0x710311ADF0E20730 0x031711B8 b323
    pub inline fn setCgoffset(entity: types.Entity, vec: types.Vector3) !void { try invoker.invoke(void, 0xD8FA3908D7B86904, .{entity, vec.x, vec.y, vec.z}); } // 0xD8FA3908D7B86904 0x59910AB2 b323
    pub inline fn getCgoffset(entity: types.Entity) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x8214A4B5A7A33612, .{entity}); } // 0x8214A4B5A7A33612 0x49A11F0D b323
    pub inline fn setCgAtBoundcenter(entity: types.Entity) !void { try invoker.invoke(void, 0xBE520D9761FF811F, .{entity}); } // 0xBE520D9761FF811F 0xA5B55421 b323
    pub inline fn breakEntityGlass(entity: types.Entity, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: f32, p_9: types.Any, p_1_0: windows.BOOL) !void { try invoker.invoke(void, 0x2E648D16F6E308F3, .{entity, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0}); } // 0x2E648D16F6E308F3 0xD0E0402F b323
    pub inline fn getIsEntityAFrag(object: types.Object) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0C112765300C7E1E, .{object}); } // 0x0C112765300C7E1E  b505
    pub inline fn setDisableBreaking(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5CEC1A84620E7D5B, .{object, toggle}); } // 0x5CEC1A84620E7D5B 0xEE77C326 b323
    pub inline fn resetDisableBreaking(object: types.Object) !void { try invoker.invoke(void, 0xCC6E963682533882, .{object}); } // 0xCC6E963682533882  b323
    pub inline fn setDisableFragDamage(object: types.Object, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x01BA3AED21C16CFB, .{object, toggle}); } // 0x01BA3AED21C16CFB 0x97269DC8 b323
    pub inline fn setUseKinematicPhysics(entity: types.Entity, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x15F944730C832252, .{entity, toggle}); } // 0x15F944730C832252  b463
    pub inline fn setInStuntMode(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x9EBD751E5787BAF2, .{p_0}); } // 0x9EBD751E5787BAF2  b791
    /// Related to the lower-end of a vehicles fTractionCurve, e.g., from standing starts and acceleration from low/zero speeds.
    pub inline fn setInArenaMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAA6A6098851C396F, .{toggle}); } // 0xAA6A6098851C396F  b1604
};

pub const Player = struct
{
    /// Gets the ped for a specified player index.
    pub inline fn getPlayerPed(player: types.Player) !types.Ped { return try invoker.invoke(types.Ped, 0x43A66C31C68491C0, .{player}); } // 0x43A66C31C68491C0 0x6E31E993 b323
    /// Does the same like PLAYER::GET_PLAYER_PED
    pub inline fn getPlayerPedScriptIndex(player: types.Player) !types.Ped { return try invoker.invoke(types.Ped, 0x50FAC3A3E030A6E1, .{player}); } // 0x50FAC3A3E030A6E1 0x6AC64990 b323
    /// Set the model for a specific Player. Be aware that this will destroy the current Ped for the Player and create a new one, any reference to the old ped should be reset \
    /// Make sure to request the model first and wait until it has loaded.
    pub inline fn setPlayerModel(player: types.Player, model: types.Hash) !void { try invoker.invoke(void, 0x00A1CADD00108836, .{player, model}); } // 0x00A1CADD00108836 0x774A4C54 b323
    pub inline fn changePlayerPed(player: types.Player, ped: types.Ped, p_2: windows.BOOL, reset_damage: windows.BOOL) !void { try invoker.invoke(void, 0x048189FAC643DEEE, .{player, ped, p_2, reset_damage}); } // 0x048189FAC643DEEE 0xBE515485 b323
    pub inline fn getPlayerRgbColour(player: types.Player, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !void { try invoker.invoke(void, 0xE902EF951DCE178F, .{player, r, g, b}); } // 0xE902EF951DCE178F 0x6EF43BBB b323
    /// Gets the number of players in the current session. \
    /// If not multiplayer, always returns 1.
    pub inline fn getNumberOfPlayers() !c_int { return try invoker.invoke(c_int, 0x407C7F91DDB46C16, .{}); } // 0x407C7F91DDB46C16 0x4C1B8867 b323
    /// Gets the player's team. \
    /// Does nothing in singleplayer.
    pub inline fn getPlayerTeam(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x37039302F4E0A008, .{player}); } // 0x37039302F4E0A008 0x9873E404 b323
    /// Set player team on deathmatch and last team standing..
    pub inline fn setPlayerTeam(player: types.Player, team: c_int) !void { try invoker.invoke(void, 0x0299FA38396A4940, .{player, team}); } // 0x0299FA38396A4940 0x725ADCF2 b323
    pub inline fn getNumberOfPlayersInTeam(team: c_int) !c_int { return try invoker.invoke(c_int, 0x1FC200409F10E6F1, .{team}); } // 0x1FC200409F10E6F1  b1180
    pub inline fn getPlayerName(player: types.Player) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x6D0DE6A7B5DA71F8, .{player}); } // 0x6D0DE6A7B5DA71F8 0x406B4B20 b323
    /// Remnant from GTA IV. Does nothing in GTA V.
    pub inline fn getWantedLevelRadius(player: types.Player) !f32 { return try invoker.invoke(f32, 0x085DEB493BE80812, .{player}); } // 0x085DEB493BE80812 0x1CF7D7DA b323
    pub inline fn getPlayerWantedCentrePosition(player: types.Player) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x0C92BA89F1AF26F8, .{player}); } // 0x0C92BA89F1AF26F8 0x821F2D2C b323
    /// # Predominant call signatures \
    /// PLAYER::SET_PLAYER_WANTED_CENTRE_POSITION(PLAYER::PLAYER_ID(), ENTITY::GET_ENTITY_COORDS(PLAYER::PLAYER_PED_ID(), 1));
    /// 
    /// # Parameter value ranges \
    /// P0: PLAYER::PLAYER_ID() \
    /// P1: ENTITY::GET_ENTITY_COORDS(PLAYER::PLAYER_PED_ID(), 1) \
    /// P2: Not set by any call
    pub inline fn setPlayerWantedCentrePosition(player: types.Player, position: [*c]types.Vector3, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x520E541A97A13354, .{player, position, p_2, p_3}); } // 0x520E541A97A13354 0xF261633A b323
    /// Drft
    pub inline fn getWantedLevelThreshold(wanted_level: c_int) !c_int { return try invoker.invoke(c_int, 0xFDD179EAF45B556C, .{wanted_level}); } // 0xFDD179EAF45B556C 0xD9783F6B b323
    /// Call SET_PLAYER_WANTED_LEVEL_NOW for immediate effect
    /// 
    /// wantedLevel is an integer value representing 0 to 5 stars even though the game supports the 6th wanted level but no police will appear since no definitions are present for it in the game files
    /// 
    /// disableNoMission-  Disables When Off Mission- appears to always be false
    /// 
    pub inline fn setPlayerWantedLevel(player: types.Player, wanted_level: c_int, disable_no_mission: windows.BOOL) !void { try invoker.invoke(void, 0x39FF19C64EF7DA5B, .{player, wanted_level, disable_no_mission}); } // 0x39FF19C64EF7DA5B 0xB7A0914B b323
    /// p2 is always false in R* scripts
    pub inline fn setPlayerWantedLevelNoDrop(player: types.Player, wanted_level: c_int, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x340E61DE7F471565, .{player, wanted_level, p_2}); } // 0x340E61DE7F471565 0xED6F44F5 b323
    /// Forces any pending wanted level to be applied to the specified player immediately.
    /// 
    /// Call SET_PLAYER_WANTED_LEVEL with the desired wanted level, followed by SET_PLAYER_WANTED_LEVEL_NOW.
    /// 
    /// Second parameter is unknown (always false).
    pub inline fn setPlayerWantedLevelNow(player: types.Player, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xE0A7D1E497FFCD6F, .{player, p_1}); } // 0xE0A7D1E497FFCD6F 0xAF3AFD83 b323
    pub inline fn arePlayerFlashingStarsAboutToDrop(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAFAF86043E5874E9, .{player}); } // 0xAFAF86043E5874E9 0xE13A71C7 b323
    pub inline fn arePlayerStarsGreyedOut(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0A6EB355EE14A2DB, .{player}); } // 0x0A6EB355EE14A2DB 0x5E72AB72 b323
    pub inline fn isWantedAndHasBeenSeenByCops(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7E07C78925D5FD96, .{player}); } // 0x7E07C78925D5FD96  b372
    pub inline fn setDispatchCopsForPlayer(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDB172424876553F4, .{player, toggle}); } // 0xDB172424876553F4 0x48A18913 b323
    pub inline fn isPlayerWantedLevelGreater(player: types.Player, wanted_level: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x238DB2A2C23EE9EF, .{player, wanted_level}); } // 0x238DB2A2C23EE9EF 0x589A2661 b323
    /// This executes at the same as speed as PLAYER::SET_PLAYER_WANTED_LEVEL(player, 0, false);
    /// 
    /// PLAYER::GET_PLAYER_WANTED_LEVEL(player); executes in less than half the time. Which means that it's worth first checking if the wanted level needs to be cleared before clearing. However, this is mostly about good code practice and can important in other situations. The difference in time in this example is negligible. 
    pub inline fn clearPlayerWantedLevel(player: types.Player) !void { try invoker.invoke(void, 0xB302540597885499, .{player}); } // 0xB302540597885499 0x54EA5BCC b323
    pub inline fn isPlayerDead(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x424D4687FA1E5652, .{player}); } // 0x424D4687FA1E5652 0x140CA5A8 b323
    pub inline fn isPlayerPressingHorn(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFA1E2BF8B10598F9, .{player}); } // 0xFA1E2BF8B10598F9 0xED1D1662 b323
    /// Flags: \
    /// SPC_AMBIENT_SCRIPT = (1 << 1), \
    /// SPC_CLEAR_TASKS = (1 << 2), \
    /// SPC_REMOVE_FIRES = (1 << 3), \
    /// SPC_REMOVE_EXPLOSIONS = (1 << 4), \
    /// SPC_REMOVE_PROJECTILES = (1 << 5), \
    /// SPC_DEACTIVATE_GADGETS = (1 << 6), \
    /// SPC_REENABLE_CONTROL_ON_DEATH = (1 << 7), \
    /// SPC_LEAVE_CAMERA_CONTROL_ON = (1 << 8), \
    /// SPC_ALLOW_PLAYER_DAMAGE = (1 << 9), \
    /// SPC_DONT_STOP_OTHER_CARS_AROUND_PLAYER = (1 << 10), \
    /// SPC_PREVENT_EVERYBODY_BACKOFF = (1 << 11), \
    /// SPC_ALLOW_PAD_SHAKE = (1 << 12)
    /// 
    /// See: https://alloc8or.re/gta5/doc/enums/eSetPlayerControlFlag.txt
    pub inline fn setPlayerControl(player: types.Player, b_has_control: windows.BOOL, flags: c_int) !void { try invoker.invoke(void, 0x8D32347D6D4C40A2, .{player, b_has_control, flags}); } // 0x8D32347D6D4C40A2 0xD17AFCD8 b323
    pub inline fn getPlayerWantedLevel(player: types.Player) !c_int { return try invoker.invoke(c_int, 0xE28E54788CE8F12D, .{player}); } // 0xE28E54788CE8F12D 0xBDCDD163 b323
    pub inline fn setMaxWantedLevel(max_wanted_level: c_int) !void { try invoker.invoke(void, 0xAA5F02DB48D704B9, .{max_wanted_level}); } // 0xAA5F02DB48D704B9 0x665A06F5 b323
    /// If toggle is set to false: \
    ///  The police won't be shown on the (mini)map
    /// 
    /// If toggle is set to true: \
    ///  The police will be shown on the (mini)map
    pub inline fn setPoliceRadarBlips(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x43286D561B72B8BF, .{toggle}); } // 0x43286D561B72B8BF 0x8E114B10 b323
    /// The player will be ignored by the police if toggle is set to true
    pub inline fn setPoliceIgnorePlayer(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x32C62AA929C2DA6A, .{player, toggle}); } // 0x32C62AA929C2DA6A 0xE6DE71B7 b323
    /// Checks whether the specified player has a Ped, the Ped is not dead, is not injured and is not arrested.
    pub inline fn isPlayerPlaying(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5E9564D8246B909A, .{player}); } // 0x5E9564D8246B909A 0xE15D777F b323
    pub inline fn setEveryoneIgnorePlayer(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8EEDA153AD141BA4, .{player, toggle}); } // 0x8EEDA153AD141BA4 0xC915285E b323
    pub inline fn setAllRandomPedsFlee(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x056E0FE8534C2949, .{player, toggle}); } // 0x056E0FE8534C2949 0x49EAE968 b323
    pub inline fn setAllRandomPedsFleeThisFrame(player: types.Player) !void { try invoker.invoke(void, 0x471D2FF42A94B4F2, .{player}); } // 0x471D2FF42A94B4F2 0xBF974891 b323
    pub inline fn setAllNeutralRandomPedsFlee(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDE45D1A1EF45EE61, .{player, toggle}); } // 0xDE45D1A1EF45EE61 0x274631FE b323
    /// - This is called after SET_ALL_RANDOM_PEDS_FLEE_THIS_FRAME
    /// 
    pub inline fn setAllNeutralRandomPedsFleeThisFrame(player: types.Player) !void { try invoker.invoke(void, 0xC3376F42B1FACCC6, .{player}); } // 0xC3376F42B1FACCC6 0x02DF7AF4 b323
    pub inline fn setLawPedsCanAttackNonWantedPlayerThisFrame(player: types.Player) !void { try invoker.invoke(void, 0xFAC75988A7D078D3, .{player}); } // 0xFAC75988A7D078D3  b463
    pub inline fn setIgnoreLowPriorityShockingEvents(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x596976B02B6B5700, .{player, toggle}); } // 0x596976B02B6B5700 0xA3D675ED b323
    pub inline fn setWantedLevelMultiplier(multiplier: f32) !void { try invoker.invoke(void, 0x020E5F00CDA207BA, .{multiplier}); } // 0x020E5F00CDA207BA 0x1359292F b323
    /// Max value is 1.0
    pub inline fn setWantedLevelDifficulty(player: types.Player, difficulty: f32) !void { try invoker.invoke(void, 0x9B0BB33B04405E7A, .{player, difficulty}); } // 0x9B0BB33B04405E7A 0xB552626C b323
    pub inline fn resetWantedLevelDifficulty(player: types.Player) !void { try invoker.invoke(void, 0xB9D0DD990DC141DD, .{player}); } // 0xB9D0DD990DC141DD 0xA64C378D b323
    pub inline fn getWantedLevelTimeToEscape() !c_int { return try invoker.invoke(c_int, 0xA72200F51875FEA4, .{}); } // 0xA72200F51875FEA4  b2372
    pub inline fn setWantedLevelHiddenEscapeTime(player: types.Player, wanted_level: c_int, loss_time: c_int) !void { try invoker.invoke(void, 0x49B856B1360C47C7, .{player, wanted_level, loss_time}); } // 0x49B856B1360C47C7  b2060
    pub inline fn resetWantedLevelHiddenEscapeTime(player: types.Player) !void { try invoker.invoke(void, 0x823EC8E82BA45986, .{player}); } // 0x823EC8E82BA45986  b2060
    pub inline fn startFiringAmnesty(duration: c_int) !void { try invoker.invoke(void, 0xBF9BD71691857E48, .{duration}); } // 0xBF9BD71691857E48 0x5F8A22A6 b323
    /// PLAYER::REPORT_CRIME(PLAYER::PLAYER_ID(), 37, PLAYER::GET_WANTED_LEVEL_THRESHOLD(1));
    /// 
    /// From am_armybase.ysc.c4:
    /// 
    /// PLAYER::REPORT_CRIME(PLAYER::PLAYER_ID(4), 36, PLAYER::GET_WANTED_LEVEL_THRESHOLD(4));
    /// 
    /// -----
    /// 
    /// This was taken from the GTAV.exe v1.334. The function is called sub_140592CE8. For a full decompilation of the function, see here: https://pastebin.com/09qSMsN7 
    /// 
    /// ----- \
    /// crimeType: \
    /// 1: Firearms possession \
    /// 2: Person running a red light ("5-0-5") \
    /// 3: Reckless driver \
    /// 4: Speeding vehicle (a "5-10") \
    /// 5: Traffic violation (a "5-0-5") \
    /// 6: Motorcycle rider without a helmet \
    /// 7: Vehicle theft (a "5-0-3") \
    /// 8: Grand Theft Auto \
    /// 9: ??? \
    /// 10: ??? \
    /// 11: Assault on a civilian (a "2-40") \
    /// 12: Assault on an officer \
    /// 13: Assault with a deadly weapon (a "2-45") \
    /// 14: Officer shot (a "2-45") \
    /// 15: Pedestrian struck by a vehicle \
    /// 16: Officer struck by a vehicle \
    /// 17: Helicopter down (an "AC"?) \
    /// 18: Civilian on fire (a "2-40") \
    /// 19: Officer set on fire (a "10-99") \
    /// 20: Car on fire \
    /// 21: Air unit down (an "AC"?) \
    /// 22: An explosion (a "9-96") \
    /// 23: A stabbing (a "2-45") (also something else I couldn't understand) \
    /// 24: Officer stabbed (also something else I couldn't understand) \
    /// 25: Attack on a vehicle ("MDV"?) \
    /// 26: Damage to property \
    /// 27: Suspect threatening officer with a firearm \
    /// 28: Shots fired \
    /// 29: ??? \
    /// 30: ??? \
    /// 31: ??? \
    /// 32: ??? \
    /// 33: ??? \
    /// 34: A "2-45" \
    /// 35: ??? \
    /// 36: A "9-25" \
    /// 37: ??? \
    /// 38: ??? \
    /// 39: ??? \
    /// 40: ??? \
    /// 41: ??? \
    /// 42: ??? \
    /// 43: Possible disturbance \
    /// 44: Civilian in need of assistance \
    /// 45: ??? \
    /// 46: ???
    pub inline fn reportCrime(player: types.Player, crime_type: c_int, wanted_lvl_thresh: c_int) !void { try invoker.invoke(void, 0xE9B09589827545E7, .{player, crime_type, wanted_lvl_thresh}); } // 0xE9B09589827545E7 0xD8EB3A44 b323
    /// crimeType: see REPORT_CRIME
    pub inline fn suppressCrimeThisFrame(player: types.Player, crime_type: c_int) !void { try invoker.invoke(void, 0x9A987297ED8BD838, .{player, crime_type}); } // 0x9A987297ED8BD838 0x59B5C2A2 b323
    /// This native is used in both singleplayer and multiplayer scripts.
    /// 
    /// Always used like this in scripts \
    /// PLAYER::UPDATE_WANTED_POSITION_THIS_FRAME(PLAYER::PLAYER_ID());
    pub inline fn updateWantedPositionThisFrame(player: types.Player) !void { try invoker.invoke(void, 0xBC9490CA15AEA8FB, .{player}); } // 0xBC9490CA15AEA8FB 0x6B34A160 b323
    /// This has been found in use in the decompiled files.
    pub inline fn suppressLosingWantedLevelIfHiddenThisFrame(player: types.Player) !void { try invoker.invoke(void, 0x4669B3ED80F24B4E, .{player}); } // 0x4669B3ED80F24B4E 0xB9FB142F b323
    pub inline fn allowEvasionHudIfDisablingHiddenEvasionThisFrame(player: types.Player, p_1: types.Any) !void { try invoker.invoke(void, 0x2F41A3BAE005E5FA, .{player, p_1}); } // 0x2F41A3BAE005E5FA  b372
    /// This has been found in use in the decompiled files.
    pub inline fn forceStartHiddenEvasion(player: types.Player) !void { try invoker.invoke(void, 0xAD73CE5A09E42D12, .{player}); } // 0xAD73CE5A09E42D12 0x85725848 b323
    pub inline fn suppressWitnessesCallingPoliceThisFrame(player: types.Player) !void { try invoker.invoke(void, 0x36F1B38855F2A8DF, .{player}); } // 0x36F1B38855F2A8DF 0x3A7E5FB6 b323
    pub inline fn reportPoliceSpottedPlayer(player: types.Player) !void { try invoker.invoke(void, 0xDC64D2C53493ED12, .{player}); } // 0xDC64D2C53493ED12 0xD15C4B1C b323
    /// PLAYER::SET_LAW_RESPONSE_DELAY_OVERRIDE(rPtr((&l_122) + 71)); // Found in decompilation
    /// 
    /// ***
    /// 
    /// In "am_hold_up.ysc" used once:
    /// 
    /// l_8d._f47 = MISC::GET_RANDOM_FLOAT_IN_RANGE(18.0, 28.0); \
    /// PLAYER::SET_LAW_RESPONSE_DELAY_OVERRIDE((l_8d._f47));
    pub inline fn setLawResponseDelayOverride(p_0: f32) !void { try invoker.invoke(void, 0xB45EFF719D8427A6, .{p_0}); } // 0xB45EFF719D8427A6 0xBF6993C7 b323
    pub inline fn resetLawResponseDelayOverride() !void { try invoker.invoke(void, 0x0032A6DBA562C518, .{}); } // 0x0032A6DBA562C518 0x47CAB814 b323
    pub inline fn canPlayerStartMission(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDE7465A27D403C06, .{player}); } // 0xDE7465A27D403C06 0x39E3CB3F b323
    pub inline fn isPlayerReadyForCutscene(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x908CBECC2CAA3690, .{player}); } // 0x908CBECC2CAA3690 0xBB77E9CD b323
    pub inline fn isPlayerTargettingEntity(player: types.Player, entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7912F7FC4F6264B6, .{player, entity}); } // 0x7912F7FC4F6264B6 0xF3240B77 b323
    /// Assigns the handle of locked-on melee target to *entity that you pass it. \
    /// Returns false if no entity found.
    pub inline fn getPlayerTargetEntity(player: types.Player, entity: [*c]types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x13EDE1A5DBF797C9, .{player, entity}); } // 0x13EDE1A5DBF797C9 0xF6AAA2D7 b323
    /// Gets a value indicating whether the specified player is currently aiming freely.
    pub inline fn isPlayerFreeAiming(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E397FD2ECD37C87, .{player}); } // 0x2E397FD2ECD37C87 0x1DEC67B7 b323
    /// Gets a value indicating whether the specified player is currently aiming freely at the specified entity.
    pub inline fn isPlayerFreeAimingAtEntity(player: types.Player, entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3C06B5C839B38F7B, .{player, entity}); } // 0x3C06B5C839B38F7B 0x7D80EEAA b323
    /// Returns TRUE if it found an entity in your crosshair within range of your weapon. Assigns the handle of the target to the *entity that you pass it. \
    /// Returns false if no entity found.
    pub inline fn getEntityPlayerIsFreeAimingAt(player: types.Player, entity: [*c]types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2975C866E6713290, .{player, entity}); } // 0x2975C866E6713290 0x8866D9D0 b323
    /// Affects the range of auto aim target.
    pub inline fn setPlayerLockonRangeOverride(player: types.Player, range: f32) !void { try invoker.invoke(void, 0x29961D490E5814FD, .{player, range}); } // 0x29961D490E5814FD 0x74D42C03 b323
    /// Set whether this player should be able to do drive-bys.
    /// 
    /// "A drive-by is when a ped is aiming/shooting from vehicle. This includes middle finger taunts. By setting this value to false I confirm the player is unable to do all that. Tested on tick."
    /// 
    pub inline fn setPlayerCanDoDriveBy(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6E8834B52EC20C77, .{player, toggle}); } // 0x6E8834B52EC20C77 0xF4D99685 b323
    /// Sets whether this player can be hassled by gangs.
    pub inline fn setPlayerCanBeHassledByGangs(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD5E460AD7020A246, .{player, toggle}); } // 0xD5E460AD7020A246 0x71B305BB b323
    /// Sets whether this player can take cover.
    pub inline fn setPlayerCanUseCover(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD465A8599DFF6814, .{player, toggle}); } // 0xD465A8599DFF6814 0x13CAFAFA b323
    /// Gets the maximum wanted level the player can get. \
    /// Ranges from 0 to 5.
    pub inline fn getMaxWantedLevel() !c_int { return try invoker.invoke(c_int, 0x462E0DB9B137DC5F, .{}); } // 0x462E0DB9B137DC5F 0x457F1E44 b323
    pub inline fn isPlayerTargettingAnything(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x78CFE51896B6B8A4, .{player}); } // 0x78CFE51896B6B8A4 0x456DB50D b323
    pub inline fn setPlayerSprint(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA01B8075D8B92DF4, .{player, toggle}); } // 0xA01B8075D8B92DF4 0x7DD7900C b323
    pub inline fn resetPlayerStamina(player: types.Player) !void { try invoker.invoke(void, 0xA6F312FCCE9C1DFE, .{player}); } // 0xA6F312FCCE9C1DFE 0xC0445A9C b323
    pub inline fn restorePlayerStamina(player: types.Player, p_1: f32) !void { try invoker.invoke(void, 0xA352C1B864CAFD33, .{player, p_1}); } // 0xA352C1B864CAFD33 0x62A93608 b323
    pub inline fn getPlayerSprintStaminaRemaining(player: types.Player) !f32 { return try invoker.invoke(f32, 0x3F9F16F8E65A7ED7, .{player}); } // 0x3F9F16F8E65A7ED7 0x47017C90 b323
    pub inline fn getPlayerSprintTimeRemaining(player: types.Player) !f32 { return try invoker.invoke(f32, 0x1885BC9B108B4C99, .{player}); } // 0x1885BC9B108B4C99 0x40E80543 b323
    pub inline fn getPlayerUnderwaterTimeRemaining(player: types.Player) !f32 { return try invoker.invoke(f32, 0xA1FCF8E6AF40B731, .{player}); } // 0xA1FCF8E6AF40B731 0x1317125A b323
    pub inline fn setPlayerUnderwaterBreathPercentRemaining(player: types.Player, time: f32) !f32 { return try invoker.invoke(f32, 0xA0D3E4F7AAFB7E78, .{player, time}); } // 0xA0D3E4F7AAFB7E78  b757
    /// Returns the group ID the player is member of.
    pub inline fn getPlayerGroup(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x0D127585F77030AF, .{player}); } // 0x0D127585F77030AF 0xA5EDCDE8 b323
    pub inline fn getPlayerMaxArmour(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x92659B4CE1863CB3, .{player}); } // 0x92659B4CE1863CB3 0x02A50657 b323
    /// Can the player control himself, used to disable controls for player for things like a cutscene.
    /// 
    /// ---
    /// 
    /// You can't disable controls with this, use SET_PLAYER_CONTROL(...) for this. 
    pub inline fn isPlayerControlOn(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x49C32D60007AFA47, .{player}); } // 0x49C32D60007AFA47 0x618857F2 b323
    /// Returns true when the player is not able to control the cam i.e. when running a benchmark test, switching the player or viewing a cutscene.
    /// 
    /// Note: I am not 100% sure if the native actually checks if the cam control is disabled but it seems promising.
    pub inline fn getAreCameraControlsDisabled() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7C814D2FB49F40C0, .{}); } // 0x7C814D2FB49F40C0  b323
    pub inline fn isPlayerScriptControlOn(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8A876A65283DD7D7, .{player}); } // 0x8A876A65283DD7D7 0x61B00A84 b323
    /// Returns TRUE if the player ('s ped) is climbing at the moment.
    pub inline fn isPlayerClimbing(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x95E8F73DC65EFB9C, .{player}); } // 0x95E8F73DC65EFB9C 0x4A9E9AE0 b323
    /// Return true while player is being arrested / busted.
    /// 
    /// If atArresting is set to 1, this function will return 1 when player is being arrested (while player is putting his hand up, but still have control)
    /// 
    /// If atArresting is set to 0, this function will return 1 only when the busted screen is shown.
    pub inline fn isPlayerBeingArrested(player: types.Player, at_arresting: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x388A47C51ABDAC8E, .{player, at_arresting}); } // 0x388A47C51ABDAC8E 0x7F6A60D3 b323
    pub inline fn resetPlayerArrestState(player: types.Player) !void { try invoker.invoke(void, 0x2D03E13C460760D6, .{player}); } // 0x2D03E13C460760D6 0x453C7CAB b323
    /// Alternative: GET_VEHICLE_PED_IS_IN(PLAYER_PED_ID(), 1);
    pub inline fn getPlayersLastVehicle() !types.Vehicle { return try invoker.invoke(types.Vehicle, 0xB6997A7EB3F5C8C0, .{}); } // 0xB6997A7EB3F5C8C0 0xE2757AC1 b323
    /// Returns the same as PLAYER_ID and NETWORK_PLAYER_ID_TO_INT
    pub inline fn getPlayerIndex() !types.Player { return try invoker.invoke(types.Player, 0xA5EDC40EF369B48D, .{}); } // 0xA5EDC40EF369B48D 0x309BBDC1 b323
    /// Simply returns whatever is passed to it (Regardless of whether the handle is valid or not).
    pub inline fn intToPlayerindex(value: c_int) !types.Player { return try invoker.invoke(types.Player, 0x41BD2A6B006AF756, .{value}); } // 0x41BD2A6B006AF756 0x98DD98F1 b323
    /// Simply returns whatever is passed to it (Regardless of whether the handle is valid or not). \
    /// -------------------------------------------------------- \
    /// if (NETWORK::NETWORK_IS_PARTICIPANT_ACTIVE(PLAYER::INT_TO_PARTICIPANTINDEX(i)))
    /// 
    pub inline fn intToParticipantindex(value: c_int) !c_int { return try invoker.invoke(c_int, 0x9EC6603812C24710, .{value}); } // 0x9EC6603812C24710 0x98F3B274 b323
    pub inline fn getTimeSincePlayerHitVehicle(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x5D35ECF3A81A0EE0, .{player}); } // 0x5D35ECF3A81A0EE0 0x6E9B8B9E b323
    pub inline fn getTimeSincePlayerHitPed(player: types.Player) !c_int { return try invoker.invoke(c_int, 0xE36A25322DC35F42, .{player}); } // 0xE36A25322DC35F42 0xB6209195 b323
    pub inline fn getTimeSincePlayerDroveOnPavement(player: types.Player) !c_int { return try invoker.invoke(c_int, 0xD559D2BE9E37853B, .{player}); } // 0xD559D2BE9E37853B 0x8836E732 b323
    pub inline fn getTimeSincePlayerDroveAgainstTraffic(player: types.Player) !c_int { return try invoker.invoke(c_int, 0xDB89591E290D9182, .{player}); } // 0xDB89591E290D9182 0x9F27D00E b323
    pub inline fn isPlayerFreeForAmbientTask(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDCCFD3F106C36AB4, .{player}); } // 0xDCCFD3F106C36AB4 0x85C7E232 b323
    /// This returns YOUR 'identity' as a Player type.
    /// 
    /// Always returns 0 in story mode.
    pub inline fn playerId() !types.Player { return try invoker.invoke(types.Player, 0x4F8644AF03D0E0D6, .{}); } // 0x4F8644AF03D0E0D6 0x8AEA886C b323
    /// Returns current player ped
    pub inline fn playerPedId() !types.Ped { return try invoker.invoke(types.Ped, 0xD80958FC74E988A6, .{}); } // 0xD80958FC74E988A6 0xFA92E226 b323
    /// Does exactly the same thing as PLAYER_ID()
    pub inline fn networkPlayerIdToInt() !c_int { return try invoker.invoke(c_int, 0xEE68096F9F37341E, .{}); } // 0xEE68096F9F37341E 0x8DD5B838 b323
    pub inline fn hasForceCleanupOccurred(cleanup_flags: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC968670BFACE42D9, .{cleanup_flags}); } // 0xC968670BFACE42D9 0x4B37333C b323
    /// used with 1,2,8,64,128 in the scripts
    pub inline fn forceCleanup(cleanup_flags: c_int) !void { try invoker.invoke(void, 0xBC8983F38F78ED51, .{cleanup_flags}); } // 0xBC8983F38F78ED51 0xFDAAEA2B b323
    /// PLAYER::FORCE_CLEANUP_FOR_ALL_THREADS_WITH_THIS_NAME("pb_prostitute", 1); // Found in decompilation
    pub inline fn forceCleanupForAllThreadsWithThisName(name: [*c]const u8, cleanup_flags: c_int) !void { try invoker.invoke(void, 0x4C68DDDDF0097317, .{name, cleanup_flags}); } // 0x4C68DDDDF0097317 0x04256C73 b323
    pub inline fn forceCleanupForThreadWithThisId(id: c_int, cleanup_flags: c_int) !void { try invoker.invoke(void, 0xF745B37630DF176B, .{id, cleanup_flags}); } // 0xF745B37630DF176B 0x882D3EB3 b323
    pub inline fn getCauseOfMostRecentForceCleanup() !c_int { return try invoker.invoke(c_int, 0x9A41CF4674A12272, .{}); } // 0x9A41CF4674A12272 0x39AA9FC8 b323
    pub inline fn setPlayerMayOnlyEnterThisVehicle(player: types.Player, vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x8026FF78F208978A, .{player, vehicle}); } // 0x8026FF78F208978A 0xA454DD29 b323
    pub inline fn setPlayerMayNotEnterAnyVehicle(player: types.Player) !void { try invoker.invoke(void, 0x1DE37BBF9E9CC14A, .{player}); } // 0x1DE37BBF9E9CC14A 0xAF7AFCC4 b323
    /// 1 - Welcome to Los Santos \
    /// 2 - A Friendship Resurrected \
    /// 3 - A Fair Day's Pay \
    /// 4 - The Moment of Truth \
    /// 5 - To Live or Die in Los Santos \
    /// 6 - Diamond Hard \
    /// 7 - Subversive \
    /// 8 - Blitzed \
    /// 9 - Small Town, Big Job \
    /// 10 - The Government Gimps \
    /// 11 - The Big One! \
    /// 12 - Solid Gold, Baby! \
    /// 13 - Career Criminal \
    /// 14 - San Andreas Sightseer \
    /// 15 - All's Fare in Love and War \
    /// 16 - TP Industries Arms Race \
    /// 17 - Multi-Disciplined \
    /// 18 - From Beyond the Stars \
    /// 19 - A Mystery, Solved \
    /// 20 - Waste Management \
    /// 21 - Red Mist \
    /// 22 - Show Off \
    /// 23 - Kifflom! \
    /// 24 - Three Man Army \
    /// 25 - Out of Your Depth \
    /// 26 - Altruist Acolyte \
    /// 27 - A Lot of Cheddar \
    /// 28 - Trading Pure Alpha \
    /// 29 - Pimp My Sidearm \
    /// 30 - Wanted: Alive Or Alive \
    /// 31 - Los Santos Customs \
    /// 32 - Close Shave \
    /// 33 - Off the Plane \
    /// 34 - Three-Bit Gangster \
    /// 35 - Making Moves \
    /// 36 - Above the Law \
    /// 37 - Numero Uno \
    /// 38 - The Midnight Club \
    /// 39 - Unnatural Selection \
    /// 40 - Backseat Driver \
    /// 41 - Run Like The Wind \
    /// 42 - Clean Sweep \
    /// 43 - Decorated \
    /// 44 - Stick Up Kid \
    /// 45 - Enjoy Your Stay \
    /// 46 - Crew Cut \
    /// 47 - Full Refund \
    /// 48 - Dialling Digits \
    /// 49 - American Dream \
    /// 50 - A New Perspective \
    /// 51 - Be Prepared \
    /// 52 - In the Name of Science \
    /// 53 - Dead Presidents \
    /// 54 - Parole Day \
    /// 55 - Shot Caller \
    /// 56 - Four Way \
    /// 57 - Live a Little \
    /// 58 - Can't Touch This \
    /// 59 - Mastermind \
    /// 60 - Vinewood Visionary \
    /// 61 - Majestic \
    /// 62 - Humans of Los Santos \
    /// 63 - First Time Director \
    /// 64 - Animal Lover \
    /// 65 - Ensemble Piece \
    /// 66 - Cult Movie \
    /// 67 - Location Scout \
    /// 68 - Method Actor \
    /// 69 - Cryptozoologist \
    /// 70 - Getting Started \
    /// 71 - The Data Breaches \
    /// 72 - The Bogdan Problem \
    /// 73 - The Doomsday Scenario \
    /// 74 - A World Worth Saving \
    /// 75 - Orbital Obliteration \
    /// 76 - Elitist \
    /// 77 - Masterminds
    pub inline fn giveAchievementToPlayer(achievement_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBEC7076D64130195, .{achievement_id}); } // 0xBEC7076D64130195 0x822BC992 b323
    /// For Steam. \
    /// Does nothing and always returns false in the retail version of the game.
    pub inline fn setAchievementProgress(achievement_id: c_int, progress: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC2AFFFDABBDC2C5C, .{achievement_id, progress}); } // 0xC2AFFFDABBDC2C5C  b323
    /// For Steam. \
    /// Always returns 0 in retail version of the game.
    pub inline fn getAchievementProgress(achievement_id: c_int) !c_int { return try invoker.invoke(c_int, 0x1C186837D0619335, .{achievement_id}); } // 0x1C186837D0619335  b323
    /// See GIVE_ACHIEVEMENT_TO_PLAYER
    pub inline fn hasAchievementBeenPassed(achievement_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x867365E111A3B6EB, .{achievement_id}); } // 0x867365E111A3B6EB 0x136A5BE9 b323
    /// Returns TRUE if the game is in online mode and FALSE if in offline mode.
    /// 
    /// This is an alias for NETWORK_IS_SIGNED_ONLINE.
    pub inline fn isPlayerOnline() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF25D331DC2627BBC, .{}); } // 0xF25D331DC2627BBC 0x9FAB6729 b323
    /// this function is hard-coded to always return 0.
    pub inline fn isPlayerLoggingInNp() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74556E1420867ECA, .{}); } // 0x74556E1420867ECA 0x8F72FAD0 b323
    /// Purpose of the BOOL currently unknown. \
    /// Both, true and false, work
    pub inline fn displaySystemSigninUi(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x94DD7888C10A979E, .{p_0}); } // 0x94DD7888C10A979E 0x4264CED2 b323
    pub inline fn isSystemUiBeingDisplayed() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5D511E3867C87139, .{}); } // 0x5D511E3867C87139 0xE495B6DA b323
    /// Simply sets you as invincible (Health will not deplete).
    /// 
    /// Use 0x733A643B5B0C53C1 instead if you want Ragdoll enabled, which is equal to: \
    /// *(DWORD *)(playerPedAddress + 0x188) |= (1 << 9);
    pub inline fn setPlayerInvincible(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x239528EACDC3E7DE, .{player, toggle}); } // 0x239528EACDC3E7DE 0xDFB9A2A2 b323
    /// Returns the Player's Invincible status.
    /// 
    /// This function will always return false if 0x733A643B5B0C53C1 is used to set the invincibility status. To always get the correct result, use this:
    /// 
    ///  bool IsPlayerInvincible(Player player) \
    ///     {
    ///      auto addr = getScriptHandleBaseAddress(GET_PLAYER_PED(player)); 
    /// 
    ///         if (addr)
    ///      {
    ///          DWORD flag = *(DWORD *)(addr + 0x188);
    ///             return ((flag & (1 << 8)) != 0) || ((flag & (1 << 9)) != 0);
    ///       }
    /// 
    ///        return false;
    ///  }
    /// 
    /// 
    pub inline fn getPlayerInvincible(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB721981B2B939E07, .{player}); } // 0xB721981B2B939E07 0x680C90EE b323
    /// Always returns false.
    pub inline fn getPlayerDebugInvincible(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDCC07526B8EC45AF, .{player}); } // 0xDCC07526B8EC45AF  b1868
    pub inline fn setPlayerInvincibleButHasReactions(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6BC97F4F4BB3C04B, .{player, toggle}); } // 0x6BC97F4F4BB3C04B  b463
    pub inline fn setPlayerCanCollectDroppedMoney(player: types.Player, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xCAC57395B151135F, .{player, p_1}); } // 0xCAC57395B151135F 0x00563E0D b323
    pub inline fn removePlayerHelmet(player: types.Player, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xF3AC26D3CC576528, .{player, p_2}); } // 0xF3AC26D3CC576528 0x6255F3B4 b323
    pub inline fn givePlayerRagdollControl(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3C49C870E66F0A28, .{player, toggle}); } // 0x3C49C870E66F0A28 0xC7B4D7AC b323
    /// Example from fm_mission_controler.ysc.c4:
    /// 
    /// PLAYER::SET_PLAYER_LOCKON(PLAYER::PLAYER_ID(), 1);
    /// 
    /// All other decompiled scripts using this seem to be using the player id as the first parameter, so I feel the need to confirm it as so.
    /// 
    /// No need to confirm it says PLAYER_ID() so it uses PLAYER_ID() lol.
    pub inline fn setPlayerLockon(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5C8B2F450EE4328E, .{player, toggle}); } // 0x5C8B2F450EE4328E 0x0B270E0F b323
    /// Sets your targeting mode. \
    /// 0 = Assisted Aim - Full \
    /// 1 = Assisted Aim - Partial \
    /// 2 = Free Aim - Assisted \
    /// 3 = Free Aim
    pub inline fn setPlayerTargetingMode(target_mode: c_int) !void { try invoker.invoke(void, 0xB1906895227793F3, .{target_mode}); } // 0xB1906895227793F3 0x61CAE253 b323
    pub inline fn getPlayerTargetingMode() !c_int { return try invoker.invoke(c_int, 0x875BDD898B99C8CE, .{}); } // 0x875BDD898B99C8CE  b3570
    pub inline fn setPlayerTargetLevel(target_level: c_int) !void { try invoker.invoke(void, 0x5702B917B99DB1CD, .{target_level}); } // 0x5702B917B99DB1CD 0x772DA539 b323
    /// Returns profile setting 237.
    pub inline fn getIsUsingFpsThirdPersonCover() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB9CF1F793A9F1BF1, .{}); } // 0xB9CF1F793A9F1BF1  b323
    /// Returns profile setting 243.
    pub inline fn getIsUsingHoodCamera() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCB645E85E97EA48B, .{}); } // 0xCB645E85E97EA48B  b372
    pub inline fn clearPlayerHasDamagedAtLeastOnePed(player: types.Player) !void { try invoker.invoke(void, 0xF0B67A4DE6AB5F98, .{player}); } // 0xF0B67A4DE6AB5F98 0x1D31CBBD b323
    pub inline fn hasPlayerDamagedAtLeastOnePed(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x20CE80B0C2BF4ACC, .{player}); } // 0x20CE80B0C2BF4ACC 0x14F52453 b323
    pub inline fn clearPlayerHasDamagedAtLeastOneNonAnimalPed(player: types.Player) !void { try invoker.invoke(void, 0x4AACB96203D11A31, .{player}); } // 0x4AACB96203D11A31 0x7E3BFBC5 b323
    pub inline fn hasPlayerDamagedAtLeastOneNonAnimalPed(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE4B90F367BD81752, .{player}); } // 0xE4B90F367BD81752 0xA3707DFC b323
    /// This can be between 1.0f - 14.9f 
    /// 
    /// You can change the max in IDA from 15.0. I say 15.0 as the function blrs if what you input is greater than or equal to 15.0 hence why it's 14.9 max default.
    /// 
    /// 
    pub inline fn setAirDragMultiplierForPlayersVehicle(player: types.Player, multiplier: f32) !void { try invoker.invoke(void, 0xCA7DC8329F0A1E9E, .{player, multiplier}); } // 0xCA7DC8329F0A1E9E 0xF20F72E5 b323
    /// Swim speed multiplier. \
    /// Multiplier goes up to 1.49
    /// 
    /// Just call it one time, it is not required to be called once every tick. - Note copied from below native.
    /// 
    /// Note: At least the IDA method if you change the max float multiplier from 1.5 it will change it for both this and RUN_SPRINT below. I say 1.5 as the function blrs if what you input is greater than or equal to 1.5 hence why it's 1.49 max default.
    pub inline fn setSwimMultiplierForPlayer(player: types.Player, multiplier: f32) !void { try invoker.invoke(void, 0xA91C6F0FF7D16A13, .{player, multiplier}); } // 0xA91C6F0FF7D16A13 0xB986FF47 b323
    /// Multiplier goes up to 1.49 any value above will be completely overruled by the game and the multiplier will not take effect, this can be edited in memory however.
    /// 
    /// Just call it one time, it is not required to be called once every tick.
    /// 
    /// Note: At least the IDA method if you change the max float multiplier from 1.5 it will change it for both this and SWIM above. I say 1.5 as the function blrs if what you input is greater than or equal to 1.5 hence why it's 1.49 max default.
    pub inline fn setRunSprintMultiplierForPlayer(player: types.Player, multiplier: f32) !void { try invoker.invoke(void, 0x6DB47AA77FD94E09, .{player, multiplier}); } // 0x6DB47AA77FD94E09 0x825423C2 b323
    /// Returns the time since the character was arrested in (ms) milliseconds.
    /// 
    /// example
    /// 
    /// var time = Function.call<int>(Hash.GET_TIME_SINCE_LAST_ARREST();
    /// 
    /// UI.DrawSubtitle(time.ToString());
    /// 
    /// if player has not been arrested, the int returned will be -1.
    pub inline fn getTimeSinceLastArrest() !c_int { return try invoker.invoke(c_int, 0x5063F92F07C2A316, .{}); } // 0x5063F92F07C2A316 0x62824EF4 b323
    /// Returns the time since the character died in (ms) milliseconds.
    /// 
    /// example
    /// 
    /// var time = Function.call<int>(Hash.GET_TIME_SINCE_LAST_DEATH();
    /// 
    /// UI.DrawSubtitle(time.ToString());
    /// 
    /// if player has not died, the int returned will be -1.
    pub inline fn getTimeSinceLastDeath() !c_int { return try invoker.invoke(c_int, 0xC7034807558DDFCA, .{}); } // 0xC7034807558DDFCA 0x24BC5AC0 b323
    pub inline fn assistedMovementCloseRoute() !void { try invoker.invoke(void, 0xAEBF081FFC0A0E5E, .{}); } // 0xAEBF081FFC0A0E5E 0xF23277F3 b323
    pub inline fn assistedMovementFlushRoute() !void { try invoker.invoke(void, 0x8621390F0CDCFE1F, .{}); } // 0x8621390F0CDCFE1F 0xD04568B9 b323
    pub inline fn setPlayerForcedAim(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0FEE4F80AC44A726, .{player, toggle}); } // 0x0FEE4F80AC44A726 0x94E42E2E b323
    pub inline fn setPlayerForcedZoom(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x75E7D505F2B15902, .{player, toggle}); } // 0x75E7D505F2B15902 0xB0C576CB b323
    pub inline fn setPlayerForceSkipAimIntro(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x7651BC64AE59E128, .{player, toggle}); } // 0x7651BC64AE59E128 0x374F42F0 b323
    /// Inhibits the player from using any method of combat including melee and firearms.
    /// 
    /// NOTE: Only disables the firing for one frame
    pub inline fn disablePlayerFiring(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5E6CC07646BBEAB8, .{player, toggle}); } // 0x5E6CC07646BBEAB8 0x30CB28CB b323
    /// Used only once in R* scripts (freemode.ysc).
    pub inline fn disablePlayerThrowGrenadeWhileUsingGun() !void { try invoker.invoke(void, 0xB885852C39CC265D, .{}); } // 0xB885852C39CC265D  b323
    pub inline fn setDisableAmbientMeleeMove(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2E8AABFA40A84F8C, .{player, toggle}); } // 0x2E8AABFA40A84F8C 0xCCD937E7 b323
    /// Default is 100. Use player id and not ped id. For instance: PLAYER::SET_PLAYER_MAX_ARMOUR(PLAYER::PLAYER_ID(), 100); // main_persistent.ct4
    pub inline fn setPlayerMaxArmour(player: types.Player, value: c_int) !void { try invoker.invoke(void, 0x77DFCCF5948B8C71, .{player, value}); } // 0x77DFCCF5948B8C71 0xC6C3C53B b323
    /// p1 is always 0 in the scripts
    pub inline fn specialAbilityActivate(player: types.Player, p_1: c_int) !void { try invoker.invoke(void, 0x821FDC827D6F4090, .{player, p_1}); } // 0x821FDC827D6F4090  b678
    pub inline fn setSpecialAbilityMp(player: types.Player, p_1: c_int, p_2: types.Any) !void { try invoker.invoke(void, 0xB214D570EAD7F81A, .{player, p_1, p_2}); } // 0xB214D570EAD7F81A  b678
    /// p1 is always 0 in the scripts
    pub inline fn specialAbilityDeactivateMp(player: types.Player, p_1: c_int) !void { try invoker.invoke(void, 0x17F7471EACA78290, .{player, p_1}); } // 0x17F7471EACA78290  b678
    pub inline fn specialAbilityDeactivate(player: types.Player, p_1: types.Any) !void { try invoker.invoke(void, 0xD6A953C6D1492057, .{player, p_1}); } // 0xD6A953C6D1492057 0x80C2AB09 b323
    pub inline fn specialAbilityDeactivateFast(player: types.Player, p_1: types.Any) !void { try invoker.invoke(void, 0x9CB5CE07A3968D5A, .{player, p_1}); } // 0x9CB5CE07A3968D5A 0x0751908A b323
    pub inline fn specialAbilityReset(player: types.Player, p_1: types.Any) !void { try invoker.invoke(void, 0x375F0E738F861A94, .{player, p_1}); } // 0x375F0E738F861A94 0xA7D8BCD3 b323
    pub inline fn specialAbilityChargeOnMissionFailed(player: types.Player, p_1: types.Any) !void { try invoker.invoke(void, 0xC9A763D8FE87436A, .{player, p_1}); } // 0xC9A763D8FE87436A 0x4136829A b323
    /// Every occurrence of p1 & p2 were both true.
    pub inline fn specialAbilityChargeSmall(player: types.Player, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0x2E7B9B683481687D, .{player, p_1, p_2, p_3}); } // 0x2E7B9B683481687D 0x6F463F56 b323
    /// Only 1 match. Both p1 & p2 were true.
    pub inline fn specialAbilityChargeMedium(player: types.Player, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xF113E3AA9BC54613, .{player, p_1, p_2, p_3}); } // 0xF113E3AA9BC54613 0xAB55D8F3 b323
    /// 2 matches. p1 was always true.
    pub inline fn specialAbilityChargeLarge(player: types.Player, p_1: windows.BOOL, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xF733F45FA4497D93, .{player, p_1, p_2, p_3}); } // 0xF733F45FA4497D93 0xF440C04D b323
    /// p1 appears to always be 1 (only comes up twice)
    pub inline fn specialAbilityChargeContinuous(player: types.Player, p_1: types.Ped, p_2: types.Any) !void { try invoker.invoke(void, 0xED481732DFF7E997, .{player, p_1, p_2}); } // 0xED481732DFF7E997 0x5FEE98A2 b323
    /// p1 appears as 5, 10, 15, 25, or 30. p2 is always true.
    pub inline fn specialAbilityChargeAbsolute(player: types.Player, p_1: c_int, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xB7B0870EB531D08D, .{player, p_1, p_2, p_3}); } // 0xB7B0870EB531D08D 0x72429998 b323
    /// 
    /// normalizedValue is from 0.0 - 1.0 \
    /// p2 is always 1
    pub inline fn specialAbilityChargeNormalized(player: types.Player, normalized_value: f32, p_2: windows.BOOL, p_3: types.Any) !void { try invoker.invoke(void, 0xA0696A65F009EE18, .{player, normalized_value, p_2, p_3}); } // 0xA0696A65F009EE18 0x8C7E68C1 b323
    /// Also known as _RECHARGE_SPECIAL_ABILITY
    pub inline fn specialAbilityFillMeter(player: types.Player, p_1: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0x3DACA8DDC6FD4980, .{player, p_1, p_2}); } // 0x3DACA8DDC6FD4980 0xB71589DA b323
    /// p1 was always true.
    pub inline fn specialAbilityDepleteMeter(player: types.Player, p_1: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0x1D506DBBBC51E64B, .{player, p_1, p_2}); } // 0x1D506DBBBC51E64B 0x9F80F6DF b323
    pub inline fn specialAbilityLock(player_model: types.Hash, p_1: types.Any) !void { try invoker.invoke(void, 0x6A09D0D590A47D13, .{player_model, p_1}); } // 0x6A09D0D590A47D13 0x1B7BB388 b323
    pub inline fn specialAbilityUnlock(player_model: types.Hash, p_1: types.Any) !void { try invoker.invoke(void, 0xF145F3BE2EFA9A3B, .{player_model, p_1}); } // 0xF145F3BE2EFA9A3B 0x1FDB2919 b323
    pub inline fn isSpecialAbilityUnlocked(player_model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC6017F6A6CDFA694, .{player_model}); } // 0xC6017F6A6CDFA694 0xC9C75E82 b323
    pub inline fn isSpecialAbilityActive(player: types.Player, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3E5F7FC85D854E15, .{player, p_1}); } // 0x3E5F7FC85D854E15 0x1B17E334 b323
    pub inline fn isSpecialAbilityMeterFull(player: types.Player, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x05A1FE504B7F2587, .{player, p_1}); } // 0x05A1FE504B7F2587 0x2E19D7F6 b323
    pub inline fn enableSpecialAbility(player: types.Player, toggle: windows.BOOL, p_2: types.Any) !void { try invoker.invoke(void, 0x181EC197DAEFE121, .{player, toggle, p_2}); } // 0x181EC197DAEFE121 0xC86C1B4E b323
    pub inline fn isSpecialAbilityEnabled(player: types.Player, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB1D200FE26AEF3CB, .{player, p_1}); } // 0xB1D200FE26AEF3CB 0xC01238CC b323
    pub inline fn setSpecialAbilityMultiplier(multiplier: f32) !void { try invoker.invoke(void, 0xA49C426ED0CA4AB7, .{multiplier}); } // 0xA49C426ED0CA4AB7 0xFF1BC556 b323
    pub inline fn updateSpecialAbilityFromStat(player: types.Player, p_1: types.Any) !void { try invoker.invoke(void, 0xFFEE8FA29AB9A18E, .{player, p_1}); } // 0xFFEE8FA29AB9A18E 0x5D0FE25B b323
    /// Appears once in "re_dealgonewrong"
    pub inline fn getIsPlayerDrivingOnHighway(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5FC472C501CCADB3, .{player}); } // 0x5FC472C501CCADB3 0x46E7E31D b323
    /// Only 1 occurrence. p1 was 2.
    pub inline fn getIsPlayerDrivingWreckless(player: types.Player, p_1: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF10B44FD479D69F3, .{player, p_1}); } // 0xF10B44FD479D69F3 0x1E359CC8 b323
    /// 2 occurrences in agency_heist3a. p1 was 0.7f then 0.4f.
    pub inline fn getIsMoppingAreaFreeInFrontOfPlayer(player: types.Player, p_1: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDD2620B7B9D16FF1, .{player, p_1}); } // 0xDD2620B7B9D16FF1 0x8CB53C9F b323
    /// `findCollisionLand`: This teleports the player to land when set to true and will not consider the Z coordinate parameter provided by you. It will automatically put the Z coordinate so that you don't fall from sky.
    pub inline fn startPlayerTeleport(player: types.Player, vec: types.Vector3, heading: f32, p_5: windows.BOOL, find_collision_land: windows.BOOL, p_7: windows.BOOL) !void { try invoker.invoke(void, 0xAD15F075A4DA0FDE, .{player, vec.x, vec.y, vec.z, heading, p_5, find_collision_land, p_7}); } // 0xAD15F075A4DA0FDE 0xC552E06C b323
    pub inline fn updatePlayerTeleport(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE23D5873C2394C61, .{player}); } // 0xE23D5873C2394C61  b323
    /// Disables the player's teleportation
    pub inline fn stopPlayerTeleport() !void { try invoker.invoke(void, 0xC449EDED9D73009C, .{}); } // 0xC449EDED9D73009C 0x86AB8DBB b323
    pub inline fn isPlayerTeleportActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x02B15662D7F8886F, .{}); } // 0x02B15662D7F8886F 0x3A11D118 b323
    pub inline fn getPlayerCurrentStealthNoise(player: types.Player) !f32 { return try invoker.invoke(f32, 0x2F395D61F3A1F877, .{player}); } // 0x2F395D61F3A1F877 0xC3B02362 b323
    /// `regenRate`: The recharge multiplier, a value between 0.0 and 1.0. \
    /// Use 1.0 to reset it back to normal
    pub inline fn setPlayerHealthRechargeMultiplier(player: types.Player, regen_rate: f32) !void { try invoker.invoke(void, 0x5DB660B38DD98A31, .{player, regen_rate}); } // 0x5DB660B38DD98A31 0x45514731 b323
    pub inline fn getPlayerHealthRechargeMaxPercent(player: types.Player) !f32 { return try invoker.invoke(f32, 0x8BC515BAE4AAF8FF, .{player}); } // 0x8BC515BAE4AAF8FF  b617
    pub inline fn setPlayerHealthRechargeMaxPercent(player: types.Player, limit: f32) !void { try invoker.invoke(void, 0xC388A0F065F5BC34, .{player, limit}); } // 0xC388A0F065F5BC34  b573
    /// Needs to be called every frame.
    pub inline fn disablePlayerHealthRecharge(player: types.Player) !void { try invoker.invoke(void, 0xBCB06442F7E52666, .{player}); } // 0xBCB06442F7E52666  b2802
    pub inline fn setPlayerFallDistanceToTriggerRagdollOverride(player: types.Player, p_1: f32) !void { try invoker.invoke(void, 0xEFD79FA81DFBA9CB, .{player, p_1}); } // 0xEFD79FA81DFBA9CB  b573
    /// This modifies the damage value of your weapon. Whether it is a multiplier or base damage is unknown. 
    /// 
    /// Based on tests, it is unlikely to be a multiplier.
    /// 
    /// modifier's min value is 0.1
    pub inline fn setPlayerWeaponDamageModifier(player: types.Player, modifier: f32) !void { try invoker.invoke(void, 0xCE07B9F7817AADA3, .{player, modifier}); } // 0xCE07B9F7817AADA3 0xB02C2F39 b323
    /// modifier's min value is 0.1
    pub inline fn setPlayerWeaponDefenseModifier(player: types.Player, modifier: f32) !void { try invoker.invoke(void, 0x2D83BC011CA14A3C, .{player, modifier}); } // 0x2D83BC011CA14A3C 0xAE446344 b323
    /// modifier's min value is 0.1
    pub inline fn setPlayerWeaponMinigunDefenseModifier(player: types.Player, modifier: f32) !void { try invoker.invoke(void, 0xBCFDE9EDE4CF27DC, .{player, modifier}); } // 0xBCFDE9EDE4CF27DC  b944
    /// modifier's min value is 0.1
    pub inline fn setPlayerMeleeWeaponDamageModifier(player: types.Player, modifier: f32, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x4A3DC7ECCC321032, .{player, modifier, p_2}); } // 0x4A3DC7ECCC321032 0x362E69AD b323
    /// modifier's min value is 0.1
    pub inline fn setPlayerMeleeWeaponDefenseModifier(player: types.Player, modifier: f32) !void { try invoker.invoke(void, 0xAE540335B4ABC4E2, .{player, modifier}); } // 0xAE540335B4ABC4E2 0x9F3D577F b323
    /// modifier's min value is 0.1
    pub inline fn setPlayerVehicleDamageModifier(player: types.Player, modifier: f32) !void { try invoker.invoke(void, 0xA50E117CDDF82F0C, .{player, modifier}); } // 0xA50E117CDDF82F0C 0x823ECA63 b323
    /// modifier's min value is 0.1
    pub inline fn setPlayerVehicleDefenseModifier(player: types.Player, modifier: f32) !void { try invoker.invoke(void, 0x4C60E6EFDAFF2462, .{player, modifier}); } // 0x4C60E6EFDAFF2462 0xA16626C7 b323
    pub inline fn setPlayerMaxExplosiveDamage(player: types.Player, p_1: f32) !void { try invoker.invoke(void, 0x8D768602ADEF2245, .{player, p_1}); } // 0x8D768602ADEF2245  b463
    pub inline fn setPlayerExplosiveDamageModifier(player: types.Player, p_1: types.Any) !void { try invoker.invoke(void, 0xD821056B9ACF8052, .{player, p_1}); } // 0xD821056B9ACF8052  b1011
    pub inline fn setPlayerWeaponTakedownDefenseModifier(player: types.Player, p_1: f32) !void { try invoker.invoke(void, 0x31E90B8873A4CD3B, .{player, p_1}); } // 0x31E90B8873A4CD3B  b617
    /// Tints: \
    ///    None = -1,
    ///     Rainbow = 0,
    ///   Red = 1,
    ///   SeasideStripes = 2,
    ///    WidowMaker = 3,
    ///    Patriot = 4,
    ///   Blue = 5,
    ///  Black = 6, \
    ///     Hornet = 7,
    ///    AirFocce = 8,
    ///  Desert = 9, \
    ///    Shadow = 10,
    ///   HighAltitude = 11,
    ///     Airbone = 12,
    ///  Sunrise = 13,
    /// 
    pub inline fn setPlayerParachuteTintIndex(player: types.Player, tint_index: c_int) !void { try invoker.invoke(void, 0xA3D0E54541D9A5E5, .{player, tint_index}); } // 0xA3D0E54541D9A5E5 0x8EA12EDB b323
    /// Tints: \
    ///   None = -1,
    ///     Rainbow = 0,
    ///   Red = 1,
    ///   SeasideStripes = 2,
    ///    WidowMaker = 3,
    ///    Patriot = 4,
    ///   Blue = 5,
    ///  Black = 6, \
    ///     Hornet = 7,
    ///    AirFocce = 8,
    ///  Desert = 9, \
    ///    Shadow = 10,
    ///   HighAltitude = 11,
    ///     Airbone = 12,
    ///  Sunrise = 13,
    pub inline fn getPlayerParachuteTintIndex(player: types.Player, tint_index: [*c]c_int) !void { try invoker.invoke(void, 0x75D3F7A1B0D9B145, .{player, tint_index}); } // 0x75D3F7A1B0D9B145 0x432B0509 b323
    /// Tints: \
    ///    None = -1,
    ///     Rainbow = 0,
    ///   Red = 1,
    ///   SeasideStripes = 2,
    ///    WidowMaker = 3,
    ///    Patriot = 4,
    ///   Blue = 5,
    ///  Black = 6, \
    ///     Hornet = 7,
    ///    AirFocce = 8,
    ///  Desert = 9, \
    ///    Shadow = 10,
    ///   HighAltitude = 11,
    ///     Airbone = 12,
    ///  Sunrise = 13,
    pub inline fn setPlayerReserveParachuteTintIndex(player: types.Player, index: c_int) !void { try invoker.invoke(void, 0xAF04C87F5DC1DF38, .{player, index}); } // 0xAF04C87F5DC1DF38 0x70689638 b323
    /// Tints: \
    ///   None = -1,
    ///     Rainbow = 0,
    ///   Red = 1,
    ///   SeasideStripes = 2,
    ///    WidowMaker = 3,
    ///    Patriot = 4,
    ///   Blue = 5,
    ///  Black = 6, \
    ///     Hornet = 7,
    ///    AirFocce = 8,
    ///  Desert = 9, \
    ///    Shadow = 10,
    ///   HighAltitude = 11,
    ///     Airbone = 12,
    ///  Sunrise = 13,
    pub inline fn getPlayerReserveParachuteTintIndex(player: types.Player, index: [*c]c_int) !void { try invoker.invoke(void, 0xD5A016BC3C09CF40, .{player, index}); } // 0xD5A016BC3C09CF40 0x77B8EF01 b323
    /// tints 0- 13 \
    /// 0 - unkown \
    /// 1 - unkown \
    /// 2 - unkown \
    /// 3 - unkown \
    /// 4 - unkown
    pub inline fn setPlayerParachutePackTintIndex(player: types.Player, tint_index: c_int) !void { try invoker.invoke(void, 0x93B0FB27C9A04060, .{player, tint_index}); } // 0x93B0FB27C9A04060 0xD79D5D1B b323
    pub inline fn getPlayerParachutePackTintIndex(player: types.Player, tint_index: [*c]c_int) !void { try invoker.invoke(void, 0x6E9C742F340CE5A2, .{player, tint_index}); } // 0x6E9C742F340CE5A2 0x4E418E13 b323
    pub inline fn setPlayerHasReserveParachute(player: types.Player) !void { try invoker.invoke(void, 0x7DDAB28D31FAC363, .{player}); } // 0x7DDAB28D31FAC363 0xA3E4798E b323
    pub inline fn getPlayerHasReserveParachute(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5DDFE2FF727F3CA3, .{player}); } // 0x5DDFE2FF727F3CA3 0x30DA1DA1 b323
    pub inline fn setPlayerCanLeaveParachuteSmokeTrail(player: types.Player, enabled: windows.BOOL) !void { try invoker.invoke(void, 0xF401B182DBA8AF53, .{player, enabled}); } // 0xF401B182DBA8AF53 0x832DEB7A b323
    pub inline fn setPlayerParachuteSmokeTrailColor(player: types.Player, r: c_int, g: c_int, b: c_int) !void { try invoker.invoke(void, 0x8217FD371A4625CF, .{player, r, g, b}); } // 0x8217FD371A4625CF 0x14FE9264 b323
    pub inline fn getPlayerParachuteSmokeTrailColor(player: types.Player, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !void { try invoker.invoke(void, 0xEF56DBABD3CD4887, .{player, r, g, b}); } // 0xEF56DBABD3CD4887 0xF66E5CDD b323
    pub inline fn setPlayerPhonePaletteIdx(player: types.Player, idx: c_int) !void { try invoker.invoke(void, 0x11D5F725F0E780E0, .{player, idx}); } // 0x11D5F725F0E780E0  b323
    pub inline fn setPlayerNoiseMultiplier(player: types.Player, multiplier: f32) !void { try invoker.invoke(void, 0xDB89EF50FF25FCE9, .{player, multiplier}); } // 0xDB89EF50FF25FCE9 0x15786DD1 b323
    /// Values around 1.0f to 2.0f used in game scripts.
    pub inline fn setPlayerSneakingNoiseMultiplier(player: types.Player, multiplier: f32) !void { try invoker.invoke(void, 0xB2C1A29588A9F47C, .{player, multiplier}); } // 0xB2C1A29588A9F47C 0x8D2D89C4 b323
    pub inline fn canPedHearPlayer(player: types.Player, ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF297383AA91DCA29, .{player, ped}); } // 0xF297383AA91DCA29 0x1C70B2EB b323
    /// This is to make the player walk without accepting input from INPUT.
    /// 
    /// gaitType is in increments of 100s. 2000, 500, 300, 200, etc.
    /// 
    /// p4 is always 1 and p5 is always 0.
    /// 
    /// C# Example :
    /// 
    /// Function.Call(Hash.SIMULATE_PLAYER_INPUT_GAIT, Game.Player, 1.0f, 100, 1.0f, 1, 0); //Player will go forward for 100ms
    pub inline fn simulatePlayerInputGait(player: types.Player, amount: f32, gait_type: c_int, speed: f32, p_4: windows.BOOL, p_5: windows.BOOL, p_6: types.Any) !void { try invoker.invoke(void, 0x477D5D63E63ECA5D, .{player, amount, gait_type, speed, p_4, p_5, p_6}); } // 0x477D5D63E63ECA5D 0x0D77CC34 b323
    pub inline fn resetPlayerInputGait(player: types.Player) !void { try invoker.invoke(void, 0x19531C47A2ABD691, .{player}); } // 0x19531C47A2ABD691 0x4A701EE1 b323
    pub inline fn setAutoGiveParachuteWhenEnterPlane(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9F343285A00B4BB6, .{player, toggle}); } // 0x9F343285A00B4BB6 0xA97C2059 b323
    pub inline fn setAutoGiveScubaGearWhenExitVehicle(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD2B315B6689D537D, .{player, toggle}); } // 0xD2B315B6689D537D 0xA25D767E b323
    pub inline fn setPlayerStealthPerceptionModifier(player: types.Player, value: f32) !void { try invoker.invoke(void, 0x4E9021C1FCDD507A, .{player, value}); } // 0x4E9021C1FCDD507A 0x3D26105F b323
    pub inline fn isRemotePlayerInNonClonedVehicle(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x690A61A6D13583F6, .{player}); } // 0x690A61A6D13583F6 0x1D371529 b323
    pub inline fn increasePlayerJumpSuppressionRange(player: types.Player) !void { try invoker.invoke(void, 0x9EDD76E87D5D51BA, .{player}); } // 0x9EDD76E87D5D51BA 0xE30A64DC b323
    pub inline fn setPlayerSimulateAiming(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC54C95DA968EC5B5, .{player, toggle}); } // 0xC54C95DA968EC5B5 0xF1E0CAFC b323
    pub inline fn setPlayerClothPinFrames(player: types.Player, p_1: c_int) !void { try invoker.invoke(void, 0x749FADDF97DFE930, .{player, p_1}); } // 0x749FADDF97DFE930 0xF7A0F00F b323
    /// Every occurrence was either 0 or 2.
    pub inline fn setPlayerClothPackageIndex(index: c_int) !void { try invoker.invoke(void, 0x9F7BBA2EA6372500, .{index}); } // 0x9F7BBA2EA6372500 0xB8209F16 b323
    /// 6 matches across 4 scripts. 5 occurrences were 240. The other was 255.
    pub inline fn setPlayerClothLockCounter(value: c_int) !void { try invoker.invoke(void, 0x14D913B777DFF5DA, .{value}); } // 0x14D913B777DFF5DA 0x8D9FD4D1 b323
    /// Only 1 match. ob_sofa_michael.
    /// 
    /// PLAYER::PLAYER_ATTACH_VIRTUAL_BOUND(-804.5928f, 173.1801f, 71.68436f, 0f, 0f, 0.590625f, 1f, 0.7f);1.0.335.2, 1.0.350.1/2, 1.0.372.2, 1.0.393.2, 1.0.393.4, 1.0.463.1;
    pub inline fn playerAttachVirtualBound(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32) !void { try invoker.invoke(void, 0xED51733DC73AED51, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0xED51733DC73AED51 0xECD12E60 b323
    /// 1.0.335.2, 1.0.350.1/2, 1.0.372.2, 1.0.393.2, 1.0.393.4, 1.0.463.1;
    pub inline fn playerDetachVirtualBound() !void { try invoker.invoke(void, 0x1DD5897E2FA6E7C9, .{}); } // 0x1DD5897E2FA6E7C9 0x96100EA4 b323
    pub inline fn hasPlayerBeenSpottedInStolenVehicle(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD705740BB0A1CF4C, .{player}); } // 0xD705740BB0A1CF4C 0x4A01B76A b323
    /// Returns true if an unk value is greater than 0.0f
    pub inline fn isPlayerBattleAware(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x38D28DA81E4E9BF9, .{player}); } // 0x38D28DA81E4E9BF9 0x013B4F72 b323
    pub inline fn getPlayerReceivedBattleEventRecently(player: types.Player, p_1: c_int, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC0753C9CA14B506, .{player, p_1, p_2}); } // 0xBC0753C9CA14B506 0x9DF75B2A b323
    /// Appears only 3 times in the scripts, more specifically in michael1.ysc
    /// 
    /// - \
    /// This can be used to prevent dying if you are "out of the world"
    pub inline fn extendWorldBoundaryForPlayer(vec: types.Vector3) !void { try invoker.invoke(void, 0x5006D96C995A5827, .{vec.x, vec.y, vec.z}); } // 0x5006D96C995A5827 0x64DDB07D b323
    pub inline fn resetWorldBoundaryForPlayer() !void { try invoker.invoke(void, 0xDA1DF03D5A315F4E, .{}); } // 0xDA1DF03D5A315F4E 0xA97C2F6C b323
    /// Returns true if the player is riding a train.
    pub inline fn isPlayerRidingTrain(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4EC12697209F2196, .{player}); } // 0x4EC12697209F2196 0x9765E71D b323
    pub inline fn hasPlayerLeftTheWorld(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD55DDFB47991A294, .{player}); } // 0xD55DDFB47991A294 0xFEA40B6C b323
    pub inline fn setPlayerLeavePedBehind(player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFF300C7649724A0B, .{player, toggle}); } // 0xFF300C7649724A0B 0xAD8383FA b323
    /// p1 was always 5. \
    /// p4 was always false.
    pub inline fn setPlayerParachuteVariationOverride(player: types.Player, p_1: c_int, p_2: types.Any, p_3: types.Any, p_4: windows.BOOL) !void { try invoker.invoke(void, 0xD9284A8C0D48352C, .{player, p_1, p_2, p_3, p_4}); } // 0xD9284A8C0D48352C 0x9254249D b323
    pub inline fn clearPlayerParachuteVariationOverride(player: types.Player) !void { try invoker.invoke(void, 0x0F4CC924CF8C7B21, .{player}); } // 0x0F4CC924CF8C7B21 0xFD60F5AB b323
    pub inline fn setPlayerParachuteModelOverride(player: types.Player, model: types.Hash) !void { try invoker.invoke(void, 0x977DB4641F6FC3DB, .{player, model}); } // 0x977DB4641F6FC3DB 0x5D382498 b323
    pub inline fn setPlayerReserveParachuteModelOverride(player: types.Player, model: types.Hash) !void { try invoker.invoke(void, 0x0764486AEDE748DB, .{player, model}); } // 0x0764486AEDE748DB  b2372
    pub inline fn getPlayerParachuteModelOverride(player: types.Player) !types.Hash { return try invoker.invoke(types.Hash, 0xC219887CA3E65C41, .{player}); } // 0xC219887CA3E65C41  b2372
    pub inline fn getPlayerReserveParachuteModelOverride(player: types.Player) !types.Hash { return try invoker.invoke(types.Hash, 0x37FAAA68DCA9D08D, .{player}); } // 0x37FAAA68DCA9D08D  b2372
    pub inline fn clearPlayerParachuteModelOverride(player: types.Player) !void { try invoker.invoke(void, 0x8753997EB5F6EE3F, .{player}); } // 0x8753997EB5F6EE3F 0x6FF034BB b323
    pub inline fn clearPlayerReserveParachuteModelOverride(player: types.Player) !void { try invoker.invoke(void, 0x290D248E25815AE8, .{player}); } // 0x290D248E25815AE8  b2372
    pub inline fn setPlayerParachutePackModelOverride(player: types.Player, model: types.Hash) !void { try invoker.invoke(void, 0xDC80A4C2F18A2B64, .{player, model}); } // 0xDC80A4C2F18A2B64 0xA877FF5E b323
    pub inline fn clearPlayerParachutePackModelOverride(player: types.Player) !void { try invoker.invoke(void, 0x10C54E4389C12B42, .{player}); } // 0x10C54E4389C12B42 0xBB62AAC5 b323
    pub inline fn disablePlayerVehicleRewards(player: types.Player) !void { try invoker.invoke(void, 0xC142BE3BB9CE125F, .{player}); } // 0xC142BE3BB9CE125F 0x8C6E611D b323
    pub inline fn setPlayerSpectatedVehicleRadioOverride(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x2F7CEB6520288061, .{p_0}); } // 0x2F7CEB6520288061 0x2849D4B2 b323
    pub inline fn setPlayerBluetoothState(player: types.Player, state: windows.BOOL) !void { try invoker.invoke(void, 0x5DC40A8869C22141, .{player, state}); } // 0x5DC40A8869C22141 0x7A6B0EF8 b323
    pub inline fn isPlayerBluetoothEnable(player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x65FAEE425DE637B0, .{player}); } // 0x65FAEE425DE637B0 0xEA01BD4A b323
    pub inline fn disableCameraViewModeCycle(player: types.Player) !void { try invoker.invoke(void, 0x5501B7A5CDB79D37, .{player}); } // 0x5501B7A5CDB79D37  b323
    pub inline fn getPlayerFakeWantedLevel(player: types.Player) !c_int { return try invoker.invoke(c_int, 0x56105E599CAB0EFA, .{player}); } // 0x56105E599CAB0EFA 0x0098D244 b323
    pub inline fn setPlayerCanDamagePlayer(player_1: types.Player, player_2: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x55FCC0C390620314, .{player_1, player_2, toggle}); } // 0x55FCC0C390620314  b573
    pub inline fn setApplyWaypointOfPlayer(player: types.Player, hud_color: c_int) !void { try invoker.invoke(void, 0x2382AB11450AE7BA, .{player, hud_color}); } // 0x2382AB11450AE7BA  b877
    pub inline fn isPlayerVehicleWeaponToggledToNonHoming(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6E4361FF3E8CD7CA, .{p_0}); } // 0x6E4361FF3E8CD7CA  b1011
    /// Unsets playerPed+330 if the current weapon has certain flags.
    pub inline fn setPlayerVehicleWeaponToNonHoming(p_0: types.Any) !void { try invoker.invoke(void, 0x237440E46D918649, .{p_0}); } // 0x237440E46D918649  b1290
    pub inline fn setPlayerHomingDisabledForAllVehicleWeapons(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xEE4EBDD2593BA844, .{p_0, p_1}); } // 0xEE4EBDD2593BA844  b1180
    pub inline fn addPlayerTargetableEntity(player: types.Player, entity: types.Entity) !void { try invoker.invoke(void, 0x9097EB6D4BB9A12A, .{player, entity}); } // 0x9097EB6D4BB9A12A  b1868
    pub inline fn removePlayerTargetableEntity(player: types.Player, entity: types.Entity) !void { try invoker.invoke(void, 0x9F260BFB59ADBCA3, .{player, entity}); } // 0x9F260BFB59ADBCA3  b1868
    pub inline fn setPlayerPreviousVariationData(player: types.Player, p_1: c_int, p_2: c_int, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0x7BAE68775557AE0B, .{player, p_1, p_2, p_3, p_4, p_5}); } // 0x7BAE68775557AE0B  b1290
    /// Resets values set by SET_SCRIPT_FIRE_POSITION
    pub inline fn removeScriptFirePosition() !void { try invoker.invoke(void, 0x7148E0F43D11F0D9, .{}); } // 0x7148E0F43D11F0D9  b1604
    pub inline fn setScriptFirePosition(coord__: types.Vector3) !void { try invoker.invoke(void, 0x70A382ADEC069DD3, .{coord__.x, coord__.y, coord__.z}); } // 0x70A382ADEC069DD3  b1604
};

pub const Recording = struct
{
    pub inline fn replayStartEvent(p_0: c_int) !void { try invoker.invoke(void, 0x48621C9FCA3EBD28, .{p_0}); } // 0x48621C9FCA3EBD28  b323
    pub inline fn replayStopEvent() !void { try invoker.invoke(void, 0x81CBAE94390F9F89, .{}); } // 0x81CBAE94390F9F89  b323
    pub inline fn replayCancelEvent() !void { try invoker.invoke(void, 0x13B350B8AD0EEE10, .{}); } // 0x13B350B8AD0EEE10  b323
    pub inline fn replayRecordBackForTime(p_0: f32, p_1: f32, p_2: c_int) !void { try invoker.invoke(void, 0x293220DA1B46CEBC, .{p_0, p_1, p_2}); } // 0x293220DA1B46CEBC  b323
    /// -This function appears to be deprecated/ unused. Tracing the call internally leads to a _nullsub -
    /// 
    /// first one seems to be a string of a mission name, second one seems to be a bool/toggle
    /// 
    /// p1 was always 0.
    /// 
    pub inline fn replayCheckForEventThisFrame(mission_name_label: [*c]const u8, p_1: types.Any) !void { try invoker.invoke(void, 0x208784099002BC30, .{mission_name_label, p_1}); } // 0x208784099002BC30  b323
    /// This disable the recording feature and has to be called every frame.
    pub inline fn replayPreventRecordingThisFrame() !void { try invoker.invoke(void, 0xEB2D525B57F42B40, .{}); } // 0xEB2D525B57F42B40  b323
    pub inline fn replayResetEventInfo() !void { try invoker.invoke(void, 0xF854439EFBB3B583, .{}); } // 0xF854439EFBB3B583  b323
    /// This will disable the ability to make camera changes in R* Editor.
    pub inline fn replayDisableCameraMovementThisFrame() !void { try invoker.invoke(void, 0xAF66DCEE6609B148, .{}); } // 0xAF66DCEE6609B148  b323
    /// Does nothing (it's a nullsub).
    pub inline fn recordGreatestMoment(p_0: c_int, p_1: c_int, p_2: c_int) !void { try invoker.invoke(void, 0x66972397E0757E7A, .{p_0, p_1, p_2}); } // 0x66972397E0757E7A  b323
    /// Starts recording a replay. \
    /// If mode is 0, turns on action replay. \
    /// If mode is 1, starts recording. \
    /// If already recording a replay, does nothing.
    pub inline fn startReplayRecording(mode: c_int) !void { try invoker.invoke(void, 0xC3AC2FFF9612AC81, .{mode}); } // 0xC3AC2FFF9612AC81  b323
    /// Stops recording and saves the recorded clip.
    pub inline fn stopReplayRecording() !void { try invoker.invoke(void, 0x071A5197D6AFC8B3, .{}); } // 0x071A5197D6AFC8B3  b323
    /// Stops recording and discards the recorded clip.
    pub inline fn cancelReplayRecording() !void { try invoker.invoke(void, 0x88BB3507ED41A240, .{}); } // 0x88BB3507ED41A240  b323
    pub inline fn saveReplayRecording() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x644546EC5287471B, .{}); } // 0x644546EC5287471B  b323
    /// Checks if you're recording, returns TRUE when you start recording (F1) or turn on action replay (F2)
    /// 
    /// mov al, cs:g_bIsRecordingGameplay // byte_141DD0CD0 in b944 \
    /// retn
    pub inline fn isReplayRecording() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1897CA71995A90B4, .{}); } // 0x1897CA71995A90B4  b323
    pub inline fn isReplayInitialized() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDF4B952F7D381B95, .{}); } // 0xDF4B952F7D381B95  b323
    pub inline fn isReplayAvailable() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4282E08174868BE3, .{}); } // 0x4282E08174868BE3  b323
    pub inline fn isReplayRecordSpaceAvailable(p_0: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x33D47E85B476ABCD, .{p_0}); } // 0x33D47E85B476ABCD  b323
};

pub const Replay = struct
{
    /// Does nothing (it's a nullsub).
    pub inline fn registerEffectForReplayEditor(p_0: [*c]const u8, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x7E2BD3EF6C205F09, .{p_0, p_1}); } // 0x7E2BD3EF6C205F09  b323
    /// Returns a bool if interior rendering is disabled, if yes, all "normal" rendered interiors are invisible
    pub inline fn replaySystemHasRequestedAScriptCleanup() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x95AB8B5C992C7B58, .{}); } // 0x95AB8B5C992C7B58  b323
    /// Disables some other rendering (internal)
    pub inline fn setScriptsHaveCleanedUpForReplaySystem() !void { try invoker.invoke(void, 0x5AD3932DAEB1E5D3, .{}); } // 0x5AD3932DAEB1E5D3  b323
    pub inline fn setReplaySystemPausedForSave(p_0: windows.BOOL) !void { try invoker.invoke(void, 0xE058175F8EAFE79A, .{p_0}); } // 0xE058175F8EAFE79A  b323
    /// Sets (almost, not sure) all Rockstar Editor values (bIsRecording etc) to 0.
    pub inline fn replayControlShutdown() !void { try invoker.invoke(void, 0x3353D13F09307691, .{}); } // 0x3353D13F09307691  b323
    /// Please note that you will need to call DO_SCREEN_FADE_IN after exiting the Rockstar Editor when you call this.
    pub inline fn activateRockstarEditor(p_0: c_int) !void { try invoker.invoke(void, 0x49DA8145672B2725, .{p_0}); } // 0x49DA8145672B2725  b323
};

pub const Savemigration = struct
{
    pub inline fn savemigrationIsMpEnabled() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x84B418E93894AC1C, .{}); } // 0x84B418E93894AC1C  b2372
    pub inline fn savemigrationMpRequestAccounts() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x85F41F9225D08C72, .{}); } // 0x85F41F9225D08C72  b2612
    pub inline fn savemigrationMpGetAccountsStatus() !c_int { return try invoker.invoke(c_int, 0xC8CB5999919EA2CA, .{}); } // 0xC8CB5999919EA2CA  b2612
    pub inline fn savemigrationMpNumAccounts() !c_int { return try invoker.invoke(c_int, 0x77A16200E18E0C55, .{}); } // 0x77A16200E18E0C55  b2612
    pub inline fn savemigrationMpGetAccount(p_0: c_int, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFCE2747EEF1D05FC, .{p_0, p_1}); } // 0xFCE2747EEF1D05FC  b2612
    pub inline fn savemigrationMpRequestStatus() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE5E9746A66359F9D, .{}); } // 0xE5E9746A66359F9D  b2372
    pub inline fn savemigrationMpGetStatus() !c_int { return try invoker.invoke(c_int, 0x690B76BD2763E068, .{}); } // 0x690B76BD2763E068  b2372
};

pub const Script = struct
{
    pub inline fn requestScript(script_name: [*c]const u8) !void { try invoker.invoke(void, 0x6EB5F71AA68F2E8E, .{script_name}); } // 0x6EB5F71AA68F2E8E 0xE26B2666 b323
    pub inline fn setScriptAsNoLongerNeeded(script_name: [*c]const u8) !void { try invoker.invoke(void, 0xC90D2DCACD56184C, .{script_name}); } // 0xC90D2DCACD56184C 0x6FCB7795 b323
    /// Returns if a script has been loaded into the game. Used to see if a script was loaded after requesting.
    pub inline fn hasScriptLoaded(script_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE6CC9F3BA0FB9EF1, .{script_name}); } // 0xE6CC9F3BA0FB9EF1 0x5D67F751 b323
    pub inline fn doesScriptExist(script_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFC04745FBE67C19A, .{script_name}); } // 0xFC04745FBE67C19A 0xDEAB87AB b323
    /// formerly _REQUEST_STREAMED_SCRIPT
    pub inline fn requestScriptWithNameHash(script_hash: types.Hash) !void { try invoker.invoke(void, 0xD62A67D26D9653E6, .{script_hash}); } // 0xD62A67D26D9653E6 0x1C68D9DC b323
    pub inline fn setScriptWithNameHashAsNoLongerNeeded(script_hash: types.Hash) !void { try invoker.invoke(void, 0xC5BC038960E9DB27, .{script_hash}); } // 0xC5BC038960E9DB27 0x96C26F66 b323
    pub inline fn hasScriptWithNameHashLoaded(script_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5F0F0C783EB16C04, .{script_hash}); } // 0x5F0F0C783EB16C04 0x06674818 b323
    pub inline fn doesScriptWithNameHashExist(script_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF86AA3C56BA31381, .{script_hash}); } // 0xF86AA3C56BA31381 0x19EAE282 b323
    pub inline fn terminateThread(thread_id: c_int) !void { try invoker.invoke(void, 0xC8B189ED9138BCD4, .{thread_id}); } // 0xC8B189ED9138BCD4 0x253FD520 b323
    pub inline fn isThreadActive(thread_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x46E9AE36D8FA6417, .{thread_id}); } // 0x46E9AE36D8FA6417 0x78D7A5A0 b323
    pub inline fn getNameOfScriptWithThisId(thread_id: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x05A42BA9FC8DA96B, .{thread_id}); } // 0x05A42BA9FC8DA96B 0xBE7ACD89 b323
    /// Starts a new iteration of the current threads. \
    /// Call this first, then SCRIPT_THREAD_ITERATOR_GET_NEXT_THREAD_ID (0x30B4FA1C82DD4B9F)
    pub inline fn scriptThreadIteratorReset() !void { try invoker.invoke(void, 0xDADFADA5A20143A8, .{}); } // 0xDADFADA5A20143A8 0xBB4E2F66 b323
    /// If the function returns 0, the end of the iteration has been reached.
    pub inline fn scriptThreadIteratorGetNextThreadId() !c_int { return try invoker.invoke(c_int, 0x30B4FA1C82DD4B9F, .{}); } // 0x30B4FA1C82DD4B9F 0x1E28B28F b323
    pub inline fn getIdOfThisThread() !c_int { return try invoker.invoke(c_int, 0xC30338E8088E2E21, .{}); } // 0xC30338E8088E2E21 0xDE524830 b323
    pub inline fn terminateThisThread() !void { try invoker.invoke(void, 0x1090044AD1DA76FA, .{}); } // 0x1090044AD1DA76FA 0x3CD9CBB7 b323
    /// Gets the number of instances of the specified script is currently running.
    /// 
    /// Actually returns numRefs - 1. \
    /// if (program) \
    ///     v3 = rage::scrProgram::GetNumRefs(program) - 1;
    /// return v3;
    pub inline fn getNumberOfThreadsRunningTheScriptWithThisHash(script_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x2C83A9DA6BFFC4F9, .{script_hash}); } // 0x2C83A9DA6BFFC4F9 0x029D3841 b323
    pub inline fn getThisScriptName() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x442E0A7EDE4A738A, .{}); } // 0x442E0A7EDE4A738A 0xA40FD5D9 b323
    pub inline fn getHashOfThisScriptName() !types.Hash { return try invoker.invoke(types.Hash, 0x8A1C8B1738FFE87E, .{}); } // 0x8A1C8B1738FFE87E 0x2BEE1F45 b323
    /// eventGroup: 0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)
    pub inline fn getNumberOfEvents(event_group: c_int) !c_int { return try invoker.invoke(c_int, 0x5F92A689A06620AA, .{event_group}); } // 0x5F92A689A06620AA 0xA3525D60 b323
    /// eventGroup: 0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)
    pub inline fn getEventExists(event_group: c_int, event_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x936E6168A9BCEDB5, .{event_group, event_index}); } // 0x936E6168A9BCEDB5 0xA1B447B5 b323
    /// eventGroup: 0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)
    pub inline fn getEventAtIndex(event_group: c_int, event_index: c_int) !c_int { return try invoker.invoke(c_int, 0xD8F66A3A60C62153, .{event_group, event_index}); } // 0xD8F66A3A60C62153 0xB49C1442 b323
    /// eventGroup: 0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)
    /// 
    /// Note: eventDataSize is NOT the size in bytes, it is the size determined by the SIZE_OF operator (RAGE Script operator, not C/C++ sizeof). That is, the size in bytes divided by 8 (script variables are always 8-byte aligned!).
    pub inline fn getEventData(event_group: c_int, event_index: c_int, event_data: [*c]types.Any, event_data_size: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2902843FCD2B2D79, .{event_group, event_index, event_data, event_data_size}); } // 0x2902843FCD2B2D79 0x4280F92F b323
    /// eventGroup: 0 = SCRIPT_EVENT_QUEUE_AI (CEventGroupScriptAI), 1 = SCRIPT_EVENT_QUEUE_NETWORK (CEventGroupScriptNetwork)
    /// 
    /// Note: eventDataSize is NOT the size in bytes, it is the size determined by the SIZE_OF operator (RAGE Script operator, not C/C++ sizeof). That is, the size in bytes divided by 8 (script variables are always 8-byte aligned!).
    /// 
    /// playerBits (also known as playersToBroadcastTo) is a bitset that indicates which players this event should be sent to. In order to send the event to specific players only, use (1 << playerIndex). Set all bits if it should be broadcast to all players.
    pub inline fn triggerScriptEvent(event_group: c_int, event_data: [*c]types.Any, event_data_size: c_int, player_bits: c_int) !void { try invoker.invoke(void, 0x5AE99C571D5BBE5D, .{event_group, event_data, event_data_size, player_bits}); } // 0x5AE99C571D5BBE5D 0x54763B35 b323
    pub inline fn shutdownLoadingScreen() !void { try invoker.invoke(void, 0x078EBE9809CCD637, .{}); } // 0x078EBE9809CCD637 0xA2826D17 b323
    pub inline fn setNoLoadingScreen(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5262CC1995D07E09, .{toggle}); } // 0x5262CC1995D07E09 0xC8055034 b323
    pub inline fn getNoLoadingScreen() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x18C1270EA7F199BC, .{}); } // 0x18C1270EA7F199BC 0x27512BA0 b323
    pub inline fn commitToLoadingscreenSelction() !void { try invoker.invoke(void, 0xB1577667C3708F9B, .{}); } // 0xB1577667C3708F9B 0xB03BCCDF b323
    /// Returns true if bit 0 in GtaThread+0x154 is set.
    pub inline fn bgIsExitflagSet() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x836B62713E0534CA, .{}); } // 0x836B62713E0534CA 0x22B9F132 b323
    /// Sets bit 1 in GtaThread+0x154
    pub inline fn bgSetExitflagResponse() !void { try invoker.invoke(void, 0x760910B49D2B98EA, .{}); } // 0x760910B49D2B98EA 0x5C95B670 b323
    /// Hashed version of BG_START_CONTEXT.
    pub inline fn bgStartContextHash(context_hash: types.Hash) !void { try invoker.invoke(void, 0x75B18E49607874C7, .{context_hash}); } // 0x75B18E49607874C7 0x67B23E17 b323
    /// Hashed version of BG_END_CONTEXT.
    pub inline fn bgEndContextHash(context_hash: types.Hash) !void { try invoker.invoke(void, 0x107E5CC7CA942BC1, .{context_hash}); } // 0x107E5CC7CA942BC1 0x3D981EBF b323
    /// Inserts the given context into the background scripts context map.
    pub inline fn bgStartContext(context_name: [*c]const u8) !void { try invoker.invoke(void, 0x9D5A25BADB742ACD, .{context_name}); } // 0x9D5A25BADB742ACD 0xF3F1D953 b323
    /// Deletes the given context from the background scripts context map.
    pub inline fn bgEndContext(context_name: [*c]const u8) !void { try invoker.invoke(void, 0xDC2BACD920D0A0DD, .{context_name}); } // 0xDC2BACD920D0A0DD 0x11F38FB3 b323
    pub inline fn bgDoesLaunchParamExist(script_index: c_int, p_1: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0F6F1EBBC4E1D5E6, .{script_index, p_1}); } // 0x0F6F1EBBC4E1D5E6 0xF8E5F73A b323
    pub inline fn bgGetLaunchParamValue(script_index: c_int, p_1: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x22E21FBCFC88C149, .{script_index, p_1}); } // 0x22E21FBCFC88C149 0x682CB7E1 b323
    pub inline fn bgGetScriptIdFromNameHash(p_0: types.Hash) !c_int { return try invoker.invoke(c_int, 0x829CD22E043A2577, .{p_0}); } // 0x829CD22E043A2577 0xC515E735 b323
    /// New variant of SEND_TU_SCRIPT_EVENT that automatically initializes the event data header. \
    /// See TRIGGER_SCRIPT_EVENT for more info.
    pub inline fn sendTuScriptEventNew_(event_group: c_int, event_data: [*c]types.Any, event_data_size: c_int, player_bits: c_int, event_type: types.Hash) !void { try invoker.invoke(void, 0x71A6F836422FDD2B, .{event_group, event_data, event_data_size, player_bits, event_type}); } // 0x71A6F836422FDD2B  b3095
};

pub const Security = struct
{
    /// Registers a protected variable that will be checked for modifications by the anticheat
    pub inline fn registerScriptVariable(variable: [*c]types.Any) !void { try invoker.invoke(void, 0x40EB1EFD921822BC, .{variable}); } // 0x40EB1EFD921822BC  b2545
    pub inline fn unregisterScriptVariable(variable: [*c]types.Any) !void { try invoker.invoke(void, 0x340A36A700E99699, .{variable}); } // 0x340A36A700E99699  b2545
    pub inline fn forceCheckScriptVariables() !void { try invoker.invoke(void, 0x8E580AB902917360, .{}); } // 0x8E580AB902917360  b2545
};

pub const Shapetest = struct
{
    /// Asynchronously starts a line-of-sight (raycast) world probe shape test.
    /// 
    /// Use the handle with 0x3D87450E15D98694 or 0x65287525D951F6BE until it returns 0 or 2.
    /// 
    /// p8 is a bit mask with bits 1, 2 and/or 4, relating to collider types; 4 should usually be used.
    pub inline fn startShapeTestLosProbe(vec_1__: types.Vector3, vec_2__: types.Vector3, flags: c_int, entity: types.Entity, p_8: c_int) !c_int { return try invoker.invoke(c_int, 0x7EE9F5D83DD4F90E, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, flags, entity, p_8}); } // 0x7EE9F5D83DD4F90E 0xEFAF4BA6 b323
    /// Does the same as 0x7EE9F5D83DD4F90E, except blocking until the shape test completes.
    pub inline fn startExpensiveSynchronousShapeTestLosProbe(vec_1__: types.Vector3, vec_2__: types.Vector3, flags: c_int, entity: types.Entity, p_8: c_int) !c_int { return try invoker.invoke(c_int, 0x377906D8A31E5586, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, flags, entity, p_8}); } // 0x377906D8A31E5586 0x8251485D b323
    pub inline fn startShapeTestBoundingBox(entity: types.Entity, flags_1: c_int, flags_2: c_int) !c_int { return try invoker.invoke(c_int, 0x052837721A854EC7, .{entity, flags_1, flags_2}); } // 0x052837721A854EC7 0xCEEAD94B b323
    pub inline fn startShapeTestBox(vec: types.Vector3, dim__: types.Vector3, rot__: types.Vector3, p_9: types.Any, flags: c_int, entity: types.Entity, p_1_2: types.Any) !c_int { return try invoker.invoke(c_int, 0xFE466162C4401D18, .{vec.x, vec.y, vec.z, dim__.x, dim__.y, dim__.z, rot__.x, rot__.y, rot__.z, p_9, flags, entity, p_1_2}); } // 0xFE466162C4401D18 0x249BC876 b323
    pub inline fn startShapeTestBound(entity: types.Entity, flags_1: c_int, flags_2: c_int) !c_int { return try invoker.invoke(c_int, 0x37181417CE7C8900, .{entity, flags_1, flags_2}); } // 0x37181417CE7C8900 0x13BC46C0 b323
    /// Raycast from point to point, where the ray has a radius. 
    /// 
    /// flags: \
    /// vehicles=10 \
    /// peds =12
    /// 
    /// Iterating through flags yields many ped / vehicle/ object combinations
    /// 
    /// p9 = 7, but no idea what it does
    /// 
    /// Entity is an entity to ignore
    pub inline fn startShapeTestCapsule(vec_1__: types.Vector3, vec_2__: types.Vector3, radius: f32, flags: c_int, entity: types.Entity, p_9: c_int) !c_int { return try invoker.invoke(c_int, 0x28579D1B8F8AAC80, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, radius, flags, entity, p_9}); } // 0x28579D1B8F8AAC80 0x591EA833 b323
    pub inline fn startShapeTestSweptSphere(vec_1__: types.Vector3, vec_2__: types.Vector3, radius: f32, flags: c_int, entity: types.Entity, p_9: types.Any) !c_int { return try invoker.invoke(c_int, 0xE6AC6C45FBE83004, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, radius, flags, entity, p_9}); } // 0xE6AC6C45FBE83004 0x4559460A b323
    /// Returns a ShapeTest handle that can be used with GET_SHAPE_TEST_RESULT.
    /// 
    /// In its only usage in game scripts its called with flag set to 511, entity to player_ped_id and flag2 set to 7
    pub inline fn startShapeTestMouseCursorLosProbe(p_vec_1: [*c]types.Vector3, p_vec_2: [*c]types.Vector3, flag: c_int, entity: types.Entity, flag_2: c_int) !c_int { return try invoker.invoke(c_int, 0xFF6BE494C7987F34, .{p_vec_1, p_vec_2, flag, entity, flag_2}); } // 0xFF6BE494C7987F34  b323
    /// Returns the result of a shape test: 0 if the handle is invalid, 1 if the shape test is still pending, or 2 if the shape test has completed, and the handle should be invalidated.
    /// 
    /// When used with an asynchronous shape test, this native should be looped until returning 0 or 2, after which the handle is invalidated.
    pub inline fn getShapeTestResult(shape_test_handle: c_int, hit: [*c]windows.BOOL, end_coords: [*c]types.Vector3, surface_normal: [*c]types.Vector3, entity_hit: [*c]types.Entity) !c_int { return try invoker.invoke(c_int, 0x3D87450E15D98694, .{shape_test_handle, hit, end_coords, surface_normal, entity_hit}); } // 0x3D87450E15D98694 0xF3C2875A b323
    /// Returns the result of a shape test, also returning the material of any touched surface.
    /// 
    /// When used with an asynchronous shape test, this native should be looped until returning 0 or 2, after which the handle is invalidated.
    /// 
    /// Unless the return value is 2, the other return values are undefined.
    pub inline fn getShapeTestResultIncludingMaterial(shape_test_handle: c_int, hit: [*c]windows.BOOL, end_coords: [*c]types.Vector3, surface_normal: [*c]types.Vector3, material_hash: [*c]types.Hash, entity_hit: [*c]types.Entity) !c_int { return try invoker.invoke(c_int, 0x65287525D951F6BE, .{shape_test_handle, hit, end_coords, surface_normal, material_hash, entity_hit}); } // 0x65287525D951F6BE 0x4301E10C b323
    /// Invalidates the entity handle passed by removing the fwScriptGuid from the entity. This should be used when receiving an ambient entity from shape testing natives, but can also be used for other natives returning an 'irrelevant' entity handle.
    pub inline fn releaseScriptGuidFromEntity(entity_hit: types.Entity) !void { try invoker.invoke(void, 0x2B3334BCA57CD799, .{entity_hit}); } // 0x2B3334BCA57CD799 0xEC2AAF06 b323
};

pub const Socialclub = struct
{
    pub inline fn scInboxGetTotalNumMessages() !c_int { return try invoker.invoke(c_int, 0x03A93FF1A2CA0864, .{}); } // 0x03A93FF1A2CA0864 0x6BE5DF29 b323
    pub inline fn scInboxGetMessageTypeAtIndex(msg_index: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0xBB8EA16ECBC976C4, .{msg_index}); } // 0xBB8EA16ECBC976C4 0x5ECF955D b323
    pub inline fn scInboxGetMessageIsReadAtIndex(msg_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x93028F1DB42BFD08, .{msg_index}); } // 0x93028F1DB42BFD08 0xD1ED1D48 b323
    pub inline fn scInboxSetMessageAsReadAtIndex(msg_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2C015348CF19CA1D, .{msg_index}); } // 0x2C015348CF19CA1D 0x19EE0CCB b323
    pub inline fn scInboxMessageGetDataInt(p_0: c_int, context: [*c]const u8, out: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA00EFE4082C4056E, .{p_0, context, out}); } // 0xA00EFE4082C4056E 0x88068C7C b323
    pub inline fn scInboxMessageGetDataBool(p_0: c_int, p_1: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFFE5C16F402D851D, .{p_0, p_1}); } // 0xFFE5C16F402D851D  b323
    pub inline fn scInboxMessageGetDataString(p_0: c_int, context: [*c]const u8, out: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7572EF42FC6A9B6D, .{p_0, context, out}); } // 0x7572EF42FC6A9B6D 0x15607620 b323
    pub inline fn scInboxMessageDoApply(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9A2C8064B6C1E41A, .{p_0}); } // 0x9A2C8064B6C1E41A 0xEBE420A4 b323
    pub inline fn scInboxMessageGetRawTypeAtIndex(p_0: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xF3E31D16CBDCB304, .{p_0}); } // 0xF3E31D16CBDCB304 0x2C959AF9 b323
    pub inline fn scInboxMessagePushGamerT0RecipList(gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0xDA024BDBD600F44A, .{gamer_handle}); } // 0xDA024BDBD600F44A 0x0B9A3512 b323
    pub inline fn scInboxSendUgcstatupdateToRecipList(data: [*c]types.Any) !void { try invoker.invoke(void, 0xA68D3D229F4F3B06, .{data}); } // 0xA68D3D229F4F3B06 0x75324674 b323
    pub inline fn scInboxMessageGetUgcdata(p_0: c_int, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x69D82604A1A5A254, .{p_0, p_1}); } // 0x69D82604A1A5A254 0x88CA3BFC b323
    pub inline fn scInboxGetBountyDataAtIndex(index: c_int, out_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x87E0052F08BD64E6, .{index, out_data}); } // 0x87E0052F08BD64E6 0xAB3346B5 b323
    pub inline fn scEmailRetrieveEmails(offset: c_int, limit: c_int) !void { try invoker.invoke(void, 0x040ADDCBAFA1018A, .{offset, limit}); } // 0x040ADDCBAFA1018A  b323
    pub inline fn scEmailGetRetrievalStatus() !c_int { return try invoker.invoke(c_int, 0x16DA8172459434AA, .{}); } // 0x16DA8172459434AA  b323
    pub inline fn scEmailGetNumRetrievedEmails() !c_int { return try invoker.invoke(c_int, 0x7DB18CA8CAD5B098, .{}); } // 0x7DB18CA8CAD5B098  b505
    pub inline fn scEmailGetEmailAtIndex(p_0: c_int, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4737980E8A283806, .{p_0, p_1}); } // 0x4737980E8A283806  b323
    pub inline fn scEmailMarketingEmailOpened_(index: c_int, @"type": types.Hash) !void { try invoker.invoke(void, 0x69AA35F3F391CDBA, .{index, @"type"}); } // 0x69AA35F3F391CDBA  b3258
    pub inline fn scEmailDeleteEmails(p_0: [*c]types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x44ACA259D67651DB, .{p_0, p_1}); } // 0x44ACA259D67651DB  b323
    pub inline fn scEmailMessagePushGamerToRecipList(gamer_handle: [*c]types.Any) !void { try invoker.invoke(void, 0x2330C12A7A605D16, .{gamer_handle}); } // 0x2330C12A7A605D16 0x9A703A2B b323
    pub inline fn scEmailMessageClearRecipList() !void { try invoker.invoke(void, 0x55DF6DB45179236E, .{}); } // 0x55DF6DB45179236E 0xD094F11A b323
    pub inline fn scEmailSendEmail(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x116FB94DC4B79F17, .{p_0}); } // 0x116FB94DC4B79F17 0xAF3C081B b323
    pub inline fn scEmailSetCurrentEmailTag(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x07DBD622D9533857, .{p_0}); } // 0x07DBD622D9533857  b505
    pub inline fn scCacheNewRockstarMsgs(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBFA0A56A817C6C7D, .{toggle}); } // 0xBFA0A56A817C6C7D 0x2FB9F53C b323
    pub inline fn scHasNewRockstarMsg() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC1CC91205EC8D6E, .{}); } // 0xBC1CC91205EC8D6E 0x6C5738AB b323
    pub inline fn scGetNewRockstarMsg() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xDF649C4E9AFDD788, .{}); } // 0xDF649C4E9AFDD788 0x468668F0 b323
    pub inline fn scPresenceAttrSetInt(attr_hash: types.Hash, value: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1F1E9682483697C7, .{attr_hash, value}); } // 0x1F1E9682483697C7 0x90C74343 b323
    pub inline fn scPresenceAttrSetFloat(attr_hash: types.Hash, value: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC4C4575F62534A24, .{attr_hash, value}); } // 0xC4C4575F62534A24 0x94BF0D35 b323
    pub inline fn scPresenceAttrSetString(attr_hash: types.Hash, value: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x287F1F75D2803595, .{attr_hash, value}); } // 0x287F1F75D2803595 0x3ACE6D6B b323
    pub inline fn scPresenceSetActivityRating(p_0: types.Any, p_1: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x487912FD248EFDDF, .{p_0, p_1}); } // 0x487912FD248EFDDF 0x579B4510 b323
    pub inline fn scGamerdataGetInt(name: [*c]const u8, value: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC85A7127E7AD02AA, .{name, value}); } // 0xC85A7127E7AD02AA 0xF8BDA989 b323
    pub inline fn scGamerdataGetFloat(name: [*c]const u8, value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA770C8EEC6FB2AC5, .{name, value}); } // 0xA770C8EEC6FB2AC5 0x515AF67C b323
    pub inline fn scGamerdataGetBool(name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8416FE4E4629D7D7, .{name}); } // 0x8416FE4E4629D7D7 0xDF45B2A7 b323
    pub inline fn scGamerdataGetString(name: [*c]const u8, value: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7FFCBFEE44ECFABF, .{name, value}); } // 0x7FFCBFEE44ECFABF 0x2AE35169 b323
    pub inline fn scGamerdataGetActiveXpBonus(value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2D874D4AE612A65F, .{value}); } // 0x2D874D4AE612A65F  b323
    /// Starts a task to check an entered string for profanity on the ROS/Social Club services.
    /// 
    /// See also: 1753344C770358AE, 82E4A58BABC15AE7.
    pub inline fn scProfanityCheckString(string: [*c]const u8, token: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x75632C5ECD7ED843, .{string, token}); } // 0x75632C5ECD7ED843 0xDF084A6B b323
    pub inline fn scProfanityCheckStringUgc(string: [*c]const u8, token: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEB2BF817463DFA28, .{string, token}); } // 0xEB2BF817463DFA28  b678
    pub inline fn scProfanityGetCheckIsValid(token: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1753344C770358AE, .{token}); } // 0x1753344C770358AE 0xFFED3676 b323
    pub inline fn scProfanityGetCheckIsPending(token: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x82E4A58BABC15AE7, .{token}); } // 0x82E4A58BABC15AE7 0xA796D7A7 b323
    pub inline fn scProfanityGetStringPassed(token: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x85535ACF97FC0969, .{token}); } // 0x85535ACF97FC0969 0x09497F31 b323
    pub inline fn scProfanityGetStringStatus(token: c_int) !c_int { return try invoker.invoke(c_int, 0x930DE22F07B1CCE3, .{token}); } // 0x930DE22F07B1CCE3 0x4D8A6521 b323
    /// Retrieves the profane part of the string with max size of 128. \
    /// Returns true if profane term was retrieved.
    pub inline fn scProfanityGetProfaneWord(token: c_int, out_profane_word: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x75CC8931A11128C9, .{token, out_profane_word}); } // 0x75CC8931A11128C9  b3258
    pub inline fn scLicenseplateCheckString(p_0: [*c]const u8, p_1: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF6BAAAF762E1BF40, .{p_0, p_1}); } // 0xF6BAAAF762E1BF40 0x7AA36406 b323
    pub inline fn scLicenseplateGetCheckIsValid(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF22CA0FD74B80E7A, .{p_0}); } // 0xF22CA0FD74B80E7A 0xF379DCE4 b323
    pub inline fn scLicenseplateGetCheckIsPending(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9237E334F6E43156, .{p_0}); } // 0x9237E334F6E43156 0x65D84665 b323
    pub inline fn scLicenseplateGetCount(token: c_int) !c_int { return try invoker.invoke(c_int, 0x700569DBA175A77C, .{token}); } // 0x700569DBA175A77C 0x159FE39C b323
    pub inline fn scLicenseplateGetPlate(token: c_int, plate_index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x1D4446A62D35B0D0, .{token, plate_index}); } // 0x1D4446A62D35B0D0 0x4CE9BAA7 b323
    pub inline fn scLicenseplateGetPlateData(token: c_int, plate_index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x2E89990DDFF670C3, .{token, plate_index}); } // 0x2E89990DDFF670C3 0x05303FC8 b323
    pub inline fn scLicenseplateSetPlateData(old_plate_text: [*c]const u8, new_plate_text: [*c]const u8, plate_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD0EE05FE193646EA, .{old_plate_text, new_plate_text, plate_data}); } // 0xD0EE05FE193646EA 0x9F98FA5C b323
    pub inline fn scLicenseplateAdd(plate_text: [*c]const u8, plate_data: [*c]types.Any, token: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1989C6E6F67E76A8, .{plate_text, plate_data, token}); } // 0x1989C6E6F67E76A8 0xEEDE7FAB b323
    pub inline fn scLicenseplateGetAddIsPending(token: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x07C61676E5BB52CD, .{token}); } // 0x07C61676E5BB52CD 0xE190E45A b323
    pub inline fn scLicenseplateGetAddStatus(token: c_int) !c_int { return try invoker.invoke(c_int, 0x8147FFF6A718E1AD, .{token}); } // 0x8147FFF6A718E1AD 0x930B3AE5 b323
    pub inline fn scLicenseplateIsvalid(plate_text: [*c]const u8, token: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0F73393BAC7E6730, .{plate_text, token}); } // 0x0F73393BAC7E6730 0x5298F472 b323
    pub inline fn scLicenseplateGetIsvalidIsPending(token: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD302E99EDF0449CF, .{token}); } // 0xD302E99EDF0449CF 0x86DAE6D6 b323
    pub inline fn scLicenseplateGetIsvalidStatus(token: c_int) !c_int { return try invoker.invoke(c_int, 0x5C4EBFFA98BDB41C, .{token}); } // 0x5C4EBFFA98BDB41C 0x9AA2BA3F b323
    pub inline fn scCommunityEventIsActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFF8F3A92B75ED67A, .{}); } // 0xFF8F3A92B75ED67A 0xC96456BA b323
    pub inline fn scCommunityEventGetEventId() !c_int { return try invoker.invoke(c_int, 0x4ED9C8D6DA297639, .{}); } // 0x4ED9C8D6DA297639 0xC5E08B66 b323
    pub inline fn scCommunityEventGetExtraDataInt(p_0: [*c]const u8, p_1: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x710BCDA8071EDED1, .{p_0, p_1}); } // 0x710BCDA8071EDED1 0x04EE74A3 b323
    pub inline fn scCommunityEventGetExtraDataFloat(p_0: [*c]const u8, p_1: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x50A8A36201DBF83E, .{p_0, p_1}); } // 0x50A8A36201DBF83E 0x8DA93C3D b323
    pub inline fn scCommunityEventGetExtraDataString(p_0: [*c]const u8, p_1: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9DE5D2F723575ED0, .{p_0, p_1}); } // 0x9DE5D2F723575ED0 0x37DD48B5 b323
    pub inline fn scCommunityEventGetDisplayName(p_0: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC2C97EA97711D1AE, .{p_0}); } // 0xC2C97EA97711D1AE 0xF929F61D b323
    pub inline fn scCommunityEventIsActiveForType(p_0: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x450819D8CF90C416, .{p_0}); } // 0x450819D8CF90C416 0x0572EB5E b323
    pub inline fn scCommunityEventGetEventIdForType(p_0: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x4A7D6E727F941747, .{p_0}); } // 0x4A7D6E727F941747 0x8E7AEEB7 b323
    pub inline fn scCommunityEventGetExtraDataIntForType(p_0: [*c]const u8, p_1: [*c]c_int, p_2: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE75A4A2E5E316D86, .{p_0, p_1, p_2}); } // 0xE75A4A2E5E316D86 0x28C57FA0 b323
    pub inline fn scCommunityEventGetExtraDataFloatForType(p_0: [*c]const u8, p_1: [*c]f32, p_2: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2570E26BE63964E3, .{p_0, p_1, p_2}); } // 0x2570E26BE63964E3 0x59394583 b323
    pub inline fn scCommunityEventGetExtraDataStringForType(p_0: [*c]const u8, p_1: [*c]u8, p_2: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1D12A56FC95BE92E, .{p_0, p_1, p_2}); } // 0x1D12A56FC95BE92E 0x92452C0E b323
    pub inline fn scCommunityEventGetDisplayNameForType(p_0: [*c]u8, p_1: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x33DF47CC0642061B, .{p_0, p_1}); } // 0x33DF47CC0642061B 0xBBA8D34D b323
    pub inline fn scCommunityEventIsActiveById(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA468E0BE12B12C70, .{p_0}); } // 0xA468E0BE12B12C70 0xB21288FA b323
    pub inline fn scCommunityEventGetExtraDataIntById(p_0: c_int, p_1: [*c]const u8, p_2: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8CC469AB4D349B7C, .{p_0, p_1, p_2}); } // 0x8CC469AB4D349B7C 0xE778B2A7 b323
    pub inline fn scCommunityEventGetExtraDataFloatById(p_0: c_int, p_1: [*c]const u8, p_2: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC5A35C73B68F3C49, .{p_0, p_1, p_2}); } // 0xC5A35C73B68F3C49 0x7E24BD6E b323
    pub inline fn scCommunityEventGetExtraDataStringById(p_0: c_int, p_1: [*c]const u8, p_2: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x699E4A5C8C893A18, .{p_0, p_1, p_2}); } // 0x699E4A5C8C893A18 0xCE7D50A8 b323
    pub inline fn scCommunityEventGetDisplayNameById(p_0: c_int, p_1: [*c]u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x19853B5B17D77BCA, .{p_0, p_1}); } // 0x19853B5B17D77BCA 0xD26CCA46 b323
    pub inline fn scTransitionNewsShow(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6BFB12CE158E3DD4, .{p_0}); } // 0x6BFB12CE158E3DD4 0x24D84334 b323
    pub inline fn scTransitionNewsShowTimed(p_0: types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFE4C1D0D3B9CC17E, .{p_0, p_1}); } // 0xFE4C1D0D3B9CC17E 0x8A023024 b323
    pub inline fn scTransitionNewsShowNextItem() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD8122C407663B995, .{}); } // 0xD8122C407663B995 0x1C65B038 b323
    pub inline fn scTransitionNewsHasExtraDataTu() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3001BEF2FECA3680, .{}); } // 0x3001BEF2FECA3680 0x4D4C37B3 b323
    pub inline fn scTransitionNewsGetExtraDataIntTu(p_0: [*c]const u8, p_1: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x92DA6E70EF249BD1, .{p_0, p_1}); } // 0x92DA6E70EF249BD1 0xAED95A6F b323
    pub inline fn scTransitionNewsEnd() !void { try invoker.invoke(void, 0x675721C9F644D161, .{}); } // 0x675721C9F644D161 0x486867E6 b323
    pub inline fn scPauseNewsInitStarterPack(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE4F6E8D07A2F0F51, .{p_0}); } // 0xE4F6E8D07A2F0F51  b1290
    /// Fills some 0x30 sized struct
    pub inline fn scPauseNewsGetPendingStory(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8A4416C0DB05FA66, .{p_0}); } // 0x8A4416C0DB05FA66  b1290
    pub inline fn scPauseNewsShutdown() !void { try invoker.invoke(void, 0xEA95C0853A27888E, .{}); } // 0xEA95C0853A27888E  b1290
    /// Returns the nickname of the logged-in Rockstar Social Club account.
    pub inline fn scAccountInfoGetNickname() ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x198D161F458ECC7F, .{}); } // 0x198D161F458ECC7F  b323
    pub inline fn scAchievementInfoStatus(p_0: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x225798743970412B, .{p_0}); } // 0x225798743970412B  b323
    /// Same as HAS_ACHIEVEMENT_BEEN_PASSED
    pub inline fn scHasAchievementBeenPassed(achievement_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x418DC16FAE452C1C, .{achievement_id}); } // 0x418DC16FAE452C1C  b323
};

pub const Stats = struct
{
    /// Example:
    /// 
    /// for (v_2 = 0; v_2 <= 4; v_2 += 1) { \
    ///     STATS::STAT_CLEAR_SLOT_FOR_RELOAD(v_2);
    /// }
    pub inline fn statClearSlotForReload(stat_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEB0A72181D4AA4AD, .{stat_slot}); } // 0xEB0A72181D4AA4AD 0x84BDD475 b323
    pub inline fn statLoad(stat_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA651443F437B1CE6, .{stat_slot}); } // 0xA651443F437B1CE6 0x9E5629F4 b323
    pub inline fn statSave(p_0: c_int, p_1: windows.BOOL, p_2: c_int, p_3: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE07BCA305B82D2FD, .{p_0, p_1, p_2, p_3}); } // 0xE07BCA305B82D2FD 0xE10A7CA4 b323
    pub inline fn statSetOpenSavetypeInJob(p_0: c_int) !void { try invoker.invoke(void, 0x5688585E6D563CD8, .{p_0}); } // 0x5688585E6D563CD8 0xC62406A6 b323
    pub inline fn statLoadPending(stat_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA1750FFAFA181661, .{stat_slot}); } // 0xA1750FFAFA181661 0x4E9AC983 b323
    pub inline fn statSavePending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7D3A583856F2C5AC, .{}); } // 0x7D3A583856F2C5AC 0xC3FD3822 b323
    pub inline fn statSavePendingOrRequested() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBBB6AD006F1BBEA3, .{}); } // 0xBBB6AD006F1BBEA3 0xA3407CA3 b323
    /// p0 is characterSlot? seems range from 0 to 2
    pub inline fn statDeleteSlot(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x49A49BED12794D70, .{p_0}); } // 0x49A49BED12794D70 0x2F171B94 b323
    pub inline fn statSlotIsLoaded(stat_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0D0A9F0E7BD91E3C, .{stat_slot}); } // 0x0D0A9F0E7BD91E3C 0x7A299C13 b323
    pub inline fn statCloudSlotLoadFailed(p_0: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7F2C4CDF2E82DF4C, .{p_0}); } // 0x7F2C4CDF2E82DF4C 0x0BF0F4B2 b323
    pub inline fn statCloudSlotLoadFailedCode(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0xE496A53BA5F50A56, .{p_0}); } // 0xE496A53BA5F50A56 0xCE6B62B5 b323
    pub inline fn statSetBlockSaves(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF434A10BA01C37D0, .{toggle}); } // 0xF434A10BA01C37D0 0xCE7A2411 b323
    pub inline fn statGetBlockSaves() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6A7F19756F1A9016, .{}); } // 0x6A7F19756F1A9016  b2060
    pub inline fn statCloudSlotSaveFailed(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7E6946F68A38B74F, .{p_0}); } // 0x7E6946F68A38B74F 0x22804C20 b323
    pub inline fn statClearPendingSaves(p_0: types.Any) !void { try invoker.invoke(void, 0xA8733668D1047B51, .{p_0}); } // 0xA8733668D1047B51 0x395D18B1 b323
    pub inline fn statLoadDirtyReadDetected() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xECB41AC6AB754401, .{}); } // 0xECB41AC6AB754401 0xED7000C8 b323
    pub inline fn statClearDirtyReadDetected() !void { try invoker.invoke(void, 0x9B4BD21D69B1E609, .{}); } // 0x9B4BD21D69B1E609  b323
    pub inline fn statGetLoadSafeToProgressToMpFromSp() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC0E0D686DDFC6EAE, .{}); } // 0xC0E0D686DDFC6EAE 0x099FCC86 b323
    /// Returns stat hash based on dataType, statIndex/statId and characterSlot. Related to CStatsMpCharacterMappingData
    pub inline fn getStatHashForCharacterStat_(data_type: c_int, stat_index: c_int, char_slot: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0xD69CE161FE614531, .{data_type, stat_index, char_slot}); } // 0xD69CE161FE614531  b2944
    /// Example: \
    ///  STATS::STAT_SET_INT(MISC::GET_HASH_KEY("MPPLY_KILLS_PLAYERS"), 1337, true);
    pub inline fn statSetInt(stat_name: types.Hash, value: c_int, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB3271D7AB655B441, .{stat_name, value, save}); } // 0xB3271D7AB655B441 0xC9CC1C5C b323
    /// Example: \
    ///  STATS::STAT_SET_FLOAT(MISC::GET_HASH_KEY("MP0_WEAPON_ACCURACY"), 66.6f, true);
    pub inline fn statSetFloat(stat_name: types.Hash, value: f32, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4851997F37FE9B3C, .{stat_name, value, save}); } // 0x4851997F37FE9B3C 0x6CEA96F2 b323
    /// Example: \
    ///  STATS::STAT_SET_BOOL(MISC::GET_HASH_KEY("MPPLY_MELEECHLENGECOMPLETED"), trur, true);
    pub inline fn statSetBool(stat_name: types.Hash, value: windows.BOOL, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4B33C4243DE0C432, .{stat_name, value, save}); } // 0x4B33C4243DE0C432 0x55D79DFB b323
    /// The following values have been found in the decompiled scripts: \
    /// "RC_ABI1" \
    /// "RC_ABI2" \
    /// "RC_BA1" \
    /// "RC_BA2" \
    /// "RC_BA3" \
    /// "RC_BA3A" \
    /// "RC_BA3C" \
    /// "RC_BA4" \
    /// "RC_DRE1" \
    /// "RC_EPS1" \
    /// "RC_EPS2" \
    /// "RC_EPS3" \
    /// "RC_EPS4" \
    /// "RC_EPS5" \
    /// "RC_EPS6" \
    /// "RC_EPS7" \
    /// "RC_EPS8" \
    /// "RC_EXT1" \
    /// "RC_EXT2" \
    /// "RC_EXT3" \
    /// "RC_EXT4" \
    /// "RC_FAN1" \
    /// "RC_FAN2" \
    /// "RC_FAN3" \
    /// "RC_HAO1" \
    /// "RC_HUN1" \
    /// "RC_HUN2" \
    /// "RC_JOS1" \
    /// "RC_JOS2" \
    /// "RC_JOS3" \
    /// "RC_JOS4" \
    /// "RC_MAU1" \
    /// "RC_MIN1" \
    /// "RC_MIN2" \
    /// "RC_MIN3" \
    /// "RC_MRS1" \
    /// "RC_MRS2" \
    /// "RC_NI1" \
    /// "RC_NI1A" \
    /// "RC_NI1B" \
    /// "RC_NI1C" \
    /// "RC_NI1D" \
    /// "RC_NI2" \
    /// "RC_NI3" \
    /// "RC_OME1" \
    /// "RC_OME2" \
    /// "RC_PA1" \
    /// "RC_PA2" \
    /// "RC_PA3" \
    /// "RC_PA3A" \
    /// "RC_PA3B" \
    /// "RC_PA4" \
    /// "RC_RAM1" \
    /// "RC_RAM2" \
    /// "RC_RAM3" \
    /// "RC_RAM4" \
    /// "RC_RAM5" \
    /// "RC_SAS1" \
    /// "RC_TON1" \
    /// "RC_TON2" \
    /// "RC_TON3" \
    /// "RC_TON4" \
    /// "RC_TON5"
    pub inline fn statSetGxtLabel(stat_name: types.Hash, value: [*c]const u8, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x17695002FD8B2AE0, .{stat_name, value, save}); } // 0x17695002FD8B2AE0 0xC1224AA7 b323
    /// 'value' is a structure to a structure, 'numFields' is how many fields there are in said structure (usually 7).
    /// 
    /// The structure looks like this:
    /// 
    /// int year \
    /// int month \
    /// int day \
    /// int hour \
    /// int minute \
    /// int second \
    /// int millisecond
    /// 
    /// The decompiled scripts use TIME::GET_POSIX_TIME to fill this structure.
    pub inline fn statSetDate(stat_name: types.Hash, value: [*c]types.Any, num_fields: c_int, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2C29BFB64F4FCBE4, .{stat_name, value, num_fields, save}); } // 0x2C29BFB64F4FCBE4 0x36BE807B b323
    pub inline fn statSetString(stat_name: types.Hash, value: [*c]const u8, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA87B2335D12531D7, .{stat_name, value, save}); } // 0xA87B2335D12531D7 0xB1EF2E21 b323
    pub inline fn statSetPos(stat_name: types.Hash, vec: types.Vector3, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDB283FDE680FE72E, .{stat_name, vec.x, vec.y, vec.z, save}); } // 0xDB283FDE680FE72E 0x1192C9A3 b323
    pub inline fn statSetMaskedInt(stat_name: types.Hash, p_1: c_int, p_2: c_int, p_3: c_int, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7BBB1B54583ED410, .{stat_name, p_1, p_2, p_3, save}); } // 0x7BBB1B54583ED410 0x2CBAA739 b323
    pub inline fn statSetUserId(stat_name: types.Hash, value: [*c]const u8, save: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8CDDF1E452BABE11, .{stat_name, value, save}); } // 0x8CDDF1E452BABE11 0xDBE78ED7 b323
    /// p1 always true.
    pub inline fn statSetCurrentPosixTime(stat_name: types.Hash, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC2F84B7F9C4D0C61, .{stat_name, p_1}); } // 0xC2F84B7F9C4D0C61 0xA286F015 b323
    /// p2 appears to always be -1
    /// 
    pub inline fn statGetInt(stat_hash: types.Hash, out_value: [*c]c_int, p_2: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x767FBC2AC802EF3D, .{stat_hash, out_value, p_2}); } // 0x767FBC2AC802EF3D 0x1C6FE43E b323
    pub inline fn statGetFloat(stat_hash: types.Hash, out_value: [*c]f32, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD7AE6C9C9C6AC54C, .{stat_hash, out_value, p_2}); } // 0xD7AE6C9C9C6AC54C 0xFCBDA612 b323
    pub inline fn statGetBool(stat_hash: types.Hash, out_value: [*c]windows.BOOL, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x11B5E6D2AE73F48E, .{stat_hash, out_value, p_2}); } // 0x11B5E6D2AE73F48E 0x28A3DD2B b323
    /// p3 is probably characterSlot or BOOL save, always -1
    pub inline fn statGetDate(stat_hash: types.Hash, out_value: [*c]types.Any, num_fields: c_int, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8B0FACEFC36C824B, .{stat_hash, out_value, num_fields, p_3}); } // 0x8B0FACEFC36C824B 0xD762D16C b323
    /// p1 is always -1 in the script files
    pub inline fn statGetString(stat_hash: types.Hash, p_1: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xE50384ACC2C3DB74, .{stat_hash, p_1}); } // 0xE50384ACC2C3DB74 0x10CE4BDE b323
    /// p3 is probably characterSlot or BOOL save, always -1
    pub inline fn statGetPos(stat_name: types.Hash, out_x: [*c]f32, out_y: [*c]f32, out_z: [*c]f32, p_4: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x350F82CCB186AA1B, .{stat_name, out_x, out_y, out_z, p_4}); } // 0x350F82CCB186AA1B 0xC846ECCE b323
    /// p4 is probably characterSlot or BOOL save
    pub inline fn statGetMaskedInt(stat_hash: types.Hash, out_value: [*c]c_int, p_2: c_int, p_3: c_int, p_4: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x655185A06D9EEAAB, .{stat_hash, out_value, p_2, p_3, p_4}); } // 0x655185A06D9EEAAB 0xE9D9B70F b323
    /// Returns the rockstar ID (user id) value of a given stat. Returns "STAT_UNKNOWN" if the statHash is invalid or the stat has no userId
    pub inline fn statGetUserId(stat_hash: types.Hash) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x2365C388E393BBE2, .{stat_hash}); } // 0x2365C388E393BBE2 0xE2E8B6BA b323
    pub inline fn statGetLicensePlate(stat_name: types.Hash) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x5473D4195058B2E4, .{stat_name}); } // 0x5473D4195058B2E4 0x1544B29F b323
    pub inline fn statSetLicensePlate(stat_name: types.Hash, str: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x69FF13266D7296DA, .{stat_name, str}); } // 0x69FF13266D7296DA 0x3507D253 b323
    pub inline fn statIncrement(stat_name: types.Hash, value: f32) !void { try invoker.invoke(void, 0x9B5A68C6489E9909, .{stat_name, value}); } // 0x9B5A68C6489E9909 0xDFC5F71E b323
    pub inline fn statCommunityStartSynch() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5A556B229A169402, .{}); } // 0x5A556B229A169402 0x46F21343 b323
    pub inline fn statCommunitySynchIsPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB1D2BB1E1631F5B1, .{}); } // 0xB1D2BB1E1631F5B1 0x02F283CE b323
    pub inline fn statCommunityGetHistory(stat_name: types.Hash, p_1: c_int, out_value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBED9F5693F34ED17, .{stat_name, p_1, out_value}); } // 0xBED9F5693F34ED17 0xC4110917 b323
    /// p0 seems to range from 0 to 7
    pub inline fn statResetAllOnlineCharacterStats(p_0: c_int) !void { try invoker.invoke(void, 0x26D7399B9587FE89, .{p_0}); } // 0x26D7399B9587FE89 0x343B27E2 b323
    /// p0 seems to range from 0 to 7
    pub inline fn statLocalResetAllOnlineCharacterStats(p_0: c_int) !void { try invoker.invoke(void, 0xA78B8FA58200DA56, .{p_0}); } // 0xA78B8FA58200DA56 0xE3247582 b323
    pub inline fn statGetNumberOfDays(stat_name: types.Hash) !c_int { return try invoker.invoke(c_int, 0xE0E854F5280FB769, .{stat_name}); } // 0xE0E854F5280FB769 0xFD66A429 b323
    pub inline fn statGetNumberOfHours(stat_name: types.Hash) !c_int { return try invoker.invoke(c_int, 0xF2D4B2FE415AAFC3, .{stat_name}); } // 0xF2D4B2FE415AAFC3 0x9B431236 b323
    pub inline fn statGetNumberOfMinutes(stat_name: types.Hash) !c_int { return try invoker.invoke(c_int, 0x7583B4BE4C5A41B5, .{stat_name}); } // 0x7583B4BE4C5A41B5 0x347B4436 b323
    pub inline fn statGetNumberOfSeconds(stat_name: types.Hash) !c_int { return try invoker.invoke(c_int, 0x2CE056FF3723F00B, .{stat_name}); } // 0x2CE056FF3723F00B 0x2C1D6C31 b323
    /// Does not take effect immediately, unfortunately.
    /// 
    /// profileSetting seems to only be 936, 937 and 938 in scripts
    pub inline fn statSetProfileSettingValue(profile_setting: c_int, value: c_int) !void { try invoker.invoke(void, 0x68F01422BE1D838F, .{profile_setting, value}); } // 0x68F01422BE1D838F 0x24DD4929 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn statsCompletedCharacterCreation(p_0: types.Any) !void { try invoker.invoke(void, 0xC01D2470F22CDE5A, .{p_0}); } // 0xC01D2470F22CDE5A  b2372
    /// Needs more research. Possibly used to calculate the "mask" when calling "STAT_SET_MASKED_INT"?
    pub inline fn packedStatGetIntStatIndex(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x94F12ABF9C79E339, .{p_0}); } // 0x94F12ABF9C79E339 0xCA160BCC b323
    pub inline fn getPackedIntStatKey(index: c_int, sp_stat: windows.BOOL, char_stat: windows.BOOL, character: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0x61E111E323419E07, .{index, sp_stat, char_stat, character}); } // 0x61E111E323419E07 0x1F938864 b323
    pub inline fn getPackedTuIntStatKey(index: c_int, sp_stat: windows.BOOL, char_stat: windows.BOOL, character: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0xD16C2AD6B8E32854, .{index, sp_stat, char_stat, character}); } // 0xD16C2AD6B8E32854 0xFB93C5A2 b323
    /// Needs more research. Gets the stat name of a masked int?
    /// 
    /// section - values used in the decompiled scripts: \
    /// "_NGPSTAT_INT" \
    /// "_MP_NGPSTAT_INT" \
    /// "_MP_LRPSTAT_INT" \
    /// "_MP_APAPSTAT_INT" \
    /// "_MP_LR2PSTAT_INT" \
    /// "_MP_BIKEPSTAT_INT" \
    /// "_MP_IMPEXPPSTAT_INT" \
    /// "_MP_GUNRPSTAT_INT" \
    /// "_NGDLCPSTAT_INT" \
    /// "_MP_NGDLCPSTAT_INT" \
    /// "_DLCSMUGCHARPSTAT_INT" \
    /// "_GANGOPSPSTAT_INT" \
    /// "_BUSINESSBATPSTAT_INT" \
    /// "_ARENAWARSPSTAT_INT" \
    /// "_CASINOPSTAT_INT" \
    /// "_CASINOHSTPSTAT_INT"
    pub inline fn getPackedNgIntStatKey(index: c_int, sp_stat: windows.BOOL, char_stat: windows.BOOL, character: c_int, section: [*c]const u8) !types.Hash { return try invoker.invoke(types.Hash, 0x2B4CDCA6F07FF3DA, .{index, sp_stat, char_stat, character, section}); } // 0x2B4CDCA6F07FF3DA  b323
    pub inline fn getPackedStatBoolCode(index: c_int, character_slot: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDA7EBFC49AE3F1B0, .{index, character_slot}); } // 0xDA7EBFC49AE3F1B0  b2545
    pub inline fn getPackedStatIntCode(index: c_int, character_slot: c_int) !c_int { return try invoker.invoke(c_int, 0x0BC900A6FE73770C, .{index, character_slot}); } // 0x0BC900A6FE73770C  b2545
    pub inline fn setPackedStatBoolCode(index: c_int, value: windows.BOOL, character_slot: c_int) !void { try invoker.invoke(void, 0xDB8A58AEAA67CD07, .{index, value, character_slot}); } // 0xDB8A58AEAA67CD07  b2545
    pub inline fn setPackedStatIntCode(index: c_int, value: c_int, character_slot: c_int) !void { try invoker.invoke(void, 0x1581503AE529CD2E, .{index, value, character_slot}); } // 0x1581503AE529CD2E  b2545
    pub inline fn playstatsBackgroundScriptAction(action: [*c]const u8, value: c_int) !void { try invoker.invoke(void, 0x5009DFD741329729, .{action, value}); } // 0x5009DFD741329729 0x61ECC465 b323
    pub inline fn playstatsFlowLow_(pos__: types.Vector3, action: [*c]const u8, p_4: windows.BOOL, p_5: c_int) !void { try invoker.invoke(void, 0xE6A27CDA42887F93, .{pos__.x, pos__.y, pos__.z, action, p_4, p_5}); } // 0xE6A27CDA42887F93  b2944
    pub inline fn playstatsFlowMedium_(pos__: types.Vector3, action: [*c]const u8, p_4: windows.BOOL, p_5: c_int) !void { try invoker.invoke(void, 0xC4493521BAA12CCE, .{pos__.x, pos__.y, pos__.z, action, p_4, p_5}); } // 0xC4493521BAA12CCE  b3095
    pub inline fn playstatsFlowHigh_(pos__: types.Vector3, action: [*c]const u8, p_4: windows.BOOL, p_5: c_int) !void { try invoker.invoke(void, 0xCFB0E9C3456319EA, .{pos__.x, pos__.y, pos__.z, action, p_4, p_5}); } // 0xCFB0E9C3456319EA  b3258
    pub inline fn playstatsNpcInvite(p_0: [*c]const u8) !void { try invoker.invoke(void, 0x93054C88E6AA7C44, .{p_0}); } // 0x93054C88E6AA7C44 0x598C06F3 b323
    pub inline fn playstatsAwardXp(amount: c_int, @"type": types.Hash, category: types.Hash) !void { try invoker.invoke(void, 0x46F917F6B4128FE4, .{amount, @"type", category}); } // 0x46F917F6B4128FE4 0x8770017B b323
    pub inline fn playstatsRankUp(rank: c_int) !void { try invoker.invoke(void, 0xC7F2DE41D102BFB4, .{rank}); } // 0xC7F2DE41D102BFB4 0x56AFB9F5 b323
    pub inline fn playstatsStartedSessionInOfflinemode() !void { try invoker.invoke(void, 0x098760C7461724CD, .{}); } // 0x098760C7461724CD 0x896CDF8D b323
    pub inline fn playstatsActivityDone(p_0: c_int, activity_id: c_int, p_2: types.Any) !void { try invoker.invoke(void, 0xA071E0ED98F91286, .{p_0, activity_id, p_2}); } // 0xA071E0ED98F91286 0x1A66945F b323
    pub inline fn playstatsLeaveJobChain(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xC5BE134EC7BA96A0, .{p_0, p_1, p_2, p_3, p_4}); } // 0xC5BE134EC7BA96A0 0xC960E161 b323
    pub inline fn playstatsMissionStarted(p_0: [*c]const u8, p_1: types.Any, p_2: types.Any, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xC19A2925C34D2231, .{p_0, p_1, p_2, p_3}); } // 0xC19A2925C34D2231 0x3AAB699C b323
    pub inline fn playstatsMissionOver(p_0: [*c]const u8, p_1: types.Any, p_2: types.Any, p_3: windows.BOOL, p_4: windows.BOOL, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x7C4BB33A8CED7324, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x7C4BB33A8CED7324 0x5B90B5FF b323
    pub inline fn playstatsMissionCheckpoint(p_0: [*c]const u8, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xC900596A63978C1D, .{p_0, p_1, p_2, p_3}); } // 0xC900596A63978C1D 0xCDC52280 b323
    pub inline fn playstatsRandomMissionDone(name: [*c]const u8, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x71862B1D855F32E1, .{name, p_1, p_2, p_3}); } // 0x71862B1D855F32E1 0xAC2C7C63 b323
    pub inline fn playstatsRosBet(amount: c_int, act: c_int, player: types.Player, cm: f32) !void { try invoker.invoke(void, 0x121FB4DDDC2D5291, .{amount, act, player, cm}); } // 0x121FB4DDDC2D5291 0x413539BC b323
    pub inline fn playstatsRaceCheckpoint(p_0: types.Vehicle, p_1: types.Any, p_2: c_int, p_3: c_int, p_4: types.Any) !void { try invoker.invoke(void, 0x9C375C315099DDE4, .{p_0, p_1, p_2, p_3, p_4}); } // 0x9C375C315099DDE4 0x580D5508 b323
    pub inline fn playstatsCreateMatchHistoryId2(player_account_id: [*c]c_int, posix_time: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6DEE77AFF8C21BD1, .{player_account_id, posix_time}); } // 0x6DEE77AFF8C21BD1 0x489E27E7 b323
    pub inline fn playstatsMatchStarted(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xBC80E22DED931E3D, .{p_0, p_1, p_2}); } // 0xBC80E22DED931E3D 0x2BDE85C1 b323
    pub inline fn playstatsShopItem(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x176852ACAAC173D1, .{p_0, p_1, p_2, p_3, p_4}); } // 0x176852ACAAC173D1 0xA4746384 b323
    pub inline fn playstatsCrateDropMissionDone(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any) !void { try invoker.invoke(void, 0x1CAE5D2E3F9A07F0, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0x1CAE5D2E3F9A07F0 0x6602CED6 b323
    pub inline fn playstatsCrateCreated(p_0: f32, p_1: f32, p_2: f32) !void { try invoker.invoke(void, 0xAFC7E5E075A96F46, .{p_0, p_1, p_2}); } // 0xAFC7E5E075A96F46 0xD003E648 b323
    pub inline fn playstatsHoldUpMissionDone(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xCB00196B31C39EB1, .{p_0, p_1, p_2, p_3}); } // 0xCB00196B31C39EB1 0x759E0EC9 b323
    pub inline fn playstatsImportExportMissionDone(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x2B69F5074C894811, .{p_0, p_1, p_2, p_3}); } // 0x2B69F5074C894811 0x62073DF7 b323
    pub inline fn playstatsRaceToPointMissionDone(p_0: c_int, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xADDD1C754E2E2914, .{p_0, p_1, p_2, p_3}); } // 0xADDD1C754E2E2914 0x06CE3692 b323
    pub inline fn playstatsAcquiredHiddenPackage(p_0: types.Any) !void { try invoker.invoke(void, 0x79AB33F0FBFAC40C, .{p_0}); } // 0x79AB33F0FBFAC40C 0x8D5C7B37 b323
    pub inline fn playstatsWebsiteVisited(scaleform_hash: types.Hash, p_1: c_int) !void { try invoker.invoke(void, 0xDDF24D535060F811, .{scaleform_hash, p_1}); } // 0xDDF24D535060F811 0x37D152BB b323
    pub inline fn playstatsFriendActivity(p_0: c_int, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x0F71DE29AB2258F1, .{p_0, p_1}); } // 0x0F71DE29AB2258F1 0xD1FA1BDB b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn playstatsOddjobDone(total_time_ms: c_int, p_1: c_int, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x69DEA3E9DB727B4C, .{total_time_ms, p_1, p_2}); } // 0x69DEA3E9DB727B4C 0xFE14A8EA b323
    pub inline fn playstatsPropChange(p_0: types.Ped, p_1: c_int, p_2: c_int, p_3: c_int) !void { try invoker.invoke(void, 0xBA739D6D5A05D6E7, .{p_0, p_1, p_2, p_3}); } // 0xBA739D6D5A05D6E7 0x25740A1D b323
    pub inline fn playstatsClothChange(p_0: types.Ped, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x34B973047A2268B9, .{p_0, p_1, p_2, p_3, p_4}); } // 0x34B973047A2268B9 0x3AFF9E58 b323
    /// This is a typo made by R*. It's supposed to be called PLAYSTATS_WEAPON_MOD_CHANGE.
    pub inline fn playstatsWeaponModeChange(weapon_hash: types.Hash, component_hash_to: types.Hash, component_hash_from: types.Hash) !void { try invoker.invoke(void, 0xE95C8A1875A02CA4, .{weapon_hash, component_hash_to, component_hash_from}); } // 0xE95C8A1875A02CA4 0x79716890 b323
    pub inline fn playstatsCheatApplied(cheat: [*c]const u8) !void { try invoker.invoke(void, 0x6058665D72302D3F, .{cheat}); } // 0x6058665D72302D3F 0x345166F3 b323
    pub inline fn playstatsJobActivityEnd(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !void { try invoker.invoke(void, 0xF8C54A461C3E11DC, .{p_0, p_1, p_2, p_3}); } // 0xF8C54A461C3E11DC 0x04181752 b323
    pub inline fn playstatsJobBend(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !void { try invoker.invoke(void, 0xF5BB8DAC426A52C0, .{p_0, p_1, p_2, p_3}); } // 0xF5BB8DAC426A52C0 0x40520E70 b323
    pub inline fn playstatsJobLtsEnd(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !void { try invoker.invoke(void, 0xA736CF7FB7C5BFF4, .{p_0, p_1, p_2, p_3}); } // 0xA736CF7FB7C5BFF4 0x31002201 b323
    pub inline fn playstatsJobLtsRoundEnd(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: [*c]types.Any, p_3: [*c]types.Any) !void { try invoker.invoke(void, 0x14E0B2D1AD1044E0, .{p_0, p_1, p_2, p_3}); } // 0x14E0B2D1AD1044E0 0xDDD1F1F3 b323
    pub inline fn playstatsQuickfixTool(element: c_int, item: [*c]const u8) !void { try invoker.invoke(void, 0x90D0622866E80445, .{element, item}); } // 0x90D0622866E80445 0x66FEB701 b323
    pub inline fn playstatsIdleKick(ms_stood_idle: c_int) !void { try invoker.invoke(void, 0x5DA3A8DE8CB6226F, .{ms_stood_idle}); } // 0x5DA3A8DE8CB6226F 0x9E2B9522 b323
    pub inline fn playstatsSetJoinType(join_type: c_int) !void { try invoker.invoke(void, 0xD1032E482629049E, .{join_type}); } // 0xD1032E482629049E 0x1AC97138 b323
    pub inline fn playstatsHeistSaveCheat(hash: types.Hash, p_1: c_int) !void { try invoker.invoke(void, 0xF4FF020A08BC8863, .{hash, p_1}); } // 0xF4FF020A08BC8863 0xB731DF54 b323
    pub inline fn playstatsAppendDirectorMetric(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x46326E13DA4E0546, .{p_0}); } // 0x46326E13DA4E0546  b323
    pub inline fn playstatsAwardBadSport(id: c_int) !void { try invoker.invoke(void, 0x47B32F5611E6E483, .{id}); } // 0x47B32F5611E6E483  b463
    pub inline fn playstatsPegasusAsPersonalAircraft(model_hash: types.Hash) !void { try invoker.invoke(void, 0x9572BD4DD6B72122, .{model_hash}); } // 0x9572BD4DD6B72122  b1180
    pub inline fn playstatsShopmenuNav_(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xF96E9EA876D9DC92, .{p_0, p_1, p_2, p_3}); } // 0xF96E9EA876D9DC92  b2802
    pub inline fn playstatsFmEventChallenges(p_0: types.Any) !void { try invoker.invoke(void, 0x6A60E43998228229, .{p_0}); } // 0x6A60E43998228229  b463
    pub inline fn playstatsFmEventVehicletarget(p_0: types.Any) !void { try invoker.invoke(void, 0xBFAFDB5FAAA5C5AB, .{p_0}); } // 0xBFAFDB5FAAA5C5AB  b463
    pub inline fn playstatsFmEventUrbanwarfare(p_0: types.Any) !void { try invoker.invoke(void, 0x8C9D11605E59D955, .{p_0}); } // 0x8C9D11605E59D955  b463
    pub inline fn playstatsFmEventCheckpointcollection(p_0: types.Any) !void { try invoker.invoke(void, 0x3DE3AA516FB126A4, .{p_0}); } // 0x3DE3AA516FB126A4  b463
    pub inline fn playstatsFmEventAtob(p_0: types.Any) !void { try invoker.invoke(void, 0xBAA2F0490E146BE8, .{p_0}); } // 0xBAA2F0490E146BE8  b463
    pub inline fn playstatsFmEventPennedin(p_0: types.Any) !void { try invoker.invoke(void, 0x1A7CE7CD3E653485, .{p_0}); } // 0x1A7CE7CD3E653485  b463
    pub inline fn playstatsFmEventPasstheparcel(p_0: types.Any) !void { try invoker.invoke(void, 0x419615486BBF1956, .{p_0}); } // 0x419615486BBF1956  b463
    pub inline fn playstatsFmEventHotproperty(p_0: types.Any) !void { try invoker.invoke(void, 0x84DFC579C2FC214C, .{p_0}); } // 0x84DFC579C2FC214C  b463
    pub inline fn playstatsFmEventDeaddrop(p_0: types.Any) !void { try invoker.invoke(void, 0x0A9C7F36E5D7B683, .{p_0}); } // 0x0A9C7F36E5D7B683  b463
    pub inline fn playstatsFmEventKingofthecastle(p_0: types.Any) !void { try invoker.invoke(void, 0x164C5FF663790845, .{p_0}); } // 0x164C5FF663790845  b463
    pub inline fn playstatsFmEventCriminaldamage(p_0: types.Any) !void { try invoker.invoke(void, 0xEDBF6C9B0D2C65C8, .{p_0}); } // 0xEDBF6C9B0D2C65C8  b463
    pub inline fn playstatsFmEventCompetitiveurbanwarfare(p_0: types.Any) !void { try invoker.invoke(void, 0x6551B1F7F6CD46EA, .{p_0}); } // 0x6551B1F7F6CD46EA  b463
    pub inline fn playstatsFmEventHuntbeast(p_0: types.Any) !void { try invoker.invoke(void, 0x2CD90358F67D0AA8, .{p_0}); } // 0x2CD90358F67D0AA8  b463
    pub inline fn playstatsPimenuHideOptions(data: [*c]types.Any) !void { try invoker.invoke(void, 0x203B381133817079, .{data}); } // 0x203B381133817079  b393
    /// Known text types: NAME_YACHT, NAME_ORG_OFFICE
    pub inline fn playstatsNamedUserContent_(is_boss: windows.BOOL, boss_type: c_int, boss_id_1: c_int, boss_id_2: c_int, text_type: c_int, text_string: [*c]const u8, text_source: c_int) !void { try invoker.invoke(void, 0xAA434D7D0A89A95C, .{is_boss, boss_type, boss_id_1, boss_id_2, text_type, text_string, text_source}); } // 0xAA434D7D0A89A95C  b3258
    pub inline fn leaderboardsGetNumberOfColumns(p_0: c_int, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x117B45156D7EFF2E, .{p_0, p_1}); } // 0x117B45156D7EFF2E 0x0A56EE34 b323
    pub inline fn leaderboardsGetColumnId(p_0: c_int, p_1: c_int, p_2: c_int) !c_int { return try invoker.invoke(c_int, 0xC4B5467A1886EA7E, .{p_0, p_1, p_2}); } // 0xC4B5467A1886EA7E 0x3821A334 b323
    pub inline fn leaderboardsGetColumnType(p_0: c_int, p_1: types.Any, p_2: types.Any) !c_int { return try invoker.invoke(c_int, 0xBF4FEF46DB7894D3, .{p_0, p_1, p_2}); } // 0xBF4FEF46DB7894D3 0x6F2820F4 b323
    pub inline fn leaderboardsReadClearAll() !c_int { return try invoker.invoke(c_int, 0xA34CB6E6F0DF4A0B, .{}); } // 0xA34CB6E6F0DF4A0B 0x233E058A b323
    pub inline fn leaderboardsReadClear(p_0: types.Any, p_1: types.Any, p_2: types.Any) !c_int { return try invoker.invoke(c_int, 0x7CCE5C737A665701, .{p_0, p_1, p_2}); } // 0x7CCE5C737A665701 0x7090012F b323
    pub inline fn leaderboardsReadPending(p_0: types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAC392C8483342AC2, .{p_0, p_1, p_2}); } // 0xAC392C8483342AC2 0xEEB8BF5C b323
    pub inline fn leaderboardsReadAnyPending() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA31FD15197B192BD, .{}); } // 0xA31FD15197B192BD 0x1789437B b323
    pub inline fn leaderboardsReadSuccessful(p_0: types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2FB19228983E832C, .{p_0, p_1, p_2}); } // 0x2FB19228983E832C 0x3AC5B2F1 b323
    pub inline fn leaderboards2ReadFriendsByRow(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: types.Any, p_3: windows.BOOL, p_4: types.Any, p_5: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x918B101666F9CB83, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x918B101666F9CB83 0xBD91B136 b323
    pub inline fn leaderboards2ReadByHandle(p_0: [*c]types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC30713A383BFBF0E, .{p_0, p_1}); } // 0xC30713A383BFBF0E 0x6B553408 b323
    pub inline fn leaderboards2ReadByRank(p_0: [*c]types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBA2C7DB0C129449A, .{p_0, p_1, p_2}); } // 0xBA2C7DB0C129449A 0x1B03F59F b323
    pub inline fn leaderboards2ReadByRadius(p_0: [*c]types.Any, p_1: types.Any, p_2: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5CE587FB5A42C8C4, .{p_0, p_1, p_2}); } // 0x5CE587FB5A42C8C4 0xC5B7E685 b323
    pub inline fn leaderboards2ReadByScoreInt(p_0: [*c]types.Any, p_1: types.Any, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7EEC7E4F6984A16A, .{p_0, p_1, p_2}); } // 0x7EEC7E4F6984A16A 0xAC020C18 b323
    pub inline fn leaderboards2ReadByScoreFloat(p_0: [*c]types.Any, p_1: f32, p_2: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE662C8B759D08F3C, .{p_0, p_1, p_2}); } // 0xE662C8B759D08F3C 0xC678B29F b323
    pub inline fn leaderboards2ReadRankPrediction(p_0: [*c]types.Any, p_1: [*c]types.Any, p_2: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC38DC1E90D22547C, .{p_0, p_1, p_2}); } // 0xC38DC1E90D22547C 0x9BEC3401 b323
    pub inline fn leaderboards2ReadByPlaform(p_0: [*c]types.Any, gamer_handle_csv: [*c]const u8, platform_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF1AE5DCDBFCA2721, .{p_0, gamer_handle_csv, platform_name}); } // 0xF1AE5DCDBFCA2721  b323
    pub inline fn leaderboards2ReadGetRowDataStart(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0F93D5465B3094D, .{p_0}); } // 0xA0F93D5465B3094D 0xC977D6E2 b323
    pub inline fn leaderboards2ReadGetRowDataEnd() !void { try invoker.invoke(void, 0x71B008056E5692D6, .{}); } // 0x71B008056E5692D6 0xF2DB6A82 b323
    pub inline fn leaderboards2ReadGetRowDataInfo(p_0: types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x34770B9CE0E03B91, .{p_0, p_1}); } // 0x34770B9CE0E03B91 0x766A74FE b323
    pub inline fn leaderboards2ReadGetRowDataInt(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x88578F6EC36B4A3A, .{p_0, p_1}); } // 0x88578F6EC36B4A3A 0x6B90E730 b323
    pub inline fn leaderboards2ReadGetRowDataFloat(p_0: types.Any, p_1: types.Any) !f32 { return try invoker.invoke(f32, 0x38491439B6BA7F7D, .{p_0, p_1}); } // 0x38491439B6BA7F7D 0x509A286F b323
    pub inline fn leaderboards2WriteData(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAE2206545888AE49, .{p_0}); } // 0xAE2206545888AE49 0x5F9DF634 b323
    pub inline fn leaderboardsWriteAddColumn(p_0: types.Any, p_1: types.Any, p_2: f32) !void { try invoker.invoke(void, 0x0BCA1D2C47B0D269, .{p_0, p_1, p_2}); } // 0x0BCA1D2C47B0D269 0x7524E27B b323
    pub inline fn leaderboardsWriteAddColumnLong(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x2E65248609523599, .{p_0, p_1, p_2}); } // 0x2E65248609523599 0x1C5CCC3A b323
    pub inline fn leaderboardsCacheDataRow(p_0: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB9BB18E2C40142ED, .{p_0}); } // 0xB9BB18E2C40142ED 0x44F7D82B b323
    pub inline fn leaderboardsClearCacheData() !void { try invoker.invoke(void, 0xD4B02A6B476E1FDC, .{}); } // 0xD4B02A6B476E1FDC 0x87F498C1 b323
    pub inline fn leaderboardsClearCacheDataId(p_0: types.Any) !void { try invoker.invoke(void, 0x8EC74CEB042E7CFF, .{p_0}); } // 0x8EC74CEB042E7CFF 0x88AE9667 b323
    pub inline fn leaderboardsGetCacheExists(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9C51349BE6CDFE2C, .{p_0}); } // 0x9C51349BE6CDFE2C 0xFC8A71F3 b323
    pub inline fn leaderboardsGetCacheTime(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0xF04C1C27DA35F6C8, .{p_0}); } // 0xF04C1C27DA35F6C8 0xEDF02302 b323
    pub inline fn leaderboardsGetCacheNumberOfRows(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x58A651CD201D89AD, .{p_0}); } // 0x58A651CD201D89AD 0xCE7CB520 b323
    pub inline fn leaderboardsGetCacheDataRow(p_0: types.Any, p_1: types.Any, p_2: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9120E8DBA3D69273, .{p_0, p_1, p_2}); } // 0x9120E8DBA3D69273 0xA11289EC b323
    pub inline fn presenceEventUpdatestatInt(stat_hash: types.Hash, value: c_int, p_2: c_int) !void { try invoker.invoke(void, 0x11FF1C80276097ED, .{stat_hash, value, p_2}); } // 0x11FF1C80276097ED 0x4AC39C6C b323
    pub inline fn presenceEventUpdatestatFloat(stat_hash: types.Hash, value: f32, p_2: c_int) !void { try invoker.invoke(void, 0x30A6614C1F7799B8, .{stat_hash, value, p_2}); } // 0x30A6614C1F7799B8 0x3E69E7C3 b323
    pub inline fn presenceEventUpdatestatIntWithString(stat_hash: types.Hash, value: c_int, p_2: c_int, string: [*c]const u8) !void { try invoker.invoke(void, 0x6483C25849031C4F, .{stat_hash, value, p_2, string}); } // 0x6483C25849031C4F 0x2FFD2FA5 b323
    pub inline fn getPlayerHasDrivenAllVehicles() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5EAD2BF6484852E4, .{}); } // 0x5EAD2BF6484852E4 0x23D70C39 b323
    pub inline fn setHasPostedAllVehiclesDriven() !void { try invoker.invoke(void, 0xC141B8917E0017EC, .{}); } // 0xC141B8917E0017EC 0x0AD43306 b323
    pub inline fn setProfileSettingPrologueComplete() !void { try invoker.invoke(void, 0xB475F27C6A994D65, .{}); } // 0xB475F27C6A994D65 0xC7DE5C30 b323
    /// Sets profile setting 939
    pub inline fn setProfileSettingSpChopMissionComplete() !void { try invoker.invoke(void, 0xC67E2DA1CBE759E2, .{}); } // 0xC67E2DA1CBE759E2  b1734
    /// Sets profile setting 933
    pub inline fn setProfileSettingCreatorRacesDone(value: c_int) !void { try invoker.invoke(void, 0xF1A1803D3476F215, .{value}); } // 0xF1A1803D3476F215 0xA3DAC790 b323
    /// Sets profile setting 934
    pub inline fn setProfileSettingCreatorDmDone(value: c_int) !void { try invoker.invoke(void, 0x38BAAA5DD4C9D19F, .{value}); } // 0x38BAAA5DD4C9D19F 0x726FAE66 b323
    /// Sets profile setting 935
    pub inline fn setProfileSettingCreatorCtfDone(value: c_int) !void { try invoker.invoke(void, 0x55384438FC55AD8E, .{value}); } // 0x55384438FC55AD8E 0xF03895A4 b323
    pub inline fn setJobActivityIdStarted(p_0: types.Any, character_slot: c_int) !void { try invoker.invoke(void, 0x723C1CE13FBFDB67, .{p_0, character_slot}); } // 0x723C1CE13FBFDB67 0x4C39CF10 b323
    pub inline fn setFreemodePrologueDone(p_0: types.Any, character_slot: c_int) !void { try invoker.invoke(void, 0x0D01D20616FC73FB, .{p_0, character_slot}); } // 0x0D01D20616FC73FB 0x2180AE13 b323
    /// Sets profile setting 940 and 941
    pub inline fn setFreemodeStrandProgressionStatus(profile_setting: c_int, setting_value: c_int) !void { try invoker.invoke(void, 0x79D310A861697CC9, .{profile_setting, setting_value}); } // 0x79D310A861697CC9  b2699
    pub inline fn statNetworkIncrementOnSuicide(p_0: types.Any, p_1: f32) !void { try invoker.invoke(void, 0x428EAF89E24F6C36, .{p_0, p_1}); } // 0x428EAF89E24F6C36 0xEE292B91 b323
    pub inline fn statSetCheatIsActive() !void { try invoker.invoke(void, 0x047CBED6F6F8B63C, .{}); } // 0x047CBED6F6F8B63C 0xA063CABD b323
    pub inline fn leaderboards2WriteDataForEventType(p_0: [*c]types.Any, p_1: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC980E62E33DF1D5C, .{p_0, p_1}); } // 0xC980E62E33DF1D5C 0x62C19A3D b323
    pub inline fn forceCloudMpStatsDownloadAndOverwriteLocalSave() !void { try invoker.invoke(void, 0x6F361B8889A792A3, .{}); } // 0x6F361B8889A792A3 0x3B4EF322 b323
    pub inline fn statMigrateClearForRestart() !void { try invoker.invoke(void, 0xC847B43F369AC0B5, .{}); } // 0xC847B43F369AC0B5  b323
    /// platformName must be one of the following: ps3, xbox360, ps4, xboxone
    pub inline fn statMigrateSavegameStart(platform_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA5C80D8E768A9E66, .{platform_name}); } // 0xA5C80D8E768A9E66  b323
    pub inline fn statMigrateSavegameGetStatus() !c_int { return try invoker.invoke(c_int, 0x9A62EC95AE10E011, .{}); } // 0x9A62EC95AE10E011  b323
    pub inline fn statMigrateCheckAlreadyDone() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C89FE2BDEB3F169, .{}); } // 0x4C89FE2BDEB3F169  b323
    pub inline fn statMigrateCheckStart() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC6E0E2616A7576BB, .{}); } // 0xC6E0E2616A7576BB  b323
    pub inline fn statMigrateCheckGetIsPlatformAvailable(p_0: c_int) !c_int { return try invoker.invoke(c_int, 0x5BD5F255321C4AAF, .{p_0}); } // 0x5BD5F255321C4AAF  b323
    pub inline fn statMigrateCheckGetPlatformStatus(p_0: c_int, p_1: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0xDEAAF77EB3687E97, .{p_0, p_1}); } // 0xDEAAF77EB3687E97  b323
    pub inline fn statGetSaveMigrationStatus(data: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0x886913BBEACA68C1, .{data}); } // 0x886913BBEACA68C1 0xE3F0D62D b323
    pub inline fn statSaveMigrationCancelPendingOperation() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4FEF53183C3C6414, .{}); } // 0x4FEF53183C3C6414  b323
    pub inline fn statGetCancelSaveMigrationStatus() !c_int { return try invoker.invoke(c_int, 0x567384DFA67029E6, .{}); } // 0x567384DFA67029E6  b323
    pub inline fn statSaveMigrationConsumeContent(content_id: types.Hash, src_platform: [*c]const u8, src_gamer_handle: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3270F67EED31FBC1, .{content_id, src_platform, src_gamer_handle}); } // 0x3270F67EED31FBC1  b323
    pub inline fn statGetSaveMigrationConsumeContentStatus(p_0: [*c]c_int) !c_int { return try invoker.invoke(c_int, 0xCE5AA445ABA8DEE0, .{p_0}); } // 0xCE5AA445ABA8DEE0  b323
    pub inline fn statEnableStatsTracking() !void { try invoker.invoke(void, 0x98E2BC1CA26287C3, .{}); } // 0x98E2BC1CA26287C3  b323
    /// Prevents updates to CStatsMgr (e.g., STAT_SET_* natives)
    pub inline fn statDisableStatsTracking() !void { try invoker.invoke(void, 0x629526ABA383BCAA, .{}); } // 0x629526ABA383BCAA  b323
    pub inline fn statIsStatsTrackingEnabled() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBE3DB208333D9844, .{}); } // 0xBE3DB208333D9844  b463
    /// enum StatTrackingType \
    /// { \
    ///     LongestWheelie = 1,
    ///     LongestStoppie = 2,
    ///     NoCrashes = 3,
    ///     HighestSpeed = 4,
    ///     _MostFlips = 5,
    ///     _LongestSpin = 6,
    ///     _HighestJumpReached = 7,
    ///     LongestJump = 8,
    ///     _NearMissesNoCrash = 9,
    ///     LongestFallSurvived = 10,
    ///     LowestParachute = 11,
    ///     ReverseDriving = 12,
    ///     LongestFreefall = 13,
    ///     VehiclesStolen = 14,
    ///     _SomeCFireEventCount = 15,
    ///     _Unk16 = 16,
    ///     _LowFlyingTime = 17,
    ///     LowFlying = 18,
    ///     _InvertedFlyingTime = 19,
    ///     InvertedFlying = 20,
    ///     _PlaneSpinCount = 21,
    ///     MeleeKills = 22, // Players
    ///     _LongestSniperKill = 23,
    ///     SniperSkills = 24, // Players
    ///     DrivebyKills = 25, // Players
    ///     HeadshotKills = 26, // Players
    ///     LongestBail = 27,
    ///     _TotalRammedByCar = 28,
    ///     NearMissesPrecise = 29,
    ///     _FreefallTime = 30,
    ///     Unk31 = 31,
    /// }
    /// 
    /// enum StatTrackingValueType \
    /// { \
    ///     Total,
    ///     Max,
    ///     Min
    /// }
    pub inline fn statStartRecordStat(stat_type: c_int, value_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x33D72899E24C3365, .{stat_type, value_type}); } // 0x33D72899E24C3365  b463
    pub inline fn statStopRecordStat() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA761D4AC6115623D, .{}); } // 0xA761D4AC6115623D  b463
    pub inline fn statGetRecordedValue(value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF11F01D98113536A, .{value}); } // 0xF11F01D98113536A  b463
    pub inline fn statIsRecordingStat() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8B9CDBD6C566C38C, .{}); } // 0x8B9CDBD6C566C38C  b944
    /// Perform the most near misses with other vehicles in a land vehicle without crashing
    pub inline fn statGetCurrentNearMissNocrashPrecise() !c_int { return try invoker.invoke(c_int, 0xE8853FBCE7D8D0D6, .{}); } // 0xE8853FBCE7D8D0D6  b463
    /// Perform the longest wheelie on a motorcycle
    pub inline fn statGetCurrentRearWheelDistance() !f32 { return try invoker.invoke(f32, 0xA943FD1722E11EFD, .{}); } // 0xA943FD1722E11EFD  b463
    /// Perform the longest stoppie on a motorcycle
    pub inline fn statGetCurrentFrontWheelDistance() !f32 { return try invoker.invoke(f32, 0x84A810B375E69C0E, .{}); } // 0x84A810B375E69C0E  b463
    /// Perform the longest jump in a land vehicle
    pub inline fn statGetCurrentJumpDistance() !f32 { return try invoker.invoke(f32, 0x9EC8858184CD253A, .{}); } // 0x9EC8858184CD253A  b463
    /// Drive the furthest distance in a land vehicle without crashing
    pub inline fn statGetCurrentDriveNocrashDistance() !f32 { return try invoker.invoke(f32, 0xBA9749CC94C1FD85, .{}); } // 0xBA9749CC94C1FD85  b463
    /// Achieve the highest speed in a land vehicle
    pub inline fn statGetCurrentSpeed() !f32 { return try invoker.invoke(f32, 0x55A8BECAF28A4EB7, .{}); } // 0x55A8BECAF28A4EB7  b463
    /// Reverse the longest distance without crashing
    pub inline fn statGetCurrentDrivingReverseDistance() !f32 { return try invoker.invoke(f32, 0x32CAC93C9DE73D32, .{}); } // 0x32CAC93C9DE73D32  b463
    /// Fall the longest distance with a parachute before opening it
    pub inline fn statGetCurrentSkydivingDistance() !f32 { return try invoker.invoke(f32, 0xAFF47709F1D5DCCE, .{}); } // 0xAFF47709F1D5DCCE  b463
    /// Fly low to the ground for the longest distance
    pub inline fn statGetChallengeFlyingDist() !f32 { return try invoker.invoke(f32, 0x6E0A5253375C4584, .{}); } // 0x6E0A5253375C4584  b463
    pub inline fn statGetFlyingAltitude(out_value: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1A8EA222F9C67DBB, .{out_value}); } // 0x1A8EA222F9C67DBB  b463
    /// Or non-flyable area
    pub inline fn statIsPlayerVehicleAboveOcean() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF9F2922717B819EC, .{}); } // 0xF9F2922717B819EC  b505
    /// Travel the furthest distance when bailing from a vehicle
    pub inline fn statGetVehicleBailDistance() !f32 { return try invoker.invoke(f32, 0x0B8B7F74BF061C6D, .{}); } // 0x0B8B7F74BF061C6D  b463
    /// This function is hard-coded to always return 1.
    pub inline fn statRollbackSaveMigration() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB3DA2606774A8E2D, .{}); } // 0xB3DA2606774A8E2D  b323
    /// Sets profile setting 866
    pub inline fn setHasSpecialeditionContent(value: c_int) !void { try invoker.invoke(void, 0xDAC073C7901F9E15, .{value}); } // 0xDAC073C7901F9E15  b323
    /// Sets profile setting 501
    pub inline fn setSaveMigrationTransactionIdWarning(transaction_id: c_int) !void { try invoker.invoke(void, 0xF6792800AC95350D, .{transaction_id}); } // 0xF6792800AC95350D  b323
    pub inline fn getBossGoonUuid(character_slot: c_int, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x6BC0ACD0673ACEBE, .{character_slot, p_1, p_2}); } // 0x6BC0ACD0673ACEBE  b573
    pub inline fn playstatsBwBossonbossdeathmatch(p_0: types.Any) !void { try invoker.invoke(void, 0x8D8ADB562F09A245, .{p_0}); } // 0x8D8ADB562F09A245  b573
    pub inline fn playstatsBwYatchattack(p_0: types.Any) !void { try invoker.invoke(void, 0xD1A1EE3B4FA8E760, .{p_0}); } // 0xD1A1EE3B4FA8E760  b573
    pub inline fn playstatsBwHuntTheBoss(p_0: types.Any) !void { try invoker.invoke(void, 0x88087EE1F28024AE, .{p_0}); } // 0x88087EE1F28024AE  b573
    pub inline fn playstatsBwSightseer(p_0: types.Any) !void { try invoker.invoke(void, 0xFCC228E07217FCAC, .{p_0}); } // 0xFCC228E07217FCAC  b573
    pub inline fn playstatsBwAssault(p_0: types.Any) !void { try invoker.invoke(void, 0x678F86D8FC040BDB, .{p_0}); } // 0x678F86D8FC040BDB  b573
    pub inline fn playstatsBwBellyOfTheBeast(p_0: types.Any) !void { try invoker.invoke(void, 0xA6F54BB2FFCA35EA, .{p_0}); } // 0xA6F54BB2FFCA35EA  b573
    pub inline fn playstatsBwHeadHunter(p_0: types.Any) !void { try invoker.invoke(void, 0x5FF2C33B13A02A11, .{p_0}); } // 0x5FF2C33B13A02A11  b757
    pub inline fn playstatsBwFragileGoods(p_0: types.Any) !void { try invoker.invoke(void, 0x282B6739644F4347, .{p_0}); } // 0x282B6739644F4347  b757
    pub inline fn playstatsBwAirFreight(p_0: types.Any) !void { try invoker.invoke(void, 0xF06A6F41CB445443, .{p_0}); } // 0xF06A6F41CB445443  b757
    pub inline fn playstatsBcCarJacking(p_0: types.Any) !void { try invoker.invoke(void, 0x7B18DA61F6BAE9D5, .{p_0}); } // 0x7B18DA61F6BAE9D5  b573
    pub inline fn playstatsBcSmashAndGrab(p_0: types.Any) !void { try invoker.invoke(void, 0x06EAF70AE066441E, .{p_0}); } // 0x06EAF70AE066441E  b573
    pub inline fn playstatsBcProtectionRacket(p_0: types.Any) !void { try invoker.invoke(void, 0x14EDA9EE27BD1626, .{p_0}); } // 0x14EDA9EE27BD1626  b573
    pub inline fn playstatsBcMostWanted(p_0: types.Any) !void { try invoker.invoke(void, 0x930F504203F561C9, .{p_0}); } // 0x930F504203F561C9  b573
    pub inline fn playstatsBcFindersKeepers(p_0: types.Any) !void { try invoker.invoke(void, 0xE3261D791EB44ACB, .{p_0}); } // 0xE3261D791EB44ACB  b573
    pub inline fn playstatsBcPointToPoint(p_0: types.Any) !void { try invoker.invoke(void, 0x73001E34F85137F8, .{p_0}); } // 0x73001E34F85137F8  b573
    pub inline fn playstatsBcCashing(p_0: types.Any) !void { try invoker.invoke(void, 0x53CAE13E9B426993, .{p_0}); } // 0x53CAE13E9B426993  b757
    pub inline fn playstatsBcSalvage(p_0: types.Any) !void { try invoker.invoke(void, 0x7D36291161859389, .{p_0}); } // 0x7D36291161859389  b757
    pub inline fn playstatsSpentPiCustomLoadout(amount: c_int) !void { try invoker.invoke(void, 0xBE509B0A3693DE8B, .{amount}); } // 0xBE509B0A3693DE8B  b757
    pub inline fn playstatsBuyContrabandMission(data: [*c]types.Any) !void { try invoker.invoke(void, 0xD6781E42755531F7, .{data}); } // 0xD6781E42755531F7  b757
    pub inline fn playstatsSellContrabandMission(data: [*c]types.Any) !void { try invoker.invoke(void, 0xC729991A9065376E, .{data}); } // 0xC729991A9065376E  b757
    pub inline fn playstatsDefendContrabandMission(data: [*c]types.Any) !void { try invoker.invoke(void, 0x2605663BD4F23B5D, .{data}); } // 0x2605663BD4F23B5D  b757
    pub inline fn playstatsRecoverContrabandMission(data: [*c]types.Any) !void { try invoker.invoke(void, 0x04D90BA8207ADA2D, .{data}); } // 0x04D90BA8207ADA2D  b757
    pub inline fn playstatsHitContrabandDestroyLimit(p_0: types.Any) !void { try invoker.invoke(void, 0x60EEDC12AF66E846, .{p_0}); } // 0x60EEDC12AF66E846  b757
    pub inline fn startBeingBoss(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x3EBEAC6C3F81F6BD, .{p_0, p_1, p_2}); } // 0x3EBEAC6C3F81F6BD  b573
    pub inline fn startBeingGoon(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x96E6D5150DBF1C09, .{p_0, p_1, p_2}); } // 0x96E6D5150DBF1C09  b573
    pub inline fn endBeingBoss(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xA3C53804BDB68ED2, .{p_0, p_1, p_2}); } // 0xA3C53804BDB68ED2  b573
    pub inline fn endBeingGoon(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x6BCCF9948492FD85, .{p_0, p_1, p_2, p_3, p_4}); } // 0x6BCCF9948492FD85  b573
    pub inline fn hiredLimo(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x792271AB35C356A4, .{p_0, p_1}); } // 0x792271AB35C356A4  b573
    pub inline fn orderBossVehicle(p_0: types.Any, p_1: types.Any, vehicle_hash: types.Hash) !void { try invoker.invoke(void, 0xCEA553E35C2246E1, .{p_0, p_1, vehicle_hash}); } // 0xCEA553E35C2246E1  b573
    pub inline fn changeUniform(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xD1C9B92BDD3F151D, .{p_0, p_1, p_2}); } // 0xD1C9B92BDD3F151D  b573
    pub inline fn changeGoonLookingForWork(p_0: types.Any) !void { try invoker.invoke(void, 0x44919CC079BB60BF, .{p_0}); } // 0x44919CC079BB60BF  b573
    pub inline fn sendMetricGhostingToPlayer(p_0: types.Any) !void { try invoker.invoke(void, 0x7033EEFD9B28088E, .{p_0}); } // 0x7033EEFD9B28088E  b678
    pub inline fn sendMetricVipPoach(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xAA525DFF66BB82F5, .{p_0, p_1, p_2}); } // 0xAA525DFF66BB82F5  b757
    pub inline fn sendMetricPunishBodyguard(p_0: types.Any) !void { try invoker.invoke(void, 0x015B03EE1C43E6EC, .{p_0}); } // 0x015B03EE1C43E6EC  b757
    /// Allows CEventNetworkStuntPerformed to be triggered.
    pub inline fn playstatsStartTrackingStunts() !void { try invoker.invoke(void, 0x928DBFB892638EF3, .{}); } // 0x928DBFB892638EF3  b791
    /// Disallows CEventNetworkStuntPerformed to be triggered.
    pub inline fn playstatsStopTrackingStunts() !void { try invoker.invoke(void, 0x8A800DACCC0DA55D, .{}); } // 0x8A800DACCC0DA55D  b791
    pub inline fn playstatsMissionEnded(p_0: types.Any) !void { try invoker.invoke(void, 0xBF371CD2B64212FD, .{p_0}); } // 0xBF371CD2B64212FD  b877
    pub inline fn playstatsImpexpMissionEnded(p_0: types.Any) !void { try invoker.invoke(void, 0x7D8BA05688AD64C7, .{p_0}); } // 0x7D8BA05688AD64C7  b944
    pub inline fn playstatsChangeMcRole(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, role: c_int, p_5: c_int, p_6: types.Any) !void { try invoker.invoke(void, 0x0B565B0AAE56A0E8, .{p_0, p_1, p_2, p_3, role, p_5, p_6}); } // 0x0B565B0AAE56A0E8  b877
    pub inline fn playstatsChangeMcOutfit(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x28ECB8AC2F607DB2, .{p_0, p_1, p_2, p_3, p_4}); } // 0x28ECB8AC2F607DB2  b877
    pub inline fn playstatsSwitchMcEmblem(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x0A50D2604E05CB94, .{p_0, p_1, p_2, p_3, p_4}); } // 0x0A50D2604E05CB94  b877
    pub inline fn playstatsMcRequestBike(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xCC25A4553DFBF9EA, .{p_0, p_1, p_2, p_3, p_4}); } // 0xCC25A4553DFBF9EA  b877
    pub inline fn playstatsMcKilledRivalMcMember(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xF534D94DFA2EAD26, .{p_0, p_1, p_2, p_3, p_4}); } // 0xF534D94DFA2EAD26  b877
    pub inline fn playstatsAbandonedMc(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0xD558BEC0BBA7E8D2, .{p_0, p_1, p_2, p_3, p_4}); } // 0xD558BEC0BBA7E8D2  b877
    pub inline fn playstatsEarnedMcPoints(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0x501478855A6074CE, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x501478855A6074CE  b877
    pub inline fn playstatsMcFormationEnds(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !void { try invoker.invoke(void, 0x03C2EEBB04B3FB72, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x03C2EEBB04B3FB72  b877
    pub inline fn playstatsMcClubhouseActivity(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any) !void { try invoker.invoke(void, 0x8989CBD7B4E82534, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7}); } // 0x8989CBD7B4E82534  b877
    pub inline fn playstatsRivalBehavior(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: types.Any) !void { try invoker.invoke(void, 0x27AA1C973CACFE63, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9}); } // 0x27AA1C973CACFE63  b944
    pub inline fn playstatsCopyRankIntoNewSlot(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !void { try invoker.invoke(void, 0xB7257BA2550EA10A, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0xB7257BA2550EA10A  b877
    pub inline fn playstatsDupeDetected(data: [*c]types.Any) !void { try invoker.invoke(void, 0x848B66100EE33B05, .{data}); } // 0x848B66100EE33B05  b1011
    pub inline fn playstatsBanAlert(p_0: c_int) !void { try invoker.invoke(void, 0x516FC96EB88EEFE5, .{p_0}); } // 0x516FC96EB88EEFE5  b1011
    pub inline fn playstatsGunrunningMissionEnded(data: [*c]types.Any) !void { try invoker.invoke(void, 0x0EACDF8487D5155A, .{data}); } // 0x0EACDF8487D5155A  b1103
    pub inline fn playstatsGunrunningRnd(p_0: types.Any) !void { try invoker.invoke(void, 0xDAF80797FC534BEC, .{p_0}); } // 0xDAF80797FC534BEC  b1103
    pub inline fn playstatsBusinessBattleEnded(p_0: types.Any) !void { try invoker.invoke(void, 0x316DB59CD14C1774, .{p_0}); } // 0x316DB59CD14C1774  b1493
    pub inline fn playstatsWarehouseMissionEnded(p_0: types.Any) !void { try invoker.invoke(void, 0x2D7A9B577E72385E, .{p_0}); } // 0x2D7A9B577E72385E  b1493
    pub inline fn playstatsNightclubMissionEnded(p_0: types.Any) !void { try invoker.invoke(void, 0x830C3A44EB3F2CF9, .{p_0}); } // 0x830C3A44EB3F2CF9  b1493
    pub inline fn playstatsDjUsage(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xB26F670685631727, .{p_0, p_1}); } // 0xB26F670685631727  b1493
    pub inline fn playstatsMinigameUsage(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xC14BD9F5337219B2, .{p_0, p_1, p_2}); } // 0xC14BD9F5337219B2  b1493
    pub inline fn playstatsStoneHatchetEnded(data: [*c]types.Any) !void { try invoker.invoke(void, 0x35E39E5570358630, .{data}); } // 0x35E39E5570358630  b1493
    pub inline fn playstatsSmugglerMissionEnded(data: [*c]types.Any) !void { try invoker.invoke(void, 0x320C35147D5B5DDD, .{data}); } // 0x320C35147D5B5DDD  b1180
    pub inline fn playstatsFmHeistPrepEnded(data: [*c]types.Any) !void { try invoker.invoke(void, 0xD8AFB345A9C5CCBB, .{data}); } // 0xD8AFB345A9C5CCBB  b1290
    pub inline fn playstatsInstancedHeistEnded(data: [*c]types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x1E1497D0D2108115, .{data, p_1, p_2, p_3}); } // 0x1E1497D0D2108115  b1290
    pub inline fn playstatsDarCheckpoint(data: [*c]types.Any) !void { try invoker.invoke(void, 0x0BC254FF3A911501, .{data}); } // 0x0BC254FF3A911501  b1290
    pub inline fn playstatsEnterSessionPack(data: [*c]types.Any) !void { try invoker.invoke(void, 0x878FF156D36E9956, .{data}); } // 0x878FF156D36E9956  b1290
    pub inline fn playstatsDroneUsage(p_0: c_int, p_1: c_int, p_2: c_int) !void { try invoker.invoke(void, 0x66C7BB2416ED3FCE, .{p_0, p_1, p_2}); } // 0x66C7BB2416ED3FCE  b1493
    pub inline fn playstatsSpinWheel(p_0: c_int, p_1: c_int, p_2: c_int, p_3: c_int) !void { try invoker.invoke(void, 0x6731DE84A38BFAD0, .{p_0, p_1, p_2, p_3}); } // 0x6731DE84A38BFAD0  b1604
    pub inline fn playstatsArenaWarsSpectator(p_0: c_int, p_1: c_int, p_2: c_int, p_3: c_int, p_4: c_int) !void { try invoker.invoke(void, 0x6F4F599753F8200A, .{p_0, p_1, p_2, p_3, p_4}); } // 0x6F4F599753F8200A  b1604
    pub inline fn playstatsArenaWarsEnded(data: [*c]types.Any) !void { try invoker.invoke(void, 0xB479D9F0D48A1BC5, .{data}); } // 0xB479D9F0D48A1BC5  b1604
    pub inline fn playstatsSwitchPassiveMode(p_0: windows.BOOL, p_1: c_int, p_2: c_int, p_3: c_int) !void { try invoker.invoke(void, 0x35EEC6C2BC821A71, .{p_0, p_1, p_2, p_3}); } // 0x35EEC6C2BC821A71  b1734
    pub inline fn playstatsCollectiblePickedUp(p_0: c_int, object_hash: types.Hash, p_2: types.Any, p_3: types.Any, money_amount: c_int, rp_amount: c_int, chips_amount: c_int, p_7: types.Any, p_8: c_int, p_9: types.Any, p_1_0: types.Any) !void { try invoker.invoke(void, 0xCD0A8A9338681CF2, .{p_0, object_hash, p_2, p_3, money_amount, rp_amount, chips_amount, p_7, p_8, p_9, p_1_0}); } // 0xCD0A8A9338681CF2  b1734
    pub inline fn playstatsCasinoStoryMissionEnded(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xFCCCAC2BD3C1F180, .{p_0, p_1}); } // 0xFCCCAC2BD3C1F180  b1734
    pub inline fn playstatsCasinoChip(p_0: types.Any) !void { try invoker.invoke(void, 0x0999F3F090EC5012, .{p_0}); } // 0x0999F3F090EC5012  b1734
    pub inline fn playstatsCasinoRoulette(p_0: types.Any) !void { try invoker.invoke(void, 0x95101C443A84E7F1, .{p_0}); } // 0x95101C443A84E7F1  b1734
    pub inline fn playstatsCasinoBlackjack(p_0: types.Any) !void { try invoker.invoke(void, 0x3EAE97309727E7AD, .{p_0}); } // 0x3EAE97309727E7AD  b1734
    pub inline fn playstatsCasinoThreeCardPoker(p_0: types.Any) !void { try invoker.invoke(void, 0xF740FB339D471C35, .{p_0}); } // 0xF740FB339D471C35  b1734
    pub inline fn playstatsCasinoSlotMachine(p_0: types.Any) !void { try invoker.invoke(void, 0xEF5EC67D392B830A, .{p_0}); } // 0xEF5EC67D392B830A  b1734
    pub inline fn playstatsCasinoInsideTrack(p_0: types.Any) !void { try invoker.invoke(void, 0x049F059625058A86, .{p_0}); } // 0x049F059625058A86  b1734
    pub inline fn playstatsCasinoLuckySeven(p_0: types.Any) !void { try invoker.invoke(void, 0x0C432C1435F5E4FA, .{p_0}); } // 0x0C432C1435F5E4FA  b1734
    pub inline fn playstatsCasinoRouletteLight(p_0: types.Any) !void { try invoker.invoke(void, 0x6572ABA3DE1197FC, .{p_0}); } // 0x6572ABA3DE1197FC  b1734
    pub inline fn playstatsCasinoBlackjackLight(p_0: types.Any) !void { try invoker.invoke(void, 0xD5451C7BF151EB6F, .{p_0}); } // 0xD5451C7BF151EB6F  b1734
    pub inline fn playstatsCasinoThreeCardPokerLight(p_0: types.Any) !void { try invoker.invoke(void, 0xC9001364B4388F22, .{p_0}); } // 0xC9001364B4388F22  b1734
    pub inline fn playstatsCasinoSlotMachineLight(p_0: types.Any) !void { try invoker.invoke(void, 0xE60054A0FAE8227F, .{p_0}); } // 0xE60054A0FAE8227F  b1734
    pub inline fn playstatsCasinoInsideTrackLight(p_0: types.Any) !void { try invoker.invoke(void, 0x23A3CBCD50D54E47, .{p_0}); } // 0x23A3CBCD50D54E47  b1734
    pub inline fn playstatsArcadeGame(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any) !void { try invoker.invoke(void, 0x533A7D1EA58DF958, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x533A7D1EA58DF958  b1734
    pub inline fn playstatsArcadeLoveMatch(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x4FCDBD3F0A813C25, .{p_0, p_1}); } // 0x4FCDBD3F0A813C25  b1868
    pub inline fn playstatsFreemodeCasinoMissionEnded(data: [*c]types.Any) !void { try invoker.invoke(void, 0x1A0D4A6C336B7BC5, .{data}); } // 0x1A0D4A6C336B7BC5  b1734
    pub inline fn playstatsHeist3Drone(p_0: types.Any) !void { try invoker.invoke(void, 0xDFBD93BF2943E29B, .{p_0}); } // 0xDFBD93BF2943E29B  b1868
    pub inline fn playstatsHeist3Hack(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0x92FC0EEDFAC04A14, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0x92FC0EEDFAC04A14  b1868
    pub inline fn playstatsNpcPhone(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x0077F15613D36993, .{p_0}); } // 0x0077F15613D36993  b1868
    pub inline fn playstatsArcadeCabinet(p_0: types.Any) !void { try invoker.invoke(void, 0xF9096193DF1F99D4, .{p_0}); } // 0xF9096193DF1F99D4  b1868
    pub inline fn playstatsHeist3Finale(p_0: types.Any) !void { try invoker.invoke(void, 0x2E0259BABC27A327, .{p_0}); } // 0x2E0259BABC27A327  b1868
    pub inline fn playstatsHeist3Prep(p_0: types.Any) !void { try invoker.invoke(void, 0x53C31853EC9531FF, .{p_0}); } // 0x53C31853EC9531FF  b1868
    pub inline fn playstatsMasterControl(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x810B5FCC52EC7FF0, .{p_0, p_1, p_2, p_3, p_4}); } // 0x810B5FCC52EC7FF0  b1868
    pub inline fn playstatsQuitMode(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x5BF29846C6527C54, .{p_0, p_1, p_2, p_3, p_4}); } // 0x5BF29846C6527C54  b1868
    pub inline fn playstatsMissionVote(p_0: types.Any) !void { try invoker.invoke(void, 0xC03FAB2C2F92289B, .{p_0}); } // 0xC03FAB2C2F92289B  b1868
    pub inline fn playstatsNjvsVote(p_0: types.Any) !void { try invoker.invoke(void, 0x5CDAED54B34B0ED0, .{p_0}); } // 0x5CDAED54B34B0ED0  b1868
    pub inline fn playstatsDeathInfo_(victim_ped: types.Ped, killer_ped: types.Ped, mental_state: c_int, revenge_kill: windows.BOOL, victim_kv_k: c_int, killer_kv_k: c_int) !void { try invoker.invoke(void, 0x01D8B04D02F1217F, .{victim_ped, killer_ped, mental_state, revenge_kill, victim_kv_k, killer_kv_k}); } // 0x01D8B04D02F1217F  b3570
    pub inline fn playstatsFmMissionEnd(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x46A70777BE6CEAB9, .{p_0, p_1, p_2, p_3}); } // 0x46A70777BE6CEAB9  b2545
    pub inline fn playstatsHeist4Prep(p_0: types.Any) !void { try invoker.invoke(void, 0xDFCDB14317A9B361, .{p_0}); } // 0xDFCDB14317A9B361  b2189
    pub inline fn playstatsHeist4Finale(p_0: types.Any) !void { try invoker.invoke(void, 0xC1E963C58664B556, .{p_0}); } // 0xC1E963C58664B556  b2189
    pub inline fn playstatsHeist4Hack(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x2FA3173480008493, .{p_0, p_1, p_2, p_3, p_4}); } // 0x2FA3173480008493  b2189
    pub inline fn playstatsSubWeap(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xD4367D310F079DB0, .{p_0, p_1, p_2, p_3}); } // 0xD4367D310F079DB0  b2189
    pub inline fn playstatsFastTrvl(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any, p_9: types.Any, p_1_0: types.Any) !void { try invoker.invoke(void, 0x4DC416F246A41FC8, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, p_9, p_1_0}); } // 0x4DC416F246A41FC8  b2189
    pub inline fn playstatsHubEntry(p_0: types.Any) !void { try invoker.invoke(void, 0x2818FF6638CB09DE, .{p_0}); } // 0x2818FF6638CB09DE  b2189
    pub inline fn playstatsDjMissionEnded(p_0: types.Any) !void { try invoker.invoke(void, 0xD6CA58B3B53A0F22, .{p_0}); } // 0xD6CA58B3B53A0F22  b2189
    pub inline fn playstatsRobberyPrep(p_0: types.Any) !void { try invoker.invoke(void, 0x1A67DFBF1F5C3835, .{p_0}); } // 0x1A67DFBF1F5C3835  b2372
    pub inline fn playstatsRobberyFinale(p_0: types.Any) !void { try invoker.invoke(void, 0xBBA55BE9AAAABF44, .{p_0}); } // 0xBBA55BE9AAAABF44  b2372
    pub inline fn playstatsExtraEvent(p_0: types.Any) !void { try invoker.invoke(void, 0xFA5B74BAB8A7EF99, .{p_0}); } // 0xFA5B74BAB8A7EF99  b2372
    pub inline fn playstatsCarclubPoints(p_0: types.Any) !void { try invoker.invoke(void, 0xFF14D6FEEC507BBE, .{p_0}); } // 0xFF14D6FEEC507BBE  b2372
    pub inline fn playstatsCarclubChallenge(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x1187CB58D7F3BED7, .{p_0, p_1, p_2, p_3}); } // 0x1187CB58D7F3BED7  b2372
    pub inline fn playstatsCarclubPrize(p_0: c_int, vehicle_model: types.Hash) !void { try invoker.invoke(void, 0x69C922B677621428, .{p_0, vehicle_model}); } // 0x69C922B677621428  b2372
    pub inline fn playstatsAwardNav(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x70F52471E758EBAE, .{p_0, p_1, p_2, p_3}); } // 0x70F52471E758EBAE  b2545
    pub inline fn playstatsInitMultiplayer_(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x7E5EED10B11CEDBA, .{p_0, p_1, p_2}); } // 0x7E5EED10B11CEDBA  b3407
    pub inline fn playstatsInstMissionEnd(p_0: types.Any) !void { try invoker.invoke(void, 0xFEA3F7E83C0610FA, .{p_0}); } // 0xFEA3F7E83C0610FA  b2545
    pub inline fn playstatsHubExit(p_0: types.Any) !void { try invoker.invoke(void, 0x5A46ACE5C4661132, .{p_0}); } // 0x5A46ACE5C4661132  b2545
    pub inline fn playstatsVehDel(boss_id_1: c_int, boss_id_2: c_int, boss_type: c_int, vehicle_i_d: c_int, reason: c_int) !void { try invoker.invoke(void, 0x10A691F5756416D0, .{boss_id_1, boss_id_2, boss_type, vehicle_i_d, reason}); } // 0x10A691F5756416D0  b2944
    pub inline fn playstatsInventory(p_0: types.Any) !void { try invoker.invoke(void, 0x887DAD63CF5B7908, .{p_0}); } // 0x887DAD63CF5B7908  b2699
    pub inline fn playstatsAcidMissionEnd_(p_0: types.Any) !void { try invoker.invoke(void, 0x8A23D1324F6B2BAC, .{p_0}); } // 0x8A23D1324F6B2BAC  b2802
    pub inline fn playstatsAcidRnd_(p_0: types.Any) !void { try invoker.invoke(void, 0xCEACCF0550FDC5BA, .{p_0}); } // 0xCEACCF0550FDC5BA  b2802
    pub inline fn playstatsIdle_(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xEC9553A178E8F1D1, .{p_0, p_1, p_2}); } // 0xEC9553A178E8F1D1  b2802
    pub inline fn playstatsPlayerStyle_(p_0: types.Any) !void { try invoker.invoke(void, 0x48FAC5DC7AC6EA99, .{p_0}); } // 0x48FAC5DC7AC6EA99  b2802
    pub inline fn playstatsRandomEvent_(p_0: types.Any) !void { try invoker.invoke(void, 0x7EA06F970F999394, .{p_0}); } // 0x7EA06F970F999394  b2944
    pub inline fn playstatsAlert_(data: [*c]types.Any) !void { try invoker.invoke(void, 0x5649CA22AF74E019, .{data}); } // 0x5649CA22AF74E019  b3095
    pub inline fn playstatsAttritionStageEnd_(p_0: types.Any) !void { try invoker.invoke(void, 0xBD642335A732F1A8, .{p_0}); } // 0xBD642335A732F1A8  b2944
    pub inline fn playstatsShowroomNav_(p_0: types.Any, p_1: types.Any, entity: types.Hash) !void { try invoker.invoke(void, 0x961D4157B9B428DB, .{p_0, p_1, entity}); } // 0x961D4157B9B428DB  b2944
    /// Data struct contains various tunables related to test drives at Simeons Showroom or Luxury Showcase.
    pub inline fn playstatsShowroomOverview_(data: [*c]types.Any) !void { try invoker.invoke(void, 0x151D6C04C9E2742F, .{data}); } // 0x151D6C04C9E2742F  b2944
    pub inline fn playstatsPimenuNav_(data: [*c]types.Any) !void { try invoker.invoke(void, 0xE6D323A5E9EFFB76, .{data}); } // 0xE6D323A5E9EFFB76  b3258
    pub inline fn playstatsRecoverVehicle_(data: [*c]types.Any) !void { try invoker.invoke(void, 0xBEB0D930B3CCE4D5, .{data}); } // 0xBEB0D930B3CCE4D5  b3258
    pub inline fn playstatsScriptEventFpom_(data: [*c]types.Any) !void { try invoker.invoke(void, 0x574A7808450E141C, .{data}); } // 0x574A7808450E141C  b3570
    pub inline fn playstatsLobbyExit_(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x4649D80CE1A35BA1, .{p_0}); } // 0x4649D80CE1A35BA1  b3717
    pub inline fn playstatsLobbyStarted_(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0xDC00BB9C27347A8F, .{p_0}); } // 0xDC00BB9C27347A8F  b3717
    pub inline fn playstatsCreatorEnd_(p_0: [*c]types.Any) !void { try invoker.invoke(void, 0x72289B8C78B02962, .{p_0}); } // 0x72289B8C78B02962  b3717
};

pub const Streaming = struct
{
    pub inline fn loadAllObjectsNow() !void { try invoker.invoke(void, 0xBD6E84632DD4CB3F, .{}); } // 0xBD6E84632DD4CB3F 0xC9DBDA90 b323
    pub inline fn loadScene(vec: types.Vector3) !void { try invoker.invoke(void, 0x4448EB75B4904BDB, .{vec.x, vec.y, vec.z}); } // 0x4448EB75B4904BDB 0xB72403F5 b323
    pub inline fn networkUpdateLoadScene() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC4582015556D1C46, .{}); } // 0xC4582015556D1C46 0xC76E023C b323
    pub inline fn isNetworkLoadingScene() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x41CA5A33160EA4AB, .{}); } // 0x41CA5A33160EA4AB 0x6DCFC021 b323
    pub inline fn setInteriorActive(interior_i_d: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE37B76C387BE28ED, .{interior_i_d, toggle}); } // 0xE37B76C387BE28ED 0xE1013910 b323
    /// Request a model to be loaded into memory.
    /// 
    pub inline fn requestModel(model: types.Hash) !void { try invoker.invoke(void, 0x963D27A58DF860AC, .{model}); } // 0x963D27A58DF860AC 0xFFF1B500 b323
    pub inline fn requestMenuPedModel(model: types.Hash) !void { try invoker.invoke(void, 0xA0261AEF7ACFC51E, .{model}); } // 0xA0261AEF7ACFC51E 0x48CEB6B4 b323
    /// Checks if the specified model has loaded into memory.
    pub inline fn hasModelLoaded(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x98A4EB5D89A0C952, .{model}); } // 0x98A4EB5D89A0C952 0x62BFDB37 b323
    /// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "V_FIB01_cur_elev"); \
    /// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "limbo"); \
    /// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BB, "V_Office_gnd_lifts"); \
    /// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BB, "limbo"); \
    /// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "v_fib01_jan_elev"); \
    /// STREAMING::REQUEST_MODELS_IN_ROOM(l_13BC, "limbo");
    pub inline fn requestModelsInRoom(interior: types.Interior, room_name: [*c]const u8) !void { try invoker.invoke(void, 0x8A7A40100EDFEC58, .{interior, room_name}); } // 0x8A7A40100EDFEC58 0x939243FB b323
    /// Unloads model from memory
    pub inline fn setModelAsNoLongerNeeded(model: types.Hash) !void { try invoker.invoke(void, 0xE532F5D78798DAAB, .{model}); } // 0xE532F5D78798DAAB 0xAE0F069E b323
    /// Check if model is in cdimage(rpf)
    pub inline fn isModelInCdimage(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x35B9E0803292B641, .{model}); } // 0x35B9E0803292B641 0x1094782F b323
    /// Returns whether the specified model exists in the game.
    pub inline fn isModelValid(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC0296A2EDF545E92, .{model}); } // 0xC0296A2EDF545E92 0xAF8F8E9D b323
    pub inline fn isModelAPed(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x75816577FEA6DAD5, .{model}); } // 0x75816577FEA6DAD5  b1103
    /// Returns whether the specified model represents a vehicle.
    pub inline fn isModelAVehicle(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x19AAC8F07BFEC53E, .{model}); } // 0x19AAC8F07BFEC53E 0xFFFC85D4 b323
    pub inline fn requestCollisionAtCoord(vec: types.Vector3) !void { try invoker.invoke(void, 0x07503F7948F491A7, .{vec.x, vec.y, vec.z}); } // 0x07503F7948F491A7 0xCD9805E7 b323
    pub inline fn requestCollisionForModel(model: types.Hash) !void { try invoker.invoke(void, 0x923CB32A3B874FCB, .{model}); } // 0x923CB32A3B874FCB 0x3930C042 b323
    pub inline fn hasCollisionForModelLoaded(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x22CCA434E368F03A, .{model}); } // 0x22CCA434E368F03A 0x41A094F8 b323
    /// Alias of REQUEST_COLLISION_AT_COORD.
    pub inline fn requestAdditionalCollisionAtCoord(vec: types.Vector3) !void { try invoker.invoke(void, 0xC9156DC11411A9EA, .{vec.x, vec.y, vec.z}); } // 0xC9156DC11411A9EA 0xC2CC1DF2 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn doesAnimDictExist(anim_dict: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2DA49C3B79856961, .{anim_dict}); } // 0x2DA49C3B79856961 0xCD31C872 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn requestAnimDict(anim_dict: [*c]const u8) !void { try invoker.invoke(void, 0xD3BD40951412FEF6, .{anim_dict}); } // 0xD3BD40951412FEF6 0xDCA96950 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn hasAnimDictLoaded(anim_dict: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD031A9162D01088C, .{anim_dict}); } // 0xD031A9162D01088C 0x05E6763C b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn removeAnimDict(anim_dict: [*c]const u8) !void { try invoker.invoke(void, 0xF66A602F829E2A06, .{anim_dict}); } // 0xF66A602F829E2A06 0x0AE050B5 b323
    /// Starts loading the specified animation set. An animation set provides movement animations for a ped. See SET_PED_MOVEMENT_CLIPSET.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn requestAnimSet(anim_set: [*c]const u8) !void { try invoker.invoke(void, 0x6EA47DAE7FAD0EED, .{anim_set}); } // 0x6EA47DAE7FAD0EED 0x2988B3FC b323
    /// Gets whether the specified animation set has finished loading. An animation set provides movement animations for a ped. See SET_PED_MOVEMENT_CLIPSET.
    /// 
    /// Animation set and clip set are synonymous.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn hasAnimSetLoaded(anim_set: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC4EA073D86FB29B0, .{anim_set}); } // 0xC4EA073D86FB29B0 0x4FFF397D b323
    /// Unloads the specified animation set. An animation set provides movement animations for a ped. See SET_PED_MOVEMENT_CLIPSET.
    /// 
    /// Animation set and clip set are synonymous.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn removeAnimSet(anim_set: [*c]const u8) !void { try invoker.invoke(void, 0x16350528F93024B3, .{anim_set}); } // 0x16350528F93024B3 0xD04A817A b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn requestClipSet(clip_set: [*c]const u8) !void { try invoker.invoke(void, 0xD2A71E1A77418A49, .{clip_set}); } // 0xD2A71E1A77418A49 0x546C627A b323
    /// Alias for HAS_ANIM_SET_LOADED.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn hasClipSetLoaded(clip_set: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x318234F4F3738AF3, .{clip_set}); } // 0x318234F4F3738AF3 0x230D5455 b323
    /// Alias for REMOVE_ANIM_SET.
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// Full list of movement clipsets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/movementClipsetsCompact.json
    pub inline fn removeClipSet(clip_set: [*c]const u8) !void { try invoker.invoke(void, 0x01F73A131C18CD94, .{clip_set}); } // 0x01F73A131C18CD94 0x1E21F7AA b323
    /// Exemple: REQUEST_IPL("TrevorsTrailerTrash");
    /// 
    /// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
    pub inline fn requestIpl(ipl_name: [*c]const u8) !void { try invoker.invoke(void, 0x41B4893843BBDB74, .{ipl_name}); } // 0x41B4893843BBDB74 0x3B70D1DB b323
    /// Removes an IPL from the map.
    /// 
    /// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
    /// 
    /// Example: \
    /// C#: \
    /// Function.Call(Hash.REMOVE_IPL, "trevorstrailertidy");
    /// 
    /// C++: \
    /// STREAMING::REMOVE_IPL("trevorstrailertidy");
    /// 
    /// iplName = Name of IPL you want to remove.
    pub inline fn removeIpl(ipl_name: [*c]const u8) !void { try invoker.invoke(void, 0xEE6C5AD3ECE0A82D, .{ipl_name}); } // 0xEE6C5AD3ECE0A82D 0xDF7CBD36 b323
    /// Full list of IPLs and interior entity sets by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/ipls.json
    pub inline fn isIplActive(ipl_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x88A741E44A2B3495, .{ipl_name}); } // 0x88A741E44A2B3495 0xB2C33714 b323
    pub inline fn setStreaming(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6E0C692677008888, .{toggle}); } // 0x6E0C692677008888 0x27EF6CB2 b323
    /// 0 - default \
    /// 1 - HeistIsland
    pub inline fn loadGlobalWaterFile(water_type: c_int) !void { try invoker.invoke(void, 0x7E3F55ED251B76D3, .{water_type}); } // 0x7E3F55ED251B76D3  b2189
    pub inline fn getGlobalWaterFile() !c_int { return try invoker.invoke(c_int, 0xF741BD853611592D, .{}); } // 0xF741BD853611592D  b2189
    pub inline fn setGamePausesForStreaming(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x717CD6E6FAEBBEDC, .{toggle}); } // 0x717CD6E6FAEBBEDC 0x9211A28A b323
    pub inline fn setReducePedModelBudget(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x77B5F9A36BF96710, .{toggle}); } // 0x77B5F9A36BF96710 0xAFCB2B86 b323
    pub inline fn setReduceVehicleModelBudget(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x80C527893080CCF3, .{toggle}); } // 0x80C527893080CCF3 0xCDB4FB7E b323
    /// This is a NOP function. It does nothing at all.
    pub inline fn setDitchPoliceModels(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x42CBE54462D92634, .{toggle}); } // 0x42CBE54462D92634 0x3EA7FCE4 b323
    pub inline fn getNumberOfStreamingRequests() !c_int { return try invoker.invoke(c_int, 0x4060057271CEBC89, .{}); } // 0x4060057271CEBC89 0xC2EE9A02 b323
    /// maps script name (thread + 0xD0) by lookup via scriptfx.dat - does nothing when script name is empty
    pub inline fn requestPtfxAsset() !void { try invoker.invoke(void, 0x944955FB2A3935C8, .{}); } // 0x944955FB2A3935C8 0x2C649263 b323
    pub inline fn hasPtfxAssetLoaded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCA7D9B86ECA7481B, .{}); } // 0xCA7D9B86ECA7481B 0x3EFF96BE b323
    pub inline fn removePtfxAsset() !void { try invoker.invoke(void, 0x88C6814073DD4A73, .{}); } // 0x88C6814073DD4A73 0xC10F178C b323
    ///  From the b678d decompiled scripts:
    /// 
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("core_snow"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("fm_mission_controler"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("proj_xmas_firework"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_apartment_mp"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_biolab_heist"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_indep_fireworks"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_indep_parachute"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_indep_wheelsmoke"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_mp_cig_plane"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_mp_creator"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_mp_tankbattle"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_ornate_heist"); \
    ///  STREAMING::REQUEST_NAMED_PTFX_ASSET("scr_prison_break_heist_station");
    pub inline fn requestNamedPtfxAsset(fx_name: [*c]const u8) !void { try invoker.invoke(void, 0xB80D8756B4668AB6, .{fx_name}); } // 0xB80D8756B4668AB6 0xCFEA19A9 b323
    pub inline fn hasNamedPtfxAssetLoaded(fx_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8702416E512EC454, .{fx_name}); } // 0x8702416E512EC454 0x9ACC6446 b323
    pub inline fn removeNamedPtfxAsset(fx_name: [*c]const u8) !void { try invoker.invoke(void, 0x5F61EBBE1A00F96D, .{fx_name}); } // 0x5F61EBBE1A00F96D 0xC44762A1 b323
    pub inline fn setVehiclePopulationBudget(p_0: c_int) !void { try invoker.invoke(void, 0xCB9E1EB3BE2AF4E9, .{p_0}); } // 0xCB9E1EB3BE2AF4E9 0x1D56993C b323
    /// Control how many new (ambient?) peds will spawn in the game world. \
    /// Range for p0 seems to be 0-3, where 0 is none and 3 is the normal level.
    pub inline fn setPedPopulationBudget(p_0: c_int) !void { try invoker.invoke(void, 0x8C95333CFC3340F3, .{p_0}); } // 0x8C95333CFC3340F3 0xD2D026CD b323
    pub inline fn clearFocus() !void { try invoker.invoke(void, 0x31B73D1EA9F01DA2, .{}); } // 0x31B73D1EA9F01DA2 0x34D91E7A b323
    /// Override the area where the camera will render the terrain. \
    /// p3, p4 and p5 are usually set to 0.0
    /// 
    pub inline fn setFocusPosAndVel(vec: types.Vector3, offset__: types.Vector3) !void { try invoker.invoke(void, 0xBB7454BAFF08FE25, .{vec.x, vec.y, vec.z, offset__.x, offset__.y, offset__.z}); } // 0xBB7454BAFF08FE25 0x14680A60 b323
    /// It seems to make the entity's coords mark the point from which LOD-distances are measured. In my testing, setting a vehicle as the focus entity and moving that vehicle more than 300 distance units away from the player will make the level of detail around the player go down drastically (shadows disappear, textures go extremely low res, etc). The player seems to be the default focus entity.
    pub inline fn setFocusEntity(entity: types.Entity) !void { try invoker.invoke(void, 0x198F77705FA0931D, .{entity}); } // 0x198F77705FA0931D 0x18DB04AC b323
    pub inline fn isEntityFocus(entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2DDFF3FB9075D747, .{entity}); } // 0x2DDFF3FB9075D747 0xB456D707 b323
    pub inline fn setRestoreFocusEntity(p_0: types.Entity) !void { try invoker.invoke(void, 0x0811381EF5062FEC, .{p_0}); } // 0x0811381EF5062FEC  b323
    /// Possible p0 values:
    /// 
    /// "prologue" \
    /// "Prologue_Main"
    pub inline fn setMapdatacullboxEnabled(name: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAF12610C644A35C9, .{name, toggle}); } // 0xAF12610C644A35C9 0x403CD434 b323
    /// This native does absolutely nothing, just a nullsub
    pub inline fn setAllMapdataCulled(p_0: types.Any) !void { try invoker.invoke(void, 0x4E52E752C76E7E7A, .{p_0}); } // 0x4E52E752C76E7E7A 0xA07BAEB9 b323
    /// Always returns zero.
    pub inline fn streamvolCreateSphere(vec: types.Vector3, rad: f32, p_4: types.Any, p_5: types.Any) !c_int { return try invoker.invoke(c_int, 0x219C7B8D53E429FD, .{vec.x, vec.y, vec.z, rad, p_4, p_5}); } // 0x219C7B8D53E429FD 0x10B6AB36 b323
    /// Always returns zero.
    pub inline fn streamvolCreateFrustum(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: types.Any, p_8: types.Any) !c_int { return try invoker.invoke(c_int, 0x1F3F018BC3AFA77C, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0x1F3F018BC3AFA77C 0x72344191 b323
    /// Always returns zero.
    pub inline fn streamvolCreateLine(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: types.Any) !c_int { return try invoker.invoke(c_int, 0x0AD9710CEE2F590F, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x0AD9710CEE2F590F 0xC0157255 b323
    pub inline fn streamvolDelete(unused: types.Any) !void { try invoker.invoke(void, 0x1EE7D8DF4425F053, .{unused}); } // 0x1EE7D8DF4425F053 0xE80F8ABE b323
    pub inline fn streamvolHasLoaded(unused: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7D41E9D2D17C5B2D, .{unused}); } // 0x7D41E9D2D17C5B2D 0x1B3521F4 b323
    pub inline fn streamvolIsValid(unused: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x07C313F94746702C, .{unused}); } // 0x07C313F94746702C 0x42CFE9C0 b323
    pub inline fn isStreamvolActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC9823AB80A3DCAC, .{}); } // 0xBC9823AB80A3DCAC 0x56253356 b323
    /// `radius` value is usually between `3f` and `7000f` in original 1868 scripts. \
    /// `p7` is 0, 1, 2, 3 or 4 used in decompiled scripts, 0 is by far the most common. \
    /// Returns True if success, used only 7 times in decompiled scripts of 1868
    pub inline fn newLoadSceneStart(pos__: types.Vector3, offset__: types.Vector3, radius: f32, p_7: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x212A8D0D2BABFAC2, .{pos__.x, pos__.y, pos__.z, offset__.x, offset__.y, offset__.z, radius, p_7}); } // 0x212A8D0D2BABFAC2 0xDF9C38B6 b323
    pub inline fn newLoadSceneStartSphere(vec: types.Vector3, radius: f32, p_4: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xACCFB4ACF53551B0, .{vec.x, vec.y, vec.z, radius, p_4}); } // 0xACCFB4ACF53551B0 0xFA037FEB b323
    pub inline fn newLoadSceneStop() !void { try invoker.invoke(void, 0xC197616D221FF4A4, .{}); } // 0xC197616D221FF4A4 0x7C05B1F6 b323
    pub inline fn isNewLoadSceneActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA41A05B6CB741B85, .{}); } // 0xA41A05B6CB741B85 0xAD234B7F b323
    pub inline fn isNewLoadSceneLoaded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x01B8247A7A8B9AD1, .{}); } // 0x01B8247A7A8B9AD1 0x3ECD839F b323
    pub inline fn isSafeToStartPlayerSwitch() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71E7B2E657449AAD, .{}); } // 0x71E7B2E657449AAD 0xEAA51103 b323
    /// // this enum comes directly from R* so don't edit this \
    /// enum ePlayerSwitchTypes \
    /// { \
    ///   SWITCH_TYPE_AUTO,
    ///  SWITCH_TYPE_LONG, \
    ///  SWITCH_TYPE_MEDIUM, \
    ///    SWITCH_TYPE_SHORT
    /// };
    /// 
    /// Use GET_IDEAL_PLAYER_SWITCH_TYPE for the best switch type.
    /// 
    /// ----------------------------------------------------
    /// 
    /// Examples from the decompiled scripts:
    /// 
    /// STREAMING::START_PLAYER_SWITCH(l_832._f3, PLAYER::PLAYER_PED_ID(), 0, 3); \
    /// STREAMING::START_PLAYER_SWITCH(l_832._f3, PLAYER::PLAYER_PED_ID(), 2050, 3); \
    /// STREAMING::START_PLAYER_SWITCH(PLAYER::PLAYER_PED_ID(), l_832._f3, 1024, 3); \
    /// STREAMING::START_PLAYER_SWITCH(g_141F27, PLAYER::PLAYER_PED_ID(), 513, v_14);
    /// 
    /// Note: DO NOT, use SWITCH_TYPE_LONG with flag 513. It leaves you stuck in the clouds. You'll have to call STOP_PLAYER_SWITCH() to return to your ped.
    /// 
    /// Flag 8 w/ SWITCH_TYPE_LONG will zoom out 3 steps, then zoom in 2/3 steps and stop on the 3rd and just hang there. \
    /// Flag 8 w/ SWITCH_TYPE_MEDIUM will zoom out 1 step, and just hang there.
    pub inline fn startPlayerSwitch(from: types.Ped, to: types.Ped, flags: c_int, switch_type: c_int) !void { try invoker.invoke(void, 0xFAA23F2CBA159D67, .{from, to, flags, switch_type}); } // 0xFAA23F2CBA159D67 0x0829E975 b323
    pub inline fn stopPlayerSwitch() !void { try invoker.invoke(void, 0x95C0A5BBDC189AA1, .{}); } // 0x95C0A5BBDC189AA1 0x2832C010 b323
    /// Returns true if the player is currently switching, false otherwise. \
    /// (When the camera is in the sky moving from Trevor to Franklin for example)
    pub inline fn isPlayerSwitchInProgress() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD9D2CFFF49FAB35F, .{}); } // 0xD9D2CFFF49FAB35F 0x56135ACC b323
    pub inline fn getPlayerSwitchType() !c_int { return try invoker.invoke(c_int, 0xB3C94A90D9FC9E62, .{}); } // 0xB3C94A90D9FC9E62 0x280DC015 b323
    /// x1, y1, z1 -- Coords of your ped model \
    /// x2, y2, z2 -- Coords of the ped you want to switch to
    pub inline fn getIdealPlayerSwitchType(vec_1__: types.Vector3, vec_2__: types.Vector3) !c_int { return try invoker.invoke(c_int, 0xB5D7B26B45720E05, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z}); } // 0xB5D7B26B45720E05 0xD5A450F1 b323
    pub inline fn getPlayerSwitchState() !c_int { return try invoker.invoke(c_int, 0x470555300D10B2A5, .{}); } // 0x470555300D10B2A5 0x39A0E1F2 b323
    pub inline fn getPlayerShortSwitchState() !c_int { return try invoker.invoke(c_int, 0x20F898A5D9782800, .{}); } // 0x20F898A5D9782800 0x9B7BA38F b323
    pub inline fn setPlayerShortSwitchStyle(p_0: c_int) !void { try invoker.invoke(void, 0x5F2013F8BC24EE69, .{p_0}); } // 0x5F2013F8BC24EE69 0xF0BD420D b323
    pub inline fn getPlayerSwitchJumpCutIndex() !c_int { return try invoker.invoke(c_int, 0x78C0D93253149435, .{}); } // 0x78C0D93253149435 0x02BA7AC2 b323
    pub inline fn setPlayerSwitchOutro(cameracoord__: types.Vector3, camrotation__: types.Vector3, cam_fov: f32, cam_far_clip: f32, rotation_order: c_int) !void { try invoker.invoke(void, 0xC208B673CE446B61, .{cameracoord__.x, cameracoord__.y, cameracoord__.z, camrotation__.x, camrotation__.y, camrotation__.z, cam_fov, cam_far_clip, rotation_order}); } // 0xC208B673CE446B61 0x47352E14 b323
    /// All names can be found in playerswitchestablishingshots.meta
    pub inline fn setPlayerSwitchEstablishingShot(name: [*c]const u8) !void { try invoker.invoke(void, 0x0FDE9DBFC0A6BC65, .{name}); } // 0x0FDE9DBFC0A6BC65 0x279077B0 b323
    pub inline fn allowPlayerSwitchPan() !void { try invoker.invoke(void, 0x43D1680C6D19A8E9, .{}); } // 0x43D1680C6D19A8E9 0x55CB21F9 b323
    pub inline fn allowPlayerSwitchOutro() !void { try invoker.invoke(void, 0x74DE2E8739086740, .{}); } // 0x74DE2E8739086740 0x1084F2F4 b323
    pub inline fn allowPlayerSwitchAscent() !void { try invoker.invoke(void, 0x8E2A065ABDAE6994, .{}); } // 0x8E2A065ABDAE6994 0x5B1E995D b323
    pub inline fn allowPlayerSwitchDescent() !void { try invoker.invoke(void, 0xAD5FDF34B81BFE79, .{}); } // 0xAD5FDF34B81BFE79 0x4B4B9A13 b323
    pub inline fn isSwitchReadyForDescent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDFA80CB25D0A19B3, .{}); } // 0xDFA80CB25D0A19B3 0x408F7148 b323
    pub inline fn enableSwitchPauseBeforeDescent() !void { try invoker.invoke(void, 0xD4793DFF3AF2ABCD, .{}); } // 0xD4793DFF3AF2ABCD 0x4062FF73 b323
    pub inline fn disableSwitchOutroFx() !void { try invoker.invoke(void, 0xBD605B8E0E18B3BB, .{}); } // 0xBD605B8E0E18B3BB 0x59CC312D b323
    /// doesn't act normally when used on mount chilliad \
    /// Flags is a bitflag: \
    /// 2^n - Enabled Functionality: \
    /// 0 - Skip camera rotate up \
    /// 3 - Wait for SET_PLAYER_SWITCH_ESTABLISHING_SHOT / hang at last step. You will still need to run 0x74DE2E8739086740 to exit "properly" and then STOP_PLAYER_SWITCH \
    /// 6 - Invert Switch Direction (false = out, true = in) \
    /// 8 - Hang above ped
    /// 
    /// switchType: 0 - 3 \
    /// 0: 1 step towards ped \
    /// 1: 3 steps out from ped \
    /// 2: 1 step out from ped \
    /// 3: 1 step towards ped
    pub inline fn switchToMultiFirstpart(ped: types.Ped, flags: c_int, switch_type: c_int) !void { try invoker.invoke(void, 0xAAB3200ED59016BC, .{ped, flags, switch_type}); } // 0xAAB3200ED59016BC 0xFB4D062D b323
    pub inline fn switchToMultiSecondpart(ped: types.Ped) !void { try invoker.invoke(void, 0xD8295AF639FD9CB8, .{ped}); } // 0xD8295AF639FD9CB8 0x2349373B b323
    pub inline fn isSwitchToMultiFirstpartFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x933BBEEB8C61B5F4, .{}); } // 0x933BBEEB8C61B5F4 0x74C16879 b323
    pub inline fn getPlayerSwitchInterpOutDuration() !c_int { return try invoker.invoke(c_int, 0x08C2D6C52A3104BB, .{}); } // 0x08C2D6C52A3104BB 0x569847E3 b323
    pub inline fn getPlayerSwitchInterpOutCurrentTime() !c_int { return try invoker.invoke(c_int, 0x5B48A06DD0E792A5, .{}); } // 0x5B48A06DD0E792A5 0xC7A3D279 b323
    pub inline fn isSwitchSkippingDescent() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5B74EA8CFD5E3E7E, .{}); } // 0x5B74EA8CFD5E3E7E 0x90F64284 b323
    pub inline fn setSceneStreamingTracksCamPosThisFrame() !void { try invoker.invoke(void, 0x1E9057A74FD73E23, .{}); } // 0x1E9057A74FD73E23  b323
    pub inline fn getLodscale() !f32 { return try invoker.invoke(f32, 0x0C15B0E443B2349D, .{}); } // 0x0C15B0E443B2349D 0x7154B6FD b323
    /// This allows you to override "extended distance scaling" setting. Needs to be called each frame. \
    /// Max scaling seems to be 200.0, normal is 1.0 \
    /// See https://gfycat.com/DetailedHauntingIncatern
    pub inline fn overrideLodscaleThisFrame(scaling: f32) !void { try invoker.invoke(void, 0xA76359FC80B2438E, .{scaling}); } // 0xA76359FC80B2438E 0xE5612C1A b323
    pub inline fn remapLodscaleRangeThisFrame(p_0: f32, p_1: f32, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0xBED8CA5FF5E04113, .{p_0, p_1, p_2, p_3}); } // 0xBED8CA5FF5E04113 0x9CD6A451 b323
    pub inline fn suppressHdMapStreamingThisFrame() !void { try invoker.invoke(void, 0x472397322E92A856, .{}); } // 0x472397322E92A856 0x4267DA87 b323
    pub inline fn setRenderHdOnly(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x40AEFD1A244741F2, .{toggle}); } // 0x40AEFD1A244741F2 0x9FA4AF99 b323
    pub inline fn forceAllowTimeBasedFadingThisFrame() !void { try invoker.invoke(void, 0x03F1A106BDA7DD3E, .{}); } // 0x03F1A106BDA7DD3E  b323
    pub inline fn iplGroupSwapStart(ipl_name_1: [*c]const u8, ipl_name_2: [*c]const u8) !void { try invoker.invoke(void, 0x95A7DABDDBB78AE7, .{ipl_name_1, ipl_name_2}); } // 0x95A7DABDDBB78AE7 0x9EF0A9CF b323
    pub inline fn iplGroupSwapCancel() !void { try invoker.invoke(void, 0x63EB2B972A218CAC, .{}); } // 0x63EB2B972A218CAC 0xF2CDD6A8 b323
    pub inline fn iplGroupSwapIsReady() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFB199266061F820A, .{}); } // 0xFB199266061F820A 0x17B0A1CD b323
    pub inline fn iplGroupSwapFinish() !void { try invoker.invoke(void, 0xF4A0DADB70F57FA6, .{}); } // 0xF4A0DADB70F57FA6 0x3DA7AA5D b323
    pub inline fn iplGroupSwapIsActive() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5068F488DDB54DD8, .{}); } // 0x5068F488DDB54DD8 0xDAB4BAC0 b323
    /// This native is used to attribute the SRL that BEGIN_SRL is going to load. This is usually used for 'in-game' cinematics (not cutscenes but camera stuff) instead of SET_FOCUS_POS_AND_VEL because it loads a specific area of the map which is pretty useful when the camera moves from distant areas. \
    /// For instance, GTA:O opening cutscene. \
    /// https://pastebin.com/2EeKVeLA : a list of SRL found in srllist.meta \
    /// https://pastebin.com/zd9XYUWY here is the content of a SRL file opened with codewalker.
    pub inline fn prefetchSrl(srl: [*c]const u8) !void { try invoker.invoke(void, 0x3D245789CE12982C, .{srl}); } // 0x3D245789CE12982C 0x37BE2FBB b323
    /// Returns true when the srl from BEGIN_SRL is loaded.
    pub inline fn isSrlLoaded() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD0263801A4C5B0BB, .{}); } // 0xD0263801A4C5B0BB 0x670FA2A6 b323
    pub inline fn beginSrl() !void { try invoker.invoke(void, 0x9BADDC94EF83B823, .{}); } // 0x9BADDC94EF83B823 0x24F49427 b323
    /// Clear the current srl and stop rendering the area selected by PREFETCH_SRL and started with BEGIN_SRL.
    pub inline fn endSrl() !void { try invoker.invoke(void, 0x0A41540E63C9EE17, .{}); } // 0x0A41540E63C9EE17 0x1977C56A b323
    pub inline fn setSrlTime(p_0: f32) !void { try invoker.invoke(void, 0xA74A541C6884E7B8, .{p_0}); } // 0xA74A541C6884E7B8 0x30F8A487 b323
    pub inline fn setSrlPostCutsceneCamera(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0xEF39EE20C537E98C, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0xEF39EE20C537E98C 0x814D0752 b323
    pub inline fn setSrlReadaheadTimes(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0xBEB2D9A1D9A8F55A, .{p_0, p_1, p_2, p_3}); } // 0xBEB2D9A1D9A8F55A 0x62F02485 b323
    pub inline fn setSrlLongJumpMode(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x20C6C7E4EB082A7F, .{p_0}); } // 0x20C6C7E4EB082A7F 0xA6459CAA b323
    pub inline fn setSrlForcePrestream(p_0: types.Any) !void { try invoker.invoke(void, 0xF8155A7F03DDFC8E, .{p_0}); } // 0xF8155A7F03DDFC8E 0xF8F515E4 b323
    pub inline fn setHdArea(vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0xB85F26619073E775, .{vec.x, vec.y, vec.z, radius}); } // 0xB85F26619073E775 0x80BAA035 b323
    pub inline fn clearHdArea() !void { try invoker.invoke(void, 0xCE58B1CFB9290813, .{}); } // 0xCE58B1CFB9290813 0x7CAC6FA0 b323
    pub inline fn initCreatorBudget() !void { try invoker.invoke(void, 0xB5A4DB34FE89B88A, .{}); } // 0xB5A4DB34FE89B88A 0xE243B2AF b323
    pub inline fn shutdownCreatorBudget() !void { try invoker.invoke(void, 0xCCE26000E9A6FAD7, .{}); } // 0xCCE26000E9A6FAD7 0x897A510F b323
    pub inline fn addModelToCreatorBudget(model_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0BC3144DEB678666, .{model_hash}); } // 0x0BC3144DEB678666 0xC0E83320 b323
    pub inline fn removeModelFromCreatorBudget(model_hash: types.Hash) !void { try invoker.invoke(void, 0xF086AD9354FAC3A3, .{model_hash}); } // 0xF086AD9354FAC3A3 0x1C576388 b323
    /// 0.0 = no memory used \
    /// 1.0 = all memory used
    /// 
    /// Maximum model memory (as defined in common\data\missioncreatordata.meta) is 100 MiB
    pub inline fn getUsedCreatorBudget() !f32 { return try invoker.invoke(f32, 0x3D3D8B3BE5A83D35, .{}); } // 0x3D3D8B3BE5A83D35 0x3E9C4CBE b323
    pub inline fn getModelAdditionalCost_(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x0F7082C60FB479EF, .{model_hash}); } // 0x0F7082C60FB479EF  b3717
    pub inline fn getTotalModelCost_(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x4A91423C04BAADA1, .{model_hash}); } // 0x4A91423C04BAADA1  b3717
    /// Enables the specified island. For more information, see islandhopper.meta
    pub inline fn setIslandEnabled(name: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9A9D1BA639675CF1, .{name, toggle}); } // 0x9A9D1BA639675CF1  b2189
    pub inline fn setSphericalStreamDistantHilodsThisFrame_() !void { try invoker.invoke(void, 0x68F1C25420D5F6AA, .{}); } // 0x68F1C25420D5F6AA  b3717
};

pub const Task = struct
{
    /// Stand still (?)
    pub inline fn taskPause(ped: types.Ped, ms: c_int) !void { try invoker.invoke(void, 0xE73A266DB0CA9042, .{ped, ms}); } // 0xE73A266DB0CA9042 0x17A64668 b323
    /// Makes the specified ped stand still for (time) milliseconds.
    pub inline fn taskStandStill(ped: types.Ped, time: c_int) !void { try invoker.invoke(void, 0x919BE13EED931959, .{ped, time}); } // 0x919BE13EED931959 0x6F80965D b323
    /// Definition is wrong. This has 4 parameters (Not sure when they were added. v350 has 2, v678 has 4).
    /// 
    /// v350: Ped ped, bool unused \
    /// v678: Ped ped, bool unused, bool flag1, bool flag2
    /// 
    /// flag1 = super jump, flag2 = do nothing if flag1 is false and doubles super jump height if flag1 is true.
    pub inline fn taskJump(ped: types.Ped, use_player_launch_force: windows.BOOL, do_super_jump: windows.BOOL, use_full_super_jump_force: windows.BOOL) !void { try invoker.invoke(void, 0x0AE4086104E067B1, .{ped, use_player_launch_force, do_super_jump, use_full_super_jump_force}); } // 0x0AE4086104E067B1 0x0356E3CE b323
    pub inline fn taskCower(ped: types.Ped, duration: c_int) !void { try invoker.invoke(void, 0x3EB1FE9E8E908E15, .{ped, duration}); } // 0x3EB1FE9E8E908E15 0x9CF1C19B b323
    /// In the scripts, p3 was always -1.
    /// 
    /// p3 seems to be duration or timeout of turn animation. \
    /// Also facingPed can be 0 or -1 so ped will just raise hands up.
    pub inline fn taskHandsUp(ped: types.Ped, duration: c_int, facing_ped: types.Ped, time_to_face_ped: c_int, flags: c_int) !void { try invoker.invoke(void, 0xF2EAB31979A7F910, .{ped, duration, facing_ped, time_to_face_ped, flags}); } // 0xF2EAB31979A7F910 0x8DCC19C5 b323
    pub inline fn updateTaskHandsUpDuration(ped: types.Ped, duration: c_int) !void { try invoker.invoke(void, 0xA98FCAFD7893C834, .{ped, duration}); } // 0xA98FCAFD7893C834 0x3AA39BE9 b323
    /// The given ped will try to open the nearest door to 'seat'. \
    /// Example: telling the ped to open the door for the driver seat does not necessarily mean it will open the driver door, it may choose to open the passenger door instead if that one is closer.
    pub inline fn taskOpenVehicleDoor(ped: types.Ped, vehicle: types.Vehicle, time_out: c_int, seat: c_int, speed: f32) !void { try invoker.invoke(void, 0x965791A9A488A062, .{ped, vehicle, time_out, seat, speed}); } // 0x965791A9A488A062 0x8EE06BF4 b323
    /// speed 1.0 = walk, 2.0 = run \
    /// p5 1 = normal, 3 = teleport to vehicle, 16 = teleport directly into vehicle \
    /// p6 is always 0
    /// 
    /// Usage of seat  \
    /// -1 = driver \
    /// 0 = passenger \
    /// 1 = left back seat \
    /// 2 = right back seat \
    /// 3 = outside left \
    /// 4 = outside right
    pub inline fn taskEnterVehicle(ped: types.Ped, vehicle: types.Vehicle, timeout: c_int, seat: c_int, speed: f32, flag: c_int, override_entry_clipset_name: [*c]const u8) !void { try invoker.invoke(void, 0xC20E50AA46D09CA8, .{ped, vehicle, timeout, seat, speed, flag, override_entry_clipset_name}); } // 0xC20E50AA46D09CA8 0xB8689B4E b323
    /// Flags from decompiled scripts: \
    /// 0 = normal exit and closes door. \
    /// 1 = normal exit and closes door. \
    /// 16 = teleports outside, door kept closed. \
    /// 64 = normal exit and closes door, maybe a bit slower animation than 0. \
    /// 256 = normal exit but does not close the door. \
    /// 4160 = ped is throwing himself out, even when the vehicle is still. \
    /// 262144 = ped moves to passenger seat first, then exits normally
    /// 
    /// Others to be tried out: 320, 512, 131072.
    pub inline fn taskLeaveVehicle(ped: types.Ped, vehicle: types.Vehicle, flags: c_int) !void { try invoker.invoke(void, 0xD3DBCE61A490BE02, .{ped, vehicle, flags}); } // 0xD3DBCE61A490BE02 0x7B1141C6 b323
    pub inline fn taskGetOffBoat(ped: types.Ped, boat: types.Vehicle) !void { try invoker.invoke(void, 0x9C00E77AF14B2DFF, .{ped, boat}); } // 0x9C00E77AF14B2DFF 0x4293601F b323
    pub inline fn taskSkyDive(ped: types.Ped, instant: windows.BOOL) !void { try invoker.invoke(void, 0x601736CFE536B0A0, .{ped, instant}); } // 0x601736CFE536B0A0 0xD3874AFA b323
    /// Second parameter is unused.
    /// 
    /// second parameter was for jetpack in the early stages of gta and the hard coded code is now removed
    pub inline fn taskParachute(ped: types.Ped, give_parachute_item: windows.BOOL, instant: windows.BOOL) !void { try invoker.invoke(void, 0xD2F1C53C97EE81AB, .{ped, give_parachute_item, instant}); } // 0xD2F1C53C97EE81AB 0xEC3060A2 b323
    /// makes ped parachute to coords x y z. Works well with PATHFIND::GET_SAFE_COORD_FOR_PED
    pub inline fn taskParachuteToTarget(ped: types.Ped, vec: types.Vector3) !void { try invoker.invoke(void, 0xB33E291AFA6BD03A, .{ped, vec.x, vec.y, vec.z}); } // 0xB33E291AFA6BD03A 0xE0104D6C b323
    pub inline fn setParachuteTaskTarget(ped: types.Ped, vec: types.Vector3) !void { try invoker.invoke(void, 0xC313379AF0FCEDA7, .{ped, vec.x, vec.y, vec.z}); } // 0xC313379AF0FCEDA7 0x6ED3AD81 b323
    pub inline fn setParachuteTaskThrust(ped: types.Ped, thrust: f32) !void { try invoker.invoke(void, 0x0729BAC1B8C64317, .{ped, thrust}); } // 0x0729BAC1B8C64317 0xD07C8AAA b323
    /// minHeightAboveGround: the minimum height above ground the heli must be at before the ped can start rappelling
    /// 
    /// Only appears twice in the scripts.
    /// 
    /// TASK::TASK_RAPPEL_FROM_HELI(PLAYER::PLAYER_PED_ID(), 10.0f); \
    /// TASK::TASK_RAPPEL_FROM_HELI(a_0, 10.0f);
    pub inline fn taskRappelFromHeli(ped: types.Ped, min_height_above_ground: f32) !void { try invoker.invoke(void, 0x09693B0312F91649, .{ped, min_height_above_ground}); } // 0x09693B0312F91649 0x2C7ADB93 b323
    /// info about driving modes: https://gtaforums.com/topic/822314-guide-driving-styles/
    pub inline fn taskVehicleDriveToCoord(ped: types.Ped, vehicle: types.Vehicle, vec: types.Vector3, speed: f32, p_6: types.Any, vehicle_model: types.Hash, driving_mode: c_int, stop_range: f32, straight_line_distance: f32) !void { try invoker.invoke(void, 0xE2A2AA2F659D77A7, .{ped, vehicle, vec.x, vec.y, vec.z, speed, p_6, vehicle_model, driving_mode, stop_range, straight_line_distance}); } // 0xE2A2AA2F659D77A7 0xE4AC0387 b323
    pub inline fn taskVehicleDriveToCoordLongrange(ped: types.Ped, vehicle: types.Vehicle, vec: types.Vector3, speed: f32, drive_mode: c_int, stop_range: f32) !void { try invoker.invoke(void, 0x158BB33F920D360C, .{ped, vehicle, vec.x, vec.y, vec.z, speed, drive_mode, stop_range}); } // 0x158BB33F920D360C 0x1490182A b323
    pub inline fn taskVehicleDriveWander(ped: types.Ped, vehicle: types.Vehicle, speed: f32, driving_style: c_int) !void { try invoker.invoke(void, 0x480142959D337D00, .{ped, vehicle, speed, driving_style}); } // 0x480142959D337D00 0x36EC0EB0 b323
    /// p6 always -1 \
    /// p7 always 10.0 \
    /// p8 always 1
    pub inline fn taskFollowToOffsetOfEntity(ped: types.Ped, entity: types.Entity, offset__: types.Vector3, movement_speed: f32, timeout: c_int, stopping_range: f32, persist_following: windows.BOOL) !void { try invoker.invoke(void, 0x304AE42E357B8C7E, .{ped, entity, offset__.x, offset__.y, offset__.z, movement_speed, timeout, stopping_range, persist_following}); } // 0x304AE42E357B8C7E 0x2DF5A6AC b323
    pub inline fn taskGoStraightToCoord(ped: types.Ped, vec: types.Vector3, speed: f32, timeout: c_int, target_heading: f32, distance_to_slide: f32) !void { try invoker.invoke(void, 0xD76B57B44F1E6F8B, .{ped, vec.x, vec.y, vec.z, speed, timeout, target_heading, distance_to_slide}); } // 0xD76B57B44F1E6F8B 0x80A9E7A7 b323
    pub inline fn taskGoStraightToCoordRelativeToEntity(ped: types.Ped, entity: types.Entity, vec: types.Vector3, move_blend_ratio: f32, time: c_int) !void { try invoker.invoke(void, 0x61E360B7E040D12E, .{ped, entity, vec.x, vec.y, vec.z, move_blend_ratio, time}); } // 0x61E360B7E040D12E 0xD26CAC68 b323
    /// Makes the specified ped achieve the specified heading.
    /// 
    /// pedHandle: The handle of the ped to assign the task to. \
    /// heading: The desired heading. \
    /// timeout: The time, in milliseconds, to allow the task to complete. If the task times out, it is cancelled, and the ped will stay at the heading it managed to reach in the time.
    pub inline fn taskAchieveHeading(ped: types.Ped, heading: f32, timeout: c_int) !void { try invoker.invoke(void, 0x93B93A37987F1F3D, .{ped, heading, timeout}); } // 0x93B93A37987F1F3D 0x0A0E9B42 b323
    /// MulleKD19: Clears the current point route. Call this before TASK_EXTEND_ROUTE and TASK_FOLLOW_POINT_ROUTE.
    pub inline fn taskFlushRoute() !void { try invoker.invoke(void, 0x841142A1376E9006, .{}); } // 0x841142A1376E9006 0x34219154 b323
    /// MulleKD19: Adds a new point to the current point route. Call TASK_FLUSH_ROUTE before the first call to this. Call TASK_FOLLOW_POINT_ROUTE to make the Ped go the route.
    /// 
    /// A maximum of 8 points can be added.
    pub inline fn taskExtendRoute(vec: types.Vector3) !void { try invoker.invoke(void, 0x1E7889778264843A, .{vec.x, vec.y, vec.z}); } // 0x1E7889778264843A 0x43271F69 b323
    /// MulleKD19: Makes the ped go on the created point route.
    /// 
    /// ped: The ped to give the task to. \
    /// speed: The speed to move at in m/s. \
    /// int: Unknown. Can be 0, 1, 2 or 3.
    /// 
    /// Example: \
    /// TASK_FLUSH_ROUTE(); \
    /// TASK_EXTEND_ROUTE(0f, 0f, 70f); \
    /// TASK_EXTEND_ROUTE(10f, 0f, 70f); \
    /// TASK_EXTEND_ROUTE(10f, 10f, 70f); \
    /// TASK_FOLLOW_POINT_ROUTE(GET_PLAYER_PED(), 1f, 0);
    pub inline fn taskFollowPointRoute(ped: types.Ped, speed: f32, mode: c_int) !void { try invoker.invoke(void, 0x595583281858626E, .{ped, speed, mode}); } // 0x595583281858626E 0xB837C816 b323
    /// The entity will move towards the target until time is over (duration) or get in target's range (distance). p5 and p6 are unknown, but you could leave p5 = 1073741824 or 100 or even 0 (didn't see any difference but on the decompiled scripts, they use 1073741824 mostly) and p6 = 0
    /// 
    /// Note: I've only tested it on entity -> ped and target -> vehicle. It could work differently on other entities, didn't try it yet.
    /// 
    /// Example: TASK::TASK_GO_TO_ENTITY(pedHandle, vehicleHandle, 5000, 4.0, 100, 1073741824, 0)
    /// 
    /// Ped will run towards the vehicle for 5 seconds and stop when time is over or when he gets 4 meters(?) around the vehicle (with duration = -1, the task duration will be ignored).
    /// 
    /// enum EGOTO_ENTITY_SCRIPT_FLAGS \
    /// { \
    ///     EGOTO_ENTITY_NEVER_SLOW_FOR_PATH_LENGTH = 0x01,
    /// };
    pub inline fn taskGoToEntity(entity: types.Entity, target: types.Entity, duration: c_int, distance: f32, move_blend_ratio: f32, slow_down_distance: f32, flags: c_int) !void { try invoker.invoke(void, 0x6A071245EB0D1882, .{entity, target, duration, distance, move_blend_ratio, slow_down_distance, flags}); } // 0x6A071245EB0D1882 0x374827C2 b323
    /// Makes the specified ped flee the specified distance from the specified position.
    pub inline fn taskSmartFleeCoord(ped: types.Ped, vec: types.Vector3, distance: f32, time: c_int, prefer_pavements: windows.BOOL, quit_if_out_of_range: windows.BOOL) !void { try invoker.invoke(void, 0x94587F17E9C365D5, .{ped, vec.x, vec.y, vec.z, distance, time, prefer_pavements, quit_if_out_of_range}); } // 0x94587F17E9C365D5 0xB2E686FC b323
    /// Makes a ped run away from another ped (fleeTarget).
    /// 
    /// distance = ped will flee this distance. \
    /// fleeTime = ped will flee for this amount of time, set to "-1" to flee forever
    pub inline fn taskSmartFleePed(ped: types.Ped, flee_target: types.Ped, safe_distance: f32, flee_time: c_int, prefer_pavements: windows.BOOL, update_to_nearest_hated_ped: windows.BOOL) !void { try invoker.invoke(void, 0x22B0D0E37CCB840D, .{ped, flee_target, safe_distance, flee_time, prefer_pavements, update_to_nearest_hated_ped}); } // 0x22B0D0E37CCB840D 0xE52EB560 b323
    pub inline fn taskReactAndFleePed(ped: types.Ped, flee_target: types.Ped) !void { try invoker.invoke(void, 0x72C896464915D1B1, .{ped, flee_target}); } // 0x72C896464915D1B1 0x8A632BD8 b323
    pub inline fn taskShockingEventReact(ped: types.Ped, event_handle: c_int) !void { try invoker.invoke(void, 0x452419CBD838065B, .{ped, event_handle}); } // 0x452419CBD838065B 0x9BD00ACF b323
    pub inline fn taskWanderInArea(ped: types.Ped, vec: types.Vector3, radius: f32, minimal_length: f32, time_between_walks: f32) !void { try invoker.invoke(void, 0xE054346CA3A0F315, .{ped, vec.x, vec.y, vec.z, radius, minimal_length, time_between_walks}); } // 0xE054346CA3A0F315 0xC6981FB9 b323
    /// Makes ped walk around the area.
    /// 
    /// set p1 to 10.0f and p2 to 10 if you want the ped to walk anywhere without a duration.
    pub inline fn taskWanderStandard(ped: types.Ped, heading: f32, flags: c_int) !void { try invoker.invoke(void, 0xBB9CE077274F6A1B, .{ped, heading, flags}); } // 0xBB9CE077274F6A1B 0xAF59151A b323
    pub inline fn taskWanderSpecific(ped: types.Ped, conditional_anim_group_str: [*c]const u8, conditional_anim_str: [*c]const u8, heading: f32) !void { try invoker.invoke(void, 0x6919A2F136426098, .{ped, conditional_anim_group_str, conditional_anim_str, heading}); } // 0x6919A2F136426098  b1868
    /// Modes: \
    /// 0 - ignore heading \
    /// 1 - park forward \
    /// 2 - park backwards
    /// 
    /// Depending on the angle of approach, the vehicle can park at the specified heading or at its exact opposite (-180) angle.
    /// 
    /// Radius seems to define how close the vehicle has to be -after parking- to the position for this task considered completed. If the value is too small, the vehicle will try to park again until it's exactly where it should be. 20.0 Works well but lower values don't, like the radius is measured in centimeters or something.
    pub inline fn taskVehiclePark(ped: types.Ped, vehicle: types.Vehicle, vec: types.Vector3, heading: f32, mode: c_int, radius: f32, keep_engine_on: windows.BOOL) !void { try invoker.invoke(void, 0x0F3E34E968EA374E, .{ped, vehicle, vec.x, vec.y, vec.z, heading, mode, radius, keep_engine_on}); } // 0x0F3E34E968EA374E 0x5C85FF90 b323
    /// known "killTypes" are: "AR_stealth_kill_knife" and "AR_stealth_kill_a".
    pub inline fn taskStealthKill(killer: types.Ped, target: types.Ped, stealth_kill_action_result_hash: types.Hash, desired_move_blend_ratio: f32, stealth_flags: c_int) !void { try invoker.invoke(void, 0xAA5DC05579D60BD9, .{killer, target, stealth_kill_action_result_hash, desired_move_blend_ratio, stealth_flags}); } // 0xAA5DC05579D60BD9 0x0D64C2FA b323
    pub inline fn taskPlantBomb(ped: types.Ped, vec: types.Vector3, heading: f32) !void { try invoker.invoke(void, 0x965FEC691D55E9BF, .{ped, vec.x, vec.y, vec.z, heading}); } // 0x965FEC691D55E9BF 0x33457535 b323
    pub inline fn taskSharkCircleCoord(ped: types.Ped, vec: types.Vector3, move_blend_ratio: f32, radius: f32) !void { try invoker.invoke(void, 0x60A19CF85FF4CEFA, .{ped, vec.x, vec.y, vec.z, move_blend_ratio, radius}); } // 0x60A19CF85FF4CEFA  b3407
    /// If no timeout, set timeout to -1.
    pub inline fn taskFollowNavMeshToCoord(ped: types.Ped, vec: types.Vector3, move_blend_ratio: f32, time: c_int, target_radius: f32, flags: c_int, target_heading: f32) !void { try invoker.invoke(void, 0x15D3A79D4E44B913, .{ped, vec.x, vec.y, vec.z, move_blend_ratio, time, target_radius, flags, target_heading}); } // 0x15D3A79D4E44B913 0xFE4A10D9 b323
    pub inline fn taskFollowNavMeshToCoordAdvanced(ped: types.Ped, vec: types.Vector3, move_blend_ratio: f32, time: c_int, target_radius: f32, flags: c_int, slide_to_coord_heading: f32, max_slope_navigable: f32, clamp_max_search_distance: f32, target_heading: f32) !void { try invoker.invoke(void, 0x17F58B88D085DBAC, .{ped, vec.x, vec.y, vec.z, move_blend_ratio, time, target_radius, flags, slide_to_coord_heading, max_slope_navigable, clamp_max_search_distance, target_heading}); } // 0x17F58B88D085DBAC 0x6BF6E296 b323
    pub inline fn setPedPathCanUseClimbovers(ped: types.Ped, _toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8E06A6FE76C9EFF4, .{ped, _toggle}); } // 0x8E06A6FE76C9EFF4 0xB7B7D442 b323
    pub inline fn setPedPathCanUseLadders(ped: types.Ped, _toggle: windows.BOOL) !void { try invoker.invoke(void, 0x77A5B103C87F476E, .{ped, _toggle}); } // 0x77A5B103C87F476E 0x53A879EE b323
    pub inline fn setPedPathCanDropFromHeight(ped: types.Ped, _toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE361C5C71C431A4F, .{ped, _toggle}); } // 0xE361C5C71C431A4F 0x394B7AC9 b323
    /// Default modifier is 1.0, minimum is 0.0 and maximum is 10.0.
    pub inline fn setPedPathClimbCostModifier(ped: types.Ped, modifier: f32) !void { try invoker.invoke(void, 0x88E32DB8C1A4AA4B, .{ped, modifier}); } // 0x88E32DB8C1A4AA4B 0x55E06443 b323
    pub inline fn setPedPathMayEnterWater(ped: types.Ped, may_enter_water: windows.BOOL) !void { try invoker.invoke(void, 0xF35425A4204367EC, .{ped, may_enter_water}); } // 0xF35425A4204367EC 0x9C606EE3 b323
    pub inline fn setPedPathPreferToAvoidWater(ped: types.Ped, avoid_water: windows.BOOL) !void { try invoker.invoke(void, 0x38FE1EC73743793C, .{ped, avoid_water}); } // 0x38FE1EC73743793C 0x0EA39A29 b323
    pub inline fn setPedPathAvoidFire(ped: types.Ped, avoid_fire: windows.BOOL) !void { try invoker.invoke(void, 0x4455517B28441E60, .{ped, avoid_fire}); } // 0x4455517B28441E60 0xDCC5B934 b323
    /// Needs to be looped! And yes, it does work and is not a hash collision. \
    /// Birds will try to reach the given height.
    pub inline fn setGlobalMinBirdFlightHeight(height: f32) !void { try invoker.invoke(void, 0x6C6B148586F934F7, .{height}); } // 0x6C6B148586F934F7 0x2AFB14B8 b323
    /// Looks like the last parameter returns true if the path has been calculated, while the first returns the remaining distance to the end of the path. \
    /// Return value of native is the same as GET_NAVMESH_ROUTE_RESULT \
    /// Looks like the native returns an int for the path's state: \
    /// 1 - ??? \
    /// 2 - ??? \
    /// 3 - Finished Generating 
    pub inline fn getNavmeshRouteDistanceRemaining(ped: types.Ped, distance_remaining: [*c]f32, is_path_ready: [*c]windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xC6F5C0BCDC74D62D, .{ped, distance_remaining, is_path_ready}); } // 0xC6F5C0BCDC74D62D 0xD9281778 b323
    /// See GET_NAVMESH_ROUTE_DISTANCE_REMAINING for more details.
    pub inline fn getNavmeshRouteResult(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x632E831F382A0FA8, .{ped}); } // 0x632E831F382A0FA8 0x96491602 b323
    pub inline fn isControlledVehicleUnableToGetToRoad(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3E38E28A1D80DDF6, .{ped}); } // 0x3E38E28A1D80DDF6 0x54856309 b323
    /// example from fm_mission_controller
    /// 
    /// TASK::TASK_GO_TO_COORD_ANY_MEANS(l_649, sub_f7e86(-1, 0), 1.0, 0, 0, 786603, 0xbf800000);
    ///  
    pub inline fn taskGoToCoordAnyMeans(ped: types.Ped, vec: types.Vector3, move_blend_ratio: f32, vehicle: types.Vehicle, use_long_range_vehicle_pathing: windows.BOOL, driving_flags: c_int, max_range_to_shoot_targets: f32) !void { try invoker.invoke(void, 0x5BC448CB78FA3E88, .{ped, vec.x, vec.y, vec.z, move_blend_ratio, vehicle, use_long_range_vehicle_pathing, driving_flags, max_range_to_shoot_targets}); } // 0x5BC448CB78FA3E88 0xF91DF93B b323
    pub inline fn taskGoToCoordAnyMeansExtraParams(ped: types.Ped, vec: types.Vector3, move_blend_ratio: f32, vehicle: types.Vehicle, use_long_range_vehicle_pathing: windows.BOOL, driving_flags: c_int, max_range_to_shoot_targets: f32, extra_veh_to_target_dist_to_prefer_vehicle: f32, drive_straight_line_distance: f32, extra_flags: c_int, warp_timer_m_s: f32) !void { try invoker.invoke(void, 0x1DD45F9ECFDB1BC9, .{ped, vec.x, vec.y, vec.z, move_blend_ratio, vehicle, use_long_range_vehicle_pathing, driving_flags, max_range_to_shoot_targets, extra_veh_to_target_dist_to_prefer_vehicle, drive_straight_line_distance, extra_flags, warp_timer_m_s}); } // 0x1DD45F9ECFDB1BC9 0x094B75EF b323
    pub inline fn taskGoToCoordAnyMeansExtraParamsWithCruiseSpeed(ped: types.Ped, vec: types.Vector3, move_blend_ratio: f32, vehicle: types.Vehicle, use_long_range_vehicle_pathing: windows.BOOL, driving_flags: c_int, max_range_to_shoot_targets: f32, extra_veh_to_target_dist_to_prefer_vehicle: f32, drive_straight_line_distance: f32, extra_flags: c_int, cruise_speed: f32, target_arrive_dist: f32) !void { try invoker.invoke(void, 0xB8ECD61F531A7B02, .{ped, vec.x, vec.y, vec.z, move_blend_ratio, vehicle, use_long_range_vehicle_pathing, driving_flags, max_range_to_shoot_targets, extra_veh_to_target_dist_to_prefer_vehicle, drive_straight_line_distance, extra_flags, cruise_speed, target_arrive_dist}); } // 0xB8ECD61F531A7B02 0x86DC03F9 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    /// 
    /// float speed > normal speed is 8.0f \
    /// ----------------------
    /// 
    /// float speedMultiplier > multiply the playback speed \
    /// ----------------------
    /// 
    /// int duration: time in millisecond \
    /// ---------------------- \
    /// -1 _ _ _ _ _ _ _> Default (see flag) \
    /// 0 _ _ _ _ _ _ _ > Not play at all \
    /// Small value _ _ > Slow down animation speed \
    /// Other _ _ _ _ _ > freeze player control until specific time (ms) has  \
    /// _ _ _ _ _ _ _ _ _ passed. (No effect if flag is set to be  \
    /// _ _ _ _ _ _ _ _ _ controllable.)
    /// 
    /// int flag: \
    /// ---------------------- \
    /// enum eAnimationFlags \
    /// { \
    ///  ANIM_FLAG_NORMAL = 0, \
    ///    ANIM_FLAG_REPEAT = 1,
    ///    ANIM_FLAG_STOP_LAST_FRAME = 2,
    ///    ANIM_FLAG_UPPERBODY = 16,
    ///    ANIM_FLAG_ENABLE_PLAYER_CONTROL = 32,
    ///    ANIM_FLAG_CANCELABLE = 120,
    /// }; \
    /// Odd number : loop infinitely \
    /// Even number : Freeze at last frame \
    /// Multiple of 4: Freeze at last frame but controllable
    /// 
    /// 01 to 15 > Full body \
    /// 10 to 31 > Upper body \
    /// 32 to 47 > Full body > Controllable \
    /// 48 to 63 > Upper body > Controllable \
    /// ... \
    /// 001 to 255 > Normal \
    /// 256 to 511 > Garbled \
    /// ...
    /// 
    /// playbackRate:
    /// 
    /// values are between 0.0 and 1.0
    /// 
    /// 
    /// lockX:  
    /// 
    /// 0 in most cases 1 for rcmepsilonism8 and rcmpaparazzo_3 \
    /// > 1 for mini@sprunk
    ///  
    /// 
    /// lockY:
    /// 
    /// 0 in most cases  \
    /// 1 for missfam5_yoga, missfra1mcs_2_crew_react
    /// 
    /// 
    /// lockZ: 
    /// 
    ///     0 for single player 
    ///     Can be 1 but only for MP 
    pub inline fn taskPlayAnim(ped: types.Ped, anim_dictionary: [*c]const u8, animation_name: [*c]const u8, blend_in_speed: f32, blend_out_speed: f32, duration: c_int, flag: c_int, playback_rate: f32, lock_x: windows.BOOL, lock_y: windows.BOOL, lock_z: windows.BOOL) !void { try invoker.invoke(void, 0xEA47FE3719165B94, .{ped, anim_dictionary, animation_name, blend_in_speed, blend_out_speed, duration, flag, playback_rate, lock_x, lock_y, lock_z}); } // 0xEA47FE3719165B94 0x5AB552C6 b323
    /// It's similar to TASK_PLAY_ANIM, except the first 6 floats let you specify the initial position and rotation of the task. (Ped gets teleported to the position).
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn taskPlayAnimAdvanced(ped: types.Ped, anim_dict: [*c]const u8, anim_name: [*c]const u8, pos__: types.Vector3, rot__: types.Vector3, anim_enter_speed: f32, anim_exit_speed: f32, duration: c_int, flag: types.Any, anim_time: f32, rot_order: c_int, ik_flags: c_int) !void { try invoker.invoke(void, 0x83CDB10EA29B370B, .{ped, anim_dict, anim_name, pos__.x, pos__.y, pos__.z, rot__.x, rot__.y, rot__.z, anim_enter_speed, anim_exit_speed, duration, flag, anim_time, rot_order, ik_flags}); } // 0x83CDB10EA29B370B 0x3DDEB0E6 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn stopAnimTask(entity: types.Entity, anim_dictionary: [*c]const u8, animation_name: [*c]const u8, blend_delta: f32) !void { try invoker.invoke(void, 0x97FF36A1D40EA00A, .{entity, anim_dictionary, animation_name, blend_delta}); } // 0x97FF36A1D40EA00A 0x2B520A57 b323
    /// From fm_mission_controller.c: \
    /// reserve_network_mission_objects(get_num_reserved_mission_objects(0) + 1); \
    ///            vVar28 = {0.094f, 0.02f, -0.005f};
    ///             vVar29 = {-92.24f, 63.64f, 150.24f};
    ///           func_253(&uVar30, joaat("prop_ld_case_01"), Global_1592429.imm_34757[iParam1 <268>], 1, 1, 0, 1);
    ///          set_entity_lod_dist(net_to_ent(uVar30), 500);
    ///          attach_entity_to_entity(net_to_ent(uVar30), iParam0, get_ped_bone_index(iParam0, 28422), vVar28, vVar29, 1, 0, 0, 0, 2, 1);
    ///            Var31.imm_4 = 1065353216;
    ///          Var31.imm_5 = 1065353216;
    ///          Var31.imm_9 = 1065353216;
    ///          Var31.imm_10 = 1065353216;
    ///             Var31.imm_14 = 1065353216;
    ///             Var31.imm_15 = 1065353216;
    ///             Var31.imm_17 = 1040187392;
    ///             Var31.imm_18 = 1040187392;
    ///             Var31.imm_19 = -1;
    ///             Var32.imm_4 = 1065353216;
    ///          Var32.imm_5 = 1065353216;
    ///          Var32.imm_9 = 1065353216;
    ///          Var32.imm_10 = 1065353216;
    ///             Var32.imm_14 = 1065353216;
    ///             Var32.imm_15 = 1065353216;
    ///             Var32.imm_17 = 1040187392;
    ///             Var32.imm_18 = 1040187392;
    ///             Var32.imm_19 = -1;
    ///             Var31 = 1;
    ///             Var31.imm_1 = "weapons@misc@jerrycan@mp_male";
    ///           Var31.imm_2 = "idle";
    ///            Var31.imm_20 = 1048633;
    ///            Var31.imm_4 = 0.5f;
    ///            Var31.imm_16 = get_hash_key("BONEMASK_ARMONLY_R");
    ///           task_scripted_animation(iParam0, &Var31, &Var32, &Var32, 0f, 0.25f);
    ///           set_model_as_no_longer_needed(joaat("prop_ld_case_01"));
    ///             remove_anim_dict("anim@heists@biolab@");
    pub inline fn taskScriptedAnimation(ped: types.Ped, priority_low_data: [*c]c_int, priority_mid_data: [*c]c_int, priority_high_data: [*c]c_int, blend_in_delta: f32, blend_out_delta: f32) !void { try invoker.invoke(void, 0x126EF75F1E17ABE5, .{ped, priority_low_data, priority_mid_data, priority_high_data, blend_in_delta, blend_out_delta}); } // 0x126EF75F1E17ABE5 0xFC2DCF47 b323
    pub inline fn playEntityScriptedAnim(entity: types.Entity, priority_low_data: [*c]c_int, priority_mid_data: [*c]c_int, priority_high_data: [*c]c_int, blend_in_delta: f32, blend_out_delta: f32) !void { try invoker.invoke(void, 0x77A1EEC547E7FCF1, .{entity, priority_low_data, priority_mid_data, priority_high_data, blend_in_delta, blend_out_delta}); } // 0x77A1EEC547E7FCF1 0x02F72AE5 b323
    /// Looks like p1 may be a flag, still need to do some research, though.
    pub inline fn stopAnimPlayback(entity: types.Entity, priority: c_int, secondary: windows.BOOL) !void { try invoker.invoke(void, 0xEE08C992D238C5D1, .{entity, priority, secondary}); } // 0xEE08C992D238C5D1 0xE5F16398 b323
    pub inline fn setAnimWeight(entity: types.Entity, weight: f32, priority: c_int, index: c_int, secondary: windows.BOOL) !void { try invoker.invoke(void, 0x207F1A47C0342F48, .{entity, weight, priority, index, secondary}); } // 0x207F1A47C0342F48 0x17229D98 b323
    pub inline fn setAnimPhase(entity: types.Entity, phase: f32, priority: c_int, secondary: windows.BOOL) !void { try invoker.invoke(void, 0xDDF3CB5A0A4C0B49, .{entity, phase, priority, secondary}); } // 0xDDF3CB5A0A4C0B49 0xB621E7E4 b2372
    pub inline fn setAnimRate(entity: types.Entity, rate: f32, priority: c_int, secondary: windows.BOOL) !void { try invoker.invoke(void, 0x032D49C5E359C847, .{entity, rate, priority, secondary}); } // 0x032D49C5E359C847 0x6DB46584 b323
    pub inline fn setAnimLooped(entity: types.Entity, looped: windows.BOOL, priority: c_int, secondary: windows.BOOL) !void { try invoker.invoke(void, 0x70033C3CC29A1FF4, .{entity, looped, priority, secondary}); } // 0x70033C3CC29A1FF4 0x095D61A4 b323
    /// Example from the scripts: \
    /// TASK::TASK_PLAY_PHONE_GESTURE_ANIMATION(PLAYER::PLAYER_PED_ID(), v_3, v_2, v_4, 0.25, 0.25, 0, 0);
    /// 
    /// ========================================================= \
    /// ^^ No offense, but Idk how that would really help anyone.
    /// 
    /// As for the animDict & animation, they're both store in a global in all 5 scripts. So if anyone would be so kind as to read that global and comment what strings they use. Thanks.
    /// 
    /// Known boneMaskTypes' \
    /// "BONEMASK_HEADONLY" \
    /// "BONEMASK_HEAD_NECK_AND_ARMS" \
    /// "BONEMASK_HEAD_NECK_AND_L_ARM" \
    /// "BONEMASK_HEAD_NECK_AND_R_ARM"
    /// 
    /// p4 known args - 0.0f, 0.5f, 0.25f \
    /// p5 known args - 0.0f, 0.25f \
    /// p6 known args - 1 if a global if check is passed. \
    /// p7 known args - 1 if a global if check is passed.
    /// 
    /// The values found above, I found within the 5 scripts this is ever called in. (fmmc_launcher, fm_deathmatch_controller, fm_impromptu_dm_controller, fm_mission_controller, and freemode). \
    /// =========================================================
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn taskPlayPhoneGestureAnimation(ped: types.Ped, anim_dict: [*c]const u8, animation: [*c]const u8, bone_mask_type: [*c]const u8, blend_in_duration: f32, blend_out_duration: f32, is_looping: windows.BOOL, hold_last_frame: windows.BOOL) !void { try invoker.invoke(void, 0x8FBB6758B3B3E9EC, .{ped, anim_dict, animation, bone_mask_type, blend_in_duration, blend_out_duration, is_looping, hold_last_frame}); } // 0x8FBB6758B3B3E9EC 0x1582162C b323
    pub inline fn taskStopPhoneGestureAnimation(ped: types.Ped, blend_out_override: f32) !void { try invoker.invoke(void, 0x3FA00D4F4641BFAE, .{ped, blend_out_override}); } // 0x3FA00D4F4641BFAE 0x5A32D4B4 b323
    pub inline fn isPlayingPhoneGestureAnim(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB8EBB1E9D3588C10, .{ped}); } // 0xB8EBB1E9D3588C10 0x500B6805 b323
    pub inline fn getPhoneGestureAnimCurrentTime(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0x47619ABE8B268C60, .{ped}); } // 0x47619ABE8B268C60 0x7B72AFD1 b323
    pub inline fn getPhoneGestureAnimTotalTime(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0x1EE0F68A7C25DEC6, .{ped}); } // 0x1EE0F68A7C25DEC6 0xEF8C3959 b323
    /// Most probably plays a specific animation on vehicle. For example getting chop out of van etc...
    /// 
    /// Here's how its used - 
    /// 
    /// TASK::TASK_VEHICLE_PLAY_ANIM(l_325, "rcmnigel1b", "idle_speedo");
    /// 
    /// TASK::TASK_VEHICLE_PLAY_ANIM(l_556[0/*1*/], "missfra0_chop_drhome", "InCar_GetOutofBack_Speedo");
    /// 
    /// FYI : Speedo is the name of van in which chop was put in the mission.
    pub inline fn taskVehiclePlayAnim(vehicle: types.Vehicle, animation_set: [*c]const u8, animation_name: [*c]const u8) !void { try invoker.invoke(void, 0x69F5C3BD0F3EBD89, .{vehicle, animation_set, animation_name}); } // 0x69F5C3BD0F3EBD89 0x2B28F598 b323
    /// enum eScriptLookatFlags \
    /// { \
    ///     SLF_SLOW_TURN_RATE            = 1,    // turn the head toward the target slowly
    ///     SLF_FAST_TURN_RATE            = 2,    // turn the head toward the target quickly
    ///     SLF_EXTEND_YAW_LIMIT        = 4,    // wide yaw head limits
    ///     SLF_EXTEND_PITCH_LIMIT        = 8,    // wide pitch head limit
    ///     SLF_WIDEST_YAW_LIMIT        = 16,   // widest yaw head limit
    ///     SLF_WIDEST_PITCH_LIMIT        = 32,   // widest pitch head limit
    ///     SLF_NARROW_YAW_LIMIT        = 64,   // narrow yaw head limits
    ///     SLF_NARROW_PITCH_LIMIT        = 128,  // narrow pitch head limit
    ///     SLF_NARROWEST_YAW_LIMIT        = 256,  // narrowest yaw head limit
    ///     SLF_NARROWEST_PITCH_LIMIT    = 512,  // narrowest pitch head limit
    ///     SLF_USE_TORSO                = 1024, // use the torso aswell as the neck and head (currently disabled)
    ///     SLF_WHILE_NOT_IN_FOV        = 2048, // keep tracking the target even if they are not in the hard coded FOV
    ///     SLF_USE_CAMERA_FOCUS        = 4096, // use the camera as the target
    ///     SLF_USE_EYES_ONLY            = 8192, // only track the target with the eyes  
    ///     SLF_USE_LOOK_DIR            = 16384, // use information in look dir DOF
    ///     SLF_FROM_SCRIPT                = 32768, // internal use only
    ///     SLF_USE_REF_DIR_ABSOLUTE    = 65536  // use absolute reference direction mode for solver
    /// };
    pub inline fn taskLookAtCoord(entity: types.Entity, vec: types.Vector3, duration: c_int, flags: c_int, priority: c_int) !void { try invoker.invoke(void, 0x6FA46612594F7973, .{entity, vec.x, vec.y, vec.z, duration, flags, priority}); } // 0x6FA46612594F7973 0x7B784DD8 b323
    /// For flags, please refer to TASK_LOOK_AT_COORD.
    pub inline fn taskLookAtEntity(ped: types.Ped, look_at: types.Entity, duration: c_int, flags: c_int, priority: c_int) !void { try invoker.invoke(void, 0x69F4BE8C8CC4796C, .{ped, look_at, duration, flags, priority}); } // 0x69F4BE8C8CC4796C 0x991D6619 b323
    pub inline fn taskClearLookAt(ped: types.Ped) !void { try invoker.invoke(void, 0x0F804F1DB19B9689, .{ped}); } // 0x0F804F1DB19B9689 0x60EB4054 b323
    pub inline fn openSequenceTask(task_sequence_id: [*c]c_int) !void { try invoker.invoke(void, 0xE8854A4326B9E12B, .{task_sequence_id}); } // 0xE8854A4326B9E12B 0xABA6923E b323
    pub inline fn closeSequenceTask(task_sequence_id: c_int) !void { try invoker.invoke(void, 0x39E72BC99E6360CB, .{task_sequence_id}); } // 0x39E72BC99E6360CB 0x1A7CEBD0 b323
    pub inline fn taskPerformSequence(ped: types.Ped, task_sequence_id: c_int) !void { try invoker.invoke(void, 0x5ABA3986D90D8A3B, .{ped, task_sequence_id}); } // 0x5ABA3986D90D8A3B 0x4D9FBD11 b323
    pub inline fn taskPerformSequenceLocally(ped: types.Ped, task_sequence_id: c_int) !void { try invoker.invoke(void, 0x8C33220C8D78CA0D, .{ped, task_sequence_id}); } // 0x8C33220C8D78CA0D  b944
    pub inline fn clearSequenceTask(task_sequence_id: [*c]c_int) !void { try invoker.invoke(void, 0x3841422E9C488D8C, .{task_sequence_id}); } // 0x3841422E9C488D8C 0x47ED03CE b323
    pub inline fn setSequenceToRepeat(task_sequence_id: c_int, repeat: windows.BOOL) !void { try invoker.invoke(void, 0x58C70CF3A41E4AE7, .{task_sequence_id, repeat}); } // 0x58C70CF3A41E4AE7 0xCDDF1508 b323
    pub inline fn setSequencePreventMigration(task_sequence_id: c_int) !void { try invoker.invoke(void, 0xF5D1F489147CB683, .{task_sequence_id}); } // 0xF5D1F489147CB683  b3570
    /// returned values: \
    /// 0 to 7 = task that's currently in progress, 0 meaning the first one. \
    /// -1 no task sequence in progress.
    pub inline fn getSequenceProgress(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x00A9010CFE1E3533, .{ped}); } // 0x00A9010CFE1E3533 0xA3419909 b323
    /// Task index enum: https://alloc8or.re/gta5/doc/enums/eTaskTypeIndex.txt
    pub inline fn getIsTaskActive(ped: types.Ped, task_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB0760331C7AA4155, .{ped, task_index}); } // 0xB0760331C7AA4155 0x86FDDF55 b323
    /// Gets the status of a script-assigned task. \
    /// taskHash: https://alloc8or.re/gta5/doc/enums/eScriptTaskHash.txt
    pub inline fn getScriptTaskStatus(ped: types.Ped, task_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x77F1BEB8863288D5, .{ped, task_hash}); } // 0x77F1BEB8863288D5 0xB2477B23 b323
    /// https://alloc8or.re/gta5/doc/enums/eVehicleMissionType.txt
    pub inline fn getActiveVehicleMissionType(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x534AEBA6E5ED4CAB, .{vehicle}); } // 0x534AEBA6E5ED4CAB 0xAFA914EF b323
    /// Flags are the same flags used in TASK_LEAVE_VEHICLE
    pub inline fn taskLeaveAnyVehicle(ped: types.Ped, delay_time: c_int, flags: c_int) !void { try invoker.invoke(void, 0x504D54DF3F6F2247, .{ped, delay_time, flags}); } // 0x504D54DF3F6F2247 0xDBDD79FA b323
    pub inline fn taskAimGunScripted(ped: types.Ped, script_task: types.Hash, disable_blocking_clip: windows.BOOL, instant_blend_to_aim: windows.BOOL) !void { try invoker.invoke(void, 0x7A192BE16D373D00, .{ped, script_task, disable_blocking_clip, instant_blend_to_aim}); } // 0x7A192BE16D373D00 0x9D296BCD b323
    pub inline fn taskAimGunScriptedWithTarget(ped: types.Ped, target: types.Ped, vec: types.Vector3, gun_task_type: c_int, disable_blocking_clip: windows.BOOL, force_aim: windows.BOOL) !void { try invoker.invoke(void, 0x8605AF0DE8B3A5AC, .{ped, target, vec.x, vec.y, vec.z, gun_task_type, disable_blocking_clip, force_aim}); } // 0x8605AF0DE8B3A5AC 0xFD517CE3 b323
    pub inline fn updateTaskAimGunScriptedTarget(ped: types.Ped, target: types.Ped, vec: types.Vector3, disable_blocking_clip: windows.BOOL) !void { try invoker.invoke(void, 0x9724FB59A3E72AD0, .{ped, target, vec.x, vec.y, vec.z, disable_blocking_clip}); } // 0x9724FB59A3E72AD0 0x67E73525 b323
    pub inline fn getClipSetForScriptedGunTask(gun_task_type: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x3A8CADC7D37AACC5, .{gun_task_type}); } // 0x3A8CADC7D37AACC5 0x249EB4EB b323
    /// duration: the amount of time in milliseconds to do the task.  -1 will keep the task going until either another task is applied, or CLEAR_ALL_TASKS() is called with the ped
    pub inline fn taskAimGunAtEntity(ped: types.Ped, entity: types.Entity, duration: c_int, instant_blend_to_aim: windows.BOOL) !void { try invoker.invoke(void, 0x9B53BB6E8943AF53, .{ped, entity, duration, instant_blend_to_aim}); } // 0x9B53BB6E8943AF53 0xBE32B3B6 b323
    /// duration: the amount of time in milliseconds to do the task. -1 will keep the task going until either another task is applied, or CLEAR_ALL_TASKS() is called with the ped
    pub inline fn taskTurnPedToFaceEntity(ped: types.Ped, entity: types.Entity, duration: c_int) !void { try invoker.invoke(void, 0x5AD23D40115353AC, .{ped, entity, duration}); } // 0x5AD23D40115353AC 0x3C37C767 b323
    pub inline fn taskAimGunAtCoord(ped: types.Ped, vec: types.Vector3, time: c_int, instant_blend_to_aim: windows.BOOL, play_anim_intro: windows.BOOL) !void { try invoker.invoke(void, 0x6671F3EEC681BDA1, .{ped, vec.x, vec.y, vec.z, time, instant_blend_to_aim, play_anim_intro}); } // 0x6671F3EEC681BDA1 0xFBF44AD3 b323
    /// Firing Pattern Hash Information: https://pastebin.com/Px036isB
    pub inline fn taskShootAtCoord(ped: types.Ped, vec: types.Vector3, duration: c_int, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0x46A6CC01E0826106, .{ped, vec.x, vec.y, vec.z, duration, firing_pattern}); } // 0x46A6CC01E0826106 0x601C22E3 b323
    /// Makes the specified ped shuffle to the next vehicle seat. \
    /// The ped MUST be in a vehicle and the vehicle parameter MUST be the ped's current vehicle.
    pub inline fn taskShuffleToNextVehicleSeat(ped: types.Ped, vehicle: types.Vehicle, use_alternate_shuffle: windows.BOOL) !void { try invoker.invoke(void, 0x7AA80209BDA643EB, .{ped, vehicle, use_alternate_shuffle}); } // 0x7AA80209BDA643EB 0xBEAF8F67 b323
    pub inline fn clearPedTasks(ped: types.Ped) !void { try invoker.invoke(void, 0xE1EF3C1216AFF2CD, .{ped}); } // 0xE1EF3C1216AFF2CD 0xDE3316AB b323
    pub inline fn clearPedScriptTaskIfRunningThreatResponseNonTempTask(ped: types.Ped) !void { try invoker.invoke(void, 0xF6DC48E56BE1243A, .{ped}); } // 0xF6DC48E56BE1243A  b3407
    pub inline fn clearPedSecondaryTask(ped: types.Ped) !void { try invoker.invoke(void, 0x176CECF6F920D707, .{ped}); } // 0x176CECF6F920D707 0xA635F451 b323
    pub inline fn taskEveryoneLeaveVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x7F93691AB4B92272, .{vehicle}); } // 0x7F93691AB4B92272 0xC1971F30 b323
    /// enum ESEEK_ENTITY_OFFSET_FLAGS \
    /// { \
    ///     ESEEK_OFFSET_ORIENTATES_WITH_ENTITY = 0x01,
    ///     ESEEK_KEEP_TO_PAVEMENTS = 0x02
    /// };
    pub inline fn taskGotoEntityOffset(ped: types.Ped, entity: types.Entity, time: c_int, seek_radius: f32, seek_angle_deg: f32, move_blend_ratio: f32, goto_entity_offset_flags: c_int) !void { try invoker.invoke(void, 0xE39B4FF4FDEBDE27, .{ped, entity, time, seek_radius, seek_angle_deg, move_blend_ratio, goto_entity_offset_flags}); } // 0xE39B4FF4FDEBDE27 0x1A17A85E b323
    pub inline fn taskGotoEntityOffsetXy(ped: types.Ped, entity: types.Entity, duration: c_int, target_radius: f32, offset__: types.Vector2, move_blend_ratio: f32, goto_entity_offset_flags: c_int) !void { try invoker.invoke(void, 0x338E7EF52B6095A9, .{ped, entity, duration, target_radius, offset__.x, offset__.y, move_blend_ratio, goto_entity_offset_flags}); } // 0x338E7EF52B6095A9 0xBC1E3D0A b323
    /// duration in milliseconds
    pub inline fn taskTurnPedToFaceCoord(ped: types.Ped, vec: types.Vector3, duration: c_int) !void { try invoker.invoke(void, 0x1DDA930A0AC38571, .{ped, vec.x, vec.y, vec.z, duration}); } // 0x1DDA930A0AC38571 0x30463D73 b323
    /// '1 - brake \
    /// '3 - brake + reverse \
    /// '4 - turn left 90 + braking \
    /// '5 - turn right 90 + braking \
    /// '6 - brake strong (handbrake?) until time ends \
    /// '7 - turn left + accelerate \
    /// '8 - turn right + accelerate \
    /// '9 - weak acceleration \
    /// '10 - turn left + restore wheel pos to center in the end \
    /// '11 - turn right + restore wheel pos to center in the end \
    /// '13 - turn left + go reverse \
    /// '14 - turn left + go reverse \
    /// '16 - crash the game after like 2 seconds :) \
    /// '17 - keep actual state, game crashed after few tries \
    /// '18 - game crash \
    /// '19 - strong brake + turn left/right \
    /// '20 - weak brake + turn left then turn right \
    /// '21 - weak brake + turn right then turn left \
    /// '22 - brake + reverse \
    /// '23 - accelerate fast \
    /// '24 - brake \
    /// '25 - brake turning left then when almost stopping it turns left more \
    /// '26 - brake turning right then when almost stopping it turns right more \
    /// '27 - brake until car stop or until time ends \
    /// '28 - brake + strong reverse acceleration \
    /// '30 - performs a burnout (brake until stop + brake and accelerate) \
    /// '31 - accelerate + handbrake \
    /// '32 - accelerate very strong
    /// 
    /// Seems to be this: \
    /// Works on NPCs, but overrides their current task. If inside a task sequence (and not being the last task), "time" will work, otherwise the task will be performed forever until tasked with something else
    pub inline fn taskVehicleTempAction(driver: types.Ped, vehicle: types.Vehicle, action: c_int, time: c_int) !void { try invoker.invoke(void, 0xC429DCEEB339E129, .{driver, vehicle, action, time}); } // 0xC429DCEEB339E129 0x0679DFB8 b323
    /// missionType: https://alloc8or.re/gta5/doc/enums/eVehicleMissionType.txt
    pub inline fn taskVehicleMission(driver: types.Ped, vehicle: types.Vehicle, vehicle_target: types.Vehicle, mission_type: c_int, cruise_speed: f32, driving_style: c_int, target_reached: f32, straight_line_distance: f32, _drive_against_traffic: windows.BOOL) !void { try invoker.invoke(void, 0x659427E0EF36BCDE, .{driver, vehicle, vehicle_target, mission_type, cruise_speed, driving_style, target_reached, straight_line_distance, _drive_against_traffic}); } // 0x659427E0EF36BCDE 0x20609E56 b323
    /// See TASK_VEHICLE_MISSION
    pub inline fn taskVehicleMissionPedTarget(ped: types.Ped, vehicle: types.Vehicle, ped_target: types.Ped, mission_type: c_int, max_speed: f32, driving_style: c_int, min_distance: f32, straight_line_distance: f32, _drive_against_traffic: windows.BOOL) !void { try invoker.invoke(void, 0x9454528DF15D657A, .{ped, vehicle, ped_target, mission_type, max_speed, driving_style, min_distance, straight_line_distance, _drive_against_traffic}); } // 0x9454528DF15D657A 0xC81C4677 b323
    /// See TASK_VEHICLE_MISSION
    pub inline fn taskVehicleMissionCoorsTarget(ped: types.Ped, vehicle: types.Vehicle, vec: types.Vector3, mission: c_int, cruise_speed: f32, driving_style: c_int, target_reached: f32, straight_line_distance: f32, _drive_against_traffic: windows.BOOL) !void { try invoker.invoke(void, 0xF0AF20AA7731F8C3, .{ped, vehicle, vec.x, vec.y, vec.z, mission, cruise_speed, driving_style, target_reached, straight_line_distance, _drive_against_traffic}); } // 0xF0AF20AA7731F8C3 0x6719C109 b323
    /// Makes a ped follow the targetVehicle with <minDistance> in between.
    /// 
    /// note: minDistance is ignored if drivingstyle is avoiding traffic, but Rushed is fine.
    /// 
    /// Mode: The mode defines the relative position to the targetVehicle. The ped will try to position its vehicle there. \
    /// -1 = behind \
    /// 0 = ahead \
    /// 1 = left \
    /// 2 = right \
    /// 3 = back left \
    /// 4 = back right
    /// 
    /// if the target is closer than noRoadsDistance, the driver will ignore pathing/roads and follow you directly.
    /// 
    /// Driving Styles guide: gtaforums.com/topic/822314-guide-driving-styles/
    pub inline fn taskVehicleEscort(ped: types.Ped, vehicle: types.Vehicle, target_vehicle: types.Vehicle, mode: c_int, speed: f32, driving_style: c_int, min_distance: f32, min_height_above_terrain: c_int, no_roads_distance: f32) !void { try invoker.invoke(void, 0x0FA6E4B75F302400, .{ped, vehicle, target_vehicle, mode, speed, driving_style, min_distance, min_height_above_terrain, no_roads_distance}); } // 0x0FA6E4B75F302400 0x9FDCB250 b323
    /// Makes a ped in a vehicle follow an entity (ped, vehicle, etc.)
    /// 
    /// drivingStyle: http://gtaforums.com/topic/822314-guide-driving-styles/
    pub inline fn taskVehicleFollow(driver: types.Ped, vehicle: types.Vehicle, target_entity: types.Entity, speed: f32, driving_style: c_int, min_distance: c_int) !void { try invoker.invoke(void, 0xFC545A9F0626E3B6, .{driver, vehicle, target_entity, speed, driving_style, min_distance}); } // 0xFC545A9F0626E3B6 0xA8B917D7 b323
    /// chases targetEnt fast and aggressively \
    /// -- \
    /// Makes ped (needs to be in vehicle) chase targetEnt.
    pub inline fn taskVehicleChase(driver: types.Ped, target_ent: types.Entity) !void { try invoker.invoke(void, 0x3C08A8E30363B353, .{driver, target_ent}); } // 0x3C08A8E30363B353 0x55634798 b323
    /// pilot, vehicle and altitude are rather self-explanatory.
    /// 
    /// p4: is unused variable in the function.
    /// 
    /// entityToFollow: you can provide a Vehicle entity or a Ped entity, the heli will protect them.
    /// 
    /// 'targetSpeed':  The pilot will dip the nose AS MUCH AS POSSIBLE so as to reach this value AS FAST AS POSSIBLE.  As such, you'll want to modulate it as opposed to calling it via a hard-wired, constant #.
    /// 
    /// 'radius' isn't just "stop within radius of X of target" like with ground vehicles.  In this case, the pilot will fly an entire circle around 'radius' and continue to do so.
    /// 
    /// NOT CONFIRMED:  p7 appears to be a FlyingStyle enum.  Still investigating it as of this writing, but playing around with values here appears to result in different -behavior- as opposed to offsetting coordinates, altitude, target speed, etc.
    /// 
    /// NOTE: If the pilot finds enemies, it will engage them until it kills them, but will return to protect the ped/vehicle given shortly thereafter.
    pub inline fn taskVehicleHeliProtect(pilot: types.Ped, vehicle: types.Vehicle, entity_to_follow: types.Entity, target_speed: f32, driving_flags: c_int, radius: f32, altitude: c_int, heli_flags: c_int) !void { try invoker.invoke(void, 0x1E09C32048FEFD1C, .{pilot, vehicle, entity_to_follow, target_speed, driving_flags, radius, altitude, heli_flags}); } // 0x1E09C32048FEFD1C 0x0CB415EE b323
    /// Flag 8: Medium-aggressive boxing tactic with a bit of PIT \
    /// Flag 1: Aggressive ramming of suspect \
    /// Flag 2: Ram attempts \
    /// Flag 32: Stay back from suspect, no tactical contact. Convoy-like. \
    /// Flag 16: Ramming, seems to be slightly less aggressive than 1-2.
    pub inline fn setTaskVehicleChaseBehaviorFlag(ped: types.Ped, flag: c_int, set: windows.BOOL) !void { try invoker.invoke(void, 0xCC665AAC360D31E7, .{ped, flag, set}); } // 0xCC665AAC360D31E7 0x2A83083F b323
    pub inline fn setTaskVehicleChaseIdealPursuitDistance(ped: types.Ped, distance: f32) !void { try invoker.invoke(void, 0x639B642FACBE4EDD, .{ped, distance}); } // 0x639B642FACBE4EDD 0x04FD3EE7 b323
    /// Ped pilot should be in a heli. \
    /// EntityToFollow can be a vehicle or Ped.
    /// 
    /// x,y,z appear to be how close to the EntityToFollow the heli should be. Scripts use 0.0, 0.0, 80.0. Then the heli tries to position itself 80 units above the EntityToFollow. If you reduce it to -5.0, it tries to go below (if the EntityToFollow is a heli or plane)
    /// 
    /// 
    /// NOTE: If the pilot finds enemies, it will engage them, then remain there idle, not continuing to chase the Entity given.
    pub inline fn taskHeliChase(pilot: types.Ped, entity_to_follow: types.Entity, vec: types.Vector3) !void { try invoker.invoke(void, 0xAC83B1DB38D0ADA0, .{pilot, entity_to_follow, vec.x, vec.y, vec.z}); } // 0xAC83B1DB38D0ADA0 0xAC290A21 b323
    pub inline fn taskPlaneChase(pilot: types.Ped, entity_to_follow: types.Entity, vec: types.Vector3) !void { try invoker.invoke(void, 0x2D2386F273FF7A25, .{pilot, entity_to_follow, vec.x, vec.y, vec.z}); } // 0x2D2386F273FF7A25 0x12FA1C28 b323
    pub inline fn taskPlaneLand(pilot: types.Ped, plane: types.Vehicle, runwaystart__: types.Vector3, runwayend__: types.Vector3) !void { try invoker.invoke(void, 0xBF19721FA34D32C0, .{pilot, plane, runwaystart__.x, runwaystart__.y, runwaystart__.z, runwayend__.x, runwayend__.y, runwayend__.z}); } // 0xBF19721FA34D32C0 0x5F7E23EA b323
    pub inline fn clearDefaultPrimaryTask(ped: types.Ped) !void { try invoker.invoke(void, 0x6100B3CEFD43452E, .{ped}); } // 0x6100B3CEFD43452E  b2189
    /// This native is very useful when switching the player to a ped inside a vehicle that has a task assigned prior to the player switch. \
    /// It is necessary to clear the ped's tasks AND call this native with the vehicle the player is switching into in order to allow the player to control the vehicle after the player switches.
    pub inline fn clearPrimaryVehicleTask(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xDBBC7A2432524127, .{vehicle}); } // 0xDBBC7A2432524127  b1290
    pub inline fn clearVehicleCrashTask(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x53DDC75BC3AC0A90, .{vehicle}); } // 0x53DDC75BC3AC0A90  b1290
    pub inline fn taskPlaneGotoPreciseVtol(ped: types.Ped, vehicle: types.Vehicle, vec: types.Vector3, flight_height: c_int, min_height_above_terrain: c_int, use_desired_orientation: windows.BOOL, desired_orientation: f32, autopilot: windows.BOOL) !void { try invoker.invoke(void, 0xF7F9DCCA89E7505B, .{ped, vehicle, vec.x, vec.y, vec.z, flight_height, min_height_above_terrain, use_desired_orientation, desired_orientation, autopilot}); } // 0xF7F9DCCA89E7505B  b1290
    /// Used in am_vehicle_spawn.ysc and am_mp_submarine.ysc.
    /// 
    /// p0 is always 0, p5 is always 1
    /// 
    /// p1 is the vehicle handle of the submarine. Submarine must have a driver, but the ped handle is not passed to the native.
    /// 
    /// Speed can be set by calling SET_DRIVE_TASK_CRUISE_SPEED after
    pub inline fn taskSubmarineGotoAndStop(ped: types.Ped, submarine: types.Vehicle, vec: types.Vector3, autopilot: windows.BOOL) !void { try invoker.invoke(void, 0xC22B40579A498CA4, .{ped, submarine, vec.x, vec.y, vec.z, autopilot}); } // 0xC22B40579A498CA4  b2189
    /// Must have targetVehicle, targetPed, OR destination X/Y/Z set \
    /// Will follow targeted vehicle/ped, or fly to destination \
    /// Set whichever is not being used to 0
    /// 
    /// 
    /// Mission mode type: \
    ///  - 4, 7: Forces heli to snap to the heading if set, flies to destination or tracks specified entity (mode 4 only works for coordinates, 7 works for coordinates OR ped/vehicle) \
    ///  - 6: Attacks the target ped/vehicle with mounted weapons. If radius is set, will maintain that distance from target. \
    ///  - 8: Makes the heli flee from the ped/vehicle/coordinate \
    ///  - 9: Circles around target ped/vehicle, snaps to angle if set. Behavior flag (last parameter) of 2048 switches from counter-clockwise to clockwise circling. Does not work with coordinate destination. \
    ///  - 10, 11: Follows ped/vehicle target and imitates target heading. Only works with ped/vehicle target, not coord target \
    ///  - 19: Heli lands at specified coordinate, ignores heading (lands facing whatever direction it is facing when the task is started) \
    ///  - 20: Makes the heli land when near target ped. It won't resume chasing. \
    ///  - 21: Emulates a helicopter crash \
    ///  - 23: makes the heli circle erratically around ped
    /// 
    /// 
    /// Heli will fly at maxSpeed (up to actual maximum speed defined by the model's handling config) \
    /// You can use SET_DRIVE_TASK_CRUISE_SPEED to modulate the speed based on distance to the target without having to re-invoke the task native. Setting to 8.0 when close to the destination results in a much smoother approach.
    /// 
    /// If minHeight and maxHeight are set, heli will fly between those specified elevations, relative to ground level and any obstructions/buildings below. You can specify -1 for either if you only want to specify one. Usually it is easiest to leave maxHeight at -1, and specify a reasonable minHeight to ensure clearance over any obstacles. Note this MUST be passed as an INT, not a FLOAT. 
    /// 
    /// Radius affects how closely the heli will follow tracked ped/vehicle, and when circling (mission type 9) sets the radius (in meters) that it will circle the target from
    /// 
    /// Heading is -1.0 for default behavior, which will point the nose of the helicopter towards the destination. Set a heading and the heli will lock to that direction when near its destination/target, but may still turn towards the destination when flying at higher speed from a further distance.
    /// 
    /// Behavior Flags is a bitwise value that modifies the AI behavior. Not clear what all flags do, but here are some guesses/notes: \
    ///    1: Forces heading to face E
    ///    2: Unknown
    ///    4: Tight circles around coordinate destination
    ///    8: Unknown
    ///   16: Circles around coordinate destination facing towards destination
    ///   32: Flys to normally, then lands at coordinate destination and stays on the ground (using mission type 4)
    ///   64: Ignores obstacles when flying, will follow at specified minHeight above ground level but will not avoid buildings, vehicles, etc.
    ///  128: Unknown \
    ///  256: Unknown \
    ///  512: Unknown \
    /// 1024: Unknown  \
    /// 2048: Reverses direction of circling (mission type 9) to clockwise \
    /// 4096: Hugs closer to the ground, maintains minHeight from ground generally, but barely clears buildings and dips down more between buildings instead of taking a more efficient/safe route \
    /// 8192: Unknown
    /// 
    /// Unk3 is a float value, you may see -1082130432 for this value in decompiled native scripts, this is the equivalent to -1.0f. Seems to affect acceleration/aggressiveness, but not sure exactly how it works. Higher value seems to result in lower acceleration/less aggressive flying. Almost always -1.0 in native scripts, occasionally 20.0 or 50.0. Setting to 400.0 seems to work well for making the pilot not overshoot the destination when using coordinate destination.
    /// 
    /// Notes updated by PNWParksFan, May 2021
    /// 
    pub inline fn taskHeliMission(pilot: types.Ped, aircraft: types.Vehicle, target_vehicle: types.Vehicle, target_ped: types.Ped, destination__: types.Vector3, mission_flag: c_int, max_speed: f32, radius: f32, target_heading: f32, max_height: c_int, min_height: c_int, slow_down_distance: f32, behavior_flags: c_int) !void { try invoker.invoke(void, 0xDAD029E187A2BEB4, .{pilot, aircraft, target_vehicle, target_ped, destination__.x, destination__.y, destination__.z, mission_flag, max_speed, radius, target_heading, max_height, min_height, slow_down_distance, behavior_flags}); } // 0xDAD029E187A2BEB4 0x0C143E97 b323
    pub inline fn taskHeliEscortHeli(pilot: types.Ped, heli_1: types.Vehicle, heli_2: types.Vehicle, offset__: types.Vector3) !void { try invoker.invoke(void, 0xB385523325077210, .{pilot, heli_1, heli_2, offset__.x, offset__.y, offset__.z}); } // 0xB385523325077210  b1290
    /// EXAMPLE USAGE:
    /// 
    /// Fly around target (Precautiously, keeps high altitude): \
    /// Function.Call(Hash.TASK_PLANE_MISSION, pilot, selectedAirplane, 0, 0, Target.X, Target.Y, Target.Z, 4, 100f, 0f, 90f, 0, 200f);
    /// 
    /// Fly around target (Dangerously, keeps VERY low altitude): \
    /// Function.Call(Hash.TASK_PLANE_MISSION, pilot, selectedAirplane, 0, 0, Target.X, Target.Y, Target.Z, 4, 100f, 0f, 90f, 0, -500f);
    /// 
    /// Fly directly into target: \
    /// Function.Call(Hash.TASK_PLANE_MISSION, pilot, selectedAirplane, 0, 0, Target.X, Target.Y, Target.Z, 4, 100f, 0f, 90f, 0, -5000f);
    /// 
    /// EXPANDED INFORMATION FOR ADVANCED USAGE (custom pilot)
    /// 
    /// 'physicsSpeed': (THIS IS NOT YOUR ORDINARY SPEED PARAMETER: READ!!) \
    /// Think of this -first- as a radius value, not a true speed value.  The ACTUAL effective speed of the plane will be that of the maximum speed permissible to successfully fly in a -circle- with a radius of 'physicsSpeed'.  This also means that the plane must complete a circle before it can begin its "bombing run", its straight line pass towards the target.  p9 appears to influence the angle at which a "bombing run" begins, although I can't confirm yet.
    /// 
    /// VERY IMPORTANT: A "bombing run" will only occur if a plane can successfully determine a possible navigable route (the slower the value of 'physicsSpeed', the more precise the pilot can be due to less influence of physics on flightpath).  Otherwise, the pilot will continue to patrol around Destination (be it a dynamic Entity position vector or a fixed world coordinate vector.)
    /// 
    /// 0 = Plane's physics are almost entirely frozen, plane appears to "orbit" around precise destination point \
    /// 1-299 = Blend of "frozen, small radius" vs. normal vs. "accelerated, hyperfast, large radius" \
    /// 300+ =  Vehicle behaves entirely like a normal gameplay plane.
    /// 
    /// 'patrolBlend' (The lower the value, the more the Destination is treated as a "fly AT" rather than a "fly AROUND point".)
    /// 
    /// Scenario: Destination is an Entity on ground level, wide open field \
    /// -5000 = Pilot kamikazes directly into Entity \
    /// -1000 = Pilot flies extremely low -around- Entity, very prone to crashing \
    /// -200 = Pilot flies lower than average around Entity. \
    /// 0 = Pilot flies around Entity, normal altitude \
    /// 200 = Pilot flies an extra eighty units or so higher than 0 while flying around Destination (this doesn't seem to correlate directly into distance units.)
    /// 
    /// -- Valid mission types found in the exe: --
    /// 
    /// 0 = None \
    /// 1 = Unk \
    /// 2 = CTaskVehicleRam \
    /// 3 = CTaskVehicleBlock \
    /// 4 = CTaskVehicleGoToPlane \
    /// 5 = CTaskVehicleStop \
    /// 6 = CTaskVehicleAttack \
    /// 7 = CTaskVehicleFollow \
    /// 8 = CTaskVehicleFleeAirborne \
    /// 9= CTaskVehicleCircle \
    /// 10 = CTaskVehicleEscort \
    /// 15 = CTaskVehicleFollowRecording \
    /// 16 = CTaskVehiclePoliceBehaviour \
    /// 17 = CTaskVehicleCrash
    pub inline fn taskPlaneMission(pilot: types.Ped, aircraft: types.Vehicle, target_vehicle: types.Vehicle, target_ped: types.Ped, destination__: types.Vector3, mission_flag: c_int, angular_drag: f32, target_reached: f32, target_heading: f32, max_z: f32, min_z: f32, precise: windows.BOOL) !void { try invoker.invoke(void, 0x23703CD154E83B88, .{pilot, aircraft, target_vehicle, target_ped, destination__.x, destination__.y, destination__.z, mission_flag, angular_drag, target_reached, target_heading, max_z, min_z, precise}); } // 0x23703CD154E83B88 0x1D007E65 b323
    pub inline fn taskPlaneTaxi(pilot: types.Ped, aircraft: types.Vehicle, vec: types.Vector3, cruise_speed: f32, target_reached: f32) !void { try invoker.invoke(void, 0x92C360B5F15D2302, .{pilot, aircraft, vec.x, vec.y, vec.z, cruise_speed, target_reached}); } // 0x92C360B5F15D2302  b1103
    /// You need to call PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS after TASK_BOAT_MISSION in order for the task to execute.
    /// 
    /// Working example \
    /// float vehicleMaxSpeed = VEHICLE::GET_VEHICLE_ESTIMATED_MAX_SPEED(ENTITY::GET_ENTITY_MODEL(pedVehicle)); \
    /// TASK::TASK_BOAT_MISSION(pedDriver, pedVehicle, 0, 0, waypointCoord.x, waypointCoord.y, waypointCoord.z, 4, vehicleMaxSpeed, 786469, -1.0, 7); \
    /// PED::SET_BLOCKING_OF_NON_TEMPORARY_EVENTS(pedDriver, 1);
    /// 
    /// P8 appears to be driving style flag - see gtaforums.com/topic/822314-guide-driving-styles/ for documentation
    pub inline fn taskBoatMission(ped_driver: types.Ped, vehicle: types.Vehicle, target_vehicle: types.Vehicle, target_ped: types.Ped, vec: types.Vector3, mission: c_int, max_speed: f32, driving_style: c_int, target_reached: f32, boat_flags: types.Any) !void { try invoker.invoke(void, 0x15C86013127CE63F, .{ped_driver, vehicle, target_vehicle, target_ped, vec.x, vec.y, vec.z, mission, max_speed, driving_style, target_reached, boat_flags}); } // 0x15C86013127CE63F 0x5865B031 b323
    /// Example:
    /// 
    /// TASK::TASK_DRIVE_BY(l_467[1/*22*/], PLAYER::PLAYER_PED_ID(), 0, 0.0, 0.0, 2.0, 300.0, 100, 0, ${firing_pattern_burst_fire_driveby});
    /// 
    /// 
    /// 
    /// 
    /// Needs working example. Doesn't seem to do anything.
    /// 
    /// I marked p2 as targetVehicle as all these shooting related tasks seem to have that in common. \
    /// I marked p6 as distanceToShoot as if you think of GTA's Logic with the native SET_VEHICLE_SHOOT natives, it won't shoot till it gets within a certain distance of the target. \
    /// I marked p7 as pedAccuracy as it seems it's mostly 100 (Completely Accurate), 75, 90, etc. Although this could be the ammo count within the gun, but I highly doubt it. I will change this comment once I find out if it's ammo count or not.
    pub inline fn taskDriveBy(driver_ped: types.Ped, target_ped: types.Ped, target_vehicle: types.Vehicle, target__: types.Vector3, distance_to_shoot: f32, ped_accuracy: c_int, push_underneath_driving_task_if_driving: windows.BOOL, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0x2F8AF0E82773A171, .{driver_ped, target_ped, target_vehicle, target__.x, target__.y, target__.z, distance_to_shoot, ped_accuracy, push_underneath_driving_task_if_driving, firing_pattern}); } // 0x2F8AF0E82773A171 0x2B84D1C4 b323
    /// For p1 & p2 (Ped, Vehicle). I could be wrong, as the only time this native is called in scripts is once and both are 0, but I assume this native will work like SET_MOUNTED_WEAPON_TARGET in which has the same exact amount of parameters and the 1st and last 3 parameters are right and the same for both natives.
    pub inline fn setDrivebyTaskTarget(shooting_ped: types.Ped, target_ped: types.Ped, target_vehicle: types.Vehicle, vec: types.Vector3) !void { try invoker.invoke(void, 0xE5B302114D8162EE, .{shooting_ped, target_ped, target_vehicle, vec.x, vec.y, vec.z}); } // 0xE5B302114D8162EE 0xDA6A6FC1 b323
    pub inline fn clearDrivebyTaskUnderneathDrivingTask(ped: types.Ped) !void { try invoker.invoke(void, 0xC35B5CDB2824CF69, .{ped}); } // 0xC35B5CDB2824CF69 0x9B76F7E6 b323
    pub inline fn isDrivebyTaskUnderneathDrivingTask(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8785E6E40C7A8818, .{ped}); } // 0x8785E6E40C7A8818 0xB23F46E6 b323
    /// Forces the ped to use the mounted weapon. \
    /// Returns false if task is not possible.
    pub inline fn controlMountedWeapon(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDCFE42068FE0135A, .{ped}); } // 0xDCFE42068FE0135A 0x500D9244 b323
    /// Note: Look in decompiled scripts and the times that p1 and p2 aren't 0. They are filled with vars. If you look through out that script what other natives those vars are used in, you can tell p1 is a ped and p2 is a vehicle. Which most likely means if you want the mounted weapon to target a ped set targetVehicle to 0 or vice-versa.
    pub inline fn setMountedWeaponTarget(shooting_ped: types.Ped, target_ped: types.Ped, target_vehicle: types.Vehicle, vec: types.Vector3, task_mode: c_int, ignore_target_veh_dead_check: windows.BOOL) !void { try invoker.invoke(void, 0xCCD892192C6D2BB9, .{shooting_ped, target_ped, target_vehicle, vec.x, vec.y, vec.z, task_mode, ignore_target_veh_dead_check}); } // 0xCCD892192C6D2BB9 0x98713C68 b323
    pub inline fn isMountedWeaponTaskUnderneathDrivingTask(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA320EF046186FA3B, .{ped}); } // 0xA320EF046186FA3B 0x291E938C b323
    /// Actually has 3 params, not 2.
    /// 
    /// p0: Ped \
    /// p1: int (or bool?) \
    /// p2: int
    pub inline fn taskUseMobilePhone(ped: types.Ped, use_phone: windows.BOOL, desired_phone_mode: c_int) !void { try invoker.invoke(void, 0xBD2A8EC3AF4DE7DB, .{ped, use_phone, desired_phone_mode}); } // 0xBD2A8EC3AF4DE7DB 0x225A38C8 b323
    pub inline fn taskUseMobilePhoneTimed(ped: types.Ped, duration: c_int) !void { try invoker.invoke(void, 0x5EE02954A14C69DB, .{ped, duration}); } // 0x5EE02954A14C69DB 0xC99C19F5 b323
    /// p2 tend to be 16, 17 or 1 \
    /// p3 to p7 tend to be 0.0
    pub inline fn taskChatToPed(ped: types.Ped, target: types.Ped, flags: c_int, gotolocation__: types.Vector3, heading_degs: f32, idle_time: f32) !void { try invoker.invoke(void, 0x8C338E0263E4FD19, .{ped, target, flags, gotolocation__.x, gotolocation__.y, gotolocation__.z, heading_degs, idle_time}); } // 0x8C338E0263E4FD19 0xA2BE1821 b323
    /// Seat Numbers \
    /// ------------------------------- \
    /// Driver = -1 \
    /// Any = -2 \
    /// Left-Rear = 1 \
    /// Right-Front = 0 \
    /// Right-Rear = 2 \
    /// Extra seats = 3-14(This may differ from vehicle type e.g. Firetruck Rear Stand, Ambulance Rear)
    pub inline fn taskWarpPedIntoVehicle(ped: types.Ped, vehicle: types.Vehicle, seat: c_int) !void { try invoker.invoke(void, 0x9A7D091411C5F684, .{ped, vehicle, seat}); } // 0x9A7D091411C5F684 0x65D4A35D b323
    /// //this part of the code is to determine at which entity the player is aiming, for example if you want to create a mod where you give orders to peds \
    /// Entity aimedentity; \
    /// Player player = PLAYER::PLAYER_ID(); \
    /// PLAYER::_GET_AIMED_ENTITY(player, &aimedentity);
    /// 
    /// //bg is an array of peds \
    /// TASK::TASK_SHOOT_AT_ENTITY(bg[i], aimedentity, 5000, MISC::GET_HASH_KEY("FIRING_PATTERN_FULL_AUTO"));
    /// 
    /// in practical usage, getting the entity the player is aiming at and then task the peds to shoot at the entity, at a button press event would be better.
    /// 
    /// Firing Pattern Hash Information: https://pastebin.com/Px036isB
    pub inline fn taskShootAtEntity(entity: types.Entity, target: types.Entity, duration: c_int, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0x08DA95E8298AE772, .{entity, target, duration, firing_pattern}); } // 0x08DA95E8298AE772 0xAC0631C9 b323
    /// Climbs or vaults the nearest thing. \
    /// usePlayerLaunchForce is unused.
    pub inline fn taskClimb(ped: types.Ped, use_player_launch_force: windows.BOOL) !void { try invoker.invoke(void, 0x89D9FCC2435112F1, .{ped, use_player_launch_force}); } // 0x89D9FCC2435112F1 0x90847790 b323
    pub inline fn taskClimbLadder(ped: types.Ped, fast: windows.BOOL) !void { try invoker.invoke(void, 0xB6C987F9285A3814, .{ped, fast}); } // 0xB6C987F9285A3814 0x35BB4EE0 b323
    /// Attaches a ped to a rope and allows player control to rappel down a wall. Disables all collisions while on the rope. \
    /// p10: Usually 1 in the scripts, clipSet: Clipset to use for the task, minZ: Minimum Z that the player can descend to, ropeHandle: Rope to attach this task to created with ADD_ROPE
    pub inline fn taskRappelDownWallUsingClipsetOverride(ped: types.Ped, vec_1__: types.Vector3, vec_2__: types.Vector3, min_z: f32, rope_handle: c_int, clip_set: [*c]const u8, p_1_0: types.Any, p_1_1: types.Any) !void { try invoker.invoke(void, 0xEAF66ACDDC794793, .{ped, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, min_z, rope_handle, clip_set, p_1_0, p_1_1}); } // 0xEAF66ACDDC794793  b1868
    pub inline fn getTaskRappelDownWallState(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x9D252648778160DF, .{ped}); } // 0x9D252648778160DF  b1868
    /// Immediately stops the pedestrian from whatever it's doing. They stop fighting, animations, etc. they forget what they were doing.
    pub inline fn clearPedTasksImmediately(ped: types.Ped) !void { try invoker.invoke(void, 0xAAA34F8A7CB32098, .{ped}); } // 0xAAA34F8A7CB32098 0xBC045625 b323
    pub inline fn taskPerformSequenceFromProgress(ped: types.Ped, task_index: c_int, progress_1: c_int, progress_2: c_int) !void { try invoker.invoke(void, 0x89221B16730234F0, .{ped, task_index, progress_1, progress_2}); } // 0x89221B16730234F0 0xFA60601B b323
    /// This native does absolutely nothing, just a nullsub
    /// 
    /// R* Comment: \
    /// SET_NEXT_DESIRED_MOVE_STATE - Function is deprecated - do not use anymore
    pub inline fn setNextDesiredMoveState(next_move_state: f32) !void { try invoker.invoke(void, 0xF1B9F16E89E2C93A, .{next_move_state}); } // 0xF1B9F16E89E2C93A 0x4E937D57 b323
    pub inline fn setPedDesiredMoveBlendRatio(ped: types.Ped, new_move_blend_ratio: f32) !void { try invoker.invoke(void, 0x1E982AC8716912C5, .{ped, new_move_blend_ratio}); } // 0x1E982AC8716912C5 0xC65FC712 b323
    pub inline fn getPedDesiredMoveBlendRatio(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0x8517D4A6CA8513ED, .{ped}); } // 0x8517D4A6CA8513ED 0x5FEFAB72 b323
    /// eg
    /// 
    ///  TASK::TASK_GOTO_ENTITY_AIMING(v_2, PLAYER::PLAYER_PED_ID(), 5.0, 25.0);
    /// 
    /// ped = Ped you want to perform this task. \
    /// target = the Entity they should aim at. \
    /// distanceToStopAt = distance from the target, where the ped should stop to aim. \
    /// StartAimingDist = distance where the ped should start to aim.
    pub inline fn taskGotoEntityAiming(ped: types.Ped, target: types.Entity, distance_to_stop_at: f32, _start_aiming_dist: f32) !void { try invoker.invoke(void, 0xA9DA48FAB8A76C12, .{ped, target, distance_to_stop_at, _start_aiming_dist}); } // 0xA9DA48FAB8A76C12 0xF1C493CF b323
    /// p1 is always GET_HASH_KEY("empty") in scripts, for the rare times this is used
    pub inline fn taskSetDecisionMaker(ped: types.Ped, decision_maker_id: types.Hash) !void { try invoker.invoke(void, 0xEB8517DDA73720DA, .{ped, decision_maker_id}); } // 0xEB8517DDA73720DA 0x830AD50C b323
    pub inline fn taskSetSphereDefensiveArea(ped: types.Ped, vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0x933C06518B52A9A4, .{ped, vec.x, vec.y, vec.z, radius}); } // 0x933C06518B52A9A4 0x9F3C5D6A b323
    pub inline fn taskClearDefensiveArea(ped: types.Ped) !void { try invoker.invoke(void, 0x95A6C46A31D1917D, .{ped}); } // 0x95A6C46A31D1917D 0x7A05BF0D b323
    pub inline fn taskPedSlideToCoord(ped: types.Ped, vec: types.Vector3, heading: f32, speed: f32) !void { try invoker.invoke(void, 0xD04FE6765D990A06, .{ped, vec.x, vec.y, vec.z, heading, speed}); } // 0xD04FE6765D990A06 0x225380EF b323
    pub inline fn taskPedSlideToCoordHdgRate(ped: types.Ped, vec: types.Vector3, heading: f32, speed: f32, heading_change_rate: f32) !void { try invoker.invoke(void, 0x5A4A6A6D3DC64F52, .{ped, vec.x, vec.y, vec.z, heading, speed, heading_change_rate}); } // 0x5A4A6A6D3DC64F52 0x38A995C1 b323
    pub inline fn addCoverPoint(vec: types.Vector3, direction: f32, usage: c_int, height: c_int, arc: c_int, is_priority: windows.BOOL) !types.ScrHandle { return try invoker.invoke(types.ScrHandle, 0xD5C12A75C7B9497F, .{vec.x, vec.y, vec.z, direction, usage, height, arc, is_priority}); } // 0xD5C12A75C7B9497F 0xA0AF0B98 b323
    pub inline fn removeCoverPoint(coverpoint: types.ScrHandle) !void { try invoker.invoke(void, 0xAE287C923D891715, .{coverpoint}); } // 0xAE287C923D891715 0x0776888B b323
    /// Checks if there is a cover point at position
    pub inline fn doesScriptedCoverPointExistAtCoords(vec: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA98B8E3C088E5A31, .{vec.x, vec.y, vec.z}); } // 0xA98B8E3C088E5A31 0x29F97A71 b323
    pub inline fn getScriptedCoverPointCoords(coverpoint: types.ScrHandle) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x594A1028FC2A3E85, .{coverpoint}); } // 0x594A1028FC2A3E85 0xC6B6CCC1 b323
    pub inline fn addScriptedCoverArea(vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0x28B7B9BFDAF274AA, .{vec.x, vec.y, vec.z, radius}); } // 0x28B7B9BFDAF274AA  b2545
    /// Makes the specified ped attack the target ped. \
    /// p2 should be 0 \
    /// p3 should be 16
    pub inline fn taskCombatPed(ped: types.Ped, target_ped: types.Ped, combat_flags: c_int, threat_response_flags: c_int) !void { try invoker.invoke(void, 0xF166E48407BAC484, .{ped, target_ped, combat_flags, threat_response_flags}); } // 0xF166E48407BAC484 0xCB0D8932 b323
    pub inline fn taskCombatPedTimed(ped: types.Ped, target: types.Ped, time: c_int, flags: c_int) !void { try invoker.invoke(void, 0x944F30DCB7096BDE, .{ped, target, time, flags}); } // 0x944F30DCB7096BDE 0xF5CA2A45 b323
    pub inline fn taskSeekCoverFromPos(ped: types.Ped, vec: types.Vector3, duration: c_int, allow_peeking_and_firing: windows.BOOL) !void { try invoker.invoke(void, 0x75AC2B60386D89F2, .{ped, vec.x, vec.y, vec.z, duration, allow_peeking_and_firing}); } // 0x75AC2B60386D89F2 0x83F18EE9 b323
    pub inline fn taskSeekCoverFromPed(ped: types.Ped, target: types.Ped, duration: c_int, allow_peeking_and_firing: windows.BOOL) !void { try invoker.invoke(void, 0x84D32B3BEC531324, .{ped, target, duration, allow_peeking_and_firing}); } // 0x84D32B3BEC531324 0xC1EC907E b323
    /// p5 is always -1
    pub inline fn taskSeekCoverToCoverPoint(ped: types.Ped, coverpoint: types.ScrHandle, vec: types.Vector3, time: c_int, allow_peeking_and_firing: windows.BOOL) !void { try invoker.invoke(void, 0xD43D95C7A869447F, .{ped, coverpoint, vec.x, vec.y, vec.z, time, allow_peeking_and_firing}); } // 0xD43D95C7A869447F 0x3D026B29 b323
    /// p8 causes the ped to take the shortest route to the cover position. It may have something to do with navmesh or pathfinding mechanics.
    /// 
    /// from michael2: \
    /// TASK::TASK_SEEK_COVER_TO_COORDS(ped, 967.5164794921875, -2121.603515625, 30.479299545288086, 978.94677734375, -2125.84130859375, 29.4752, -1, 1);
    /// 
    /// 
    /// appears to be shorter variation \
    /// from michael3: \
    /// TASK::TASK_SEEK_COVER_TO_COORDS(ped, -2231.011474609375, 263.6326599121094, 173.60195922851562, -1, 0);
    pub inline fn taskSeekCoverToCoords(ped: types.Ped, vec_1__: types.Vector3, vec_2__: types.Vector3, timeout: c_int, short_route: windows.BOOL) !void { try invoker.invoke(void, 0x39246A6958EF072C, .{ped, vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, timeout, short_route}); } // 0x39246A6958EF072C 0xFFFE754E b323
    pub inline fn taskPutPedDirectlyIntoCover(ped: types.Ped, vec: types.Vector3, time: c_int, allow_peeking_and_firing: windows.BOOL, blend_in_duration: f32, force_initial_facing_direction: windows.BOOL, force_face_left: windows.BOOL, identifier: c_int, do_entry: windows.BOOL) !void { try invoker.invoke(void, 0x4172393E6BE1FECE, .{ped, vec.x, vec.y, vec.z, time, allow_peeking_and_firing, blend_in_duration, force_initial_facing_direction, force_face_left, identifier, do_entry}); } // 0x4172393E6BE1FECE 0xC9F00E68 b323
    pub inline fn taskWarpPedDirectlyIntoCover(ped: types.Ped, time: c_int, allow_peeking_and_firing: windows.BOOL, force_initial_facing_direction: windows.BOOL, force_face_left: windows.BOOL, identifier: c_int) !void { try invoker.invoke(void, 0x6E01E9E8D89F8276, .{ped, time, allow_peeking_and_firing, force_initial_facing_direction, force_face_left, identifier}); } // 0x6E01E9E8D89F8276  b2545
    /// p1 is 1, 2, or 3 in scripts
    pub inline fn taskExitCover(ped: types.Ped, exit_type: c_int, vec: types.Vector3) !void { try invoker.invoke(void, 0x79B258E397854D29, .{ped, exit_type, vec.x, vec.y, vec.z}); } // 0x79B258E397854D29 0xC829FAC9 b323
    /// from armenian3.c4
    /// 
    /// TASK::TASK_PUT_PED_DIRECTLY_INTO_MELEE(PlayerPed, armenianPed, 0.0, -1.0, 0.0, 0);
    /// 
    pub inline fn taskPutPedDirectlyIntoMelee(ped: types.Ped, melee_target: types.Ped, blend_in_duration: f32, time_in_melee: f32, strafe_phase_sync: f32, ai_combat_flags: c_int) !void { try invoker.invoke(void, 0x1C6CD14A876FFE39, .{ped, melee_target, blend_in_duration, time_in_melee, strafe_phase_sync, ai_combat_flags}); } // 0x1C6CD14A876FFE39 0x79E1D27D b323
    /// used in sequence task
    /// 
    /// both parameters seems to be always 0
    pub inline fn taskToggleDuck(ped: types.Ped, toggle_type: c_int) !void { try invoker.invoke(void, 0xAC96609B9995EDF8, .{ped, toggle_type}); } // 0xAC96609B9995EDF8 0x61CFBCBF b323
    /// From re_prisonvanbreak:
    /// 
    /// TASK::TASK_GUARD_CURRENT_POSITION(l_DD, 35.0, 35.0, 1);
    pub inline fn taskGuardCurrentPosition(ped: types.Ped, max_patrol_proximity: f32, defensive_area_radius: f32, set_defensive_area: windows.BOOL) !void { try invoker.invoke(void, 0x4A58A47A72E3FCB4, .{ped, max_patrol_proximity, defensive_area_radius, set_defensive_area}); } // 0x4A58A47A72E3FCB4 0x2FB099E9 b323
    pub inline fn taskGuardAssignedDefensiveArea(ped: types.Ped, vec: types.Vector3, heading: f32, max_patrol_proximity: f32, timer: c_int) !void { try invoker.invoke(void, 0xD2A207EEBDF9889B, .{ped, vec.x, vec.y, vec.z, heading, max_patrol_proximity, timer}); } // 0xD2A207EEBDF9889B 0x7AF0133D b323
    pub inline fn taskGuardSphereDefensiveArea(ped: types.Ped, defendposition__: types.Vector3, heading: f32, max_patrol_proximity: f32, time: c_int, vec: types.Vector3, defensive_area_radius: f32) !void { try invoker.invoke(void, 0xC946FE14BE0EB5E2, .{ped, defendposition__.x, defendposition__.y, defendposition__.z, heading, max_patrol_proximity, time, vec.x, vec.y, vec.z, defensive_area_radius}); } // 0xC946FE14BE0EB5E2 0x86B76CB7 b323
    /// scenarioName example: "WORLD_HUMAN_GUARD_STAND"
    pub inline fn taskStandGuard(ped: types.Ped, vec: types.Vector3, heading: f32, scenario_name: [*c]const u8) !void { try invoker.invoke(void, 0xAE032F8BBA959E90, .{ped, vec.x, vec.y, vec.z, heading, scenario_name}); } // 0xAE032F8BBA959E90 0xD130F636 b323
    pub inline fn setDriveTaskCruiseSpeed(driver: types.Ped, cruise_speed: f32) !void { try invoker.invoke(void, 0x5C9B84BD7D31D908, .{driver, cruise_speed}); } // 0x5C9B84BD7D31D908 0x3CEC07B1 b323
    pub inline fn setDriveTaskMaxCruiseSpeed(ped: types.Ped, speed: f32, update_base_task: windows.BOOL) !void { try invoker.invoke(void, 0x404A5AA9B9F0B746, .{ped, speed, update_base_task}); } // 0x404A5AA9B9F0B746 0x7FDF6131 b323
    /// This native is used to set the driving style for specific ped.
    /// 
    /// Driving styles id seems to be: \
    /// 786468 \
    /// 262144 \
    /// 786469
    /// 
    /// http://gtaforums.com/topic/822314-guide-driving-styles/
    pub inline fn setDriveTaskDrivingStyle(ped: types.Ped, driving_style: c_int) !void { try invoker.invoke(void, 0xDACE1BE37D88AF67, .{ped, driving_style}); } // 0xDACE1BE37D88AF67 0x59C5FAD7 b323
    pub inline fn addCoverBlockingArea(start__: types.Vector3, end__: types.Vector3, block_objects: windows.BOOL, block_vehicles: windows.BOOL, block_map: windows.BOOL, block_player: windows.BOOL) !void { try invoker.invoke(void, 0x45C597097DD7CB81, .{start__.x, start__.y, start__.z, end__.x, end__.y, end__.z, block_objects, block_vehicles, block_map, block_player}); } // 0x45C597097DD7CB81 0x3536946F b323
    pub inline fn removeAllCoverBlockingAreas() !void { try invoker.invoke(void, 0xDB6708C0B46F56D8, .{}); } // 0xDB6708C0B46F56D8 0xCF9221A7 b323
    pub inline fn removeCoverBlockingAreasAtPosition(vec: types.Vector3) !void { try invoker.invoke(void, 0xFA83CA6776038F64, .{vec.x, vec.y, vec.z}); } // 0xFA83CA6776038F64  b1493
    pub inline fn removeSpecificCoverBlockingAreas(start__: types.Vector3, end__: types.Vector3, block_objects: windows.BOOL, block_vehicles: windows.BOOL, block_map: windows.BOOL, block_player: windows.BOOL) !void { try invoker.invoke(void, 0x1F351CF1C6475734, .{start__.x, start__.y, start__.z, end__.x, end__.y, end__.z, block_objects, block_vehicles, block_map, block_player}); } // 0x1F351CF1C6475734  b505
    /// Plays a scenario on a Ped at their current location.
    /// 
    /// unkDelay - Usually 0 or -1, doesn't seem to have any effect. Might be a delay between sequences. \
    /// playEnterAnim - Plays the "Enter" anim if true, otherwise plays the "Exit" anim. Scenarios that don't have any "Enter" anims won't play if this is set to true.
    /// 
    /// ----
    /// 
    /// From "am_hold_up.ysc.c4" at line 339:
    /// 
    /// TASK::TASK_START_SCENARIO_IN_PLACE(NETWORK::NET_TO_PED(l_8D._f4), sub_adf(), 0, 1);
    /// 
    /// I'm unsure of what the last two parameters are, however sub_adf() randomly returns 1 of 3 scenarios, those being: \
    /// WORLD_HUMAN_SMOKING \
    /// WORLD_HUMAN_HANG_OUT_STREET \
    /// WORLD_HUMAN_STAND_MOBILE
    /// 
    /// This makes sense, as these are what I commonly see when going by a liquor store. \
    /// ------------------------- \
    /// List of scenarioNames: https://pastebin.com/6mrYTdQv \
    /// (^ Thank you so fucking much for this)
    /// 
    /// Also these: \
    /// WORLD_FISH_FLEE \
    /// DRIVE \
    /// WORLD_HUMAN_HIKER \
    /// WORLD_VEHICLE_ATTRACTOR \
    /// WORLD_VEHICLE_BICYCLE_MOUNTAIN \
    /// WORLD_VEHICLE_BIKE_OFF_ROAD_RACE \
    /// WORLD_VEHICLE_BIKER \
    /// WORLD_VEHICLE_CONSTRUCTION_PASSENGERS \
    /// WORLD_VEHICLE_CONSTRUCTION_SOLO \
    /// WORLD_VEHICLE_DRIVE_PASSENGERS \
    /// WORLD_VEHICLE_DRIVE_SOLO \
    /// WORLD_VEHICLE_EMPTY \
    /// WORLD_VEHICLE_PARK_PARALLEL \
    /// WORLD_VEHICLE_PARK_PERPENDICULAR_NOSE_IN \
    /// WORLD_VEHICLE_POLICE_BIKE \
    /// WORLD_VEHICLE_POLICE_CAR \
    /// WORLD_VEHICLE_POLICE_NEXT_TO_CAR \
    /// WORLD_VEHICLE_SALTON_DIRT_BIKE \
    /// WORLD_VEHICLE_TRUCK_LOGS
    /// 
    /// Full list of ped scenarios by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenariosCompact.json
    pub inline fn taskStartScenarioInPlace(ped: types.Ped, scenario_name: [*c]const u8, unk_delay: c_int, play_enter_anim: windows.BOOL) !void { try invoker.invoke(void, 0x142A02425FF02BD9, .{ped, scenario_name, unk_delay, play_enter_anim}); } // 0x142A02425FF02BD9 0xE50D6DDE b323
    /// Full list of ped scenarios by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenariosCompact.json
    /// 
    /// Also a few more listed at TASK::TASK_START_SCENARIO_IN_PLACE just above. \
    /// --------------- \
    /// The first parameter in every scenario has always been a Ped of some sort. The second like TASK_START_SCENARIO_IN_PLACE is the name of the scenario. 
    /// 
    /// The next 4 parameters were harder to decipher. After viewing "hairdo_shop_mp.ysc.c4", and being confused from seeing the case in other scripts, they passed the first three of the arguments as one array from a function, and it looked like it was obviously x, y, and z.
    /// 
    /// I haven't seen the sixth parameter go to or over 360, making me believe that it is rotation, but I really can't confirm anything.
    /// 
    /// I have no idea what the last 3 parameters are, but I'll try to find out.
    /// 
    /// -going on the last 3 parameters, they appear to always be "0, 0, 1"
    /// 
    /// p6 -1 also used in scrips
    /// 
    /// p7 used for sitting scenarios
    /// 
    /// p8 teleports ped to position
    pub inline fn taskStartScenarioAtPosition(ped: types.Ped, scenario_name: [*c]const u8, vec: types.Vector3, heading: f32, duration: c_int, sitting_scenario: windows.BOOL, teleport: windows.BOOL) !void { try invoker.invoke(void, 0xFA4EFC79F69D4F07, .{ped, scenario_name, vec.x, vec.y, vec.z, heading, duration, sitting_scenario, teleport}); } // 0xFA4EFC79F69D4F07 0xAA2C4AC2 b323
    /// Updated variables
    /// 
    /// An alternative to TASK::TASK_USE_NEAREST_SCENARIO_TO_COORD_WARP. Makes the ped walk to the scenario instead.
    pub inline fn taskUseNearestScenarioToCoord(ped: types.Ped, vec: types.Vector3, distance: f32, duration: c_int) !void { try invoker.invoke(void, 0x277F471BA9DB000B, .{ped, vec.x, vec.y, vec.z, distance, duration}); } // 0x277F471BA9DB000B 0x9C50FBF0 b323
    pub inline fn taskUseNearestScenarioToCoordWarp(ped: types.Ped, vec: types.Vector3, radius: f32, time_to_leave: c_int) !void { try invoker.invoke(void, 0x58E2E0F23F6B76C3, .{ped, vec.x, vec.y, vec.z, radius, time_to_leave}); } // 0x58E2E0F23F6B76C3 0x1BE9D65C b323
    /// p5 is always 0 in scripts
    pub inline fn taskUseNearestScenarioChainToCoord(ped: types.Ped, vec: types.Vector3, max_range: f32, time_to_leave: c_int) !void { try invoker.invoke(void, 0x9FDA1B3D7E7028B3, .{ped, vec.x, vec.y, vec.z, max_range, time_to_leave}); } // 0x9FDA1B3D7E7028B3 0xE32FFB22 b323
    /// p5 is always -1 or 0 in scripts
    pub inline fn taskUseNearestScenarioChainToCoordWarp(ped: types.Ped, vec: types.Vector3, radius: f32, time_to_leave: c_int) !void { try invoker.invoke(void, 0x97A28E63F0BA5631, .{ped, vec.x, vec.y, vec.z, radius, time_to_leave}); } // 0x97A28E63F0BA5631 0xBAB4C0AE b323
    pub inline fn doesScenarioExistInArea(vec: types.Vector3, radius: f32, must_be_free: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5A59271FFADD33C1, .{vec.x, vec.y, vec.z, radius, must_be_free}); } // 0x5A59271FFADD33C1 0xFA7F5047 b323
    pub inline fn doesScenarioOfTypeExistInArea(vec: types.Vector3, scenario_name: [*c]const u8, radius: f32, must_be_free: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0A9D0C2A3BBC86C1, .{vec.x, vec.y, vec.z, scenario_name, radius, must_be_free}); } // 0x0A9D0C2A3BBC86C1 0x0FB138A5 b323
    pub inline fn isScenarioOccupied(vec: types.Vector3, max_range: f32, only_users_actually_at_scenario: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x788756D73AC2E07C, .{vec.x, vec.y, vec.z, max_range, only_users_actually_at_scenario}); } // 0x788756D73AC2E07C 0x697FC008 b323
    pub inline fn pedHasUseScenarioTask(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x295E3CCEC879CCD7, .{ped}); } // 0x295E3CCEC879CCD7 0x9BE9C691 b323
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn playAnimOnRunningScenario(ped: types.Ped, anim_dict: [*c]const u8, anim_name: [*c]const u8) !void { try invoker.invoke(void, 0x748040460F8DF5DC, .{ped, anim_dict, anim_name}); } // 0x748040460F8DF5DC 0x1984A5D1 b323
    /// Full list of scenario groups used in scripts by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenarioGroupNames.json \
    /// Occurrences in the b617d scripts:
    /// 
    /// "ARMY_GUARD", \
    /// "ARMY_HELI", \
    /// "Cinema_Downtown", \
    /// "Cinema_Morningwood", \
    /// "Cinema_Textile", \
    /// "City_Banks", \
    /// "Countryside_Banks", \
    /// "DEALERSHIP", \
    /// "GRAPESEED_PLANES", \
    /// "KORTZ_SECURITY", \
    /// "LOST_BIKERS", \
    /// "LSA_Planes", \
    /// "LSA_Planes", \
    /// "MP_POLICE", \
    /// "Observatory_Bikers",  \
    /// "POLICE_POUND1", \
    /// "POLICE_POUND2", \
    /// "POLICE_POUND3", \
    /// "POLICE_POUND4", \
    /// "POLICE_POUND5" \
    /// "QUARRY", \
    /// "SANDY_PLANES", \
    /// "SCRAP_SECURITY", \
    /// "SEW_MACHINE", \
    /// "SOLOMON_GATE", \
    /// "Triathlon_1_Start",  \
    /// "Triathlon_2_Start",  \
    /// "Triathlon_3_Start"
    /// 
    /// Sometimes used with IS_SCENARIO_GROUP_ENABLED: \
    /// if (TASK::DOES_SCENARIO_GROUP_EXIST("Observatory_Bikers") && (!TASK::IS_SCENARIO_GROUP_ENABLED("Observatory_Bikers"))) { \
    /// else if (TASK::IS_SCENARIO_GROUP_ENABLED("BLIMP")) {
    /// 
    pub inline fn doesScenarioGroupExist(scenario_group: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF9034C136C9E00D3, .{scenario_group}); } // 0xF9034C136C9E00D3 0x5F072EB9 b323
    /// Full list of scenario groups used in scripts by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenarioGroupNames.json \
    /// Occurrences in the b617d scripts: 
    /// 
    ///  "ARMY_GUARD", \
    ///  "ARMY_HELI", \
    ///  "BLIMP", \
    ///  "Cinema_Downtown", \
    ///  "Cinema_Morningwood", \
    ///  "Cinema_Textile", \
    ///  "City_Banks", \
    ///  "Countryside_Banks", \
    ///  "DEALERSHIP", \
    ///  "KORTZ_SECURITY", \
    ///  "LSA_Planes", \
    ///  "MP_POLICE", \
    ///  "Observatory_Bikers", \
    ///  "POLICE_POUND1", \
    ///  "POLICE_POUND2", \
    ///  "POLICE_POUND3", \
    ///  "POLICE_POUND4", \
    ///  "POLICE_POUND5", \
    ///  "Rampage1", \
    ///  "SANDY_PLANES", \
    ///  "SCRAP_SECURITY", \
    ///  "SEW_MACHINE", \
    ///  "SOLOMON_GATE"
    /// 
    /// Sometimes used with DOES_SCENARIO_GROUP_EXIST: \
    /// if (TASK::DOES_SCENARIO_GROUP_EXIST("Observatory_Bikers") &&   (!TASK::IS_SCENARIO_GROUP_ENABLED("Observatory_Bikers"))) { \
    /// else if (TASK::IS_SCENARIO_GROUP_ENABLED("BLIMP")) {
    pub inline fn isScenarioGroupEnabled(scenario_group: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x367A09DED4E05B99, .{scenario_group}); } // 0x367A09DED4E05B99 0x90991122 b323
    /// Full list of scenario groups used in scripts by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenarioGroupNames.json \
    /// Occurrences in the b617d scripts: https://pastebin.com/Tvg2PRHU
    pub inline fn setScenarioGroupEnabled(scenario_group: [*c]const u8, enabled: windows.BOOL) !void { try invoker.invoke(void, 0x02C8E5B49848664E, .{scenario_group, enabled}); } // 0x02C8E5B49848664E 0x116997B1 b323
    pub inline fn resetScenarioGroupsEnabled() !void { try invoker.invoke(void, 0xDD902D0349AFAD3A, .{}); } // 0xDD902D0349AFAD3A 0xBF55025D b323
    /// Full list of scenario groups used in scripts by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenarioGroupNames.json \
    /// Groups found in the scripts used with this native:
    /// 
    /// "AMMUNATION", \
    /// "QUARRY", \
    /// "Triathlon_1", \
    /// "Triathlon_2", \
    /// "Triathlon_3"
    pub inline fn setExclusiveScenarioGroup(scenario_group: [*c]const u8) !void { try invoker.invoke(void, 0x535E97E1F7FC0C6A, .{scenario_group}); } // 0x535E97E1F7FC0C6A 0x59DB8F26 b323
    pub inline fn resetExclusiveScenarioGroup() !void { try invoker.invoke(void, 0x4202BBCB8684563D, .{}); } // 0x4202BBCB8684563D 0x17F9DFE8 b323
    /// Full list of scenario types used in scripts by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenariosCompact.json \
    /// Occurrences in the b617d scripts: \
    /// "PROP_HUMAN_SEAT_CHAIR", \
    /// "WORLD_HUMAN_DRINKING", \
    /// "WORLD_HUMAN_HANG_OUT_STREET", \
    /// "WORLD_HUMAN_SMOKING", \
    /// "WORLD_MOUNTAIN_LION_WANDER", \
    /// "WORLD_HUMAN_DRINKING"
    /// 
    /// Sometimes used together with MISC::IS_STRING_NULL_OR_EMPTY in the scripts.
    /// 
    /// scenarioType could be the same as scenarioName, used in for example TASK::TASK_START_SCENARIO_AT_POSITION.
    /// 
    pub inline fn isScenarioTypeEnabled(scenario_type: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3A815DB3EA088722, .{scenario_type}); } // 0x3A815DB3EA088722 0xAE37E969 b323
    /// Full list of scenario types used in scripts by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/scenariosCompact.json \
    /// seems to enable/disable specific scenario-types from happening in the game world.
    /// 
    /// Here are some scenario types from the scripts: \
    /// "WORLD_MOUNTAIN_LION_REST"                                              \
    /// "WORLD_MOUNTAIN_LION_WANDER"                                             \
    /// "DRIVE"                                                                   \
    /// "WORLD_VEHICLE_POLICE_BIKE"                                              \
    /// "WORLD_VEHICLE_POLICE_CAR"                                              \
    /// "WORLD_VEHICLE_POLICE_NEXT_TO_CAR"                                         \
    /// "WORLD_VEHICLE_DRIVE_SOLO"                                                  \
    /// "WORLD_VEHICLE_BIKER"                                                       \
    /// "WORLD_VEHICLE_DRIVE_PASSENGERS"                                            \
    /// "WORLD_VEHICLE_SALTON_DIRT_BIKE"                                            \
    /// "WORLD_VEHICLE_BICYCLE_MOUNTAIN"                                            \
    /// "PROP_HUMAN_SEAT_CHAIR"                                              \
    /// "WORLD_VEHICLE_ATTRACTOR"                                              \
    /// "WORLD_HUMAN_LEANING"                                                  \
    /// "WORLD_HUMAN_HANG_OUT_STREET"                                         \
    /// "WORLD_HUMAN_DRINKING"                                                 \
    /// "WORLD_HUMAN_SMOKING"                                                 \
    /// "WORLD_HUMAN_GUARD_STAND"                                             \
    /// "WORLD_HUMAN_CLIPBOARD"                                               \
    /// "WORLD_HUMAN_HIKER"                                                   \
    /// "WORLD_VEHICLE_EMPTY"                                                       \
    /// "WORLD_VEHICLE_BIKE_OFF_ROAD_RACE"                                       \
    /// "WORLD_HUMAN_PAPARAZZI"                                                \
    /// "WORLD_VEHICLE_PARK_PERPENDICULAR_NOSE_IN"                             \
    /// "WORLD_VEHICLE_PARK_PARALLEL"                                               \
    /// "WORLD_VEHICLE_CONSTRUCTION_SOLO"                                \
    /// "WORLD_VEHICLE_CONSTRUCTION_PASSENGERS"                                                                     \
    /// "WORLD_VEHICLE_TRUCK_LOGS"
    /// 
    /// scenarioType could be the same as scenarioName, used in for example TASK::TASK_START_SCENARIO_AT_POSITION.
    pub inline fn setScenarioTypeEnabled(scenario_type: [*c]const u8, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEB47EC4E34FB7EE1, .{scenario_type, toggle}); } // 0xEB47EC4E34FB7EE1 0xDB18E5DE b323
    pub inline fn resetScenarioTypesEnabled() !void { try invoker.invoke(void, 0x0D40EE2A7F2B2D6D, .{}); } // 0x0D40EE2A7F2B2D6D 0xF58FDEB4 b323
    pub inline fn isPedActiveInScenario(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAA135F9482C82CC3, .{ped}); } // 0xAA135F9482C82CC3 0x05038F1A b323
    /// Used only once (am_mp_property_int)
    /// 
    /// ped was PLAYER_PED_ID()
    /// 
    /// Related to CTaskAmbientClips.
    pub inline fn isPedPlayingBaseClipInScenario(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x621C6E4729388E41, .{ped}); } // 0x621C6E4729388E41 0xA0DA6B1D b323
    /// Appears only in fm_mission_controller and used only 3 times.
    /// 
    /// ped was always PLAYER_PED_ID() \
    /// p1 was always true \
    /// p2 was always true
    pub inline fn setPedCanPlayAmbientIdles(ped: types.Ped, block_idle_clips: windows.BOOL, remove_idle_clip_if_playing: windows.BOOL) !void { try invoker.invoke(void, 0x8FD89A6240813FD0, .{ped, block_idle_clips, remove_idle_clip_if_playing}); } // 0x8FD89A6240813FD0 0xB5AD044E b323
    /// Despite its name, it only attacks ONE hated target. The one closest to the specified position.
    pub inline fn taskCombatHatedTargetsInArea(ped: types.Ped, vec: types.Vector3, radius: f32, combat_flags: c_int) !void { try invoker.invoke(void, 0x4CF5F55DAC3280A0, .{ped, vec.x, vec.y, vec.z, radius, combat_flags}); } // 0x4CF5F55DAC3280A0 0xDF099E18 b323
    /// Despite its name, it only attacks ONE hated target. The one closest hated target.
    /// 
    /// p2 seems to be always 0
    pub inline fn taskCombatHatedTargetsAroundPed(ped: types.Ped, radius: f32, combat_flags: c_int) !void { try invoker.invoke(void, 0x7BF835BB9E2698C8, .{ped, radius, combat_flags}); } // 0x7BF835BB9E2698C8 0x2E7064E4 b323
    pub inline fn taskCombatHatedTargetsAroundPedTimed(ped: types.Ped, radius: f32, time: c_int, combat_flags: c_int) !void { try invoker.invoke(void, 0x2BBA30B854534A0C, .{ped, radius, time, combat_flags}); } // 0x2BBA30B854534A0C 0xF127AD6A b323
    /// In every case of this native, I've only seen the first parameter passed as 0, although I believe it's a Ped after seeing tasks around it using 0. That's because it's used in a Sequence Task.
    /// 
    /// The last 3 parameters are definitely coordinates after seeing them passed in other scripts, and even being used straight from the player's coordinates. \
    /// --- \
    /// It seems that - in the decompiled scripts - this native was used on a ped who was in a vehicle to throw a projectile out the window at the player. This is something any ped will naturally do if they have a throwable and they are doing driveby-combat (although not very accurately). \
    /// It is possible, however, that this is how SWAT throws smoke grenades at the player when in cover. \
    /// ---------------------------------------------------- \
    /// The first comment is right it definately is the ped as if you look in script finale_heist2b.c line 59628 in Xbox Scripts atleast you will see task_throw_projectile and the first param is Local_559[2 <14>] if you look above it a little bit line 59622 give_weapon_to_ped uses the same exact param Local_559[2 <14>] and we all know the first param of that native is ped. So it guaranteed has to be ped. 0 just may mean to use your ped by default for some reason.
    pub inline fn taskThrowProjectile(ped: types.Ped, vec: types.Vector3, ignore_collision_entity_index: c_int, create_invincible_projectile: windows.BOOL) !void { try invoker.invoke(void, 0x7285951DBF6B5A51, .{ped, vec.x, vec.y, vec.z, ignore_collision_entity_index, create_invincible_projectile}); } // 0x7285951DBF6B5A51 0xF65C20A7 b323
    pub inline fn taskSwapWeapon(ped: types.Ped, draw_weapon: windows.BOOL) !void { try invoker.invoke(void, 0xA21C51255B205245, .{ped, draw_weapon}); } // 0xA21C51255B205245 0xDAF4F8FC b323
    /// The 2nd param (drawWeapon) is not implemented.
    /// 
    /// -----------------------------------------------------------------------
    /// 
    /// The only occurrence I found in a R* script ("assassin_construction.ysc.c4"):
    /// 
    ///             if (((v_3 < v_4) && (TASK::GET_SCRIPT_TASK_STATUS(PLAYER::PLAYER_PED_ID(), 0x6a67a5cc) != 1)) && (v_5 > v_3)) {
    ///                 TASK::TASK_RELOAD_WEAPON(PLAYER::PLAYER_PED_ID(), 1);
    ///             }
    pub inline fn taskReloadWeapon(ped: types.Ped, draw_weapon: windows.BOOL) !void { try invoker.invoke(void, 0x62D2916F56B9CD2D, .{ped, draw_weapon}); } // 0x62D2916F56B9CD2D 0xCA6E91FD b323
    pub inline fn isPedGettingUp(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2A74E1D5F2F00EEC, .{ped}); } // 0x2A74E1D5F2F00EEC 0x320813E6 b323
    /// EX: Function.Call(Ped1, Ped2, Time, 0);
    /// 
    /// The last parameter is always 0 for some reason I do not know. The first parameter is the pedestrian who will writhe to the pedestrian in the other parameter. The third paremeter is how long until the Writhe task ends. When the task ends, the ped will die. If set to -1, he will not die automatically, and the task will continue until something causes it to end. This can be being touched by an entity, being shot, explosion, going into ragdoll, having task cleared. Anything that ends the current task will kill the ped at this point.
    /// 
    /// 
    /// 
    /// Third parameter does not appear to be time. The last parameter is not implemented (It's not used, regardless of value).
    pub inline fn taskWrithe(ped: types.Ped, target: types.Ped, min_fire_loops: c_int, start_state: c_int, force_shoot_on_ground: windows.BOOL, shoot_from_ground_timer: c_int) !void { try invoker.invoke(void, 0xCDDC2B77CE54AC6E, .{ped, target, min_fire_loops, start_state, force_shoot_on_ground, shoot_from_ground_timer}); } // 0xCDDC2B77CE54AC6E 0x0FDC54FC b323
    /// This native checks if a ped is on the ground, in pain from a (gunshot) wound. \
    /// Returns `true` if the ped is in writhe, `false` otherwise.
    pub inline fn isPedInWrithe(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDEB6D52126E7D640, .{ped}); } // 0xDEB6D52126E7D640 0x09E61921 b323
    ///  patrolRoutes found in the b617d scripts: \
    ///  "miss_Ass0", \
    ///  "miss_Ass1", \
    ///  "miss_Ass2", \
    ///  "miss_Ass3", \
    ///  "miss_Ass4", \
    ///  "miss_Ass5", \
    ///  "miss_Ass6", \
    ///  "MISS_PATROL_6", \
    ///  "MISS_PATROL_7", \
    ///  "MISS_PATROL_8", \
    ///  "MISS_PATROL_9", \
    ///  "miss_Tower_01", \
    ///  "miss_Tower_02", \
    ///  "miss_Tower_03", \
    ///  "miss_Tower_04", \
    ///  "miss_Tower_05", \
    ///  "miss_Tower_06", \
    ///  "miss_Tower_07", \
    ///  "miss_Tower_08", \
    ///  "miss_Tower_10"
    pub inline fn openPatrolRoute(patrol_route: [*c]const u8) !void { try invoker.invoke(void, 0xA36BFB5EE89F3D82, .{patrol_route}); } // 0xA36BFB5EE89F3D82 0xF33F83CA b323
    pub inline fn closePatrolRoute() !void { try invoker.invoke(void, 0xB043ECA801B8CBC1, .{}); } // 0xB043ECA801B8CBC1 0x67305E59 b323
    /// Example:  \
    /// TASK::ADD_PATROL_ROUTE_NODE(2, "WORLD_HUMAN_GUARD_STAND", -193.4915, -2378.864990234375, 10.9719, -193.4915, -2378.864990234375, 10.9719, 3000);
    /// 
    /// p0 is between 0 and 4 in the scripts.
    /// 
    /// p1 is "WORLD_HUMAN_GUARD_STAND" or "StandGuard".
    /// 
    /// p2, p3 and p4 is only one parameter sometimes in the scripts. Most likely a Vector3 hence p2, p3 and p4 are coordinates.  \
    /// Examples:  \
    /// TASK::ADD_PATROL_ROUTE_NODE(1, "WORLD_HUMAN_GUARD_STAND", l_739[7/*3*/], 0.0, 0.0, 0.0, 0);
    /// 
    /// TASK::ADD_PATROL_ROUTE_NODE(1, "WORLD_HUMAN_GUARD_STAND", l_B0[17/*44*/]._f3, l_B0[17/*44*/]._f3, 2000);
    /// 
    /// p5, p6 and p7 are for example set to: 1599.0406494140625, 2713.392578125, 44.4309.
    /// 
    /// p8 is an int, often random set to for example: MISC::GET_RANDOM_INT_IN_RANGE(5000, 10000).
    pub inline fn addPatrolRouteNode(node_id: c_int, node_type: [*c]const u8, pos__: types.Vector3, heading__: types.Vector3, duration: c_int) !void { try invoker.invoke(void, 0x8EDF950167586B7C, .{node_id, node_type, pos__.x, pos__.y, pos__.z, heading__.x, heading__.y, heading__.z, duration}); } // 0x8EDF950167586B7C 0x21B48F10 b323
    pub inline fn addPatrolRouteLink(node_id_1: c_int, node_id_2: c_int) !void { try invoker.invoke(void, 0x23083260DEC3A551, .{node_id_1, node_id_2}); } // 0x23083260DEC3A551 0xD8761BB3 b323
    pub inline fn createPatrolRoute() !void { try invoker.invoke(void, 0xAF8A443CCC8018DC, .{}); } // 0xAF8A443CCC8018DC 0x0A6C7864 b323
    /// From the b617d scripts:
    /// 
    /// TASK::DELETE_PATROL_ROUTE("miss_merc0"); \
    /// TASK::DELETE_PATROL_ROUTE("miss_merc1"); \
    /// TASK::DELETE_PATROL_ROUTE("miss_merc2"); \
    /// TASK::DELETE_PATROL_ROUTE("miss_dock");
    pub inline fn deletePatrolRoute(patrol_route: [*c]const u8) !void { try invoker.invoke(void, 0x7767DD9D65E91319, .{patrol_route}); } // 0x7767DD9D65E91319 0x2A4E6706 b323
    pub inline fn getPatrolTaskInfo(ped: types.Ped, time_left_at_node: [*c]c_int, node_id: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x52F734CEBE20DFBA, .{ped, time_left_at_node, node_id}); } // 0x52F734CEBE20DFBA  b2545
    /// After looking at some scripts the second parameter seems to be an id of some kind. Here are some I found from some R* scripts:
    /// 
    /// "miss_Tower_01" (this went from 01 - 10) \
    /// "miss_Ass0" (0, 4, 6, 3) \
    /// "MISS_PATROL_8"
    /// 
    /// I think they're patrol routes, but I'm not sure. And I believe the 3rd parameter is a BOOL, but I can't confirm other than only seeing 0 and 1 being passed.
    /// 
    /// 
    /// As far as I can see the patrol routes names such as "miss_Ass0" have been defined earlier in the scripts. This leads me to believe we can defined our own new patrol routes by following the same approach.  \
    /// From the scripts
    /// 
    ///     TASK::OPEN_PATROL_ROUTE("miss_Ass0");
    ///     TASK::ADD_PATROL_ROUTE_NODE(0, "WORLD_HUMAN_GUARD_STAND", l_738[0/*3*/], -139.4076690673828, -993.4732055664062, 26.2754, MISC::GET_RANDOM_INT_IN_RANGE(5000, 10000));
    ///     TASK::ADD_PATROL_ROUTE_NODE(1, "WORLD_HUMAN_GUARD_STAND", l_738[1/*3*/], -116.1391830444336, -987.4984130859375, 26.38541030883789, MISC::GET_RANDOM_INT_IN_RANGE(5000, 10000));
    ///     TASK::ADD_PATROL_ROUTE_NODE(2, "WORLD_HUMAN_GUARD_STAND", l_738[2/*3*/], -128.46847534179688, -979.0340576171875, 26.2754, MISC::GET_RANDOM_INT_IN_RANGE(5000, 10000));
    ///     TASK::ADD_PATROL_ROUTE_LINK(0, 1);
    ///     TASK::ADD_PATROL_ROUTE_LINK(1, 2);
    ///     TASK::ADD_PATROL_ROUTE_LINK(2, 0);
    ///     TASK::CLOSE_PATROL_ROUTE();
    ///     TASK::CREATE_PATROL_ROUTE();
    /// 
    /// 
    pub inline fn taskPatrol(ped: types.Ped, patrol_route_name: [*c]const u8, alert_state: c_int, can_chat_to_peds: windows.BOOL, use_head_look_at: windows.BOOL) !void { try invoker.invoke(void, 0xBDA5DF49D080FE4E, .{ped, patrol_route_name, alert_state, can_chat_to_peds, use_head_look_at}); } // 0xBDA5DF49D080FE4E 0xB92E5AF6 b323
    /// Makes the ped run to take cover
    pub inline fn taskStayInCover(ped: types.Ped) !void { try invoker.invoke(void, 0xE5DA8615A6180789, .{ped}); } // 0xE5DA8615A6180789 0xA27A9413 b323
    /// x, y, z: offset in world coords from some entity.
    pub inline fn addVehicleSubtaskAttackCoord(ped: types.Ped, vec: types.Vector3) !void { try invoker.invoke(void, 0x5CF0D8F9BBA0DD75, .{ped, vec.x, vec.y, vec.z}); } // 0x5CF0D8F9BBA0DD75 0x50779A2C b323
    pub inline fn addVehicleSubtaskAttackPed(ped: types.Ped, target: types.Ped) !void { try invoker.invoke(void, 0x85F462BADC7DA47F, .{ped, target}); } // 0x85F462BADC7DA47F 0x80461113 b323
    pub inline fn taskVehicleShootAtPed(ped: types.Ped, target: types.Ped, fire_tolerance: f32) !void { try invoker.invoke(void, 0x10AB107B887214D8, .{ped, target, fire_tolerance}); } // 0x10AB107B887214D8 0x59677BA0 b323
    pub inline fn taskVehicleAimAtPed(ped: types.Ped, target: types.Ped) !void { try invoker.invoke(void, 0xE41885592B08B097, .{ped, target}); } // 0xE41885592B08B097 0x920AE6DB b323
    pub inline fn taskVehicleShootAtCoord(ped: types.Ped, vec: types.Vector3, fire_tolerance: f32) !void { try invoker.invoke(void, 0x5190796ED39C9B6D, .{ped, vec.x, vec.y, vec.z, fire_tolerance}); } // 0x5190796ED39C9B6D 0xA7AAA4D6 b323
    pub inline fn taskVehicleAimAtCoord(ped: types.Ped, vec: types.Vector3) !void { try invoker.invoke(void, 0x447C1E9EF844BC0F, .{ped, vec.x, vec.y, vec.z}); } // 0x447C1E9EF844BC0F 0x010F47CE b323
    /// Differs from TASK_VEHICLE_DRIVE_TO_COORDS in that it will pick the shortest possible road route without taking one-way streets and other "road laws" into consideration.
    /// 
    /// WARNING: \
    /// A behaviorFlag value of 0 will result in a clunky, stupid driver!
    /// 
    /// Recommended settings: \
    /// speed = 30.0f, \
    /// behaviorFlag = 156,  \
    /// stoppingRange = 5.0f;
    /// 
    /// If you simply want to have your driver move to a fixed location, call it only once, or, when necessary in the event of interruption. 
    /// 
    /// If using this to continually follow a Ped who is on foot:  You will need to run this in a tick loop.  Call it in with the Ped's updated coordinates every 20 ticks or so and you will have one hell of a smart, fast-reacting NPC driver -- provided he doesn't get stuck.  If your update frequency is too fast, the Ped may not have enough time to figure his way out of being stuck, and thus, remain stuck.  One way around this would be to implement an "anti-stuck" mechanism, which allows the driver to realize he's stuck, temporarily pause the tick, unstuck, then resume the tick.
    /// 
    /// EDIT:  This is being discussed in more detail at http://gtaforums.com/topic/818504-any-idea-on-how-to-make-peds-clever-and-insanely-fast-c/  
    pub inline fn taskVehicleGotoNavmesh(ped: types.Ped, vehicle: types.Vehicle, vec: types.Vector3, speed: f32, behavior_flag: c_int, stopping_range: f32) !void { try invoker.invoke(void, 0x195AEEB13CEFE2EE, .{ped, vehicle, vec.x, vec.y, vec.z, speed, behavior_flag, stopping_range}); } // 0x195AEEB13CEFE2EE 0x55CF3BCD b323
    /// movement_speed: mostly 2f, but also 1/1.2f, etc. \
    /// p8: always false \
    /// p9: 2f \
    /// p10: 0.5f \
    /// p11: true \
    /// p12: 0 / 512 / 513, etc. \
    /// p13: 0 \
    /// firing_pattern: ${firing_pattern_full_auto}, 0xC6EE6B4C
    pub inline fn taskGoToCoordWhileAimingAtCoord(ped: types.Ped, vec: types.Vector3, aimat__: types.Vector3, move_blend_ratio: f32, shoot: windows.BOOL, target_radius: f32, slow_distance: f32, use_nav_mesh: windows.BOOL, nav_flags: c_int, instant_blend_to_aim: windows.BOOL, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0x11315AB3385B8AC0, .{ped, vec.x, vec.y, vec.z, aimat__.x, aimat__.y, aimat__.z, move_blend_ratio, shoot, target_radius, slow_distance, use_nav_mesh, nav_flags, instant_blend_to_aim, firing_pattern}); } // 0x11315AB3385B8AC0 0x1552DC91 b323
    pub inline fn taskGoToCoordWhileAimingAtEntity(ped: types.Ped, vec: types.Vector3, aim_at_i_d: types.Entity, move_blend_ratio: f32, shoot: windows.BOOL, target_radius: f32, slow_distance: f32, use_nav_mesh: windows.BOOL, nav_flags: c_int, instant_blend_to_aim: windows.BOOL, firing_pattern: types.Hash, time: c_int) !void { try invoker.invoke(void, 0xB2A16444EAD9AE47, .{ped, vec.x, vec.y, vec.z, aim_at_i_d, move_blend_ratio, shoot, target_radius, slow_distance, use_nav_mesh, nav_flags, instant_blend_to_aim, firing_pattern, time}); } // 0xB2A16444EAD9AE47 0x9BD52ABD b323
    /// The ped will walk or run towards goToLocation, aiming towards goToLocation or focusLocation (depending on the aimingFlag) and shooting if shootAtEnemies = true to any enemy in his path.
    /// 
    /// If the ped is closer than noRoadsDistance, the ped will ignore pathing/navmesh and go towards goToLocation directly. This could cause the ped to get stuck behind tall walls if the goToLocation is on the other side. To avoid this, use 0.0f and the ped will always use pathing/navmesh to reach his destination.
    /// 
    /// If the speed is set to 0.0f, the ped will just stand there while aiming, if set to 1.0f he will walk while aiming, 2.0f will run while aiming.
    /// 
    /// The ped will stop aiming when he is closer than distanceToStopAt to goToLocation.
    /// 
    /// I still can't figure out what unkTrue is used for. I don't notice any difference if I set it to false but in the decompiled scripts is always true.
    /// 
    /// I think that unkFlag, like the driving styles, could be a flag that "work as a list of 32 bits converted to a decimal integer. Each bit acts as a flag, and enables or disables a function". What leads me to this conclusion is the fact that in the decompiled scripts, unkFlag takes values like: 0, 1, 5 (101 in binary) and 4097 (4096 + 1 or 1000000000001 in binary). For now, I don't know what behavior enable or disable this possible flag so I leave it at 0.
    /// 
    /// Note: After some testing, using unkFlag = 16 (0x10) enables the use of sidewalks while moving towards goToLocation.
    /// 
    /// The aimingFlag takes 2 values: 0 to aim at the focusLocation, 1 to aim at where the ped is heading (goToLocation).
    /// 
    /// Example:
    /// 
    /// enum AimFlag \
    /// { \
    ///    AimAtFocusLocation,
    ///    AimAtGoToLocation
    /// };
    /// 
    /// Vector3 goToLocation1 = { 996.2867f, 0, -2143.044f, 0, 28.4763f, 0 }; // remember the padding.
    /// 
    /// Vector3 goToLocation2 = { 990.2867f, 0, -2140.044f, 0, 28.4763f, 0 }; // remember the padding.
    /// 
    /// Vector3 focusLocation = { 994.3478f, 0, -2136.118f, 0, 29.2463f, 0 }; // the coord z should be a little higher, around +1.0f to avoid aiming at the ground
    /// 
    /// // 1st example \
    /// TASK::TASK_GO_TO_COORD_AND_AIM_AT_HATED_ENTITIES_NEAR_COORD(pedHandle, goToLocation1.x, goToLocation1.y, goToLocation1.z, focusLocation.x, focusLocation.y, focusLocation.z, 2.0f /*run*/, true /*shoot*/, 3.0f /*stop at*/, 0.0f /*noRoadsDistance*/, true /*always true*/, 0 /*possible flag*/, AimFlag::AimAtGoToLocation, -957453492 /*FullAuto pattern*/);
    /// 
    /// // 2nd example \
    /// TASK::TASK_GO_TO_COORD_AND_AIM_AT_HATED_ENTITIES_NEAR_COORD(pedHandle, goToLocation2.x, goToLocation2.y, goToLocation2.z, focusLocation.x, focusLocation.y, focusLocation.z, 1.0f /*walk*/, false /*don't shoot*/, 3.0f /*stop at*/, 0.0f /*noRoadsDistance*/, true /*always true*/, 0 /*possible flag*/, AimFlag::AimAtFocusLocation, -957453492 /*FullAuto pattern*/);
    /// 
    /// 
    /// 1st example: The ped (pedhandle) will run towards goToLocation1. While running and aiming towards goToLocation1, the ped will shoot on sight to any enemy in his path, using "FullAuto" firing pattern. The ped will stop once he is closer than distanceToStopAt to goToLocation1.
    /// 
    /// 2nd example: The ped will walk towards goToLocation2. This time, while walking towards goToLocation2 and aiming at focusLocation, the ped will point his weapon on sight to any enemy in his path without shooting. The ped will stop once he is closer than distanceToStopAt to goToLocation2.
    pub inline fn taskGoToCoordAndAimAtHatedEntitiesNearCoord(ped_handle: types.Ped, gotolocation__: types.Vector3, focuslocation__: types.Vector3, speed: f32, shoot_at_enemies: windows.BOOL, distance_to_stop_at: f32, no_roads_distance: f32, use_nav_mesh: windows.BOOL, nav_flags: c_int, task_flags: c_int, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0xA55547801EB331FC, .{ped_handle, gotolocation__.x, gotolocation__.y, gotolocation__.z, focuslocation__.x, focuslocation__.y, focuslocation__.z, speed, shoot_at_enemies, distance_to_stop_at, no_roads_distance, use_nav_mesh, nav_flags, task_flags, firing_pattern}); } // 0xA55547801EB331FC 0x3F91358E b323
    pub inline fn taskGoToEntityWhileAimingAtCoord(ped: types.Ped, entity: types.Entity, aim__: types.Vector3, move_blend_ratio: f32, shoot: windows.BOOL, target_radius: f32, slow_distance: f32, use_nav_mesh: windows.BOOL, instant_blend_to_aim: windows.BOOL, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0x04701832B739DCE5, .{ped, entity, aim__.x, aim__.y, aim__.z, move_blend_ratio, shoot, target_radius, slow_distance, use_nav_mesh, instant_blend_to_aim, firing_pattern}); } // 0x04701832B739DCE5 0xD896CD82 b323
    /// shootatEntity: \
    /// If true, peds will shoot at Entity till it is dead. \
    /// If false, peds will just walk till they reach the entity and will cease shooting.
    pub inline fn taskGoToEntityWhileAimingAtEntity(ped: types.Ped, entity_to_walk_to: types.Entity, entity_to_aim_at: types.Entity, speed: f32, shootat_entity: windows.BOOL, target_radius: f32, slow_distance: f32, use_nav_mesh: windows.BOOL, instant_blend_to_aim: windows.BOOL, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0x97465886D35210E9, .{ped, entity_to_walk_to, entity_to_aim_at, speed, shootat_entity, target_radius, slow_distance, use_nav_mesh, instant_blend_to_aim, firing_pattern}); } // 0x97465886D35210E9 0x68E36B7A b323
    /// Makes the ped ragdoll like when falling from a great height
    pub inline fn setHighFallTask(ped: types.Ped, min_time: c_int, max_time: c_int, entry_type: c_int) !void { try invoker.invoke(void, 0x8C825BDC7741D37C, .{ped, min_time, max_time, entry_type}); } // 0x8C825BDC7741D37C 0xBBB26172 b323
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json \
    /// For a full list of the points, see here: goo.gl/wIH0vn
    /// 
    /// Max number of loaded recordings is 32.
    pub inline fn requestWaypointRecording(name: [*c]const u8) !void { try invoker.invoke(void, 0x9EEFB62EB27B5792, .{name}); } // 0x9EEFB62EB27B5792 0xAFABFB5D b323
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
    pub inline fn getIsWaypointRecordingLoaded(name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCB4E8BE8A0063C5D, .{name}); } // 0xCB4E8BE8A0063C5D 0x87125F5D b323
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
    pub inline fn removeWaypointRecording(name: [*c]const u8) !void { try invoker.invoke(void, 0xFF1B8B4AA1C25DC8, .{name}); } // 0xFF1B8B4AA1C25DC8 0x624530B0 b323
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json \
    /// For a full list of the points, see here: goo.gl/wIH0vn
    pub inline fn waypointRecordingGetNumPoints(name: [*c]const u8, points: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5343532C01A07234, .{name, points}); } // 0x5343532C01A07234 0xF5F9B71E b323
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json \
    /// For a full list of the points, see here: goo.gl/wIH0vn
    pub inline fn waypointRecordingGetCoord(name: [*c]const u8, point: c_int, coord: [*c]types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2FB897405C90B361, .{name, point, coord}); } // 0x2FB897405C90B361 0x19266913 b323
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
    pub inline fn waypointRecordingGetSpeedAtPoint(name: [*c]const u8, point: c_int) !f32 { return try invoker.invoke(f32, 0x005622AEBC33ACA9, .{name, point}); } // 0x005622AEBC33ACA9 0xC765633A b323
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json \
    /// For a full list of the points, see here: goo.gl/wIH0vn
    pub inline fn waypointRecordingGetClosestWaypoint(name: [*c]const u8, vec: types.Vector3, point: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB629A298081F876F, .{name, vec.x, vec.y, vec.z, point}); } // 0xB629A298081F876F 0xC4CD35AF b323
    pub inline fn taskFollowWaypointRecording(ped: types.Ped, name: [*c]const u8, p_2: c_int, p_3: c_int, p_4: c_int) !void { try invoker.invoke(void, 0x0759591819534F7B, .{ped, name, p_2, p_3, p_4}); } // 0x0759591819534F7B 0xADF9904D b323
    pub inline fn isWaypointPlaybackGoingOnForPed(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE03B3F2D3DC59B64, .{ped}); } // 0xE03B3F2D3DC59B64 0x85B7725F b323
    pub inline fn getPedWaypointProgress(ped: types.Ped) !c_int { return try invoker.invoke(c_int, 0x2720AAA75001E094, .{ped}); } // 0x2720AAA75001E094 0x3595B104 b323
    pub inline fn setPedWaypointProgress(ped: types.Ped, progress: c_int) !void { try invoker.invoke(void, 0x686ECCD99D4E61BB, .{ped, progress}); } // 0x686ECCD99D4E61BB  b3570
    pub inline fn getPedWaypointDistance(p_0: types.Any) !f32 { return try invoker.invoke(f32, 0xE6A877C64CAF1BC5, .{p_0}); } // 0xE6A877C64CAF1BC5 0x084B35B0 b323
    pub inline fn setPedWaypointRouteOffset(ped: types.Ped, vec: types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xED98E10B0AFCE4B4, .{ped, vec.x, vec.y, vec.z}); } // 0xED98E10B0AFCE4B4 0xF867F747 b323
    pub inline fn getWaypointDistanceAlongRoute(name: [*c]const u8, point: c_int) !f32 { return try invoker.invoke(f32, 0xA5B769058763E497, .{name, point}); } // 0xA5B769058763E497 0xE8422AC4 b323
    pub inline fn waypointPlaybackGetIsPaused(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x701375A7D43F01CB, .{p_0}); } // 0x701375A7D43F01CB 0xA6BB5717 b323
    pub inline fn waypointPlaybackPause(p_0: types.Any, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x0F342546AA06FED5, .{p_0, p_1, p_2}); } // 0x0F342546AA06FED5 0xFE39ECF8 b323
    pub inline fn waypointPlaybackResume(p_0: types.Any, p_1: windows.BOOL, p_2: types.Any, p_3: types.Any) !void { try invoker.invoke(void, 0x244F70C84C547D2D, .{p_0, p_1, p_2, p_3}); } // 0x244F70C84C547D2D 0x50F392EF b323
    pub inline fn waypointPlaybackOverrideSpeed(p_0: types.Any, p_1: f32, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x7D7D2B47FA788E85, .{p_0, p_1, p_2}); } // 0x7D7D2B47FA788E85 0x23E6BA96 b323
    pub inline fn waypointPlaybackUseDefaultSpeed(p_0: types.Any) !void { try invoker.invoke(void, 0x6599D834B12D0800, .{p_0}); } // 0x6599D834B12D0800 0x1BBB2CAC b323
    pub inline fn useWaypointRecordingAsAssistedMovementRoute(name: [*c]const u8, p_1: windows.BOOL, p_2: f32, p_3: f32) !void { try invoker.invoke(void, 0x5A353B8E6B1095B5, .{name, p_1, p_2, p_3}); } // 0x5A353B8E6B1095B5 0x4DFD5FEC b323
    pub inline fn waypointPlaybackStartAimingAtPed(ped: types.Ped, target: types.Ped, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x20E330937C399D29, .{ped, target, p_2}); } // 0x20E330937C399D29 0x75E60CF6 b323
    pub inline fn waypointPlaybackStartAimingAtCoord(ped: types.Ped, vec: types.Vector3, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x8968400D900ED8B3, .{ped, vec.x, vec.y, vec.z, p_4}); } // 0x8968400D900ED8B3 0xF120A34E b323
    pub inline fn waypointPlaybackStartShootingAtPed(ped: types.Ped, ped_2: types.Ped, p_2: windows.BOOL, p_3: windows.BOOL) !void { try invoker.invoke(void, 0xE70BA7B90F8390DC, .{ped, ped_2, p_2, p_3}); } // 0xE70BA7B90F8390DC 0xBD5F0EB8 b323
    pub inline fn waypointPlaybackStartShootingAtCoord(ped: types.Ped, vec: types.Vector3, p_4: windows.BOOL, firing_pattern: types.Hash) !void { try invoker.invoke(void, 0x057A25CFCC9DB671, .{ped, vec.x, vec.y, vec.z, p_4, firing_pattern}); } // 0x057A25CFCC9DB671 0xCDDB44D5 b323
    pub inline fn waypointPlaybackStopAimingOrShooting(ped: types.Ped) !void { try invoker.invoke(void, 0x47EFA040EBB8E2EA, .{ped}); } // 0x47EFA040EBB8E2EA 0x6D7CF40C b323
    /// Routes: "1_FIBStairs", "2_FIBStairs", "3_FIBStairs", "4_FIBStairs", "5_FIBStairs", "5_TowardsFire", "6a_FIBStairs", "7_FIBStairs", "8_FIBStairs", "Aprtmnt_1", "AssAfterLift", "ATM_1", "coroner2", "coroner_stairs", "f5_jimmy1", "fame1", "family5b", "family5c", "Family5d", "family5d", "FIB_Glass1", "FIB_Glass2", "FIB_Glass3", "finaBroute1A", "finalb1st", "finalB1sta", "finalbround", "finalbroute2", "Hairdresser1", "jan_foyet_ft_door", "Jo_3", "Lemar1", "Lemar2", "mansion_1", "Mansion_1", "pols_1", "pols_2", "pols_3", "pols_4", "pols_5", "pols_6", "pols_7", "pols_8", "Pro_S1", "Pro_S1a", "Pro_S2", "Towards_case", "trev_steps", "tunrs1", "tunrs2", "tunrs3", "Wave01457s"
    pub inline fn assistedMovementRequestRoute(route: [*c]const u8) !void { try invoker.invoke(void, 0x817268968605947A, .{route}); } // 0x817268968605947A 0x48262EDA b323
    pub inline fn assistedMovementRemoveRoute(route: [*c]const u8) !void { try invoker.invoke(void, 0x3548536485DD792B, .{route}); } // 0x3548536485DD792B 0xB3CEC06F b323
    pub inline fn assistedMovementIsRouteLoaded(route: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x60F9A4393A21F741, .{route}); } // 0x60F9A4393A21F741 0x79B067AF b323
    pub inline fn assistedMovementSetRouteProperties(route: [*c]const u8, props: c_int) !void { try invoker.invoke(void, 0xD5002D78B7162E1B, .{route, props}); } // 0xD5002D78B7162E1B 0x01CAAFCC b323
    pub inline fn assistedMovementOverrideLoadDistanceThisFrame(dist: f32) !void { try invoker.invoke(void, 0x13945951E16EF912, .{dist}); } // 0x13945951E16EF912 0x8FB923EC b323
    /// 
    /// 
    /// p2 = Waypoint recording string (found in update\update.rpf\x64\levels\gta5\waypointrec.rpf \
    /// p3 = 786468 \
    /// p4 = 0 \
    /// p5 = 16 \
    /// p6 = -1 (angle?) \
    /// p7/8/9 = usually v3.zero \
    /// p10 = bool (repeat?) \
    /// p11 = 1073741824
    /// 
    /// Full list of waypoint recordings by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/waypointRecordings.json
    pub inline fn taskVehicleFollowWaypointRecording(ped: types.Ped, vehicle: types.Vehicle, _w_p_recording: [*c]const u8, p_3: c_int, p_4: c_int, p_5: c_int, p_6: c_int, p_7: f32, p_8: windows.BOOL, p_9: f32) !void { try invoker.invoke(void, 0x3123FAA6DB1CF7ED, .{ped, vehicle, _w_p_recording, p_3, p_4, p_5, p_6, p_7, p_8, p_9}); } // 0x3123FAA6DB1CF7ED 0x959818B6 b323
    pub inline fn isWaypointPlaybackGoingOnForVehicle(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF5134943EA29868C, .{vehicle}); } // 0xF5134943EA29868C 0x80DD15DB b323
    pub inline fn getVehicleWaypointProgress(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x9824CFF8FC66E159, .{vehicle}); } // 0x9824CFF8FC66E159 0xD3CCF64E b323
    pub inline fn getVehicleWaypointTargetPoint(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x416B62AC8B9E5BBD, .{vehicle}); } // 0x416B62AC8B9E5BBD 0x81049608 b323
    pub inline fn vehicleWaypointPlaybackPause(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x8A4E6AC373666BC5, .{vehicle}); } // 0x8A4E6AC373666BC5 0x7C00B415 b323
    pub inline fn vehicleWaypointPlaybackGetIsPaused(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE435D3539EFDCD1B, .{vehicle}); } // 0xE435D3539EFDCD1B  b3570
    pub inline fn vehicleWaypointPlaybackResume(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xDC04FCAA7839D492, .{vehicle}); } // 0xDC04FCAA7839D492 0xBEB14C82 b323
    pub inline fn vehicleWaypointPlaybackUseDefaultSpeed(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x5CEB25A7D2848963, .{vehicle}); } // 0x5CEB25A7D2848963 0x923C3AA4 b323
    pub inline fn vehicleWaypointPlaybackOverrideSpeed(vehicle: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0x121F0593E0A431D7, .{vehicle, speed}); } // 0x121F0593E0A431D7 0xBE1E7BB4 b323
    /// I cant believe I have to define this, this is one of the best natives.
    /// 
    /// It makes the ped ignore basically all shocking events around it. Occasionally the ped may comment or gesture, but other than that they just continue their daily activities. This includes shooting and wounding the ped. And - most importantly - they do not flee.
    /// 
    /// Since it is a task, every time the native is called the ped will stop for a moment. 
    pub inline fn taskSetBlockingOfNonTemporaryEvents(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x90D2156198831D69, .{ped, toggle}); } // 0x90D2156198831D69 0x1B54FB6B b323
    /// p2 always false
    /// 
    /// [30/03/2017] ins1de :
    /// 
    /// See FORCE_PED_MOTION_STATE
    pub inline fn taskForceMotionState(ped: types.Ped, state: types.Hash, force_restart: windows.BOOL) !void { try invoker.invoke(void, 0x4F056E1AFFEF17AB, .{ped, state, force_restart}); } // 0x4F056E1AFFEF17AB 0xCAD2EF77 b323
    /// Example: \
    /// TASK::TASK_MOVE_NETWORK_BY_NAME(PLAYER::PLAYER_PED_ID(), "arm_wrestling_sweep_paired_a_rev3", 0.0f, true, "mini@arm_wrestling", 0);
    pub inline fn taskMoveNetworkByName(ped: types.Ped, task: [*c]const u8, multiplier: f32, allow_override_clone_update: windows.BOOL, anim_dict: [*c]const u8, flags: c_int) !void { try invoker.invoke(void, 0x2D537BA194896636, .{ped, task, multiplier, allow_override_clone_update, anim_dict, flags}); } // 0x2D537BA194896636 0x6F5D215F b323
    /// Example: \
    /// TASK::TASK_MOVE_NETWORK_ADVANCED_BY_NAME(PLAYER::PLAYER_PED_ID(), "minigame_tattoo_michael_parts", 324.13f, 181.29f, 102.6f, 0.0f, 0.0f, 22.32f, 2, 0, false, 0, 0);
    pub inline fn taskMoveNetworkAdvancedByName(ped: types.Ped, network: [*c]const u8, vec: types.Vector3, rot__: types.Vector3, rot_order: c_int, blend_duration: f32, allow_override_clone_update: windows.BOOL, anim_dict: [*c]const u8, flags: c_int) !void { try invoker.invoke(void, 0xD5B35BEA41919ACB, .{ped, network, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, rot_order, blend_duration, allow_override_clone_update, anim_dict, flags}); } // 0xD5B35BEA41919ACB 0x71A5C5DB b323
    /// Used only once in the scripts (am_mp_nightclub)
    pub inline fn taskMoveNetworkByNameWithInitParams(ped: types.Ped, network: [*c]const u8, initial_parameters: [*c]c_int, blend_duration: f32, allow_override_clone_update: windows.BOOL, anim_dict: [*c]const u8, flags: c_int) !void { try invoker.invoke(void, 0x3D45B0B355C5E0C9, .{ped, network, initial_parameters, blend_duration, allow_override_clone_update, anim_dict, flags}); } // 0x3D45B0B355C5E0C9  b1493
    pub inline fn taskMoveNetworkAdvancedByNameWithInitParams(ped: types.Ped, network: [*c]const u8, initial_parameters: [*c]c_int, vec: types.Vector3, rot__: types.Vector3, rot_order: c_int, blend_duration: f32, allow_override_clone_update: windows.BOOL, dictionary: [*c]const u8, flags: c_int) !void { try invoker.invoke(void, 0x29682E2CCF21E9B5, .{ped, network, initial_parameters, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, rot_order, blend_duration, allow_override_clone_update, dictionary, flags}); } // 0x29682E2CCF21E9B5  b1868
    pub inline fn isTaskMoveNetworkActive(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x921CE12C489C4C41, .{ped}); } // 0x921CE12C489C4C41 0x902656EB b323
    pub inline fn isTaskMoveNetworkReadyForTransition(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x30ED88D5E0C56A37, .{ped}); } // 0x30ED88D5E0C56A37 0x92FDBAE6 b323
    pub inline fn requestTaskMoveNetworkStateTransition(ped: types.Ped, name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD01015C7316AE176, .{ped, name}); } // 0xD01015C7316AE176 0x885724DE b323
    /// Used only once in the scripts (fm_mission_controller) like so:
    /// 
    /// TASK::SET_EXPECTED_CLONE_NEXT_TASK_MOVE_NETWORK_STATE(iLocal_3160, "Cutting");
    pub inline fn setExpectedCloneNextTaskMoveNetworkState(ped: types.Ped, state: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAB13A5565480B6D9, .{ped, state}); } // 0xAB13A5565480B6D9 0x1E58A7AD b323
    pub inline fn getTaskMoveNetworkState(ped: types.Ped) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x717E4D1F2048376D, .{ped}); } // 0x717E4D1F2048376D 0x96C0277B b323
    pub inline fn setTaskMoveNetworkAnimSet(ped: types.Ped, clip_set: types.Hash, variable_clip_set: types.Hash) !void { try invoker.invoke(void, 0x8423541E8B3A1589, .{ped, clip_set, variable_clip_set}); } // 0x8423541E8B3A1589  b1493
    /// signalName - "Phase", "Wobble", "x_axis","y_axis","introphase","speed". \
    /// p2 - From what i can see it goes up to 1f (maybe).
    /// 
    /// Example: TASK::SET_TASK_MOVE_NETWORK_SIGNAL_FLOAT(PLAYER::PLAYER_PED_ID(), "Phase", 0.5);
    pub inline fn setTaskMoveNetworkSignalFloat(ped: types.Ped, signal_name: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0xD5BB4025AE449A4E, .{ped, signal_name, value}); } // 0xD5BB4025AE449A4E 0xA79BE783 b323
    pub inline fn setTaskMoveNetworkSignalLocalFloat(ped: types.Ped, signal_name: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0x373EF409B82697A3, .{ped, signal_name, value}); } // 0x373EF409B82697A3  b1493
    pub inline fn setTaskMoveNetworkSignalFloatLerpRate(ped: types.Ped, signal_name: [*c]const u8, value: f32) !void { try invoker.invoke(void, 0x8634CEF2522D987B, .{ped, signal_name, value}); } // 0x8634CEF2522D987B  b1493
    pub inline fn setTaskMoveNetworkSignalBool(ped: types.Ped, signal_name: [*c]const u8, value: windows.BOOL) !void { try invoker.invoke(void, 0xB0A6CFD2C69C1088, .{ped, signal_name, value}); } // 0xB0A6CFD2C69C1088 0xF3538041 b323
    pub inline fn getTaskMoveNetworkSignalFloat(ped: types.Ped, signal_name: [*c]const u8) !f32 { return try invoker.invoke(f32, 0x44AB0B3AFECCE242, .{ped, signal_name}); } // 0x44AB0B3AFECCE242  b1493
    pub inline fn getTaskMoveNetworkSignalBool(ped: types.Ped, signal_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA7FFBA498E4AAF67, .{ped, signal_name}); } // 0xA7FFBA498E4AAF67 0x1EBB6F3D b323
    pub inline fn getTaskMoveNetworkEvent(ped: types.Ped, event_name: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB4F47213DF45A64C, .{ped, event_name}); } // 0xB4F47213DF45A64C 0x72FA5EF2 b323
    /// Doesn't actually return anything.
    pub inline fn setTaskMoveNetworkEnableCollisionOnNetworkCloneWhenFixed(ped: types.Ped, enable: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0FFB3C758E8C07B9, .{ped, enable}); } // 0x0FFB3C758E8C07B9  b2060
    pub inline fn setScriptTaskEnableCollisionOnNetworkCloneWhenFixed_(ped: types.Ped, enable: windows.BOOL) !void { try invoker.invoke(void, 0x32F6EEF031F943DC, .{ped, enable}); } // 0x32F6EEF031F943DC  b3095
    pub inline fn setAmbientPedEnableCollisionOnNetworkCloneWhenFixed_(ped: types.Ped, enable: windows.BOOL) !void { try invoker.invoke(void, 0x0EFE4834A2F40563, .{ped, enable}); } // 0x0EFE4834A2F40563  b3570
    pub inline fn isMoveBlendRatioStill(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x349CE7B56DAFD95C, .{ped}); } // 0x349CE7B56DAFD95C 0xE9DAF877 b323
    pub inline fn isMoveBlendRatioWalking(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF133BBBE91E1691F, .{ped}); } // 0xF133BBBE91E1691F 0xD21639A8 b323
    pub inline fn isMoveBlendRatioRunning(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD4D8636C0199A939, .{ped}); } // 0xD4D8636C0199A939 0xE76A2353 b323
    pub inline fn isMoveBlendRatioSprinting(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x24A2AD74FA9814E2, .{ped}); } // 0x24A2AD74FA9814E2 0xDD616893 b323
    pub inline fn isPedStill(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAC29253EEF8F0180, .{ped}); } // 0xAC29253EEF8F0180 0x09E3418D b323
    pub inline fn isPedWalking(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDE4C184B2B9B071A, .{ped}); } // 0xDE4C184B2B9B071A 0x4B865C4A b323
    pub inline fn isPedRunning(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC5286FFC176F28A2, .{ped}); } // 0xC5286FFC176F28A2 0xE9A5578F b323
    pub inline fn isPedSprinting(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57E457CD2C0FC168, .{ped}); } // 0x57E457CD2C0FC168 0x4F3E0633 b323
    pub inline fn isPedStrafing(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE45B7F222DE47E09, .{ped}); } // 0xE45B7F222DE47E09 0xEFEED13C b323
    ///  TASK::TASK_SYNCHRONIZED_SCENE(ped, scene, "creatures@rottweiler@in_vehicle@std_car", "get_in", 1000.0, -8.0, 4, 0, 0x447a0000, 0);
    /// 
    /// Full list of animation dictionaries and anims by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/animDictsCompact.json
    pub inline fn taskSynchronizedScene(ped: types.Ped, scene: c_int, anim_dictionary: [*c]const u8, animation_name: [*c]const u8, blend_in: f32, blend_out: f32, flags: c_int, ragdoll_blocking_flags: c_int, mover_blend_delta: f32, ik_flags: c_int) !void { try invoker.invoke(void, 0xEEA929141F699854, .{ped, scene, anim_dictionary, animation_name, blend_in, blend_out, flags, ragdoll_blocking_flags, mover_blend_delta, ik_flags}); } // 0xEEA929141F699854 0x4F217E7B b323
    pub inline fn taskAgitatedActionConfrontResponse(ped: types.Ped, ped_2: types.Ped) !void { try invoker.invoke(void, 0x19D1B791CB3670FE, .{ped, ped_2}); } // 0x19D1B791CB3670FE  b877
    /// This function is called on peds in vehicles.
    /// 
    /// anim: animation name \
    /// p2, p3, p4: "sweep_low", "sweep_med" or "sweep_high" \
    /// p5: no idea what it does but is usually -1
    pub inline fn taskSweepAimEntity(ped: types.Ped, anim_dict: [*c]const u8, low_anim_name: [*c]const u8, med_anim_name: [*c]const u8, hi_anim_name: [*c]const u8, runtime: c_int, target_entity: types.Entity, turn_rate: f32, blend_in_duration: f32) !void { try invoker.invoke(void, 0x2047C02158D6405A, .{ped, anim_dict, low_anim_name, med_anim_name, hi_anim_name, runtime, target_entity, turn_rate, blend_in_duration}); } // 0x2047C02158D6405A 0x4D210467 b323
    pub inline fn updateTaskSweepAimEntity(ped: types.Ped, entity: types.Entity) !void { try invoker.invoke(void, 0xE4973DBDBE6E44B3, .{ped, entity}); } // 0xE4973DBDBE6E44B3 0xF65F0F4F b323
    pub inline fn taskSweepAimPosition(ped: types.Ped, anim_dict: [*c]const u8, low_anim_name: [*c]const u8, med_anim_name: [*c]const u8, hi_anim_name: [*c]const u8, runtime: c_int, vec: types.Vector3, turn_rate: f32, blend_in_duration: f32) !void { try invoker.invoke(void, 0x7AFE8FDC10BC07D2, .{ped, anim_dict, low_anim_name, med_anim_name, hi_anim_name, runtime, vec.x, vec.y, vec.z, turn_rate, blend_in_duration}); } // 0x7AFE8FDC10BC07D2 0x1683FE66 b323
    pub inline fn updateTaskSweepAimPosition(ped: types.Ped, vec: types.Vector3) !void { try invoker.invoke(void, 0xBB106883F5201FC4, .{ped, vec.x, vec.y, vec.z}); } // 0xBB106883F5201FC4 0x6345EC80 b323
    /// Example from "me_amanda1.ysc.c4": \
    /// TASK::TASK_ARREST_PED(l_19F /* This is a Ped */ , PLAYER::PLAYER_PED_ID());
    /// 
    /// Example from "armenian1.ysc.c4": \
    /// if (!PED::IS_PED_INJURED(l_B18[0/*1*/])) { \
    ///     TASK::TASK_ARREST_PED(l_B18[0/*1*/], PLAYER::PLAYER_PED_ID());
    /// }
    /// 
    /// I would love to have time to experiment to see if a player Ped can arrest another Ped. Might make for a good cop mod.
    /// 
    /// 
    /// Looks like only the player can be arrested this way. Peds react and try to arrest you if you task them, but the player charater doesn't do anything if tasked to arrest another ped.
    pub inline fn taskArrestPed(ped: types.Ped, target: types.Ped) !void { try invoker.invoke(void, 0xF3B9A78A178572B1, .{ped, target}); } // 0xF3B9A78A178572B1 0xBC0F153D b323
    pub inline fn isPedRunningArrestTask(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3DC52677769B4AE0, .{ped}); } // 0x3DC52677769B4AE0 0x6942DB7A b323
    /// This function is hard-coded to always return 0.
    pub inline fn isPedBeingArrested(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x90A09F3A45FED688, .{ped}); } // 0x90A09F3A45FED688 0x5FF6C2ED b323
    pub inline fn uncuffPed(ped: types.Ped) !void { try invoker.invoke(void, 0x67406F2C8F87FC4F, .{ped}); } // 0x67406F2C8F87FC4F 0xA23A1D61 b323
    pub inline fn isPedCuffed(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x74E559B3BC910685, .{ped}); } // 0x74E559B3BC910685 0x511CE741 b323
};

pub const Vehicle = struct
{
    /// p7 when set to true allows you to spawn vehicles under -100 z. \
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn createVehicle(model_hash: types.Hash, vec: types.Vector3, heading: f32, is_network: windows.BOOL, b_script_host_veh: windows.BOOL, p_7: windows.BOOL) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0xAF35D0D2583051B0, .{model_hash, vec.x, vec.y, vec.z, heading, is_network, b_script_host_veh, p_7}); } // 0xAF35D0D2583051B0 0xDD75460A b323
    /// Deletes a vehicle. \
    /// The vehicle must be a mission entity to delete, so call this before deleting: SET_ENTITY_AS_MISSION_ENTITY(vehicle, true, true);
    /// 
    /// eg how to use: \
    /// SET_ENTITY_AS_MISSION_ENTITY(vehicle, true, true); \
    /// DELETE_VEHICLE(&vehicle);
    /// 
    /// Deletes the specified vehicle, then sets the handle pointed to by the pointer to NULL.
    pub inline fn deleteVehicle(vehicle: [*c]types.Vehicle) !void { try invoker.invoke(void, 0xEA386986E786A54F, .{vehicle}); } // 0xEA386986E786A54F 0x9803AF60 b323
    pub inline fn setVehicleAllowHomingMissleLockon(vehicle: types.Vehicle, toggle: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x7D6F9A3EF26136A0, .{vehicle, toggle, p_2}); } // 0x7D6F9A3EF26136A0 0xBB54ECCA b323
    pub inline fn getVehicleAllowHomingMissleLockonSynced_(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x613A431BCD5A22EB, .{vehicle}); } // 0x613A431BCD5A22EB  b3717
    pub inline fn setVehicleAllowHomingMissleLockonSynced(vehicle: types.Vehicle, can_be_locked_on: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x1DDA078D12879EEE, .{vehicle, can_be_locked_on, p_2}); } // 0x1DDA078D12879EEE  b463
    /// Makes the vehicle accept no passengers.
    pub inline fn setVehicleAllowNoPassengersLockon(veh: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5D14D4154BFE7B2C, .{veh, toggle}); } // 0x5D14D4154BFE7B2C 0x8BAAC437 b323
    /// Returns a value depending on the lock-on state of vehicle weapons. \
    /// 0: not locked on \
    /// 1: locking on \
    /// 2: locked on
    pub inline fn getVehicleHomingLockonState(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xE6B0E8CFC3633BF0, .{vehicle}); } // 0xE6B0E8CFC3633BF0 0xFBDE9FD8 b323
    pub inline fn getVehicleHomingLockedontoState(p_0: types.Any) !c_int { return try invoker.invoke(c_int, 0x6EAAEFC76ACC311F, .{p_0}); } // 0x6EAAEFC76ACC311F  b757
    pub inline fn setVehicleHomingLockedontoState(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x407DC5E97DB1A4D3, .{p_0, p_1}); } // 0x407DC5E97DB1A4D3  b1493
    pub inline fn isVehicleModel(vehicle: types.Vehicle, model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x423E8DE37D934D89, .{vehicle, model}); } // 0x423E8DE37D934D89 0x013B10B6 b323
    pub inline fn doesScriptVehicleGeneratorExist(vehicle_generator: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF6086BC836400876, .{vehicle_generator}); } // 0xF6086BC836400876 0xF6BDDA30 b323
    /// Creates a script vehicle generator at the given coordinates. Most parameters after the model hash are unknown.
    /// 
    /// Parameters: \
    /// x/y/z - Generator position \
    /// heading - Generator heading \
    /// p4 - Unknown (always 5.0) \
    /// p5 - Unknown (always 3.0) \
    /// modelHash - Vehicle model hash \
    /// p7/8/9/10 - Unknown (always -1) \
    /// p11 - Unknown (usually TRUE, only one instance of FALSE) \
    /// p12/13 - Unknown (always FALSE) \
    /// p14 - Unknown (usally FALSE, only two instances of TRUE) \
    /// p15 - Unknown (always TRUE) \
    /// p16 - Unknown (always -1)
    /// 
    /// Vector3 coords = GET_ENTITY_COORDS(PLAYER_PED_ID(), 0);    CREATE_SCRIPT_VEHICLE_GENERATOR(coords.x, coords.y, coords.z, 1.0f, 5.0f, 3.0f, GET_HASH_KEY("adder"), -1. -1, -1, -1, -1, true, false, false, false, true, -1);
    pub inline fn createScriptVehicleGenerator(vec: types.Vector3, heading: f32, p_4: f32, p_5: f32, model_hash: types.Hash, p_7: c_int, p_8: c_int, p_9: c_int, p_1_0: c_int, p_1_1: windows.BOOL, p_1_2: windows.BOOL, p_1_3: windows.BOOL, p_1_4: windows.BOOL, p_1_5: windows.BOOL, p_1_6: c_int) !c_int { return try invoker.invoke(c_int, 0x9DEF883114668116, .{vec.x, vec.y, vec.z, heading, p_4, p_5, model_hash, p_7, p_8, p_9, p_1_0, p_1_1, p_1_2, p_1_3, p_1_4, p_1_5, p_1_6}); } // 0x9DEF883114668116 0x25A9A261 b323
    pub inline fn deleteScriptVehicleGenerator(vehicle_generator: c_int) !void { try invoker.invoke(void, 0x22102C9ABFCF125D, .{vehicle_generator}); } // 0x22102C9ABFCF125D 0xE4328E3F b323
    /// Only called once in the decompiled scripts. Presumably activates the specified generator.
    pub inline fn setScriptVehicleGenerator(vehicle_generator: c_int, enabled: windows.BOOL) !void { try invoker.invoke(void, 0xD9D620E0AC6DC4B0, .{vehicle_generator, enabled}); } // 0xD9D620E0AC6DC4B0 0x40D73747 b323
    /// When p6 is true, vehicle generators are active. \
    /// p7 seems to always be true in story mode scripts, but it's sometimes false in online scripts.
    pub inline fn setAllVehicleGeneratorsActiveInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, toggle: windows.BOOL, p_7: windows.BOOL) !void { try invoker.invoke(void, 0xC12321827687FE4D, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, toggle, p_7}); } // 0xC12321827687FE4D 0xB4E0E69A b323
    pub inline fn setAllVehicleGeneratorsActive() !void { try invoker.invoke(void, 0x34AD89078831A4BC, .{}); } // 0x34AD89078831A4BC 0xAB1FDD76 b323
    pub inline fn setAllLowPriorityVehicleGeneratorsActive(active: windows.BOOL) !void { try invoker.invoke(void, 0x608207E7A8FB787C, .{active}); } // 0x608207E7A8FB787C 0x87F767F2 b323
    /// Related to car generators & CPlayerSwitchMgrLong
    pub inline fn setVehicleGeneratorAreaOfInterest(vec: types.Vector3, radius: f32) !void { try invoker.invoke(void, 0x9A75585FB2E54FAD, .{vec.x, vec.y, vec.z, radius}); } // 0x9A75585FB2E54FAD 0x935A95DA b323
    pub inline fn clearVehicleGeneratorAreaOfInterest() !void { try invoker.invoke(void, 0x0A436B8643716D14, .{}); } // 0x0A436B8643716D14 0x6C73E45A b323
    /// Sets a vehicle on the ground on all wheels.  Returns whether or not the operation was successful.
    /// 
    /// sfink: This has an additional param(Vehicle vehicle, float p1) which is always set to 5.0f in the b944 scripts.
    pub inline fn setVehicleOnGroundProperly(vehicle: types.Vehicle, p_1: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x49733E92263139D1, .{vehicle, p_1}); } // 0x49733E92263139D1 0xE14FDBA6 b323
    pub inline fn setVehicleUseCutsceneWheelCompression(p_0: types.Vehicle, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE023E8AC4EF7C117, .{p_0, p_1, p_2, p_3}); } // 0xE023E8AC4EF7C117 0xA0909ADB b323
    pub inline fn isVehicleStuckOnRoof(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB497F06B288DCFDF, .{vehicle}); } // 0xB497F06B288DCFDF 0x18D07C6C b323
    pub inline fn addVehicleUpsidedownCheck(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xB72E26D81006005B, .{vehicle}); } // 0xB72E26D81006005B 0x3A13D384 b323
    pub inline fn removeVehicleUpsidedownCheck(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xC53EB42A499A7E90, .{vehicle}); } // 0xC53EB42A499A7E90 0xF390BA1B b323
    /// Returns true if the vehicle's current speed is less than, or equal to 0.0025f.
    /// 
    /// For some vehicles it returns true if the current speed is <= 0.00039999999.
    pub inline fn isVehicleStopped(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5721B434AD84D57A, .{vehicle}); } // 0x5721B434AD84D57A 0x655F072C b323
    /// Gets the number of passengers.
    /// 
    /// This native was modified in b2545 to take two additional parameters, allowing you to include the driver or exclude dead passengers.
    /// 
    /// To keep it working like before b2545, set includeDriver to false and includeDeadOccupants to true.
    pub inline fn getVehicleNumberOfPassengers(vehicle: types.Vehicle, include_driver: windows.BOOL, include_dead_occupants: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x24CB2137731FFE89, .{vehicle, include_driver, include_dead_occupants}); } // 0x24CB2137731FFE89 0x1EF20849 b323
    pub inline fn getVehicleMaxNumberOfPassengers(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xA7C4F2C6E744A550, .{vehicle}); } // 0xA7C4F2C6E744A550 0x0A2FC08C b323
    /// Returns max number of passengers (including the driver) for the specified vehicle model.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleModelNumberOfSeats(model_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x2AD93716F184EDA4, .{model_hash}); } // 0x2AD93716F184EDA4 0x838F7BF7 b323
    pub inline fn isSeatWarpOnly(vehicle: types.Vehicle, seat_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF7F203E31F96F6A1, .{vehicle, seat_index}); } // 0xF7F203E31F96F6A1 0x769E5CF2 b323
    pub inline fn isTurretSeat(vehicle: types.Vehicle, seat_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE33FFA906CE74880, .{vehicle, seat_index}); } // 0xE33FFA906CE74880 0x7C43D32A b323
    /// Returns true if the vehicle has the FLAG_ALLOWS_RAPPEL flag set.
    pub inline fn doesVehicleAllowRappel(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4E417C547182C84D, .{vehicle}); } // 0x4E417C547182C84D  b757
    /// Use this native inside a looped function. \
    /// Values: \
    /// - `0.0` = no vehicles on streets \
    /// - `1.0` = normal vehicles on streets
    pub inline fn setVehicleDensityMultiplierThisFrame(multiplier: f32) !void { try invoker.invoke(void, 0x245A6883D966D537, .{multiplier}); } // 0x245A6883D966D537 0xF4187E51 b323
    pub inline fn setRandomVehicleDensityMultiplierThisFrame(multiplier: f32) !void { try invoker.invoke(void, 0xB3B3359379FE77D3, .{multiplier}); } // 0xB3B3359379FE77D3 0x543F712B b323
    pub inline fn setParkedVehicleDensityMultiplierThisFrame(multiplier: f32) !void { try invoker.invoke(void, 0xEAE6DCC7EEE3DB1D, .{multiplier}); } // 0xEAE6DCC7EEE3DB1D 0xDD46CEBE b323
    pub inline fn setDisableRandomTrainsThisFrame(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD4B8E3D1917BC86B, .{toggle}); } // 0xD4B8E3D1917BC86B 0x09462665 b323
    pub inline fn setAmbientVehicleRangeMultiplierThisFrame(value: f32) !void { try invoker.invoke(void, 0x90B6DA738A9A25DA, .{value}); } // 0x90B6DA738A9A25DA 0xDAE2A2BE b323
    pub inline fn setFarDrawVehicles(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x26324F33423F3CC3, .{toggle}); } // 0x26324F33423F3CC3 0x9F019C49 b323
    pub inline fn setNumberOfParkedVehicles(value: c_int) !void { try invoker.invoke(void, 0xCAA15F13EBD417FF, .{value}); } // 0xCAA15F13EBD417FF 0x206A58E8 b323
    /// enum eVehicleLockState \
    /// { \
    ///     VEHICLELOCK_NONE,
    ///     VEHICLELOCK_UNLOCKED,
    ///     VEHICLELOCK_LOCKED,
    ///     VEHICLELOCK_LOCKOUT_PLAYER_ONLY,
    ///     VEHICLELOCK_LOCKED_PLAYER_INSIDE,
    ///     VEHICLELOCK_LOCKED_INITIALLY,
    ///     VEHICLELOCK_FORCE_SHUT_DOORS,
    ///     VEHICLELOCK_LOCKED_BUT_CAN_BE_DAMAGED,
    ///     VEHICLELOCK_LOCKED_BUT_BOOT_UNLOCKED,
    ///     VEHICLELOCK_LOCKED_NO_PASSENGERS,
    ///     VEHICLELOCK_CANNOT_ENTER    
    /// };
    pub inline fn setVehicleDoorsLocked(vehicle: types.Vehicle, door_lock_status: c_int) !void { try invoker.invoke(void, 0xB664292EAECF7FA6, .{vehicle, door_lock_status}); } // 0xB664292EAECF7FA6 0x4CDD35D0 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn setVehicleIndividualDoorsLocked(vehicle: types.Vehicle, door_id: c_int, door_lock_status: c_int) !void { try invoker.invoke(void, 0xBE70724027F85BCD, .{vehicle, door_id, door_lock_status}); } // 0xBE70724027F85BCD 0xD61D182D b323
    /// If set to true, prevents vehicle sirens from having sound, leaving only the lights.
    pub inline fn setVehicleHasMutedSirens(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD8050E0EB60CF274, .{vehicle, toggle}); } // 0xD8050E0EB60CF274 0xC54156A9 b323
    pub inline fn setVehicleDoorsLockedForPlayer(vehicle: types.Vehicle, player: types.Player, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x517AAF684BB50CD1, .{vehicle, player, toggle}); } // 0x517AAF684BB50CD1 0x49829236 b323
    pub inline fn getVehicleDoorsLockedForPlayer(vehicle: types.Vehicle, player: types.Player) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF6AF6CB341349015, .{vehicle, player}); } // 0xF6AF6CB341349015 0x1DC50247 b323
    /// After some analysis, I've decided that these are what the parameters are.
    /// 
    /// We can see this being used in R* scripts such as "am_mp_property_int.ysc.c4": \
    /// l_11A1 = PED::GET_VEHICLE_PED_IS_IN(PLAYER::PLAYER_PED_ID(), 1); \
    /// ... \
    /// VEHICLE::SET_VEHICLE_DOORS_LOCKED_FOR_ALL_PLAYERS(l_11A1, 1);
    pub inline fn setVehicleDoorsLockedForAllPlayers(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA2F80B8D040727CC, .{vehicle, toggle}); } // 0xA2F80B8D040727CC 0x891BA8A4 b323
    pub inline fn setVehicleDoorsLockedForNonScriptPlayers(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9737A37136F07E75, .{vehicle, toggle}); } // 0x9737A37136F07E75 0xE4EF6514 b323
    pub inline fn setVehicleDoorsLockedForTeam(vehicle: types.Vehicle, team: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB81F6D4A8F5EEBA8, .{vehicle, team, toggle}); } // 0xB81F6D4A8F5EEBA8 0x4F85E783 b323
    pub inline fn setVehicleDoorsLockedForAllTeams(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x203B527D1B77904C, .{vehicle, toggle}); } // 0x203B527D1B77904C  b1365
    pub inline fn setVehicleDontTerminateTaskWhenAchieved(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x76D26A22750E849E, .{vehicle}); } // 0x76D26A22750E849E  b1103
    /// 0.0f = engine rev minimum \
    /// 1.0f = engine rev limit
    pub inline fn setVehicleMaxLaunchEngineRevs_(vehicle: types.Vehicle, modifier: f32) !void { try invoker.invoke(void, 0x5AE614ECA5FDD423, .{vehicle, modifier}); } // 0x5AE614ECA5FDD423  b3095
    pub inline fn getVehicleThrottle_(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x92D96892FC06AF22, .{vehicle}); } // 0x92D96892FC06AF22  b3095
    /// Explodes a selected vehicle.
    /// 
    /// Vehicle vehicle = Vehicle you want to explode. \
    /// BOOL isAudible = If explosion makes a sound. \
    /// BOOL isInvisible = If the explosion is invisible or not.
    /// 
    /// First BOOL does not give any visual explosion, the vehicle just falls apart completely but slowly and starts to burn.
    pub inline fn explodeVehicle(vehicle: types.Vehicle, is_audible: windows.BOOL, is_invisible: windows.BOOL) !void { try invoker.invoke(void, 0xBA71116ADF5B514C, .{vehicle, is_audible, is_invisible}); } // 0xBA71116ADF5B514C 0xBEDEACEB b323
    /// Tested on the player's current vehicle. Unless you kill the driver, the vehicle doesn't loose control, however, if enabled, explodeOnImpact is still active. The moment you crash, boom.
    pub inline fn setVehicleOutOfControl(vehicle: types.Vehicle, kill_driver: windows.BOOL, explode_on_impact: windows.BOOL) !void { try invoker.invoke(void, 0xF19D095E42D430CC, .{vehicle, kill_driver, explode_on_impact}); } // 0xF19D095E42D430CC 0x3764D734 b323
    pub inline fn setVehicleTimedExplosion(vehicle: types.Vehicle, ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2E0A74E1002380B1, .{vehicle, ped, toggle}); } // 0x2E0A74E1002380B1 0xDB8CB8E2 b323
    pub inline fn addVehiclePhoneExplosiveDevice(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x99AD4CCCB128CBC9, .{vehicle}); } // 0x99AD4CCCB128CBC9 0x811373DE b323
    pub inline fn clearVehiclePhoneExplosiveDevice() !void { try invoker.invoke(void, 0xAA3F739ABDDCF21F, .{}); } // 0xAA3F739ABDDCF21F  b463
    pub inline fn hasVehiclePhoneExplosiveDevice() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6ADAABD3068C5235, .{}); } // 0x6ADAABD3068C5235 0xA4E69134 b323
    pub inline fn detonateVehiclePhoneExplosiveDevice() !void { try invoker.invoke(void, 0xEF49CF0270307CBE, .{}); } // 0xEF49CF0270307CBE 0x65255524 b323
    pub inline fn haveVehicleRearDoorsBeenBlownOpenByStickybomb(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6B407F2525E93644, .{vehicle}); } // 0x6B407F2525E93644  b2944
    /// This is not tested - it's just an assumption. \
    /// - Nac
    /// 
    /// Doesn't seem to work.  I'll try with an int instead. --JT
    /// 
    /// Read the scripts, im dumpass. 
    /// 
    ///                             if (!VEHICLE::IS_TAXI_LIGHT_ON(l_115)) {
    ///                                 VEHICLE::SET_TAXI_LIGHTS(l_115, 1);
    ///                             }
    pub inline fn setTaxiLights(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0x598803E85E8448D9, .{vehicle, state}); } // 0x598803E85E8448D9 0x68639D85 b323
    pub inline fn isTaxiLightOn(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7504C0F113AB50FC, .{vehicle}); } // 0x7504C0F113AB50FC 0x6FC4924A b323
    /// garageName example "Michael - Beverly Hills"
    /// 
    /// Full list of garages by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/garages.json
    pub inline fn isVehicleInGarageArea(garage_name: [*c]const u8, vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCEE4490CD57BB3C2, .{garage_name, vehicle}); } // 0xCEE4490CD57BB3C2 0xA90EC257 b323
    /// colorPrimary & colorSecondary are the paint index for the vehicle. \
    /// For a list of valid paint indexes, view: https://pastebin.com/pwHci0xK \
    /// ------------------------------------------------------------------------- \
    /// Note: minimum color index is 0, maximum color index is (numColorIndices - 1)
    /// 
    /// Full list of vehicle colors by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleColors.json
    pub inline fn setVehicleColours(vehicle: types.Vehicle, color_primary: c_int, color_secondary: c_int) !void { try invoker.invoke(void, 0x4F1D4BE3A7F24601, .{vehicle, color_primary, color_secondary}); } // 0x4F1D4BE3A7F24601 0x57F24253 b323
    /// It switch to highbeam when p1 is set to true.
    pub inline fn setVehicleFullbeam(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8B7FD87F0DDB421E, .{vehicle, toggle}); } // 0x8B7FD87F0DDB421E 0x9C49CC15 b323
    /// p1 (toggle) was always 1 (true) except in one case in the b678 scripts.
    pub inline fn setVehicleIsRacing(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x07116E24E9D1929D, .{vehicle, toggle}); } // 0x07116E24E9D1929D 0xA59E3DCD b323
    /// p1, p2, p3 are RGB values for color (255,0,0 for Red, ect)
    pub inline fn setVehicleCustomPrimaryColour(vehicle: types.Vehicle, r: c_int, g: c_int, b: c_int) !void { try invoker.invoke(void, 0x7141766F91D15BEA, .{vehicle, r, g, b}); } // 0x7141766F91D15BEA 0x8DF9F9BC b323
    pub inline fn getVehicleCustomPrimaryColour(vehicle: types.Vehicle, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !void { try invoker.invoke(void, 0xB64CF2CCA9D95F52, .{vehicle, r, g, b}); } // 0xB64CF2CCA9D95F52 0x1C2B9FEF b323
    pub inline fn clearVehicleCustomPrimaryColour(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x55E1D2758F34E437, .{vehicle}); } // 0x55E1D2758F34E437 0x51E1E33D b323
    pub inline fn getIsVehiclePrimaryColourCustom(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF095C0405307B21B, .{vehicle}); } // 0xF095C0405307B21B 0xD7EC8760 b323
    /// p1, p2, p3 are RGB values for color (255,0,0 for Red, ect)
    pub inline fn setVehicleCustomSecondaryColour(vehicle: types.Vehicle, r: c_int, g: c_int, b: c_int) !void { try invoker.invoke(void, 0x36CED73BFED89754, .{vehicle, r, g, b}); } // 0x36CED73BFED89754 0x9D77259E b323
    pub inline fn getVehicleCustomSecondaryColour(vehicle: types.Vehicle, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !void { try invoker.invoke(void, 0x8389CD56CA8072DC, .{vehicle, r, g, b}); } // 0x8389CD56CA8072DC 0x3FF247A2 b323
    pub inline fn clearVehicleCustomSecondaryColour(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x5FFBDEEC3E8E2009, .{vehicle}); } // 0x5FFBDEEC3E8E2009 0x7CE00B29 b323
    /// Check if Vehicle Secondary is avaliable for customize
    pub inline fn getIsVehicleSecondaryColourCustom(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x910A32E7AAD2656C, .{vehicle}); } // 0x910A32E7AAD2656C 0x288AD228 b323
    /// The parameter fade is a value from 0-1, where 0 is fresh paint.
    pub inline fn setVehicleEnveffScale(vehicle: types.Vehicle, fade: f32) !void { try invoker.invoke(void, 0x3AFDC536C3D01674, .{vehicle, fade}); } // 0x3AFDC536C3D01674 0x8332730C b323
    /// The result is a value from 0-1, where 0 is fresh paint.
    pub inline fn getVehicleEnveffScale(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xA82819CAC9C4C403, .{vehicle}); } // 0xA82819CAC9C4C403 0xD5F1EEE1 b323
    /// Hardcoded to not work in multiplayer.
    pub inline fn setCanResprayVehicle(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0x52BBA29D5EC69356, .{vehicle, state}); } // 0x52BBA29D5EC69356 0x37677590 b323
    /// Used for GTAO CEO/Associate spawned vehicles.
    pub inline fn setGoonBossVehicle(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAB31EF4DE6800CE9, .{vehicle, toggle}); } // 0xAB31EF4DE6800CE9  b573
    pub inline fn setOpenRearDoorsOnExplosion(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1B212B26DD3C04DF, .{vehicle, toggle}); } // 0x1B212B26DD3C04DF  b757
    pub inline fn forceSubmarineSurfaceMode(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x33506883545AC0DF, .{vehicle, toggle}); } // 0x33506883545AC0DF 0x54E9EE75 b323
    pub inline fn forceSubmarineNeurtalBuoyancy(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xC67DB108A9ADE3BE, .{p_0, p_1}); } // 0xC67DB108A9ADE3BE  b2189
    pub inline fn setSubmarineCrushDepths(vehicle: types.Vehicle, p_1: windows.BOOL, depth_1: f32, depth_2: f32, depth_3: f32) !void { try invoker.invoke(void, 0xC59872A5134879C7, .{vehicle, p_1, depth_1, depth_2, depth_3}); } // 0xC59872A5134879C7 0x4A46E814 b323
    pub inline fn getSubmarineIsUnderDesignDepth(submarine: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3E71D0B300B7AA79, .{submarine}); } // 0x3E71D0B300B7AA79  b2189
    pub inline fn getSubmarineNumberOfAirLeaks(submarine: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x093D6DDCA5B8FBAE, .{submarine}); } // 0x093D6DDCA5B8FBAE  b2189
    pub inline fn setBoatIgnoreLandProbes(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xED5EDE9E676643C9, .{p_0, p_1}); } // 0xED5EDE9E676643C9  b944
    /// Use the vehicle bounds (instead of viewport) when deciding if a vehicle is sufficiently above the water (waterheight.dat), bypassing wave simulation checks
    pub inline fn setBoundsAffectWaterProbes_(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x85FC953F6C6CBDE1, .{vehicle, toggle}); } // 0x85FC953F6C6CBDE1  b2802
    pub inline fn setBoatAnchor(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x75DBEC174AEEAD10, .{vehicle, toggle}); } // 0x75DBEC174AEEAD10 0xA3906284 b323
    pub inline fn canAnchorBoatHere(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x26C10ECBDA5D043B, .{vehicle}); } // 0x26C10ECBDA5D043B 0xE97A4F5E b323
    pub inline fn canAnchorBoatHereIgnorePlayers(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x24F4121D07579880, .{vehicle}); } // 0x24F4121D07579880  b678
    pub inline fn setBoatRemainsAnchoredWhilePlayerIsDriver(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE3EBAAE484798530, .{vehicle, toggle}); } // 0xE3EBAAE484798530 0x0ED84792 b323
    /// No observed effect.
    pub inline fn setForceLowLodAnchorMode(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xB28B1FE5BFADD7F5, .{vehicle, p_1}); } // 0xB28B1FE5BFADD7F5 0xA739012A b323
    pub inline fn setBoatLowLodAnchorDistance(vehicle: types.Vehicle, value: f32) !void { try invoker.invoke(void, 0xE842A9398079BD82, .{vehicle, value}); } // 0xE842A9398079BD82 0x66FA450C b323
    pub inline fn isBoatAnchored(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB0AD1238A709B1A2, .{vehicle}); } // 0xB0AD1238A709B1A2  b573
    pub inline fn setBoatSinksWhenWrecked(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8F719973E1445BA2, .{vehicle, toggle}); } // 0x8F719973E1445BA2 0x35614622 b323
    pub inline fn setBoatWrecked(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xBD32E46AA95C1DD2, .{vehicle}); } // 0xBD32E46AA95C1DD2  b757
    /// Activate siren on vehicle (Only works if the vehicle has a siren).
    pub inline fn setVehicleSiren(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF4924635A19EB37D, .{vehicle, toggle}); } // 0xF4924635A19EB37D 0x4AC1EFC7 b323
    pub inline fn isVehicleSirenOn(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C9BF537BE2634B2, .{vehicle}); } // 0x4C9BF537BE2634B2 0x25EB5873 b323
    pub inline fn isVehicleSirenAudioOn(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB5CC40FBCB586380, .{vehicle}); } // 0xB5CC40FBCB586380 0xC9458688 b323
    /// If set to true, vehicle will not take crash damage, but is still susceptible to damage from bullets and explosives
    pub inline fn setVehicleStrong(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3E8C8727991A8A0B, .{vehicle, toggle}); } // 0x3E8C8727991A8A0B 0xC758D19F b323
    pub inline fn removeVehicleStuckCheck(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x8386BFB614D06749, .{vehicle}); } // 0x8386BFB614D06749 0x81594917 b323
    pub inline fn getVehicleColours(vehicle: types.Vehicle, color_primary: [*c]c_int, color_secondary: [*c]c_int) !void { try invoker.invoke(void, 0xA19435F193E081AC, .{vehicle, color_primary, color_secondary}); } // 0xA19435F193E081AC 0x40D82D88 b323
    /// Check if a vehicle seat is free.
    /// 
    /// seatIndex  = -1 being the driver seat. \
    /// Use GET_VEHICLE_MAX_NUMBER_OF_PASSENGERS(vehicle) - 1 for last seat index. \
    /// isTaskRunning = on true the function returns already false while a task on the target seat is running (TASK_ENTER_VEHICLE/TASK_SHUFFLE_TO_NEXT_VEHICLE_SEAT) - on false only when a ped is finally sitting in the seat.
    pub inline fn isVehicleSeatFree(vehicle: types.Vehicle, seat_index: c_int, is_task_running: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x22AC59A870E6A669, .{vehicle, seat_index, is_task_running}); } // 0x22AC59A870E6A669 0xDAF42B02 b323
    /// If there is no ped in the seat, and the game considers the vehicle as ambient population, this will create a random occupant ped in the seat, which may be cleaned up by the game fairly soon if not marked as script-owned mission entity.
    /// 
    /// Seat indexes: \
    /// -1 = Driver \
    /// 0 = Front Right Passenger \
    /// 1 = Back Left Passenger \
    /// 2 = Back Right Passenger \
    /// 3 = Further Back Left Passenger (vehicles > 4 seats) \
    /// 4 = Further Back Right Passenger (vehicles > 4 seats) \
    /// etc.
    /// 
    /// If p2 is true it uses a different GetOccupant function.
    pub inline fn getPedInVehicleSeat(vehicle: types.Vehicle, seat_index: c_int, p_2: windows.BOOL) !types.Ped { return try invoker.invoke(types.Ped, 0xBB40DD2270B65366, .{vehicle, seat_index, p_2}); } // 0xBB40DD2270B65366 0x388FDE9A b323
    pub inline fn getLastPedInVehicleSeat(vehicle: types.Vehicle, seat_index: c_int) !types.Ped { return try invoker.invoke(types.Ped, 0x83F969AA1EE2A664, .{vehicle, seat_index}); } // 0x83F969AA1EE2A664 0xF7C6792D b323
    pub inline fn getVehicleLightsState(vehicle: types.Vehicle, lights_on: [*c]windows.BOOL, highbeams_on: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB91B4C20085BD12F, .{vehicle, lights_on, highbeams_on}); } // 0xB91B4C20085BD12F 0x7C278621 b323
    /// wheelID used for 4 wheelers seem to be (0, 1, 4, 5) \
    /// completely - is to check if tire completely gone from rim.
    /// 
    /// '0 = wheel_lf / bike, plane or jet front \
    /// '1 = wheel_rf \
    /// '2 = wheel_lm / in 6 wheels trailer, plane or jet is first one on left \
    /// '3 = wheel_rm / in 6 wheels trailer, plane or jet is first one on right \
    /// '4 = wheel_lr / bike rear / in 6 wheels trailer, plane or jet is last one on left \
    /// '5 = wheel_rr / in 6 wheels trailer, plane or jet is last one on right \
    /// '45 = 6 wheels trailer mid wheel left \
    /// '47 = 6 wheels trailer mid wheel right
    pub inline fn isVehicleTyreBurst(vehicle: types.Vehicle, wheel_i_d: c_int, completely: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBA291848A0815CA9, .{vehicle, wheel_i_d, completely}); } // 0xBA291848A0815CA9 0x48C80210 b323
    /// SCALE: Setting the speed to 30 would result in a speed of roughly 60mph, according to speedometer.
    /// 
    /// Speed is in meters per second \
    /// You can convert meters/s to mph here: \
    /// http://www.calculateme.com/Speed/MetersperSecond/ToMilesperHour.htm
    pub inline fn setVehicleForwardSpeed(vehicle: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0xAB54A438726D25D5, .{vehicle, speed}); } // 0xAB54A438726D25D5 0x69880D14 b323
    /// Seems to be identical to SET_VEHICLE_FORWARD_SPEED
    pub inline fn setVehicleForwardSpeedXy(vehicle: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0x6501129C9E0FFA05, .{vehicle, speed}); } // 0x6501129C9E0FFA05  b877
    /// This native makes the vehicle stop immediately, as happens when we enter a MP garage.
    /// 
    /// . distance defines how far it will travel until stopping. Garage doors use 3.0.
    /// 
    /// . If killEngine is set to 1, you cannot resume driving the vehicle once it stops. This looks like is a bitmapped integer.
    pub inline fn bringVehicleToHalt(vehicle: types.Vehicle, distance: f32, duration: c_int, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x260BE8F09E326A20, .{vehicle, distance, duration, p_3}); } // 0x260BE8F09E326A20 0xCBC7D3C8 b323
    pub inline fn setVehicleSteerForBuildings(vehicle: types.Vehicle, p_1: types.Any) !void { try invoker.invoke(void, 0xDCE97BDF8A0EABC8, .{vehicle, p_1}); } // 0xDCE97BDF8A0EABC8  b1103
    pub inline fn setVehicleCausesSwerving(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9849DE24FCF23CCC, .{vehicle, toggle}); } // 0x9849DE24FCF23CCC  b1604
    pub inline fn setIgnorePlanesSmallPitchChange(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x8664170EF165C4A6, .{p_0, p_1}); } // 0x8664170EF165C4A6  b2189
    /// Stops CTaskBringVehicleToHalt
    pub inline fn stopBringingVehicleToHalt(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x7C06330BFDDA182E, .{vehicle}); } // 0x7C06330BFDDA182E  b1103
    /// Returns true if vehicle is halted by BRING_VEHICLE_TO_HALT
    pub inline fn isVehicleBeingBroughtToHalt(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC69BB1D832A710EF, .{vehicle}); } // 0xC69BB1D832A710EF  b1493
    pub inline fn lowerForkliftForks(forklift: types.Vehicle) !void { try invoker.invoke(void, 0x923A293361DF44E5, .{forklift}); } // 0x923A293361DF44E5  b2802
    /// 0.0 = Lowest 1.0 = Highest. This is best to be used if you wanna pick-up a car since un-realistically on GTA V forklifts can't pick up much of anything due to vehicle mass. If you put this under a car then set it above 0.0 to a 'lifted-value' it will raise the car with no issue lol
    pub inline fn setForkliftForkHeight(vehicle: types.Vehicle, height: f32) !void { try invoker.invoke(void, 0x37EBBF3117BD6A25, .{vehicle, height}); } // 0x37EBBF3117BD6A25 0x943A6CFC b323
    pub inline fn isEntityAttachedToHandlerFrame(vehicle: types.Vehicle, entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57715966069157AD, .{vehicle, entity}); } // 0x57715966069157AD 0x7FB25568 b323
    pub inline fn isAnyEntityAttachedToHandlerFrame(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x62CA17B74C435651, .{vehicle}); } // 0x62CA17B74C435651 0x593143B9 b323
    /// Finds the vehicle that is carrying this entity with a handler frame. \
    /// The model of the entity must be prop_contr_03b_ld or the function will return 0.
    pub inline fn findHandlerVehicleContainerIsAttachedTo(entity: types.Entity) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x375E7FC44F21C8AB, .{entity}); } // 0x375E7FC44F21C8AB 0x70DD5E25 b323
    pub inline fn isHandlerFrameLinedUpWithContainer(vehicle: types.Vehicle, entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x89D630CF5EA96D23, .{vehicle, entity}); } // 0x89D630CF5EA96D23 0xFBF5536A b323
    pub inline fn attachContainerToHandlerFrameWhenLinedUp(vehicle: types.Vehicle, entity: types.Entity) !void { try invoker.invoke(void, 0x6A98C2ECF57FA5D4, .{vehicle, entity}); } // 0x6A98C2ECF57FA5D4 0x20AB5783 b323
    pub inline fn detachContainerFromHandlerFrame(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x7C0043FDFF6436BC, .{vehicle}); } // 0x7C0043FDFF6436BC 0x0F11D01F b323
    pub inline fn setVehicleDisableHeightMapAvoidance(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x8AA9180DE2FEDD45, .{vehicle, p_1}); } // 0x8AA9180DE2FEDD45 0xAE040377 b323
    pub inline fn setPlaneAvoidsOthers_(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBAFB99B304BC52A7, .{vehicle, toggle}); } // 0xBAFB99B304BC52A7  b3407
    pub inline fn setBoatDisableAvoidance(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x0A6A279F3AA4FD70, .{vehicle, p_1}); } // 0x0A6A279F3AA4FD70 0x4C0E4031 b323
    pub inline fn isHeliLandingAreaBlocked(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x634148744F385576, .{vehicle}); } // 0x634148744F385576 0x6346B7CC b323
    /// Used on helicopters and blimps during the CTaskVehicleLand task. Sets a value on the task to 10f
    pub inline fn setShortSlowdownForLanding(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x107A473D7A6647A9, .{vehicle}); } // 0x107A473D7A6647A9  b1290
    pub inline fn setHeliTurbulenceScalar(vehicle: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0xE6F13851780394DA, .{vehicle, p_1}); } // 0xE6F13851780394DA 0xCCB41A55 b323
    /// Initially used in Max Payne 3, that's why we know the name.
    pub inline fn setCarBootOpen(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xFC40CBF7B90CA77C, .{vehicle}); } // 0xFC40CBF7B90CA77C  b877
    /// "To burst tyres VEHICLE::SET_VEHICLE_TYRE_BURST(vehicle, 0, true, 1000.0) \
    /// to burst all tyres type it 8 times where p1 = 0 to 7.
    /// 
    /// p3 seems to be how much damage it has taken. 0 doesn't deflate them, 1000 completely deflates them.
    /// 
    /// '0 = wheel_lf / bike, plane or jet front \
    /// '1 = wheel_rf \
    /// '2 = wheel_lm / in 6 wheels trailer, plane or jet is first one on left \
    /// '3 = wheel_rm / in 6 wheels trailer, plane or jet is first one on right \
    /// '4 = wheel_lr / bike rear / in 6 wheels trailer, plane or jet is last one on left \
    /// '5 = wheel_rr / in 6 wheels trailer, plane or jet is last one on right \
    /// '45 = 6 wheels trailer mid wheel left \
    /// '47 = 6 wheels trailer mid wheel right
    pub inline fn setVehicleTyreBurst(vehicle: types.Vehicle, index: c_int, on_rim: windows.BOOL, p_3: f32) !void { try invoker.invoke(void, 0xEC6A202EE4960385, .{vehicle, index, on_rim, p_3}); } // 0xEC6A202EE4960385 0x89D28068 b323
    /// Closes all doors of a vehicle:
    pub inline fn setVehicleDoorsShut(vehicle: types.Vehicle, close_instantly: windows.BOOL) !void { try invoker.invoke(void, 0x781B3D62BB013EF5, .{vehicle, close_instantly}); } // 0x781B3D62BB013EF5 0xBB1FF6E7 b323
    /// Allows you to toggle bulletproof tires.
    pub inline fn setVehicleTyresCanBurst(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEB9DC3C7D8596C46, .{vehicle, toggle}); } // 0xEB9DC3C7D8596C46 0xA198DB54 b323
    pub inline fn getVehicleTyresCanBurst(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x678B9BB8C3F58FEB, .{vehicle}); } // 0x678B9BB8C3F58FEB 0x4D76CD2F b323
    pub inline fn setVehicleWheelsCanBreak(vehicle: types.Vehicle, enabled: windows.BOOL) !void { try invoker.invoke(void, 0x29B18B4FD460CA8F, .{vehicle, enabled}); } // 0x29B18B4FD460CA8F 0x829ED654 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn setVehicleDoorOpen(vehicle: types.Vehicle, door_id: c_int, loose: windows.BOOL, open_instantly: windows.BOOL) !void { try invoker.invoke(void, 0x7C65DAC73C35C862, .{vehicle, door_id, loose, open_instantly}); } // 0x7C65DAC73C35C862 0xBB75D38B b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    /// 
    /// Usually used alongside other vehicle door natives.
    pub inline fn setVehicleDoorAutoLock(vehicle: types.Vehicle, door_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3B458DDB57038F08, .{vehicle, door_id, toggle}); } // 0x3B458DDB57038F08  b877
    pub inline fn setFleeingVehiclesUseSwitchedOffNodes(p_0: types.Any) !void { try invoker.invoke(void, 0xA247F9EF01D8082E, .{p_0}); } // 0xA247F9EF01D8082E  b1103
    /// windowIndex: \
    /// 0 = Front Right Window \
    /// 1 = Front Left Window \
    /// 2 = Back Right Window \
    /// 3 = Back Left Window \
    /// 4 = Unknown \
    /// 5 = Unknown \
    /// 6 = Windscreen \
    /// 7 = Rear Windscreen
    pub inline fn removeVehicleWindow(vehicle: types.Vehicle, window_index: c_int) !void { try invoker.invoke(void, 0xA711568EEDB43069, .{vehicle, window_index}); } // 0xA711568EEDB43069 0xBB8104A3 b323
    /// Roll down all the windows of the vehicle passed through the first parameter.
    pub inline fn rollDownWindows(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x85796B0549DDE156, .{vehicle}); } // 0x85796B0549DDE156 0x51A16DC6 b323
    /// windowIndex: \
    /// 0 = Front Left Window \
    /// 1 = Front Right Window \
    /// 2 = Rear Left Window \
    /// 3 = Rear Right Window \
    /// 4 = Front Windscreen \
    /// 5 = Rear Windscreen \
    /// 6 = Mid Left \
    /// 7 = Mid Right \
    /// 8 = Invalid
    pub inline fn rollDownWindow(vehicle: types.Vehicle, window_index: c_int) !void { try invoker.invoke(void, 0x7AD9E6CE657D69E3, .{vehicle, window_index}); } // 0x7AD9E6CE657D69E3 0xF840134C b323
    /// windowIndex: \
    /// 0 = Front Left Window \
    /// 1 = Front Right Window \
    /// 2 = Rear Left Window \
    /// 3 = Rear Right Window \
    /// 4 = Front Windscreen \
    /// 5 = Rear Windscreen \
    /// 6 = Mid Left \
    /// 7 = Mid Right \
    /// 8 = Invalid
    pub inline fn rollUpWindow(vehicle: types.Vehicle, window_index: c_int) !void { try invoker.invoke(void, 0x602E548F46E24D59, .{vehicle, window_index}); } // 0x602E548F46E24D59 0x83B7E06A b323
    /// windowIndex: \
    /// 0 = Front Left Window \
    /// 1 = Front Right Window \
    /// 2 = Rear Left Window \
    /// 3 = Rear Right Window \
    /// 4 = Front Windscreen \
    /// 5 = Rear Windscreen \
    /// 6 = Mid Left \
    /// 7 = Mid Right \
    /// 8 = Invalid
    pub inline fn smashVehicleWindow(vehicle: types.Vehicle, window_index: c_int) !void { try invoker.invoke(void, 0x9E5B5E4D2CCD2259, .{vehicle, window_index}); } // 0x9E5B5E4D2CCD2259 0xDDD9A8C2 b323
    /// windowIndex: \
    /// 0 = Front Left Window \
    /// 1 = Front Right Window \
    /// 2 = Rear Left Window \
    /// 3 = Rear Right Window \
    /// 4 = Front Windscreen \
    /// 5 = Rear Windscreen \
    /// 6 = Mid Left \
    /// 7 = Mid Right \
    /// 8 = Invalid
    /// 
    /// Additional information: FIX_VEHICLE_WINDOW (0x140D0BB88) references an array of bone vehicle indices (0x141D4B3E0) { 2Ah, 2Bh, 2Ch, 2Dh, 2Eh, 2Fh, 28h, 29h } that correspond to: window_lf, window_rf, window_lr, window_rr, window_lm, window_rm, windscreen, windscreen_r. This array is used by most vehwindow natives.
    /// 
    /// Also, this function is coded to not work on vehicles of type: CBike, Bmx, CBoat, CTrain, and CSubmarine.
    pub inline fn fixVehicleWindow(vehicle: types.Vehicle, window_index: c_int) !void { try invoker.invoke(void, 0x772282EBEB95E682, .{vehicle, window_index}); } // 0x772282EBEB95E682 0x6B8E990D b323
    /// Detaches the vehicle's windscreen. \
    /// For further information, see : gtaforums.com/topic/859570-glass/#entry1068894566
    pub inline fn popOutVehicleWindscreen(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x6D645D59FB5F5AD3, .{vehicle}); } // 0x6D645D59FB5F5AD3 0xCC95C96B b323
    /// Pops off the "roof" bone in the direction of the specified offset from the vehicle.
    pub inline fn popOffVehicleRoofWithImpulse(vehicle: types.Vehicle, vec: types.Vector3) !void { try invoker.invoke(void, 0xE38CB9D7D39FDBCC, .{vehicle, vec.x, vec.y, vec.z}); } // 0xE38CB9D7D39FDBCC 0xFDA7B6CA b323
    /// set's if the vehicle has lights or not. \
    /// not an on off toggle. \
    /// p1 = 0 ;vehicle normal lights, off then lowbeams, then highbeams \
    /// p1 = 1 ;vehicle doesn't have lights, always off \
    /// p1 = 2 ;vehicle has always on lights \
    /// p1 = 3 ;or even larger like 4,5,... normal lights like =1 \
    /// note1: when using =2 on day it's lowbeam,highbeam \
    /// but at night it's lowbeam,lowbeam,highbeam \
    /// note2: when using =0 it's affected by day or night for highbeams don't exist in daytime.
    pub inline fn setVehicleLights(vehicle: types.Vehicle, state: c_int) !void { try invoker.invoke(void, 0x34E710FF01247C5A, .{vehicle, state}); } // 0x34E710FF01247C5A 0xE8930226 b323
    pub inline fn setVehicleUsePlayerLightSettings(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC45C27EF50F36ADC, .{vehicle, toggle}); } // 0xC45C27EF50F36ADC 0x4221E435 b323
    /// p1 can be either 0, 1 or 2.
    /// 
    /// Determines how vehicle lights behave when toggled.
    /// 
    /// 0 = Default (Lights can be toggled between off, normal and high beams) \
    /// 1 = Lights Disabled (Lights are fully disabled, cannot be toggled) \
    /// 2 = Always On (Lights can be toggled between normal and high beams)
    pub inline fn setVehicleHeadlightShadows(vehicle: types.Vehicle, p_1: c_int) !void { try invoker.invoke(void, 0x1FD09E7390A74D54, .{vehicle, p_1}); } // 0x1FD09E7390A74D54  b323
    pub inline fn setVehicleAlarm(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0xCDE5E70C1DDB954C, .{vehicle, state}); } // 0xCDE5E70C1DDB954C 0x24877D84 b323
    pub inline fn startVehicleAlarm(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xB8FF7AB45305C345, .{vehicle}); } // 0xB8FF7AB45305C345 0x5B451FF7 b323
    pub inline fn isVehicleAlarmActivated(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4319E335B71FFF34, .{vehicle}); } // 0x4319E335B71FFF34 0xF2630A4C b323
    pub inline fn setVehicleInteriorlight(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBC2042F090AF6AD3, .{vehicle, toggle}); } // 0xBC2042F090AF6AD3 0x9AD1FE1E b323
    /// Sets some bit of vehicle
    pub inline fn setVehicleForceInteriorlight(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8821196D91FA2DE5, .{vehicle, toggle}); } // 0x8821196D91FA2DE5  b1290
    /// multiplier = brightness of head lights. \
    /// this value isn't capped afaik.
    /// 
    /// multiplier = 0.0 no lights \
    /// multiplier = 1.0 default game value
    /// 
    pub inline fn setVehicleLightMultiplier(vehicle: types.Vehicle, multiplier: f32) !void { try invoker.invoke(void, 0xB385454F8791F57C, .{vehicle, multiplier}); } // 0xB385454F8791F57C 0x48039D6A b323
    pub inline fn attachVehicleToTrailer(vehicle: types.Vehicle, trailer: types.Vehicle, radius: f32) !void { try invoker.invoke(void, 0x3C7D42D58F770B54, .{vehicle, trailer, radius}); } // 0x3C7D42D58F770B54 0x2133977F b323
    /// This is the proper way of attaching vehicles to the car carrier, it's what Rockstar uses. Video Demo: https://www.youtube.com/watch?v=2lVEIzf7bgo
    pub inline fn attachVehicleOnToTrailer(vehicle: types.Vehicle, trailer: types.Vehicle, offset__: types.Vector3, coords__: types.Vector3, rotation__: types.Vector3, disable_collisions: f32) !void { try invoker.invoke(void, 0x16B5E274BDE402F8, .{vehicle, trailer, offset__.x, offset__.y, offset__.z, coords__.x, coords__.y, coords__.z, rotation__.x, rotation__.y, rotation__.z, disable_collisions}); } // 0x16B5E274BDE402F8 0x12AC1A16 b323
    pub inline fn stabiliseEntityAttachedToHeli(vehicle: types.Vehicle, entity: types.Entity, p_2: f32) !void { try invoker.invoke(void, 0x374706271354CB18, .{vehicle, entity, p_2}); } // 0x374706271354CB18 0x40C4763F b323
    pub inline fn detachVehicleFromTrailer(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x90532EDF0D2BDD86, .{vehicle}); } // 0x90532EDF0D2BDD86 0xB5DBF91D b323
    pub inline fn isVehicleAttachedToTrailer(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE7CF3C4F9F489F0C, .{vehicle}); } // 0xE7CF3C4F9F489F0C 0xE142BBCC b323
    pub inline fn setTrailerInverseMassScale(vehicle: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0x2A8F319B392E7B3F, .{vehicle, p_1}); } // 0x2A8F319B392E7B3F 0xE74E85CE b323
    /// in the decompiled scripts, seems to be always called on the vehicle right after being attached to a trailer.
    pub inline fn setTrailerLegsRaised(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x95CF53B3D687F9FA, .{vehicle}); } // 0x95CF53B3D687F9FA 0x06C47A6F b323
    pub inline fn setTrailerLegsLowered(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x878C75C09FBDB942, .{vehicle}); } // 0x878C75C09FBDB942  b1103
    /// tyreIndex = 0 to 4 on normal vehicles
    /// 
    /// '0 = wheel_lf / bike, plane or jet front \
    /// '1 = wheel_rf \
    /// '2 = wheel_lm / in 6 wheels trailer, plane or jet is first one on left \
    /// '3 = wheel_rm / in 6 wheels trailer, plane or jet is first one on right \
    /// '4 = wheel_lr / bike rear / in 6 wheels trailer, plane or jet is last one on left \
    /// '5 = wheel_rr / in 6 wheels trailer, plane or jet is last one on right \
    /// '45 = 6 wheels trailer mid wheel left \
    /// '47 = 6 wheels trailer mid wheel right
    pub inline fn setVehicleTyreFixed(vehicle: types.Vehicle, tyre_index: c_int) !void { try invoker.invoke(void, 0x6E13FC662B882D1D, .{vehicle, tyre_index}); } // 0x6E13FC662B882D1D 0xA42EFA6B b323
    /// Sets a vehicle's license plate text.  8 chars maximum.
    /// 
    /// Example: \
    /// Ped playerPed = PLAYER::PLAYER_PED_ID(); \
    /// Vehicle veh = PED::GET_VEHICLE_PED_IS_USING(playerPed); \
    /// char *plateText = "KING"; \
    /// VEHICLE::SET_VEHICLE_NUMBER_PLATE_TEXT(veh, plateText);
    pub inline fn setVehicleNumberPlateText(vehicle: types.Vehicle, plate_text: [*c]const u8) !void { try invoker.invoke(void, 0x95A88F0B409CDA47, .{vehicle, plate_text}); } // 0x95A88F0B409CDA47 0x400F9556 b323
    /// Returns the license plate text from a vehicle. 8 chars maximum.
    pub inline fn getVehicleNumberPlateText(vehicle: types.Vehicle) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x7CE1CCB9B293020E, .{vehicle}); } // 0x7CE1CCB9B293020E 0xE8522D58 b323
    /// Returns the number of *types* of licence plates, enumerated below in SET_VEHICLE_NUMBER_PLATE_TEXT_INDEX.
    pub inline fn getNumberOfVehicleNumberPlates() !c_int { return try invoker.invoke(c_int, 0x4C4D6B2644F458CB, .{}); } // 0x4C4D6B2644F458CB 0xD24BC1AE b323
    /// Plates: \
    /// Blue/White - 0 \
    /// Yellow/black - 1 \
    /// Yellow/Blue - 2 \
    /// Blue/White2 - 3 \
    /// Blue/White3 - 4 \
    /// Yankton - 5
    pub inline fn setVehicleNumberPlateTextIndex(vehicle: types.Vehicle, plate_index: c_int) !void { try invoker.invoke(void, 0x9088EB5A43FFB0A1, .{vehicle, plate_index}); } // 0x9088EB5A43FFB0A1 0xA1A1890E b323
    /// Returns the PlateType of a vehicle \
    ///       Blue_on_White_1 = 3,
    ///       Blue_on_White_2 = 0,
    ///       Blue_on_White_3 = 4,
    ///       Yellow_on_Blue = 2,
    ///        Yellow_on_Black = 1,
    ///       North_Yankton = 5,
    pub inline fn getVehicleNumberPlateTextIndex(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xF11BC2DD9A3E7195, .{vehicle}); } // 0xF11BC2DD9A3E7195 0x499747B6 b323
    pub inline fn setRandomTrains(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x80D9F74197EA47D9, .{toggle}); } // 0x80D9F74197EA47D9 0xD461CA7F b323
    /// Train models HAVE TO be loaded (requested) before you use this. \
    /// For variation 15 - request:
    /// 
    /// freight \
    /// freightcar \
    /// freightgrain \
    /// freightcont1 \
    /// freightcont2 \
    /// freighttrailer
    /// 
    /// 
    pub inline fn createMissionTrain(variation: c_int, vec: types.Vector3, direction: windows.BOOL, p_5: types.Any, p_6: types.Any) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x63C6CCA8E68AE8C8, .{variation, vec.x, vec.y, vec.z, direction, p_5, p_6}); } // 0x63C6CCA8E68AE8C8 0xD4C2EAFD b323
    /// Toggles whether ambient trains can spawn on the specified track or not
    /// 
    /// `trackId` is the internal id of the train track to switch. \
    /// `state` is whether ambient trains can spawn or not
    /// 
    /// trackIds \
    /// 0 (`trains1.dat`) Main track around SA \
    /// 1 (`trains2.dat`) Davis Quartz Quarry branch \
    /// 2 (`trains3.dat`) Second track alongside live track along Roy Lewenstein Blv. \
    /// 3 (`trains4.dat`) Metro track circuit \
    /// 4 (`trains5.dat`) Branch in Mirror Park Railyard \
    /// 5 (`trains6.dat`) Branch in Mirror Park Railyard \
    /// 6 (`trains7.dat`) LS branch to Mirror Park Railyard \
    /// 7 (`trains8.dat`) Overground part of metro track along Forum Dr. \
    /// 8 (`trains9.dat`) Branch to Mirror Park Railyard \
    /// 9 (`trains10.dat`) Yankton train \
    /// 10 (`trains11.dat`) Part of metro track near mission row \
    /// 11 (`trains12.dat`) Yankton prologue mission train \
    /// Full list of all train tracks + track nodes by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/traintracks.json
    pub inline fn switchTrainTrack(track_id: c_int, state: windows.BOOL) !void { try invoker.invoke(void, 0xFD813BB7DB977F20, .{track_id, state}); } // 0xFD813BB7DB977F20 0x68BFDD61 b323
    /// Only called once inside main_persitant with the parameters p0 = 0, p1 = 120000
    /// 
    /// trackIndex: 0 - 26 \
    /// Full list of all train tracks + track nodes by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/traintracks.json
    pub inline fn setTrainTrackSpawnFrequency(track_index: c_int, frequency: c_int) !void { try invoker.invoke(void, 0x21973BBF8D17EDFA, .{track_index, frequency}); } // 0x21973BBF8D17EDFA 0xD5774FB7 b323
    pub inline fn allowTrainToBeRemovedByPopulation(p_0: types.Any) !void { try invoker.invoke(void, 0x2310A8F9421EBF43, .{p_0}); } // 0x2310A8F9421EBF43  b2372
    pub inline fn deleteAllTrains() !void { try invoker.invoke(void, 0x736A718577F39C7D, .{}); } // 0x736A718577F39C7D 0x83DE7ABF b323
    pub inline fn setTrainSpeed(train: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0xAA0BC91BE0B796E3, .{train, speed}); } // 0xAA0BC91BE0B796E3 0xDFC35E4D b323
    pub inline fn setTrainCruiseSpeed(train: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0x16469284DB8C62B5, .{train, speed}); } // 0x16469284DB8C62B5 0xB507F51D b323
    pub inline fn setRandomBoats(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x84436EC293B1415F, .{toggle}); } // 0x84436EC293B1415F 0xB505BD89 b323
    pub inline fn setRandomBoatsMp(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDA5E12F728DB30CA, .{toggle}); } // 0xDA5E12F728DB30CA  b2372
    pub inline fn setGarbageTrucks(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2AFD795EEAC8D30D, .{toggle}); } // 0x2AFD795EEAC8D30D 0xD9ABB0FF b323
    /// Maximum amount of vehicles with vehicle stuck check appears to be 16.
    pub inline fn doesVehicleHaveStuckVehicleCheck(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x57E4C39DE5EE8470, .{vehicle}); } // 0x57E4C39DE5EE8470 0x5D91D9AC b323
    /// See REQUEST_VEHICLE_RECORDING
    pub inline fn getVehicleRecordingId(recording: c_int, script: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x21543C612379DB3C, .{recording, script}); } // 0x21543C612379DB3C 0x328D601D b323
    /// Request the vehicle recording defined by the lowercase format string "%s%03d.yvr". For example, REQUEST_VEHICLE_RECORDING(1, "FBIs1UBER") corresponds to fbis1uber001.yvr. \
    /// For all vehicle recording/playback natives, "script" is a common prefix that usually corresponds to the script/mission the recording is used in, "recording" is its int suffix, and "id" (e.g., in native GET_TOTAL_DURATION_OF_VEHICLE_RECORDING_ID) corresponds to a unique identifier within the recording streaming module. \
    /// Note that only 24 recordings (hardcoded in multiple places) can ever active at a given time before clobbering begins.
    pub inline fn requestVehicleRecording(recording: c_int, script: [*c]const u8) !void { try invoker.invoke(void, 0xAF514CABE74CBF15, .{recording, script}); } // 0xAF514CABE74CBF15 0x91AFEFD9 b323
    /// See REQUEST_VEHICLE_RECORDING
    pub inline fn hasVehicleRecordingBeenLoaded(recording: c_int, script: [*c]const u8) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x300D614A4C785FC4, .{recording, script}); } // 0x300D614A4C785FC4 0xF52CD7F5 b323
    /// See REQUEST_VEHICLE_RECORDING
    pub inline fn removeVehicleRecording(recording: c_int, script: [*c]const u8) !void { try invoker.invoke(void, 0xF1160ACCF98A3FC8, .{recording, script}); } // 0xF1160ACCF98A3FC8 0xD3C05B00 b323
    pub inline fn getPositionOfVehicleRecordingIdAtTime(id: c_int, time: f32) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x92523B76657A517D, .{id, time}); } // 0x92523B76657A517D 0xF31973BB b323
    /// This native does no interpolation between pathpoints. The same position will be returned for all times up to the next pathpoint in the recording.
    /// 
    /// See REQUEST_VEHICLE_RECORDING
    pub inline fn getPositionOfVehicleRecordingAtTime(recording: c_int, time: f32, script: [*c]const u8) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xD242728AA6F0FBA2, .{recording, time, script}); } // 0xD242728AA6F0FBA2 0x7178558D b323
    pub inline fn getRotationOfVehicleRecordingIdAtTime(id: c_int, time: f32) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xF0F2103EFAF8CBA7, .{id, time}); } // 0xF0F2103EFAF8CBA7 0x4D1C15C2 b323
    /// This native does no interpolation between pathpoints. The same rotation will be returned for all times up to the next pathpoint in the recording.
    /// 
    /// See REQUEST_VEHICLE_RECORDING
    pub inline fn getRotationOfVehicleRecordingAtTime(recording: c_int, time: f32, script: [*c]const u8) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x2058206FBE79A8AD, .{recording, time, script}); } // 0x2058206FBE79A8AD 0xD96DEC68 b323
    pub inline fn getTotalDurationOfVehicleRecordingId(id: c_int) !f32 { return try invoker.invoke(f32, 0x102D125411A7B6E6, .{id}); } // 0x102D125411A7B6E6 0x7116785E b323
    /// See REQUEST_VEHICLE_RECORDING
    pub inline fn getTotalDurationOfVehicleRecording(recording: c_int, script: [*c]const u8) !f32 { return try invoker.invoke(f32, 0x0E48D1C262390950, .{recording, script}); } // 0x0E48D1C262390950 0x5B35EEB7 b323
    /// Distance traveled in the vehicles current recording.
    pub inline fn getPositionInRecording(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x2DACD605FC681475, .{vehicle}); } // 0x2DACD605FC681475 0x7DCD644C b323
    /// Can be used with GET_TOTAL_DURATION_OF_VEHICLE_RECORDING{_ID} to compute a percentage.
    pub inline fn getTimePositionInRecording(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x5746F3A7AB7FE544, .{vehicle}); } // 0x5746F3A7AB7FE544 0xF8C3E4A2 b323
    /// p3 is some flag related to 'trailers' (invokes CVehicle::GetTrailer).
    /// 
    /// See REQUEST_VEHICLE_RECORDING
    pub inline fn startPlaybackRecordedVehicle(vehicle: types.Vehicle, recording: c_int, script: [*c]const u8, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x3F878F92B3A7A071, .{vehicle, recording, script, p_3}); } // 0x3F878F92B3A7A071 0xCF614CA8 b323
    /// flags requires further research, e.g., 0x4/0x8 are related to the AI driving task and 0x20 is internally set and interacts with dynamic entity components.
    /// 
    /// time, often zero and capped at 500, is related to SET_PLAYBACK_TO_USE_AI_TRY_TO_REVERT_BACK_LATER
    pub inline fn startPlaybackRecordedVehicleWithFlags(vehicle: types.Vehicle, recording: c_int, script: [*c]const u8, flags: c_int, time: c_int, driving_style: c_int) !void { try invoker.invoke(void, 0x7D80FD645D4DA346, .{vehicle, recording, script, flags, time, driving_style}); } // 0x7D80FD645D4DA346 0x4E721AD2 b323
    /// Often called after START_PLAYBACK_RECORDED_VEHICLE and SKIP_TIME_IN_PLAYBACK_RECORDED_VEHICLE; similar in use to FORCE_ENTITY_AI_AND_ANIMATION_UPDATE.
    pub inline fn forcePlaybackRecordedVehicleUpdate(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x1F2E4E06DEA8992B, .{vehicle, p_1}); } // 0x1F2E4E06DEA8992B 0x01B91CD0 b323
    pub inline fn stopPlaybackRecordedVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x54833611C17ABDEA, .{vehicle}); } // 0x54833611C17ABDEA 0xAE99C57C b323
    pub inline fn pausePlaybackRecordedVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x632A689BF42301B1, .{vehicle}); } // 0x632A689BF42301B1 0xCCF54912 b323
    pub inline fn unpausePlaybackRecordedVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x8879EE09268305D5, .{vehicle}); } // 0x8879EE09268305D5 0x59060F75 b323
    pub inline fn isPlaybackGoingOnForVehicle(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1C8A4C2C19E68EEC, .{vehicle}); } // 0x1C8A4C2C19E68EEC 0x61F7650D b323
    pub inline fn isPlaybackUsingAiGoingOnForVehicle(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAEA8FD591FAD4106, .{vehicle}); } // 0xAEA8FD591FAD4106 0x63022C58 b323
    pub inline fn getCurrentPlaybackForVehicle(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x42BC05C27A946054, .{vehicle}); } // 0x42BC05C27A946054 0xA3F44390 b323
    pub inline fn skipToEndAndStopPlaybackRecordedVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xAB8E2EDA0C0A5883, .{vehicle}); } // 0xAB8E2EDA0C0A5883 0x8DEA18C8 b323
    pub inline fn setPlaybackSpeed(vehicle: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0x6683AB880E427778, .{vehicle, speed}); } // 0x6683AB880E427778 0x684E26E4 b323
    /// AI abides by the provided driving style (e.g., stopping at red lights or waiting behind traffic) while executing the specificed vehicle recording.
    /// 
    /// FORCE_PLAYBACK_RECORDED_VEHICLE_UPDATE is a related native that deals with the AI physics for such recordings.
    pub inline fn startPlaybackRecordedVehicleUsingAi(vehicle: types.Vehicle, recording: c_int, script: [*c]const u8, speed: f32, driving_style: c_int) !void { try invoker.invoke(void, 0x29DE5FA52D00428C, .{vehicle, recording, script, speed, driving_style}); } // 0x29DE5FA52D00428C 0x8DE8E24E b323
    /// SET_TIME_POSITION_IN_RECORDING can be emulated by: desired_time - GET_TIME_POSITION_IN_RECORDING(vehicle)
    pub inline fn skipTimeInPlaybackRecordedVehicle(vehicle: types.Vehicle, time: f32) !void { try invoker.invoke(void, 0x9438F7AD68771A20, .{vehicle, time}); } // 0x9438F7AD68771A20 0xCF3EFA4B b323
    /// Identical to SET_PLAYBACK_TO_USE_AI_TRY_TO_REVERT_BACK_LATER with 0 as arguments for p1 and p3.
    pub inline fn setPlaybackToUseAi(vehicle: types.Vehicle, driving_style: c_int) !void { try invoker.invoke(void, 0xA549C3B37EA28131, .{vehicle, driving_style}); } // 0xA549C3B37EA28131 0xB536CCD7 b323
    /// Time is number of milliseconds before reverting, zero for indefinitely.
    pub inline fn setPlaybackToUseAiTryToRevertBackLater(vehicle: types.Vehicle, time: c_int, driving_style: c_int, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x6E63860BBB190730, .{vehicle, time, driving_style, p_3}); } // 0x6E63860BBB190730 0x0C8ABAA4 b323
    pub inline fn setAdditionalRotationForRecordedVehiclePlayback(vehicle: types.Vehicle, vec: types.Vector3, p_4: types.Any) !void { try invoker.invoke(void, 0x5845066D8A1EA7F7, .{vehicle, vec.x, vec.y, vec.z, p_4}); } // 0x5845066D8A1EA7F7 0x943A58EB b323
    pub inline fn setPositionOffsetForRecordedVehiclePlayback(vehicle: types.Vehicle, vec: types.Vector3) !void { try invoker.invoke(void, 0x796A877E459B99EA, .{vehicle, vec.x, vec.y, vec.z}); } // 0x796A877E459B99EA 0x5C9F477C b323
    pub inline fn setGlobalPositionOffsetForRecordedVehiclePlayback(vehicle: types.Vehicle, vec: types.Vector3) !void { try invoker.invoke(void, 0xFAF2A78061FD9EF4, .{vehicle, vec.x, vec.y, vec.z}); } // 0xFAF2A78061FD9EF4 0xCD83C393 b323
    /// A vehicle recording playback flag only used in jewelry_heist
    pub inline fn setShouldLerpFromAiToFullRecording(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x063AE2B2CC273588, .{vehicle, p_1}); } // 0x063AE2B2CC273588 0x2EF8435C b323
    pub inline fn explodeVehicleInCutscene(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x786A4EB67B01BF0B, .{vehicle, p_1}); } // 0x786A4EB67B01BF0B 0xA85207B5 b323
    pub inline fn addVehicleStuckCheckWithWarp(p_0: types.Any, p_1: f32, p_2: types.Any, p_3: windows.BOOL, p_4: windows.BOOL, p_5: windows.BOOL, p_6: types.Any) !void { try invoker.invoke(void, 0x2FA9923062DD396C, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x2FA9923062DD396C 0xC8B789AD b323
    /// Makes the vehicle stop spawning naturally in traffic. Here's an essential example:
    /// 
    /// VEHICLE::SET_VEHICLE_MODEL_IS_SUPPRESSED(MISC::GET_HASH_KEY("taco"), true);
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn setVehicleModelIsSuppressed(model: types.Hash, suppressed: windows.BOOL) !void { try invoker.invoke(void, 0x0FC2D89AC25A5814, .{model, suppressed}); } // 0x0FC2D89AC25A5814 0x42A08C9B b323
    /// Gets a random vehicle in a sphere at the specified position, of the specified radius.
    /// 
    /// x: The X-component of the position of the sphere. \
    /// y: The Y-component of the position of the sphere. \
    /// z: The Z-component of the position of the sphere. \
    /// radius: The radius of the sphere. Max is 9999.9004. \
    /// modelHash: The vehicle model to limit the selection to. Pass 0 for any model. \
    /// flags: The bitwise flags that modifies the behaviour of this function.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getRandomVehicleInSphere(vec: types.Vector3, radius: f32, model_hash: types.Hash, flags: c_int) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x386F6CE5BAF6091C, .{vec.x, vec.y, vec.z, radius, model_hash, flags}); } // 0x386F6CE5BAF6091C 0x57216D03 b323
    pub inline fn getRandomVehicleFrontBumperInSphere(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: c_int, p_5: c_int, p_6: c_int) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0xC5574E0AEB86BA68, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0xC5574E0AEB86BA68 0xDCADEB66 b323
    pub inline fn getRandomVehicleBackBumperInSphere(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: c_int, p_5: c_int, p_6: c_int) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0xB50807EABE20A8DC, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0xB50807EABE20A8DC 0xD6343F6B b323
    /// Example usage \
    /// VEHICLE::GET_CLOSEST_VEHICLE(x, y, z, radius, hash, unknown leave at 70) 
    /// 
    /// x, y, z: Position to get closest vehicle to. \
    /// radius: Max radius to get a vehicle. \
    /// modelHash: Limit to vehicles with this model. 0 for any. \
    /// flags: The bitwise flags altering the function's behaviour.
    /// 
    /// Does not return police cars or helicopters.
    /// 
    /// It seems to return police cars for me, does not seem to return helicopters, planes or boats for some reason
    /// 
    /// Only returns non police cars and motorbikes with the flag set to 70 and modelHash to 0. ModelHash seems to always be 0 when not a modelHash in the scripts, as stated above. 
    /// 
    /// These flags were found in the b617d scripts: 0,2,4,6,7,23,127,260,2146,2175,12294,16384,16386,20503,32768,67590,67711,98309,100359. \
    /// Converted to binary, each bit probably represents a flag as explained regarding another native here: gtaforums.com/topic/822314-guide-driving-styles
    /// 
    /// Conversion of found flags to binary: https://pastebin.com/kghNFkRi
    /// 
    /// At exactly 16384 which is 0100000000000000 in binary and 4000 in hexadecimal only planes are returned. 
    /// 
    /// It's probably more convenient to use worldGetAllVehicles(int *arr, int arrSize) and check the shortest distance yourself and sort if you want by checking the vehicle type with for example VEHICLE::IS_THIS_MODEL_A_BOAT
    /// 
    /// -------------------------------------------------------------------------
    /// 
    /// Conclusion: This native is not worth trying to use. Use something like this instead: https://pastebin.com/xiFdXa7h
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getClosestVehicle(vec: types.Vector3, radius: f32, model_hash: types.Hash, flags: c_int) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0xF73EB622C4F1689B, .{vec.x, vec.y, vec.z, radius, model_hash, flags}); } // 0xF73EB622C4F1689B 0xD7E26B2C b323
    /// Corrected p1. it's basically the 'carriage/trailer number'. So if the train has 3 trailers you'd call the native once with a var or 3 times with 1, 2, 3.
    pub inline fn getTrainCarriage(train: types.Vehicle, trailer_number: c_int) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x08AAFD0814722BC3, .{train, trailer_number}); } // 0x08AAFD0814722BC3 0x2544E7A6 b323
    pub inline fn setMakeTrainScanForBlockingEntities_(train: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x559B6073DB7FFFF9, .{train, toggle}); } // 0x559B6073DB7FFFF9  b3717
    pub inline fn getMissionTrainConfigIndexByName_(name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x7DFAD92A34F09C00, .{name}); } // 0x7DFAD92A34F09C00  b3717
    pub inline fn isMissionTrain(train: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAD464F2E18836BFC, .{train}); } // 0xAD464F2E18836BFC  b2372
    pub inline fn deleteMissionTrain(train: [*c]types.Vehicle) !void { try invoker.invoke(void, 0x5B76B14AE875C795, .{train}); } // 0x5B76B14AE875C795 0x86C9497D b323
    /// p1 is always 0
    pub inline fn setMissionTrainAsNoLongerNeeded(train: [*c]types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xBBE7648349B49BE8, .{train, p_1}); } // 0xBBE7648349B49BE8 0x19808560 b323
    pub inline fn setMissionTrainCoords(train: types.Vehicle, vec: types.Vector3) !void { try invoker.invoke(void, 0x591CA673AA6AB736, .{train, vec.x, vec.y, vec.z}); } // 0x591CA673AA6AB736 0xD6D70803 b323
    pub inline fn isThisModelABoat(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x45A9187928F4B9E3, .{model}); } // 0x45A9187928F4B9E3 0x10F6085C b323
    /// Checks if model is a boat, then checks for FLAG_IS_JETSKI.
    pub inline fn isThisModelAJetski(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9537097412CF75FE, .{model}); } // 0x9537097412CF75FE  b323
    pub inline fn isThisModelAPlane(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA0948AB42D7BA0DE, .{model}); } // 0xA0948AB42D7BA0DE 0x3B3907BB b323
    pub inline fn isThisModelAHeli(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDCE4334788AF94EA, .{model}); } // 0xDCE4334788AF94EA 0x8AF7F568 b323
    /// To check if the model is an amphibious car, use IS_THIS_MODEL_AN_AMPHIBIOUS_CAR.
    pub inline fn isThisModelACar(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7F6DB52EEFC96DF8, .{model}); } // 0x7F6DB52EEFC96DF8 0x60E4C22F b323
    pub inline fn isThisModelATrain(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAB935175B22E822B, .{model}); } // 0xAB935175B22E822B 0xF87DCFFD b323
    pub inline fn isThisModelABike(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB50C0B0CEDC6CE84, .{model}); } // 0xB50C0B0CEDC6CE84 0x7E702CDD b323
    pub inline fn isThisModelABicycle(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBF94DD42F63BDED2, .{model}); } // 0xBF94DD42F63BDED2 0x328E6FF5 b323
    pub inline fn isThisModelAQuadbike(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x39DAC362EE65FA28, .{model}); } // 0x39DAC362EE65FA28 0xC1625277 b323
    pub inline fn isThisModelAnAmphibiousCar(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x633F6F44A537EBB6, .{model}); } // 0x633F6F44A537EBB6  b944
    pub inline fn isThisModelAnAmphibiousQuadbike(model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA1A9FC1C76A6730D, .{model}); } // 0xA1A9FC1C76A6730D  b1103
    /// Equivalent of SET_HELI_BLADES_SPEED(vehicleHandle, 1.0f);
    pub inline fn setHeliBladesFullSpeed(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xA178472EBB8AE60D, .{vehicle}); } // 0xA178472EBB8AE60D 0x033A9408 b323
    /// Sets the speed of the helicopter blades in percentage of the full speed.
    /// 
    /// vehicleHandle: The helicopter. \
    /// speed: The speed in percentage, 0.0f being 0% and 1.0f being 100%.
    pub inline fn setHeliBladesSpeed(vehicle: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0xFD280B4D7F3ABC4D, .{vehicle, speed}); } // 0xFD280B4D7F3ABC4D 0x5C7D4EA9 b323
    pub inline fn forceSubThrottleForTime(vehicle: types.Vehicle, p_1: f32, p_2: f32) !void { try invoker.invoke(void, 0x99CAD8E7AFDB60FA, .{vehicle, p_1, p_2}); } // 0x99CAD8E7AFDB60FA 0x1128A45B b323
    /// This has not yet been tested - it's just an assumption of what the types could be.
    pub inline fn setVehicleCanBeTargetted(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0x3750146A28097A82, .{vehicle, state}); } // 0x3750146A28097A82 0x64B70B1D b323
    pub inline fn setDontAllowPlayerToEnterVehicleIfLockedForPlayer(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xDBC631F109350B8C, .{vehicle, p_1}); } // 0xDBC631F109350B8C 0x486C1280 b323
    pub inline fn setVehicleCanBeVisiblyDamaged(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0x4C7028F78FFD3681, .{vehicle, state}); } // 0x4C7028F78FFD3681 0xC5D94017 b323
    pub inline fn setVehicleHasUnbreakableLights(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1AA8A837D2169D94, .{vehicle, toggle}); } // 0x1AA8A837D2169D94 0x009AB49E b323
    pub inline fn setVehicleRespectsLocksWhenHasDriver(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x2311DD7159F00582, .{vehicle, p_1}); } // 0x2311DD7159F00582 0x758C5E2E b323
    pub inline fn setVehicleCanEjectPassengersIfLocked(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x065D03A9D6B2C6B5, .{p_0, p_1}); } // 0x065D03A9D6B2C6B5  b463
    /// Dirt level does not become greater than 15.0
    pub inline fn getVehicleDirtLevel(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x8F17BC8BA08DA62B, .{vehicle}); } // 0x8F17BC8BA08DA62B 0xFD15C065 b323
    /// You can't use values greater than 15.0 \
    /// Also, R* does (float)(rand() % 15) to get a random dirt level when generating a vehicle.
    pub inline fn setVehicleDirtLevel(vehicle: types.Vehicle, dirt_level: f32) !void { try invoker.invoke(void, 0x79D3B596FE44EE8B, .{vehicle, dirt_level}); } // 0x79D3B596FE44EE8B 0x2B39128B b323
    /// Appears to return true if the vehicle has any damage, including cosmetically.
    pub inline fn getDoesVehicleHaveDamageDecals(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBCDC5017D3CE1E9E, .{vehicle}); } // 0xBCDC5017D3CE1E9E 0xDAC523BC b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn isVehicleDoorFullyOpen(vehicle: types.Vehicle, door_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3E933CFF7B111C22, .{vehicle, door_id}); } // 0x3E933CFF7B111C22 0xC2385B6F b323
    /// Starts or stops the engine on the specified vehicle.
    /// 
    /// vehicle: The vehicle to start or stop the engine on. \
    /// value: true to turn the vehicle on; false to turn it off. \
    /// instantly: if true, the vehicle will be set to the state immediately; otherwise, the current driver will physically turn on or off the engine. \
    /// disableAutoStart: If true, the system will prevent the engine from starting when the player got into it.
    pub inline fn setVehicleEngineOn(vehicle: types.Vehicle, value: windows.BOOL, instantly: windows.BOOL, disable_auto_start: windows.BOOL) !void { try invoker.invoke(void, 0x2497C4717C8B881E, .{vehicle, value, instantly, disable_auto_start}); } // 0x2497C4717C8B881E 0x7FBC86F1 b323
    pub inline fn setVehicleUndriveable(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8ABA6AF54B942B95, .{vehicle, toggle}); } // 0x8ABA6AF54B942B95 0x48D02A4E b323
    pub inline fn setVehicleProvidesCover(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5AFEEDD9BB2899D7, .{vehicle, toggle}); } // 0x5AFEEDD9BB2899D7 0xEFC01CA9 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn setVehicleDoorControl(vehicle: types.Vehicle, door_id: c_int, speed: c_int, angle: f32) !void { try invoker.invoke(void, 0xF2BFA0430F0A0FCB, .{vehicle, door_id, speed, angle}); } // 0xF2BFA0430F0A0FCB 0x572DD360 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn setVehicleDoorLatched(vehicle: types.Vehicle, door_id: c_int, p_2: windows.BOOL, p_3: windows.BOOL, p_4: windows.BOOL) !void { try invoker.invoke(void, 0xA5A9653A8D2CAF48, .{vehicle, door_id, p_2, p_3, p_4}); } // 0xA5A9653A8D2CAF48 0x4EB7BBFC b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn getVehicleDoorAngleRatio(vehicle: types.Vehicle, door_id: c_int) !f32 { return try invoker.invoke(f32, 0xFE3F9C29F7B32BD5, .{vehicle, door_id}); } // 0xFE3F9C29F7B32BD5 0x0E399C26 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn getPedUsingVehicleDoor(vehicle: types.Vehicle, doord: c_int) !types.Ped { return try invoker.invoke(types.Ped, 0x218297BF0CFD853B, .{vehicle, doord}); } // 0x218297BF0CFD853B 0x0630101F b323
    /// enum eDoorId \
    /// { \
    ///     VEH_EXT_DOOR_INVALID_ID = -1,
    ///     VEH_EXT_DOOR_DSIDE_F,
    ///     VEH_EXT_DOOR_DSIDE_R,
    ///     VEH_EXT_DOOR_PSIDE_F,
    ///     VEH_EXT_DOOR_PSIDE_R,
    ///     VEH_EXT_BONNET,
    ///     VEH_EXT_BOOT
    /// };
    pub inline fn setVehicleDoorShut(vehicle: types.Vehicle, door_id: c_int, close_instantly: windows.BOOL) !void { try invoker.invoke(void, 0x93D9BD300D7789E5, .{vehicle, door_id, close_instantly}); } // 0x93D9BD300D7789E5 0x142606BD b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn setVehicleDoorBroken(vehicle: types.Vehicle, door_id: c_int, delete_door: windows.BOOL) !void { try invoker.invoke(void, 0xD4D4F6A4AB575A33, .{vehicle, door_id, delete_door}); } // 0xD4D4F6A4AB575A33 0x8147FEA7 b323
    pub inline fn setVehicleCanBreak(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x59BF8C3D52C92F66, .{vehicle, toggle}); } // 0x59BF8C3D52C92F66 0x90A810D1 b323
    pub inline fn doesVehicleHaveRoof(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8AC862B0B32C5B80, .{vehicle}); } // 0x8AC862B0B32C5B80 0xDB817403 b323
    pub inline fn setVehicleRemoveAggressiveCarjackMission(p_0: types.Any) !void { try invoker.invoke(void, 0xC4B3347BD68BD609, .{p_0}); } // 0xC4B3347BD68BD609  b573
    pub inline fn setVehicleAvoidPlayerVehicleRiotVanMission(p_0: types.Any) !void { try invoker.invoke(void, 0xD3301660A57C9272, .{p_0}); } // 0xD3301660A57C9272  b757
    pub inline fn setCarjackMissionRemovalParameters(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xB9562064627FF9DB, .{p_0, p_1}); } // 0xB9562064627FF9DB  b573
    /// Returns true if MF_IS_BIG (strModelFlags 0x8) handling model flag is set.
    pub inline fn isBigVehicle(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9F243D3919F442FE, .{vehicle}); } // 0x9F243D3919F442FE 0x9CDBA8DE b323
    /// Returns the total amount of color combinations found in the vehicle's carvariations.meta entry.
    pub inline fn getNumberOfVehicleColours(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x3B963160CD65D41E, .{vehicle}); } // 0x3B963160CD65D41E 0xF2442EE2 b323
    /// Sets the selected vehicle's colors to the specified index of the color combination found in the vehicle's carvariations.meta entry.
    pub inline fn setVehicleColourCombination(vehicle: types.Vehicle, color_combination: c_int) !void { try invoker.invoke(void, 0x33E8CD3322E2FE31, .{vehicle, color_combination}); } // 0x33E8CD3322E2FE31 0xA557AEAD b323
    /// Returns the index of the color combination found in the vehicle's carvariations.meta entry.
    pub inline fn getVehicleColourCombination(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x6A842D197F845D56, .{vehicle}); } // 0x6A842D197F845D56 0x77AC1B4C b323
    /// `color`: is the paint index for the vehicle. \
    /// Paint index goes from 0 to 12. \
    /// Be aware that it only works on xenon lights. Example: https://i.imgur.com/yV3cpG9.png \
    /// Full list of all vehicle xenon lights by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleColors.json
    pub inline fn setVehicleXenonLightColorIndex(vehicle: types.Vehicle, color_index: c_int) !void { try invoker.invoke(void, 0xE41033B25D003A07, .{vehicle, color_index}); } // 0xE41033B25D003A07  b1604
    /// Returns the headlight color index from the vehicle. Value between 0, 12. \
    /// Use SET_VEHICLE_XENON_LIGHT_COLOR_INDEX to set the headlights color for the vehicle. \
    /// Must enable xenon headlights before it'll take affect.
    /// 
    /// Returns an int, value between 0-12 or 255 if no color is set.
    pub inline fn getVehicleXenonLightColorIndex(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x3DFF319A831E0CDB, .{vehicle}); } // 0x3DFF319A831E0CDB  b1604
    /// Setting this to false, makes the specified vehicle to where if you press Y your character doesn't even attempt the animation to enter the vehicle. Hence it's not considered aka ignored.
    pub inline fn setVehicleIsConsideredByPlayer(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x31B927BBC44156CD, .{vehicle, toggle}); } // 0x31B927BBC44156CD 0x14413319 b323
    pub inline fn setVehicleWillForceOtherVehiclesToStop(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBE5C1255A1830FF5, .{vehicle, toggle}); } // 0xBE5C1255A1830FF5 0xA6D8D7A5 b323
    pub inline fn setVehicleActAsIfHasSirenOn(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x9BECD4B9FEF3F8A6, .{vehicle, p_1}); } // 0x9BECD4B9FEF3F8A6 0xACAB8FF3 b323
    pub inline fn setVehicleUseMoreRestrictiveSpawnChecks(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x88BC673CA9E0AE99, .{vehicle, p_1}); } // 0x88BC673CA9E0AE99 0xF0E5C41D b323
    pub inline fn setVehicleMayBeUsedByGotoPointAnyMeans(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xE851E480B814D4BA, .{vehicle, p_1}); } // 0xE851E480B814D4BA 0x2F98B4B7 b323
    /// Not present in the retail version! It's just a nullsub.
    /// 
    /// p0 always true (except in one case) \
    /// successIndicator: 0 if success, -1 if failed
    pub inline fn getRandomVehicleModelInMemory(p_0: windows.BOOL, model_hash: [*c]types.Hash, success_indicator: [*c]c_int) !void { try invoker.invoke(void, 0x055BF0AC0C34F4FD, .{p_0, model_hash, success_indicator}); } // 0x055BF0AC0C34F4FD 0xE2C45631 b323
    /// enum VehicleLockStatus = { \
    ///     None = 0,
    ///     Unlocked = 1,
    ///     Locked = 2,
    ///     LockedForPlayer = 3,
    ///     StickPlayerInside = 4, -- Doesn't allow players to exit the vehicle with the exit vehicle key.
    ///     CanBeBrokenInto = 7, -- Can be broken into the car. If the glass is broken, the value will be set to 1
    ///     CanBeBrokenIntoPersist = 8, -- Can be broken into persist
    ///     CannotBeTriedToEnter = 10, -- Cannot be tried to enter (Nothing happens when you press the vehicle enter key).
    /// }
    pub inline fn getVehicleDoorLockStatus(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x25BC98A59C2EA962, .{vehicle}); } // 0x25BC98A59C2EA962 0x0D72CEF2 b323
    /// Returns vehicle door lock state previously set with SET_VEHICLE_INDIVIDUAL_DOORS_LOCKED
    pub inline fn getVehicleIndividualDoorLockStatus(vehicle: types.Vehicle, door_id: c_int) !c_int { return try invoker.invoke(c_int, 0xCA4AC3EAAE46EC7B, .{vehicle, door_id}); } // 0xCA4AC3EAAE46EC7B  b1103
    /// doorID starts at 0, not seeming to skip any numbers. Four door vehicles intuitively range from 0 to 3.
    pub inline fn isVehicleDoorDamaged(veh: types.Vehicle, door_i_d: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB8E181E559464527, .{veh, door_i_d}); } // 0xB8E181E559464527 0x4999E3C3 b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn setDoorAllowedToBeBrokenOff(vehicle: types.Vehicle, door_id: c_int, is_breakable: windows.BOOL) !void { try invoker.invoke(void, 0x2FA133A4A9D37ED8, .{vehicle, door_id, is_breakable}); } // 0x2FA133A4A9D37ED8 0x065B92B3 b323
    pub inline fn isVehicleBumperBouncing(vehicle: types.Vehicle, front_bumper: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x27B926779DEB502D, .{vehicle, front_bumper}); } // 0x27B926779DEB502D 0xB3A2CC4F b323
    pub inline fn isVehicleBumperBrokenOff(vehicle: types.Vehicle, front_bumper: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x468056A6BB6F3846, .{vehicle, front_bumper}); } // 0x468056A6BB6F3846 0xAF25C027 b323
    /// Usage:
    /// 
    /// public bool isCopInRange(Vector3 Location, float Range) \
    ///         {
    ///             return Function.Call<bool>(Hash.IS_COP_PED_IN_AREA_3D, Location.X - Range, Location.Y - Range, Location.Z - Range, Location.X + Range, Location.Y + Range, Location.Z + Range);
    ///         }
    pub inline fn isCopVehicleInArea3d(x_1: f32, x_2: f32, y_1: f32, y_2: f32, z_1: f32, z_2: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x7EEF65D5F153E26A, .{x_1, x_2, y_1, y_2, z_1, z_2}); } // 0x7EEF65D5F153E26A 0xFB16C6D1 b323
    ///  Public Function isVehicleOnAllWheels(vh As Vehicle) As Boolean \
    ///         Return Native.Function.Call(Of Boolean)(Hash.IS_VEHICLE_ON_ALL_WHEELS, vh)
    ///     End Function
    /// 
    pub inline fn isVehicleOnAllWheels(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB104CD1BABF302E2, .{vehicle}); } // 0xB104CD1BABF302E2 0x10089F8E b323
    /// Returns `nMonetaryValue` from handling.meta for specific model.
    pub inline fn getVehicleModelValue(vehicle_model: types.Hash) !c_int { return try invoker.invoke(c_int, 0x5873C14A52D74236, .{vehicle_model}); } // 0x5873C14A52D74236 0x58FEFC3D b463
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleLayoutHash(vehicle: types.Vehicle) !types.Hash { return try invoker.invoke(types.Hash, 0x28D37D4F71AC5C58, .{vehicle}); } // 0x28D37D4F71AC5C58 0xE0B35187 b323
    pub inline fn getInVehicleClipsetHashForSeat(vehicle: types.Vehicle, p_1: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0xA01BC64DD4BFBBAC, .{vehicle, p_1}); } // 0xA01BC64DD4BFBBAC  b323
    /// Makes the train all jumbled up and derailed as it moves on the tracks (though that wont stop it from its normal operations)
    pub inline fn setRenderTrainAsDerailed(train: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x317B11A312DF5534, .{train, toggle}); } // 0x317B11A312DF5534 0x899D9092 b323
    /// They use the same color indexs as SET_VEHICLE_COLOURS.
    pub inline fn setVehicleExtraColours(vehicle: types.Vehicle, pearlescent_color: c_int, wheel_color: c_int) !void { try invoker.invoke(void, 0x2036F561ADD12E33, .{vehicle, pearlescent_color, wheel_color}); } // 0x2036F561ADD12E33 0x515DB2A0 b323
    pub inline fn getVehicleExtraColours(vehicle: types.Vehicle, pearlescent_color: [*c]c_int, wheel_color: [*c]c_int) !void { try invoker.invoke(void, 0x3BC4245933A166F7, .{vehicle, pearlescent_color, wheel_color}); } // 0x3BC4245933A166F7 0x80E4659B b323
    pub inline fn setVehicleExtraColour5(vehicle: types.Vehicle, color: c_int) !void { try invoker.invoke(void, 0xF40DD601A65F7F19, .{vehicle, color}); } // 0xF40DD601A65F7F19  b505
    pub inline fn getVehicleExtraColour5(vehicle: types.Vehicle, color: [*c]c_int) !void { try invoker.invoke(void, 0x7D1464D472D32136, .{vehicle, color}); } // 0x7D1464D472D32136  b505
    pub inline fn setVehicleExtraColour6(vehicle: types.Vehicle, color: c_int) !void { try invoker.invoke(void, 0x6089CDF6A57F326C, .{vehicle, color}); } // 0x6089CDF6A57F326C  b505
    pub inline fn getVehicleExtraColour6(vehicle: types.Vehicle, color: [*c]c_int) !void { try invoker.invoke(void, 0xB7635E80A5C31BFF, .{vehicle, color}); } // 0xB7635E80A5C31BFF  b505
    pub inline fn stopAllGarageActivity() !void { try invoker.invoke(void, 0x0F87E938BDF29D66, .{}); } // 0x0F87E938BDF29D66 0x17A0BCE5 b323
    /// This fixes a vehicle. \
    /// If the vehicle's engine's broken then you cannot fix it with this native.
    pub inline fn setVehicleFixed(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x115722B1B9C14C1C, .{vehicle}); } // 0x115722B1B9C14C1C 0x17469AA1 b323
    /// This fixes the deformation of a vehicle but the vehicle health doesn't improve
    pub inline fn setVehicleDeformationFixed(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x953DA1E1B12C0491, .{vehicle}); } // 0x953DA1E1B12C0491 0xDD2920C8 b323
    pub inline fn setVehicleCanEngineMissfire(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x206BC5DC9D1AC70A, .{vehicle, toggle}); } // 0x206BC5DC9D1AC70A 0x8EACBD13 b323
    pub inline fn setVehicleCanLeakOil(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x51BB2D88D31A914B, .{vehicle, toggle}); } // 0x51BB2D88D31A914B 0x88F0F7E7 b323
    pub inline fn setVehicleCanLeakPetrol(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x192547247864DFDD, .{vehicle, toggle}); } // 0x192547247864DFDD 0x90D6EE57 b323
    pub inline fn setDisableVehiclePetrolTankFires(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x465BF26AB9684352, .{vehicle, toggle}); } // 0x465BF26AB9684352 0xC40192B5 b323
    pub inline fn setDisableVehiclePetrolTankDamage(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x37C8252A7C92D017, .{vehicle, toggle}); } // 0x37C8252A7C92D017 0xAD3E05F2 b323
    pub inline fn setDisableVehicleEngineFires(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x91A0BD635321F145, .{vehicle, toggle}); } // 0x91A0BD635321F145 0x1784BA1A b323
    pub inline fn setVehicleLimitSpeedWhenPlayerInactive(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC50CE861B55EAB8B, .{vehicle, toggle}); } // 0xC50CE861B55EAB8B 0x40C323AE b323
    /// sfink: sets bit in vehicle's structure, used by maintransition, fm_mission_controller, mission_race and a couple of other scripts. see dissassembly:  \
    /// CVehicle *__fastcall sub_140CDAA10(signed int a1, char a2) \
    /// { \
    ///     CVehicle *result; // rax@1
    /// 
    ///     result = EntityAsCVehicle(a1);
    ///     if ( result )
    ///     {
    ///         result->field_886 &= 0xEFu;
    ///         result->field_886 |= 16 * (a2 & 1);
    ///     }
    ///     return result;
    /// }
    pub inline fn setVehicleStopInstantlyWhenPlayerInactive(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6EBFB22D646FFC18, .{vehicle, toggle}); } // 0x6EBFB22D646FFC18 0x847F1304 b323
    pub inline fn setDisablePretendOccupants(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x25367DE49D64CF16, .{vehicle, toggle}); } // 0x25367DE49D64CF16 0xCBD98BA1 b323
    pub inline fn removeVehiclesFromGeneratorsInArea(vec_1__: types.Vector3, vec_2__: types.Vector3, p_6: types.Any) !void { try invoker.invoke(void, 0x46A1E1A299EC4BBA, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, p_6}); } // 0x46A1E1A299EC4BBA 0x42CC15E0 b323
    /// Locks the vehicle's steering to the desired angle, explained below.
    /// 
    /// Requires to be called onTick. Steering is unlocked the moment the function stops being called on the vehicle.
    /// 
    /// Steer bias: \
    /// -1.0 = full right \
    /// 0.0 = centered steering \
    /// 1.0 = full left
    pub inline fn setVehicleSteerBias(vehicle: types.Vehicle, value: f32) !void { try invoker.invoke(void, 0x42A8EC77D5150CBE, .{vehicle, value}); } // 0x42A8EC77D5150CBE 0x7357C1EB b323
    pub inline fn isVehicleExtraTurnedOn(vehicle: types.Vehicle, extra_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD2E6822DBFD6C8BD, .{vehicle, extra_id}); } // 0xD2E6822DBFD6C8BD 0x042098B5 b323
    /// Available extraIds are 1-14, however none of the vehicles have extras above 12.
    pub inline fn setVehicleExtra(vehicle: types.Vehicle, extra_id: c_int, disable: windows.BOOL) !void { try invoker.invoke(void, 0x7EE3A3C5E4A40CC9, .{vehicle, extra_id, disable}); } // 0x7EE3A3C5E4A40CC9 0x642D065C b323
    /// Checks via CVehicleModelInfo
    pub inline fn doesExtraExist(vehicle: types.Vehicle, extra_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1262D55792428154, .{vehicle, extra_id}); } // 0x1262D55792428154 0x409411CC b323
    /// Returns true if specified extra part is broken off. It only works for extras that can break off during collisions, non-breakable extras always return false. Also returns true if the breakable extra is toggled off through script.
    pub inline fn isExtraBrokenOff(vehicle: types.Vehicle, extra_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x534E36D4DB9ECC5D, .{vehicle, extra_id}); } // 0x534E36D4DB9ECC5D  b1493
    pub inline fn setConvertibleRoof(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xF39C4F538B5124C2, .{vehicle, p_1}); } // 0xF39C4F538B5124C2 0xC87B6A51 b323
    pub inline fn lowerConvertibleRoof(vehicle: types.Vehicle, instantly_lower: windows.BOOL) !void { try invoker.invoke(void, 0xDED51F703D0FA83D, .{vehicle, instantly_lower}); } // 0xDED51F703D0FA83D 0xC5F72EAE b323
    pub inline fn raiseConvertibleRoof(vehicle: types.Vehicle, instantly_raise: windows.BOOL) !void { try invoker.invoke(void, 0x8F5FB35D7E88FC70, .{vehicle, instantly_raise}); } // 0x8F5FB35D7E88FC70 0xA4E4CBA3 b323
    /// 0 -> up \
    /// 1 -> lowering down \
    /// 2 -> down \
    /// 3 -> raising up
    pub inline fn getConvertibleRoofState(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xF8C397922FC03F41, .{vehicle}); } // 0xF8C397922FC03F41 0x1B09714D b323
    /// Returns true if the vehicle has a convertible roof.
    /// 
    /// p1 is false almost always. However, in launcher_carwash/carwash1/carwash2 scripts, p1 is true and is accompanied by DOES_VEHICLE_HAVE_ROOF. If p1 is true, it seems that every single vehicle will return true irrespective of being a convertible.
    pub inline fn isVehicleAConvertible(vehicle: types.Vehicle, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x52F357A30698BCCE, .{vehicle, p_1}); } // 0x52F357A30698BCCE 0x6EF54490 b323
    /// Transforms the `stormberg`/`toreador` to its "submarine" variant. If the vehicle is already in that state then the vehicle transformation audio will still play, but the vehicle won't change at all.
    pub inline fn transformToSubmarine(vehicle: types.Vehicle, no_animation: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBE4C854FFDB6EEBE, .{vehicle, no_animation}); } // 0xBE4C854FFDB6EEBE 0xCAFE5FE0 b1365
    /// Transforms the `stormberg`/`toreador` to its "road vehicle" variant. If the vehicle is already in that state then the vehicle transformation audio will still play, but the vehicle won't change at all.
    pub inline fn transformToCar(vehicle: types.Vehicle, no_animation: windows.BOOL) !void { try invoker.invoke(void, 0x2A69FFD1B42BFF9E, .{vehicle, no_animation}); } // 0x2A69FFD1B42BFF9E 0xD8B90941 b1290
    pub inline fn isVehicleInSubmarineMode(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA77DC70BD689A1E5, .{vehicle}); } // 0xA77DC70BD689A1E5 0xE2FF06DB b1290
    pub inline fn isVehicleStoppedAtTrafficLights(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2959F696AE390A99, .{vehicle}); } // 0x2959F696AE390A99 0x69200FA4 b323
    /// Apply damage to vehicle at a location. Location is relative to vehicle model (not world).
    /// 
    /// Radius of effect damage applied in a sphere at impact location \
    /// When `focusOnModel` set to `true`, the damage sphere will travel towards the vehicle from the given point, thus guaranteeing an impact
    pub inline fn setVehicleDamage(vehicle: types.Vehicle, offset__: types.Vector3, damage: f32, radius: f32, focus_on_model: windows.BOOL) !void { try invoker.invoke(void, 0xA1DD317EA8FD4F29, .{vehicle, offset__.x, offset__.y, offset__.z, damage, radius, focus_on_model}); } // 0xA1DD317EA8FD4F29 0x21B458B2 b323
    pub inline fn setVehicleOccupantsTakeExplosiveDamage(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x35BB21DE06784373, .{vehicle, toggle}); } // 0x35BB21DE06784373  b463
    /// Returns 1000.0 if the function is unable to get the address of the specified vehicle or if it's not a vehicle.
    /// 
    /// Minimum: -4000 \
    /// Maximum: 1000
    /// 
    /// -4000: Engine is destroyed \
    /// 0 and below: Engine catches fire and health rapidly declines \
    /// 300: Engine is smoking and losing functionality \
    /// 1000: Engine is perfect
    pub inline fn getVehicleEngineHealth(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xC45D23BAF168AAB8, .{vehicle}); } // 0xC45D23BAF168AAB8 0x8880038A b323
    /// 1000 is max health \
    /// Begins leaking gas at around 650 health \
    /// Minimum: -4000 \
    /// Maximum: 1000
    /// 
    /// -4000: Engine is destroyed \
    /// 0 and below: Engine catches fire and health rapidly declines \
    /// 300: Engine is smoking and losing functionality \
    /// 1000: Engine is perfect
    pub inline fn setVehicleEngineHealth(vehicle: types.Vehicle, health: f32) !void { try invoker.invoke(void, 0x45F6D8EEF34ABEF1, .{vehicle, health}); } // 0x45F6D8EEF34ABEF1 0x1B760FB5 b323
    /// Works just like SET_VEHICLE_ENGINE_HEALTH, but only for planes.
    pub inline fn setPlaneEngineHealth(vehicle: types.Vehicle, health: f32) !void { try invoker.invoke(void, 0x2A86A0475B6A1434, .{vehicle, health}); } // 0x2A86A0475B6A1434  b1103
    /// 1000 is max health \
    /// Begins leaking gas at around 650 health \
    /// -999.90002441406 appears to be minimum health, although nothing special occurs
    pub inline fn getVehiclePetrolTankHealth(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x7D5DABE888D2D074, .{vehicle}); } // 0x7D5DABE888D2D074 0xE41595CE b323
    /// 1000 is max health \
    /// Begins leaking gas at around 650 health \
    /// -999.90002441406 appears to be minimum health, although nothing special occurs
    pub inline fn setVehiclePetrolTankHealth(vehicle: types.Vehicle, health: f32) !void { try invoker.invoke(void, 0x70DB57649FA8D0D8, .{vehicle, health}); } // 0x70DB57649FA8D0D8 0x660A3692 b323
    /// p1 can be anywhere from 0 to 3 in the scripts. \
    /// p2 being how long in milliseconds the vehicle has been stuck
    pub inline fn isVehicleStuckTimerUp(vehicle: types.Vehicle, p_1: c_int, ms: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x679BE1DAF71DA874, .{vehicle, p_1, ms}); } // 0x679BE1DAF71DA874 0x2FCF58C1 b323
    /// The inner function has a switch on the second parameter. It's the stuck timer index.
    /// 
    /// Here's some pseudo code I wrote for the inner function: \
    /// void __fastcall NATIVE_RESET_VEHICLE_STUCK_TIMER_INNER(CUnknown* unknownClassInVehicle, int timerIndex) \
    /// { \
    ///  switch (timerIndex) \
    ///    {
    ///  case 0: \
    ///        unknownClassInVehicle->FirstStuckTimer = (WORD)0u;
    ///  case 1: \
    ///        unknownClassInVehicle->SecondStuckTimer = (WORD)0u;
    ///     case 2:
    ///        unknownClassInVehicle->ThirdStuckTimer = (WORD)0u;
    ///  case 3: \
    ///        unknownClassInVehicle->FourthStuckTimer = (WORD)0u;
    ///     case 4:
    ///        unknownClassInVehicle->FirstStuckTimer = (WORD)0u;
    ///      unknownClassInVehicle->SecondStuckTimer = (WORD)0u;
    ///         unknownClassInVehicle->ThirdStuckTimer = (WORD)0u;
    ///      unknownClassInVehicle->FourthStuckTimer = (WORD)0u;
    ///         break;
    ///     };
    /// }
    pub inline fn resetVehicleStuckTimer(vehicle: types.Vehicle, null_attributes: c_int) !void { try invoker.invoke(void, 0xD7591B0065AFAA7A, .{vehicle, null_attributes}); } // 0xD7591B0065AFAA7A 0xEF2A6016 b323
    /// p1 is always 0 in the scripts.
    /// 
    /// p1 = check if vehicle is on fire
    pub inline fn isVehicleDriveable(vehicle: types.Vehicle, is_on_fire_check: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C241E39B23DF959, .{vehicle, is_on_fire_check}); } // 0x4C241E39B23DF959 0x41A7267A b323
    pub inline fn setVehicleHasBeenOwnedByPlayer(vehicle: types.Vehicle, owned: windows.BOOL) !void { try invoker.invoke(void, 0x2B5F9D2AF1F1722D, .{vehicle, owned}); } // 0x2B5F9D2AF1F1722D 0xB4D3DBFB b323
    pub inline fn setVehicleNeedsToBeHotwired(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFBA550EA44404EE6, .{vehicle, toggle}); } // 0xFBA550EA44404EE6 0xD8260751 b323
    pub inline fn setVehicleBlipThrottleRandomly(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x9F3F689B814F2599, .{vehicle, p_1}); } // 0x9F3F689B814F2599  b323
    pub inline fn setPoliceFocusWillTrackVehicle(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4E74E62E0A97E901, .{vehicle, toggle}); } // 0x4E74E62E0A97E901 0x5690F6C3 b323
    /// Sounds the horn for the specified vehicle.
    /// 
    /// vehicle: The vehicle to activate the horn for. \
    /// mode: The hash of "NORMAL" or "HELDDOWN". Can be 0. \
    /// duration: The duration to sound the horn, in milliseconds.
    /// 
    /// Note: If a player is in the vehicle, it will only sound briefly.
    pub inline fn startVehicleHorn(vehicle: types.Vehicle, duration: c_int, mode: types.Hash, forever: windows.BOOL) !void { try invoker.invoke(void, 0x9C8C6504B5B63D2C, .{vehicle, duration, mode, forever}); } // 0x9C8C6504B5B63D2C 0x0DF5ADB3 b323
    /// If set to TRUE, it seems to suppress door noises and doesn't allow the horn to be continuous.
    pub inline fn setVehicleInCarModShop(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9D44FCCE98450843, .{vehicle, toggle}); } // 0x9D44FCCE98450843 0x968E5770 b323
    /// if true, axles won't bend.
    pub inline fn setVehicleHasStrongAxles(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x92F0CF722BC4202F, .{vehicle, toggle}); } // 0x92F0CF722BC4202F 0x0D1CBC65 b323
    /// Returns model name of vehicle in all caps. Needs to be displayed through localizing text natives to get proper display name. \
    /// ----------------------------------------------------------------------------------------------------------------------------------------- \
    /// While often the case, this does not simply return the model name of the vehicle (which could be hashed to return the model hash). Variations of the same vehicle may also use the same display name. \
    /// -----------------------------------------------------------------------------------------------------------------------------------------
    /// 
    /// Returns "CARNOTFOUND" if the hash doesn't match a vehicle hash.
    /// 
    /// Using HUD::GET_FILENAME_FOR_AUDIO_CONVERSATION, you can get the localized name.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getDisplayNameFromVehicleModel(model_hash: types.Hash) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xB215AAC32D25D019, .{model_hash}); } // 0xB215AAC32D25D019 0xEC86DF39 b323
    /// Will return a vehicle's manufacturer display label. \
    /// Returns "CARNOTFOUND" if the hash doesn't match a vehicle hash.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getMakeNameFromVehicleModel(model_hash: types.Hash) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xF7AF4F159FF99F97, .{model_hash}); } // 0xF7AF4F159FF99F97  b1868
    /// The only example I can find of this function in the scripts, is this:
    /// 
    /// struct _s = VEHICLE::GET_VEHICLE_DEFORMATION_AT_POS(rPtr((A_0) + 4), 1.21f, 6.15f, 0.3f);
    /// 
    /// ----------------------------------------------------------------------------------------------------------------------------------------- \
    /// PC scripts:
    /// 
    /// v_5/*{3}*/ = VEHICLE::GET_VEHICLE_DEFORMATION_AT_POS(a_0._f1, 1.21, 6.15, 0.3);
    pub inline fn getVehicleDeformationAtPos(vehicle: types.Vehicle, offset__: types.Vector3) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x4EC6CFBC7B2E9536, .{vehicle, offset__.x, offset__.y, offset__.z}); } // 0x4EC6CFBC7B2E9536 0xABF02075 b323
    pub inline fn setVehicleLivery(vehicle: types.Vehicle, livery: c_int) !void { try invoker.invoke(void, 0x60BF608F1B8CD1B6, .{vehicle, livery}); } // 0x60BF608F1B8CD1B6 0x7AD87059 b323
    /// -1 = no livery
    pub inline fn getVehicleLivery(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x2BB9230590DA5E8A, .{vehicle}); } // 0x2BB9230590DA5E8A 0xEC82A51D b323
    /// Returns -1 if the vehicle has no livery
    pub inline fn getVehicleLiveryCount(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x87B63E25A529D526, .{vehicle}); } // 0x87B63E25A529D526 0xFB0CA947 b323
    /// Used to set the secondary livery (the roof on Tornado Custom being one such example.)
    /// 
    /// Livery value is dependent on the amount of liveries present in the vehicle's texture dictionary, for Tornado Custom this would be 0-6.
    pub inline fn setVehicleLivery2(vehicle: types.Vehicle, livery: c_int) !void { try invoker.invoke(void, 0xA6D3A8750DC73270, .{vehicle, livery}); } // 0xA6D3A8750DC73270  b505
    /// Returns index of the current vehicle's secondary livery. A getter for SET_VEHICLE_LIVERY2.
    pub inline fn getVehicleLivery2(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x60190048C0764A26, .{vehicle}); } // 0x60190048C0764A26  b505
    /// Returns a number of available secondary liveries, or -1 if vehicle has no secondary liveries available.
    pub inline fn getVehicleLivery2Count(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x5ECB40269053C0D4, .{vehicle}); } // 0x5ECB40269053C0D4  b505
    /// This will return false if the window is broken, or rolled down. \
    /// Window indexes: \
    /// 0 = Front Right Window \
    /// 1 = Front Left Window \
    /// 2 = Back Right Window \
    /// 3 = Back Left Window
    /// 
    /// 
    /// Those numbers go on for vehicles that have more than 4 doors with windows.
    pub inline fn isVehicleWindowIntact(vehicle: types.Vehicle, window_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x46E571A0E20D01F1, .{vehicle, window_index}); } // 0x46E571A0E20D01F1 0xAC4EF23D b323
    /// Appears to return false if any window is broken.
    pub inline fn areAllVehicleWindowsIntact(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x11D862A3E977A9EF, .{vehicle}); } // 0x11D862A3E977A9EF 0xBB619744 b323
    /// Returns false if every seat is occupied.
    pub inline fn areAnyVehicleSeatsFree(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2D34FC3BC4ADB780, .{vehicle}); } // 0x2D34FC3BC4ADB780 0x648E685A b323
    pub inline fn resetVehicleWheels(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x21D2E5662C1F6FED, .{vehicle, toggle}); } // 0x21D2E5662C1F6FED 0xD5FFE779 b323
    pub inline fn isHeliPartBroken(vehicle: types.Vehicle, p_1: windows.BOOL, p_2: windows.BOOL, p_3: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC74B4BE25EB6C8A, .{vehicle, p_1, p_2, p_3}); } // 0xBC74B4BE25EB6C8A 0xF4E4C439 b323
    /// Max 1000. \
    /// At 0 the main rotor will stall.
    pub inline fn getHeliMainRotorHealth(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xE4CB7541F413D2C5, .{vehicle}); } // 0xE4CB7541F413D2C5 0xF01E2AAB b323
    /// Max 1000. \
    /// At 0 the tail rotor will stall.
    pub inline fn getHeliTailRotorHealth(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xAE8CE82A4219AC8C, .{vehicle}); } // 0xAE8CE82A4219AC8C 0xA41BC13D b323
    /// Max 1000. \
    /// At -100 both helicopter rotors will stall.
    pub inline fn getHeliTailBoomHealth(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xAC51915D27E4A5F7, .{vehicle}); } // 0xAC51915D27E4A5F7 0x8A68388F b323
    pub inline fn setHeliMainRotorHealth(vehicle: types.Vehicle, health: f32) !void { try invoker.invoke(void, 0x4056EA1105F5ABD7, .{vehicle, health}); } // 0x4056EA1105F5ABD7  b463
    pub inline fn setHeliTailRotorHealth(vehicle: types.Vehicle, health: f32) !void { try invoker.invoke(void, 0xFE205F38AAA58E5B, .{vehicle, health}); } // 0xFE205F38AAA58E5B  b463
    pub inline fn setHeliTailBoomCanBreakOff(vehicle: types.Vehicle, toggle: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3EC8BF18AA453FE9, .{vehicle, toggle}); } // 0x3EC8BF18AA453FE9 0x2916D69B b323
    /// NOTE: Debugging functions are not present in the retail version of the game.
    pub inline fn setVehicleNameDebug(vehicle: types.Vehicle, name: [*c]const u8) !void { try invoker.invoke(void, 0xBFDF984E2C22B94F, .{vehicle, name}); } // 0xBFDF984E2C22B94F 0xA712FF5C b323
    /// Sets a vehicle to be strongly resistant to explosions. p0 is the vehicle; set p1 to false to toggle the effect on/off.
    pub inline fn setVehicleExplodesOnHighExplosionDamage(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x71B0892EC081D60A, .{vehicle, toggle}); } // 0x71B0892EC081D60A 0x38CC692B b323
    pub inline fn setVehicleExplodesOnExplosionDamageAtZeroBodyHealth(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xD565F438137F0E10, .{vehicle, toggle}); } // 0xD565F438137F0E10  b1103
    pub inline fn setAllowVehicleExplodesOnContact(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x3441CAD2F2231923, .{vehicle, toggle}); } // 0x3441CAD2F2231923 0xC306A9A3 b323
    pub inline fn setVehicleDisableTowing(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2B6747FAA9DB9D6B, .{vehicle, toggle}); } // 0x2B6747FAA9DB9D6B 0x95A9ACCB b323
    pub inline fn getVehicleHasLandingGear(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE43701C36CAFF1A4, .{vehicle}); } // 0xE43701C36CAFF1A4  b1180
    /// Works for vehicles with a retractable landing gear
    /// 
    /// Landing gear states:
    /// 
    /// 0: Deployed \
    /// 1: Closing \
    /// 2: Opening \
    /// 3: Retracted
    pub inline fn controlLandingGear(vehicle: types.Vehicle, state: c_int) !void { try invoker.invoke(void, 0xCFC8BE9A5E1FE575, .{vehicle, state}); } // 0xCFC8BE9A5E1FE575 0x24F873FB b323
    /// Landing gear states:
    /// 
    /// 0: Deployed \
    /// 1: Closing (Retracting) \
    /// 2: (Landing gear state 2 is never used.) \
    /// 3: Opening (Deploying) \
    /// 4: Retracted
    /// 
    /// Returns the current state of the vehicles landing gear.
    pub inline fn getLandingGearState(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x9B0F3DCA3DB0F4CD, .{vehicle}); } // 0x9B0F3DCA3DB0F4CD 0xA6F02670 b323
    pub inline fn isAnyVehicleNearPoint(vec: types.Vector3, radius: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x61E1DD6125A3EEE6, .{vec.x, vec.y, vec.z, radius}); } // 0x61E1DD6125A3EEE6 0x2867A834 b323
    pub inline fn requestVehicleHighDetailModel(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xA6E9FDCB2C76785E, .{vehicle}); } // 0xA6E9FDCB2C76785E 0x9DA21956 b323
    pub inline fn getVehicleModelNumDriveGears_(vehicle_model: types.Hash) !c_int { return try invoker.invoke(c_int, 0x61F02E4E9A7A61EA, .{vehicle_model}); } // 0x61F02E4E9A7A61EA  b3095
    pub inline fn getVehicleMaxDriveGearCount_(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x24910C3D66BA770D, .{vehicle}); } // 0x24910C3D66BA770D  b3095
    pub inline fn getIsVehicleElectric_(vehicle_model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1FCB07FE230B6639, .{vehicle_model}); } // 0x1FCB07FE230B6639  b3258
    /// Returns the vehicle's drivetrain type.
    /// 
    /// enum eVehicleDrivetrainType \
    /// { \
    ///     VehicleDrivetrainType_INVALID,
    ///     VehicleDrivetrainType_FWD,
    ///     VehicleDrivetrainType_RWD,
    ///     VehicleDrivetrainType_AWD
    /// };
    /// 
    /// _GET_VEHICLE_DE* - _GET_VEHICLE_DI*
    pub inline fn getVehicleDrivetrainType_(vehicle_model: types.Hash) !c_int { return try invoker.invoke(c_int, 0x1423725069EE1D14, .{vehicle_model}); } // 0x1423725069EE1D14  b3258
    pub inline fn getVehicleCurrentDriveGear_(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x56185A25D45A0DCD, .{vehicle}); } // 0x56185A25D45A0DCD  b3095
    pub inline fn getVehicleCurrentRevRatio_(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xF9DDA40BC293A61E, .{vehicle}); } // 0xF9DDA40BC293A61E  b3095
    pub inline fn removeVehicleHighDetailModel(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x00689CDE5F7C6787, .{vehicle}); } // 0x00689CDE5F7C6787 0x382BE070 b323
    pub inline fn isVehicleHighDetail(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1F25887F3C104278, .{vehicle}); } // 0x1F25887F3C104278 0x55D41928 b323
    /// REQUEST_VEHICLE_ASSET(GET_HASH_KEY(cargobob3), 3);
    /// 
    /// vehicle found that have asset's: \
    /// cargobob3 \
    /// submersible \
    /// blazer
    pub inline fn requestVehicleAsset(vehicle_hash: types.Hash, vehicle_asset: c_int) !void { try invoker.invoke(void, 0x81A15811460FAB3A, .{vehicle_hash, vehicle_asset}); } // 0x81A15811460FAB3A 0x902B4F06 b323
    pub inline fn hasVehicleAssetLoaded(vehicle_asset: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1BBE0523B8DB9A21, .{vehicle_asset}); } // 0x1BBE0523B8DB9A21 0x8DAAC3CB b323
    pub inline fn removeVehicleAsset(vehicle_asset: c_int) !void { try invoker.invoke(void, 0xACE699C71AB9DEB5, .{vehicle_asset}); } // 0xACE699C71AB9DEB5 0x9620E9C6 b323
    /// Sets how much the crane on the tow truck is raised, where 0.0 is fully lowered and 1.0 is fully raised.
    pub inline fn setVehicleTowTruckArmPosition(vehicle: types.Vehicle, position: f32) !void { try invoker.invoke(void, 0xFE54B92A344583CA, .{vehicle, position}); } // 0xFE54B92A344583CA 0x88236E22 b323
    pub inline fn setAttachedVehicleToTowTruckArm_(tow_truck: types.Vehicle, vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x48BD57D0DD17786A, .{tow_truck, vehicle}); } // 0x48BD57D0DD17786A  b3095
    /// HookOffset defines where the hook is attached. leave at 0 for default attachment.
    pub inline fn attachVehicleToTowTruck(tow_truck: types.Vehicle, vehicle: types.Vehicle, rear: windows.BOOL, hookoffset__: types.Vector3) !void { try invoker.invoke(void, 0x29A16F8D621C4508, .{tow_truck, vehicle, rear, hookoffset__.x, hookoffset__.y, hookoffset__.z}); } // 0x29A16F8D621C4508 0x8151571A b323
    /// First two parameters swapped. Scripts verify that towTruck is the first parameter, not the second.
    pub inline fn detachVehicleFromTowTruck(tow_truck: types.Vehicle, vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xC2DB6B6708350ED8, .{tow_truck, vehicle}); } // 0xC2DB6B6708350ED8 0xC666CF33 b323
    pub inline fn detachVehicleFromAnyTowTruck(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD0E9CE05A1E68CD8, .{vehicle}); } // 0xD0E9CE05A1E68CD8 0x3BF93651 b323
    /// Scripts verify that towTruck is the first parameter, not the second.
    pub inline fn isVehicleAttachedToTowTruck(tow_truck: types.Vehicle, vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x146DF9EC4C4B9FD4, .{tow_truck, vehicle}); } // 0x146DF9EC4C4B9FD4 0x9699CFDC b323
    pub inline fn getEntityAttachedToTowTruck(tow_truck: types.Vehicle) !types.Entity { return try invoker.invoke(types.Entity, 0xEFEA18DCF10F8F75, .{tow_truck}); } // 0xEFEA18DCF10F8F75 0x11EC7844 b323
    pub inline fn setVehicleAutomaticallyAttaches(vehicle: types.Vehicle, p_1: windows.BOOL, p_2: types.Any) !types.Entity { return try invoker.invoke(types.Entity, 0x8BA6F76BC53A1493, .{vehicle, p_1, p_2}); } // 0x8BA6F76BC53A1493 0x4273A8D3 b323
    /// Sets the arm position of a bulldozer. Position must be a value between 0.0 and 1.0. Ignored when `p2` is set to false, instead incrementing arm position by 0.1 (or 10%).
    pub inline fn setVehicleBulldozerArmPosition(vehicle: types.Vehicle, position: f32, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xF8EBCCC96ADB9FB7, .{vehicle, position, p_2}); } // 0xF8EBCCC96ADB9FB7 0xED23C8A3 b323
    pub inline fn setVehicleTankTurretPosition(vehicle: types.Vehicle, position: f32, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x56B94C6D7127DFBA, .{vehicle, position, p_2}); } // 0x56B94C6D7127DFBA 0xB1A52EF7 b323
    pub inline fn setVehicleTurretTarget(vehicle: types.Vehicle, p_1: windows.BOOL, vec: types.Vector3, p_5: windows.BOOL) !void { try invoker.invoke(void, 0x0581730AB9380412, .{vehicle, p_1, vec.x, vec.y, vec.z, p_5}); } // 0x0581730AB9380412  b1103
    pub inline fn setVehicleTankStationary(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x737E398138550FFF, .{vehicle, p_1}); } // 0x737E398138550FFF  b944
    pub inline fn setVehicleTurretSpeedThisFrame(vehicle: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0x1093408B4B9D1146, .{vehicle, speed}); } // 0x1093408B4B9D1146 0xF30C566F b323
    pub inline fn disableVehicleTurretMovementThisFrame(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x32CAEDF24A583345, .{vehicle}); } // 0x32CAEDF24A583345  b463
    pub inline fn setVehicleFlightNozzlePosition(vehicle: types.Vehicle, angle_ratio: f32) !void { try invoker.invoke(void, 0x30D779DE7C4F6DD3, .{vehicle, angle_ratio}); } // 0x30D779DE7C4F6DD3 0xA7DF64D7 b323
    pub inline fn setVehicleFlightNozzlePositionImmediate(vehicle: types.Vehicle, angle: f32) !void { try invoker.invoke(void, 0x9AA47FFF660CB932, .{vehicle, angle}); } // 0x9AA47FFF660CB932 0xDD7936F5 b323
    pub inline fn getVehicleFlightNozzlePosition(plane: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xDA62027C8BDB326E, .{plane}); } // 0xDA62027C8BDB326E 0xAD40AD55 b1180
    /// True stops vtols from switching modes. Doesn't stop the sound though.
    pub inline fn setDisableVerticalFlightModeTransition(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCE2B43770B655F8F, .{vehicle, toggle}); } // 0xCE2B43770B655F8F  b1290
    pub inline fn generateVehicleCreationPosFromPaths(out_vec: [*c]types.Vector3, p_1: types.Any, out_vec_1: [*c]types.Vector3, p_3: types.Any, p_4: types.Any, p_5: types.Any, p_6: types.Any, p_7: types.Any, p_8: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA4822F1CF23F4810, .{out_vec, p_1, out_vec_1, p_3, p_4, p_5, p_6, p_7, p_8}); } // 0xA4822F1CF23F4810 0x34E02FCD b323
    /// On accelerating, spins the driven wheels with the others braked, so you don't go anywhere.
    pub inline fn setVehicleBurnout(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xFB8794444A7D60FB, .{vehicle, toggle}); } // 0xFB8794444A7D60FB 0x9B6EF0EA b323
    /// Returns whether the specified vehicle is currently in a burnout.
    /// 
    /// 
    /// vb.net \
    /// Public Function isVehicleInBurnout(vh As Vehicle) As Boolean \
    ///         Return Native.Function.Call(Of Boolean)(Hash.IS_VEHICLE_IN_BURNOUT, vh)
    ///     End Function
    pub inline fn isVehicleInBurnout(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1297A88E081430EB, .{vehicle}); } // 0x1297A88E081430EB 0x6632BC12 b323
    /// Reduces grip significantly so it's hard to go anywhere.
    pub inline fn setVehicleReduceGrip(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x222FF6A823D122E2, .{vehicle, toggle}); } // 0x222FF6A823D122E2 0x90D3A0D9 b323
    /// val is 0-3 \
    /// Often used in conjunction with: SET_VEHICLE_REDUCE_GRIP
    pub inline fn setVehicleReduceGripLevel(vehicle: types.Vehicle, val: c_int) !void { try invoker.invoke(void, 0x6DEE944E1EE90CFB, .{vehicle, val}); } // 0x6DEE944E1EE90CFB  b1604
    /// Sets the turn signal enabled for a vehicle. \
    /// Set turnSignal to 1 for left light, 0 for right light.
    pub inline fn setVehicleIndicatorLights(vehicle: types.Vehicle, turn_signal: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB5D45264751B7DF0, .{vehicle, turn_signal, toggle}); } // 0xB5D45264751B7DF0 0xA6073B5D b323
    pub inline fn setVehicleBrakeLights(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x92B35082E0B42F66, .{vehicle, toggle}); } // 0x92B35082E0B42F66 0x6D9BA11E b323
    pub inline fn setVehicleTailLights(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5815BD2763178DF4, .{vehicle, toggle}); } // 0x5815BD2763178DF4  b2802
    pub inline fn setVehicleHandbrake(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x684785568EF26A22, .{vehicle, toggle}); } // 0x684785568EF26A22 0xBA729A25 b323
    pub inline fn setVehicleBrake(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE4E2FD323574965C, .{vehicle, toggle}); } // 0xE4E2FD323574965C 0x5A36BC37 b757
    pub inline fn instantlyFillVehiclePopulation() !void { try invoker.invoke(void, 0x48ADC8A773564670, .{}); } // 0x48ADC8A773564670 0x37BC6ACB b323
    pub inline fn hasInstantFillVehiclePopulationFinished() !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x91D6DD290888CBAB, .{}); } // 0x91D6DD290888CBAB 0x71D898EF b323
    pub inline fn networkEnableEmptyCrowdingVehiclesRemoval(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x51DB102F4A3BA5E0, .{toggle}); } // 0x51DB102F4A3BA5E0 0x0B0523B0 b323
    /// Default:1000||This sets a value which is used when NETWORK_ENABLE_EMPTY_CROWDING_VEHICLES_REMOVAL(true) is called each frame.
    pub inline fn networkCapEmptyCrowdingVehiclesRemoval(p_0: c_int) !void { try invoker.invoke(void, 0xA4A9A4C40E615885, .{p_0}); } // 0xA4A9A4C40E615885  b1604
    /// Gets the trailer of a vehicle and puts it into the trailer parameter.
    pub inline fn getVehicleTrailerVehicle(vehicle: types.Vehicle, trailer: [*c]types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1CDD6BADC297830D, .{vehicle, trailer}); } // 0x1CDD6BADC297830D 0xAE84D758 b323
    pub inline fn getVehicleTrailerParentVehicle_(trailer: types.Vehicle) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x80D9D32636369C92, .{trailer}); } // 0x80D9D32636369C92  b2802
    /// vehicle must be a plane
    pub inline fn setVehicleUsesLargeRearRamp(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xCAC66558B944DA67, .{vehicle, toggle}); } // 0xCAC66558B944DA67 0x0B200CE2 b323
    pub inline fn setVehicleRudderBroken(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x09606148B6C71DEF, .{vehicle, toggle}); } // 0x09606148B6C71DEF 0x3FAC3CD4 b323
    pub inline fn setVehicleTailBroken(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6CB5B84B78AC55FE, .{vehicle, toggle}); } // 0x6CB5B84B78AC55FE  b3717
    pub inline fn setConvertibleRoofLatchState(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0x1A78AD3D8240536F, .{vehicle, state}); } // 0x1A78AD3D8240536F 0x0858678C b323
    pub inline fn getVehicleEstimatedMaxSpeed(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x53AF99BAA671CA47, .{vehicle}); } // 0x53AF99BAA671CA47 0x7D1A0616 b323
    pub inline fn getVehicleMaxBraking(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xAD7E85FC227197C4, .{vehicle}); } // 0xAD7E85FC227197C4 0x03B926F6 b323
    pub inline fn getVehicleMaxTraction(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xA132FB5370554DB0, .{vehicle}); } // 0xA132FB5370554DB0 0x7E5A1587 b323
    /// static - max acceleration
    pub inline fn getVehicleAcceleration(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x5DD35C8D074E57AE, .{vehicle}); } // 0x5DD35C8D074E57AE 0x00478321 b323
    /// Returns max speed (without mods) of the specified vehicle model in m/s.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleModelEstimatedMaxSpeed(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0xF417C2502FFFED43, .{model_hash}); } // 0xF417C2502FFFED43 0x8F291C4A b323
    /// Returns max braking of the specified vehicle model.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleModelMaxBraking(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0xDC53FD41B4ED944C, .{model_hash}); } // 0xDC53FD41B4ED944C 0x7EF02883 b323
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleModelMaxBrakingMaxMods(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0xBFBA3BA79CFF7EBF, .{model_hash}); } // 0xBFBA3BA79CFF7EBF 0xF3A7293F b323
    /// Returns max traction of the specified vehicle model.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleModelMaxTraction(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x539DE94D44FDFD0D, .{model_hash}); } // 0x539DE94D44FDFD0D 0x7F985597 b323
    /// Returns the acceleration of the specified model.
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleModelAcceleration(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x8C044C5C84505B6A, .{model_hash}); } // 0x8C044C5C84505B6A 0x29CB3537 b323
    /// 9.8 * thrust if air vehicle, else 0.38 + drive force?
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleModelAccelerationMaxMods(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x53409B5163D5B846, .{model_hash}); } // 0x53409B5163D5B846 0x37FBA7BC b323
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getFlyingVehicleModelAgility(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0xC6AD107DDC9054CC, .{model_hash}); } // 0xC6AD107DDC9054CC 0x95BB67EB b323
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getBoatVehicleModelAgility(model_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x5AA3F878A178C4FC, .{model_hash}); } // 0x5AA3F878A178C4FC 0x87C5D271 b323
    pub inline fn getVehicleClassEstimatedMaxSpeed(vehicle_class: c_int) !f32 { return try invoker.invoke(f32, 0x00C09F246ABEDD82, .{vehicle_class}); } // 0x00C09F246ABEDD82 0xCE67162C b323
    pub inline fn getVehicleClassMaxTraction(vehicle_class: c_int) !f32 { return try invoker.invoke(f32, 0xDBC86D85C5059461, .{vehicle_class}); } // 0xDBC86D85C5059461 0x5B4FDC16 b323
    pub inline fn getVehicleClassMaxAgility(vehicle_class: c_int) !f32 { return try invoker.invoke(f32, 0x4F930AD022D6DE3B, .{vehicle_class}); } // 0x4F930AD022D6DE3B 0x45F2BD83 b323
    pub inline fn getVehicleClassMaxAcceleration(vehicle_class: c_int) !f32 { return try invoker.invoke(f32, 0x2F83E7E45D9EA7AE, .{vehicle_class}); } // 0x2F83E7E45D9EA7AE 0x3E220A9B b323
    pub inline fn getVehicleClassMaxBraking(vehicle_class: c_int) !f32 { return try invoker.invoke(f32, 0x4BF54C16EC8FEC03, .{vehicle_class}); } // 0x4BF54C16EC8FEC03 0xD08CC1A5 b323
    pub inline fn addRoadNodeSpeedZone(vec: types.Vector3, radius: f32, speed: f32, p_5: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0x2CE544C68FB812A0, .{vec.x, vec.y, vec.z, radius, speed, p_5}); } // 0x2CE544C68FB812A0 0xD6685803 b323
    pub inline fn removeRoadNodeSpeedZone(speedzone: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1033371FC8E842A7, .{speedzone}); } // 0x1033371FC8E842A7 0x0C0332A6 b323
    pub inline fn openBombBayDoors(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x87E7F24270732CB1, .{vehicle}); } // 0x87E7F24270732CB1 0x6574041D b323
    pub inline fn closeBombBayDoors(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x3556041742A0DC74, .{vehicle}); } // 0x3556041742A0DC74 0xF8EC5751 b323
    /// Returns true when the bomb bay doors of this plane are open. False if they're closed.
    pub inline fn getAreBombBayDoorsOpen(aircraft: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD0917A423314BBA8, .{aircraft}); } // 0xD0917A423314BBA8  b1180
    /// Possibly: Returns whether the searchlight (found on police vehicles) is toggled on.
    /// 
    /// @Author Nac
    pub inline fn isVehicleSearchlightOn(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC0F97FCE55094987, .{vehicle}); } // 0xC0F97FCE55094987 0xADAF3513 b323
    /// Only works during nighttime.
    pub inline fn setVehicleSearchlight(heli: types.Vehicle, toggle: windows.BOOL, can_be_used_by_a_i: windows.BOOL) !void { try invoker.invoke(void, 0x14E85C5EE7A4D542, .{heli, toggle, can_be_used_by_a_i}); } // 0x14E85C5EE7A4D542 0xE2C0DD8A b323
    pub inline fn doesVehicleHaveSearchlight(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x99015ED7DBEA5113, .{vehicle}); } // 0x99015ED7DBEA5113  b2189
    /// Check if a vehicle seat is accessible. If you park your vehicle near a wall and the ped cannot enter/exit this side, the return value toggles from true (not blocked) to false (blocked).
    /// 
    /// seatIndex  = -1 being the driver seat. \
    /// Use GET_VEHICLE_MAX_NUMBER_OF_PASSENGERS(vehicle) - 1 for last seat index. \
    /// side = only relevant for bikes/motorcycles to check if the left (false)/right (true) side is blocked. \
    /// onEnter = check if you can enter (true) or exit (false) a vehicle.
    pub inline fn isEntryPointForSeatClear(ped: types.Ped, vehicle: types.Vehicle, seat_index: c_int, side: windows.BOOL, on_enter: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x639431E895B9AA57, .{ped, vehicle, seat_index, side, on_enter}); } // 0x639431E895B9AA57 0xAB0E79EB b323
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn getEntryPointPosition(vehicle: types.Vehicle, door_id: c_int) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xC0572928C0ABFDA3, .{vehicle, door_id}); } // 0xC0572928C0ABFDA3  b944
    pub inline fn canShuffleSeat(vehicle: types.Vehicle, seat_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x30785D90C956BF35, .{vehicle, seat_index}); } // 0x30785D90C956BF35 0xB3EB01ED b323
    pub inline fn getNumModKits(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x33F2E3FE70EAAE1D, .{vehicle}); } // 0x33F2E3FE70EAAE1D 0xE4903AA0 b323
    /// Set modKit to 0 if you plan to call SET_VEHICLE_MOD. That's what the game does. Most body modifications through SET_VEHICLE_MOD will not take effect until this is set to 0.
    /// 
    /// Full list of vehicle mod kits and mods by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleModKits.json
    pub inline fn setVehicleModKit(vehicle: types.Vehicle, mod_kit: c_int) !void { try invoker.invoke(void, 0x1F2AA07F00B3217A, .{vehicle, mod_kit}); } // 0x1F2AA07F00B3217A 0xB8132158 b323
    pub inline fn getVehicleModKit(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x6325D1A044AE510D, .{vehicle}); } // 0x6325D1A044AE510D 0x9FE60927 b323
    pub inline fn getVehicleModKitType(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xFC058F5121E54C32, .{vehicle}); } // 0xFC058F5121E54C32 0xE5F76765 b323
    /// Returns an int
    /// 
    /// Wheel Types: \
    /// 0: Sport \
    /// 1: Muscle \
    /// 2: Lowrider \
    /// 3: SUV \
    /// 4: Offroad \
    /// 5: Tuner \
    /// 6: Bike Wheels \
    /// 7: High End \
    /// 8: Benny's Originals \
    /// 9: Benny's Bespoke \
    /// 10: Racing \
    /// 11: Street \
    /// 12: Track
    /// 
    /// Tested in Los Santos Customs
    pub inline fn getVehicleWheelType(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xB3ED1BFB4BE636DC, .{vehicle}); } // 0xB3ED1BFB4BE636DC 0xDA58D7AE b323
    /// 0: Sport \
    /// 1: Muscle \
    /// 2: Lowrider \
    /// 3: SUV \
    /// 4: Offroad \
    /// 5: Tuner \
    /// 6: Bike Wheels \
    /// 7: High End \
    /// 8: Benny's Originals \
    /// 9: Benny's Bespoke \
    /// 10: Racing \
    /// 11: Street \
    /// 12: Track
    pub inline fn setVehicleWheelType(vehicle: types.Vehicle, _wheel_type: c_int) !void { try invoker.invoke(void, 0x487EB21CC7295BA1, .{vehicle, _wheel_type}); } // 0x487EB21CC7295BA1 0x64BDAAAD b323
    /// paintType: \
    /// 0: Normal \
    /// 1: Metallic \
    /// 2: Pearl \
    /// 3: Matte \
    /// 4: Metal \
    /// 5: Chrome \
    /// 6: Chameleon
    pub inline fn getNumModColors(paint_type: c_int, p_1: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xA551BE18C11A476D, .{paint_type, p_1}); } // 0xA551BE18C11A476D 0x73722CD9 b323
    /// paintType: \
    /// 0: Normal \
    /// 1: Metallic \
    /// 2: Pearl \
    /// 3: Matte \
    /// 4: Metal \
    /// 5: Chrome \
    /// 6: Chameleon
    /// 
    /// color: number of the color.
    /// 
    /// p3 seems to always be 0.
    /// 
    /// Full list of vehicle colors and vehicle plates by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleColors.json
    pub inline fn setVehicleModColor1(vehicle: types.Vehicle, paint_type: c_int, color: c_int, pearlescent_color: c_int) !void { try invoker.invoke(void, 0x43FEB945EE7F85B8, .{vehicle, paint_type, color, pearlescent_color}); } // 0x43FEB945EE7F85B8 0xCBE9A54D b323
    /// Changes the secondary paint type and color \
    /// paintType: \
    /// 0: Normal \
    /// 1: Metallic \
    /// 2: Pearl \
    /// 3: Matte \
    /// 4: Metal \
    /// 5: Chrome \
    /// 6: Chameleon
    /// 
    /// color: number of the color
    /// 
    /// Full list of vehicle colors and vehicle plates by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleColors.json
    pub inline fn setVehicleModColor2(vehicle: types.Vehicle, paint_type: c_int, color: c_int) !void { try invoker.invoke(void, 0x816562BADFDEC83E, .{vehicle, paint_type, color}); } // 0x816562BADFDEC83E 0xC32613C2 b323
    pub inline fn getVehicleModColor1(vehicle: types.Vehicle, paint_type: [*c]c_int, color: [*c]c_int, pearlescent_color: [*c]c_int) !void { try invoker.invoke(void, 0xE8D65CA700C9A693, .{vehicle, paint_type, color, pearlescent_color}); } // 0xE8D65CA700C9A693 0xE625510A b323
    pub inline fn getVehicleModColor2(vehicle: types.Vehicle, paint_type: [*c]c_int, color: [*c]c_int) !void { try invoker.invoke(void, 0x81592BE4E3878728, .{vehicle, paint_type, color}); } // 0x81592BE4E3878728 0x9B76BB8E b323
    /// Returns a string which is the codename of the vehicle's currently selected primary color
    /// 
    /// p1 is always 0
    pub inline fn getVehicleModColor1Name(vehicle: types.Vehicle, p_1: windows.BOOL) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xB45085B721EFD38C, .{vehicle, p_1}); } // 0xB45085B721EFD38C 0x9A0840FD b323
    /// Returns a string which is the codename of the vehicle's currently selected secondary color
    pub inline fn getVehicleModColor2Name(vehicle: types.Vehicle) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x4967A516ED23A5A1, .{vehicle}); } // 0x4967A516ED23A5A1 0x9BDC0B49 b323
    pub inline fn haveVehicleModsStreamedIn(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9A83F5F9963775EF, .{vehicle}); } // 0x9A83F5F9963775EF 0x112D637A b323
    /// Returns true for any mod part listed in GEN9_EXCLUSIVE_ASSETS_VEHICLES_FILE.
    pub inline fn isVehicleModGen9Exclusive(vehicle: types.Vehicle, mod_type: c_int, mod_index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x00834EAC4A96E010, .{vehicle, mod_type, mod_index}); } // 0x00834EAC4A96E010  b2699
    /// In b944, there are 50 (0 - 49) mod types.
    /// 
    /// Sets the vehicle mod. \
    /// The vehicle must have a mod kit first.
    /// 
    /// Any out of range ModIndex is stock.
    /// 
    /// #Mod Type \
    /// Spoilers - 0 \
    /// Front Bumper - 1 \
    /// Rear Bumper - 2 \
    /// Side Skirt - 3 \
    /// Exhaust - 4 \
    /// Frame - 5 \
    /// Grille - 6 \
    /// Hood - 7 \
    /// Fender - 8 \
    /// Right Fender - 9 \
    /// Roof - 10 \
    /// Engine - 11 \
    /// Brakes - 12 \
    /// Transmission - 13 \
    /// Horns - 14 (modIndex from 0 to 51) \
    /// Suspension - 15 \
    /// Armor - 16 \
    /// Front Wheels - 23 \
    /// Back Wheels - 24 //only for motocycles \
    /// Plate holders - 25 \
    /// Trim Design - 27 \
    /// Ornaments - 28 \
    /// Dial Design - 30 \
    /// Steering Wheel - 33 \
    /// Shifter Leavers - 34 \
    /// Plaques - 35 \
    /// Hydraulics - 38 \
    /// Livery - 48
    /// 
    /// ENUMS: https://pastebin.com/QzEAn02v
    pub inline fn setVehicleMod(vehicle: types.Vehicle, mod_type: c_int, mod_index: c_int, custom_tires: windows.BOOL) !void { try invoker.invoke(void, 0x6AF0636DDEDCB6DD, .{vehicle, mod_type, mod_index, custom_tires}); } // 0x6AF0636DDEDCB6DD 0xB52E5ED5 b323
    /// In b944, there are 50 (0 - 49) mod types. See SET_VEHICLE_MOD for the list.
    /// 
    /// Returns -1 if the vehicle mod is stock
    pub inline fn getVehicleMod(vehicle: types.Vehicle, mod_type: c_int) !c_int { return try invoker.invoke(c_int, 0x772960298DA26FDB, .{vehicle, mod_type}); } // 0x772960298DA26FDB 0xDC520069 b323
    /// Only used for wheels(ModType = 23/24) Returns true if the wheels are custom wheels
    pub inline fn getVehicleModVariation(vehicle: types.Vehicle, mod_type: c_int) !c_int { return try invoker.invoke(c_int, 0xB3924ECD70E095DC, .{vehicle, mod_type}); } // 0xB3924ECD70E095DC 0xC1B92003 b323
    /// Returns how many possible mods a vehicle has for a given mod type
    pub inline fn getNumVehicleMods(vehicle: types.Vehicle, mod_type: c_int) !c_int { return try invoker.invoke(c_int, 0xE38E9162A2500646, .{vehicle, mod_type}); } // 0xE38E9162A2500646 0x8A814FF9 b323
    pub inline fn removeVehicleMod(vehicle: types.Vehicle, mod_type: c_int) !void { try invoker.invoke(void, 0x92D619E420858204, .{vehicle, mod_type}); } // 0x92D619E420858204 0x9CC80A43 b323
    /// Toggles: \
    /// UNK17 - 17 \
    /// Turbo - 18 \
    /// UNK19 - 19 \
    /// Tire Smoke - 20 \
    /// UNK21 - 21 \
    /// Xenon Headlights - 22
    pub inline fn toggleVehicleMod(vehicle: types.Vehicle, mod_type: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2A1F4F37F95BAD08, .{vehicle, mod_type, toggle}); } // 0x2A1F4F37F95BAD08 0xD095F811 b323
    pub inline fn isToggleModOn(vehicle: types.Vehicle, mod_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x84B233A8C8FC8AE7, .{vehicle, mod_type}); } // 0x84B233A8C8FC8AE7 0xF0E1689F b323
    /// Returns the text label of a mod type for a given vehicle
    /// 
    /// Use GET_FILENAME_FOR_AUDIO_CONVERSATION to get the part name in the game's language
    pub inline fn getModTextLabel(vehicle: types.Vehicle, mod_type: c_int, mod_value: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x8935624F8C5592CC, .{vehicle, mod_type, mod_value}); } // 0x8935624F8C5592CC 0x0BA39CA7 b323
    /// Returns the name for the type of vehicle mod(Armour, engine etc)
    /// 
    pub inline fn getModSlotName(vehicle: types.Vehicle, mod_type: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0x51F0FEB9F6AE98C0, .{vehicle, mod_type}); } // 0x51F0FEB9F6AE98C0 0x5E113483 b323
    /// Returns the text label of the vehicle's liveryIndex, as specified by the liveryNames section of the vehicle's modkit data in the carcols file.
    /// 
    /// example 
    /// 
    /// int count = VEHICLE::GET_VEHICLE_LIVERY_COUNT(veh); \
    /// for (int i = 0; i < count; i++)   \
    ///   {
    ///      const char* LiveryName = VEHICLE::GET_LIVERY_NAME(veh, i);
    ///   }
    /// 
    /// 
    /// this example will work fine to fetch all names  \
    /// for example for Sanchez we get 
    /// 
    /// SANC_LV1 \
    /// SANC_LV2 \
    /// SANC_LV3 \
    /// SANC_LV4 \
    /// SANC_LV5
    /// 
    /// 
    /// Use GET_FILENAME_FOR_AUDIO_CONVERSATION, to get the localized livery name.
    /// 
    /// Full list of vehicle mod kits and mods by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleModKits.json
    pub inline fn getLiveryName(vehicle: types.Vehicle, livery_index: c_int) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xB4C7A93837C91A1F, .{vehicle, livery_index}); } // 0xB4C7A93837C91A1F 0xED80B5BE b323
    pub inline fn getVehicleModModifierValue(vehicle: types.Vehicle, mod_type: c_int, mod_index: c_int) !c_int { return try invoker.invoke(c_int, 0x90A38E9838E0A8C1, .{vehicle, mod_type, mod_index}); } // 0x90A38E9838E0A8C1 0x73AE5505 b323
    /// Can be used for IS_DLC_VEHICLE_MOD and GET_DLC_VEHICLE_MOD_LOCK_HASH
    pub inline fn getVehicleModIdentifierHash(vehicle: types.Vehicle, mod_type: c_int, mod_index: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0x4593CF82AA179706, .{vehicle, mod_type, mod_index}); } // 0x4593CF82AA179706 0x94850968 b323
    pub inline fn preloadVehicleMod(vehicle: types.Vehicle, mod_type: c_int, mod_index: c_int) !void { try invoker.invoke(void, 0x758F49C24925568A, .{vehicle, mod_type, mod_index}); } // 0x758F49C24925568A 0x6EA5F4A8 b323
    pub inline fn hasPreloadModsFinished(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x06F43E5175EB6D96, .{vehicle}); } // 0x06F43E5175EB6D96 0xA8A0D246 b323
    pub inline fn releasePreloadMods(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x445D79F995508307, .{vehicle}); } // 0x445D79F995508307 0xD442521F b323
    /// Sets the tire smoke's color of this vehicle.
    /// 
    /// vehicle: The vehicle that is the target of this method. \
    /// r: The red level in the RGB color code. \
    /// g: The green level in the RGB color code. \
    /// b: The blue level in the RGB color code.
    /// 
    /// Note: setting r,g,b to 0 will give the car the "Patriot" tire smoke.
    pub inline fn setVehicleTyreSmokeColor(vehicle: types.Vehicle, r: c_int, g: c_int, b: c_int) !void { try invoker.invoke(void, 0xB5BA80F839791C0F, .{vehicle, r, g, b}); } // 0xB5BA80F839791C0F 0x3EDEC0DB b323
    pub inline fn getVehicleTyreSmokeColor(vehicle: types.Vehicle, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !void { try invoker.invoke(void, 0xB635392A4938B3C3, .{vehicle, r, g, b}); } // 0xB635392A4938B3C3 0x75280015 b323
    /// enum WindowTints \
    /// { \
    ///  WINDOWTINT_NONE, \
    ///   WINDOWTINT_PURE_BLACK,
    ///     WINDOWTINT_DARKSMOKE,
    ///  WINDOWTINT_LIGHTSMOKE, \
    ///     WINDOWTINT_STOCK,
    ///  WINDOWTINT_LIMO, \
    ///   WINDOWTINT_GREEN
    /// }; \
    /// Full list of all vehicle window tints by DurtyFree https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicleColors.json
    pub inline fn setVehicleWindowTint(vehicle: types.Vehicle, tint: c_int) !void { try invoker.invoke(void, 0x57C51E6BAD752696, .{vehicle, tint}); } // 0x57C51E6BAD752696 0x497C8787 b323
    pub inline fn getVehicleWindowTint(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x0EE21293DAD47C95, .{vehicle}); } // 0x0EE21293DAD47C95 0x13D53892 b323
    pub inline fn getNumVehicleWindowTints() !c_int { return try invoker.invoke(c_int, 0x9D1224004B3A6707, .{}); } // 0x9D1224004B3A6707 0x625C7B66 b323
    /// What's this for? Primary and Secondary RGB have their own natives and this one doesn't seem specific.
    pub inline fn getVehicleColor(vehicle: types.Vehicle, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !void { try invoker.invoke(void, 0xF3CC740D36221548, .{vehicle, r, g, b}); } // 0xF3CC740D36221548 0x03BC8F1B b323
    /// Some kind of flags.
    pub inline fn getVehicleColoursWhichCanBeSet(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xEEBFC7A7EFDC35B4, .{vehicle}); } // 0xEEBFC7A7EFDC35B4 0x749DEEA2 b323
    /// iVar3 = get_vehicle_cause_of_destruction(uLocal_248[iVar2]); \
    /// if (iVar3 == joaat("weapon_stickybomb")) \
    /// { \
    ///     func_171(726);
    ///     iLocal_260 = 1;
    /// }
    pub inline fn getVehicleCauseOfDestruction(vehicle: types.Vehicle) !types.Hash { return try invoker.invoke(types.Hash, 0xE495D1EF4C91FD20, .{vehicle}); } // 0xE495D1EF4C91FD20 0x7F8C20DD b323
    /// Used for helis.
    pub inline fn overridePlaneDamageThrehsold(vehicle: types.Vehicle, health: f32) !void { try invoker.invoke(void, 0x5EE5632F47AE9695, .{vehicle, health}); } // 0x5EE5632F47AE9695  b463
    pub inline fn setTransmissionReducedGearRatio_(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x337EF33DA3DDB990, .{vehicle, toggle}); } // 0x337EF33DA3DDB990  b3095
    pub inline fn getVehicleDesiredDriveGear_(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xFD8CE53356B5D745, .{vehicle}); } // 0xFD8CE53356B5D745  b3095
    /// From the driver's perspective, is the left headlight broken.
    pub inline fn getIsLeftVehicleHeadlightDamaged(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5EF77C9ADD3B11A3, .{vehicle}); } // 0x5EF77C9ADD3B11A3 0xA0777943 b323
    /// From the driver's perspective, is the right headlight broken.
    pub inline fn getIsRightVehicleHeadlightDamaged(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA7ECB73355EB2F20, .{vehicle}); } // 0xA7ECB73355EB2F20 0xF178390B b323
    /// Returns true when both headlights are broken. This does not include extralights.
    pub inline fn getBothVehicleHeadlightsDamaged(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEC69ADF931AAE0C3, .{vehicle}); } // 0xEC69ADF931AAE0C3  b505
    pub inline fn modifyVehicleTopSpeed(vehicle: types.Vehicle, value: f32) !void { try invoker.invoke(void, 0x93A3996368C94158, .{vehicle, value}); } // 0x93A3996368C94158 0xE943B09C b323
    /// To reset the max speed, set the `speed` value to `0.0` or lower.
    pub inline fn setVehicleMaxSpeed(vehicle: types.Vehicle, speed: f32) !void { try invoker.invoke(void, 0xBAA045B4E42F3C06, .{vehicle, speed}); } // 0xBAA045B4E42F3C06  b1103
    /// Has something to do with trains. Always precedes SET_MISSION_TRAIN_AS_NO_LONGER_NEEDED. \
    /// May be true that it can be used with trains not sure, but not specifically for trains. Go find Xbox360 decompiled scripts and search for 'func_1333' in freemode.c it isn't used just for trains. Thanks for the info tho.
    pub inline fn setVehicleStaysFrozenWhenCleanedUp(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1CF38D529D7441D9, .{vehicle, toggle}); } // 0x1CF38D529D7441D9 0xDF594D8D b323
    pub inline fn setVehicleActAsIfHighSpeedForFragSmashing(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x1F9FB66F3A3842D2, .{vehicle, p_1}); } // 0x1F9FB66F3A3842D2 0x4D840FC4 b323
    /// Sets some bit and float of vehicle. float is >= 0
    pub inline fn setPedsCanFallOffThisVehicleFromLargeFallDamage(vehicle: types.Vehicle, toggle: windows.BOOL, p_2: f32) !void { try invoker.invoke(void, 0x59C3757B3B7408E8, .{vehicle, toggle, p_2}); } // 0x59C3757B3B7408E8  b1493
    pub inline fn addVehicleCombatAngledAvoidanceArea(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32) !c_int { return try invoker.invoke(c_int, 0x54B0F614960F4A5F, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6}); } // 0x54B0F614960F4A5F 0x5AB26C2B b323
    pub inline fn removeVehicleCombatAvoidanceArea(p_0: c_int) !void { try invoker.invoke(void, 0xE30524E1871F481D, .{p_0}); } // 0xE30524E1871F481D 0xEF05F807 b323
    pub inline fn isAnyPedRappellingFromHeli(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x291E373D483E7EE7, .{vehicle}); } // 0x291E373D483E7EE7 0xD656E7E5 b323
    /// <1.0 - Decreased torque \
    /// =1.0 - Default torque \
    /// >1.0 - Increased torque
    /// 
    /// Negative values will cause the vehicle to go backwards instead of forwards while accelerating.
    /// 
    /// value - is between 0.2 and 1.8 in the decompiled scripts. 
    /// 
    /// This needs to be called every frame to take effect.
    pub inline fn setVehicleCheatPowerIncrease(vehicle: types.Vehicle, value: f32) !void { try invoker.invoke(void, 0xB59E4BD37AE292DB, .{vehicle, value}); } // 0xB59E4BD37AE292DB 0x642DA5AA b323
    pub inline fn setVehicleInfluencesWantedLevel(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x0AD9E8F87FF7C16F, .{p_0, p_1}); } // 0x0AD9E8F87FF7C16F 0x04F5546C b323
    /// Sets the wanted state of this vehicle.
    pub inline fn setVehicleIsWanted(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0xF7EC25A3EBEEC726, .{vehicle, state}); } // 0xF7EC25A3EBEEC726 0xDAA388E8 b323
    /// Sets the boat boom position for the `TR3` trailer. \
    /// Ratio value is between `0.0` and `1.0`, where `0.0` is 90 degrees to the left of the boat, and `1.0` is just slightly to the right/back of the boat. \
    /// To get the current boom position ratio, use GET_BOAT_BOOM_POSITION_RATIO
    pub inline fn swingBoatBoomToRatio(vehicle: types.Vehicle, ratio: f32) !void { try invoker.invoke(void, 0xF488C566413B4232, .{vehicle, ratio}); } // 0xF488C566413B4232 0xA25CCB8C b323
    /// Same call as ALLOW_BOAT_BOOM_TO_ANIMATE
    pub inline fn swingBoatBoomFreely(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC1F981A6F74F0C23, .{vehicle, toggle}); } // 0xC1F981A6F74F0C23 0x00966934 b323
    pub inline fn allowBoatBoomToAnimate(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0F3B4D4E43177236, .{vehicle, toggle}); } // 0x0F3B4D4E43177236 0x113DF5FD b323
    pub inline fn getBoatBoomPositionRatio(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x6636C535F6CC2725, .{vehicle}); } // 0x6636C535F6CC2725 0x7C8D6464 b323
    pub inline fn disablePlaneAileron(vehicle: types.Vehicle, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x23428FC53C60919C, .{vehicle, p_1, p_2}); } // 0x23428FC53C60919C 0x7E84C45C b323
    /// Returns true when in a vehicle, false whilst entering/exiting.
    pub inline fn getIsVehicleEngineRunning(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAE31E7DF9B5B132E, .{vehicle}); } // 0xAE31E7DF9B5B132E 0x7DC6D022 b323
    pub inline fn setVehicleUseAlternateHandling(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1D97D1E3A70A649F, .{vehicle, toggle}); } // 0x1D97D1E3A70A649F 0xA03E42DF b323
    /// Only works on bikes, both X and Y work in the -1 - 1 range.
    /// 
    /// X forces the bike to turn left or right (-1, 1) \
    /// Y forces the bike to lean to the left or to the right (-1, 1)
    /// 
    /// Example with X -1/Y 1 \
    /// http://i.imgur.com/TgIuAPJ.jpg
    pub inline fn setBikeOnStand(vehicle: types.Vehicle, vec: types.Vector2) !void { try invoker.invoke(void, 0x9CFA4896C3A53CBB, .{vehicle, vec.x, vec.y}); } // 0x9CFA4896C3A53CBB 0x15D40761 b323
    pub inline fn setVehicleNotStealableAmbiently(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xAB04325045427AAE, .{vehicle, p_1}); } // 0xAB04325045427AAE 0x1984F88D b323
    pub inline fn lockDoorsWhenNoLongerNeeded(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xCFD778E7904C255E, .{vehicle}); } // 0xCFD778E7904C255E 0x3FBE904F b323
    pub inline fn setLastDrivenVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xACFB2463CC22BED2, .{vehicle}); } // 0xACFB2463CC22BED2 0xD1B71A25 b323
    pub inline fn getLastDrivenVehicle() !types.Vehicle { return try invoker.invoke(types.Vehicle, 0xB2D06FAEDE65B577, .{}); } // 0xB2D06FAEDE65B577 0xFEB0C0C8 b323
    pub inline fn clearLastDrivenVehicle() !void { try invoker.invoke(void, 0xE01903C47C7AC89E, .{}); } // 0xE01903C47C7AC89E 0x07186AD9 b323
    pub inline fn setVehicleHasBeenDrivenFlag(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x02398B627547189C, .{vehicle, toggle}); } // 0x02398B627547189C 0x08CD58F9 b323
    pub inline fn setTaskVehicleGotoPlaneMinHeightAboveTerrain(plane: types.Vehicle, height: c_int) !void { try invoker.invoke(void, 0xB893215D8D4C015B, .{plane, height}); } // 0xB893215D8D4C015B 0x8C4B63E2 b323
    pub inline fn setVehicleLodMultiplier(vehicle: types.Vehicle, multiplier: f32) !void { try invoker.invoke(void, 0x93AE6A61BE015BF1, .{vehicle, multiplier}); } // 0x93AE6A61BE015BF1 0x569E5AE3 b323
    pub inline fn setVehicleCanSaveInGarage(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x428BACCDF5E26EAD, .{vehicle, toggle}); } // 0x428BACCDF5E26EAD 0x1604C2F5 b323
    /// Also includes some "turnOffBones" when vehicle mods are installed.
    pub inline fn getVehicleNumOfBrokenOffParts(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x42A4BEB35D372407, .{vehicle}); } // 0x42A4BEB35D372407 0x8CDB0C09 b323
    pub inline fn getVehicleNumOfBrokenLoosenParts(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x2C8CBFE1EA5FC631, .{vehicle}); } // 0x2C8CBFE1EA5FC631 0xABC99E21 b323
    pub inline fn setForceVehicleEngineDamageByBullet(p_0: types.Any, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x4D9D109F63FEE1D4, .{p_0, p_1}); } // 0x4D9D109F63FEE1D4 0x900C878C b323
    /// Allows creation of CEventShockingPlaneFlyby, CEventShockingHelicopterOverhead, and other(?) Shocking events
    pub inline fn setVehicleGeneratesEngineShockingEvents(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x279D50DE5652D935, .{vehicle, toggle}); } // 0x279D50DE5652D935 0xB3200F72 b323
    /// Copies sourceVehicle's damage (broken bumpers, broken lights, etc.) to targetVehicle.
    pub inline fn copyVehicleDamages(source_vehicle: types.Vehicle, target_vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xE44A982368A4AF23, .{source_vehicle, target_vehicle}); } // 0xE44A982368A4AF23 0xBAE491C7 b323
    pub inline fn disableVehicleExplosionBreakOffParts() !void { try invoker.invoke(void, 0xF25E02CB9C5818F8, .{}); } // 0xF25E02CB9C5818F8 0xF0E59BC1 b323
    pub inline fn setLightsCutoffDistanceTweak(distance: f32) !void { try invoker.invoke(void, 0xBC3CCA5844452B06, .{distance}); } // 0xBC3CCA5844452B06 0x929801C6 b323
    /// Commands the driver of an armed vehicle (p0) to shoot its weapon at a target (p1). p3, p4 and p5 are the coordinates of the target. Example:
    /// 
    /// WEAPON::SET_CURRENT_PED_VEHICLE_WEAPON(pilot,MISC::GET_HASH_KEY("VEHICLE_WEAPON_PLANE_ROCKET"));                        VEHICLE::SET_VEHICLE_SHOOT_AT_TARGET(pilot, target, targPos.x, targPos.y, targPos.z);
    pub inline fn setVehicleShootAtTarget(driver: types.Ped, entity: types.Entity, target__: types.Vector3) !void { try invoker.invoke(void, 0x74CD9A9327A282EA, .{driver, entity, target__.x, target__.y, target__.z}); } // 0x74CD9A9327A282EA 0x2343FFDF b323
    pub inline fn getVehicleLockOnTarget(vehicle: types.Vehicle, entity: [*c]types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8F5EBAB1F260CFCE, .{vehicle, entity}); } // 0x8F5EBAB1F260CFCE 0x4A557117 b323
    pub inline fn setForceHdVehicle(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x97CE68CB032583F0, .{vehicle, toggle}); } // 0x97CE68CB032583F0 0xE0FC6A32 b323
    pub inline fn setVehicleCustomPathNodeStreamingRadius(vehicle: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0x182F266C2D9E2BEB, .{vehicle, p_1}); } // 0x182F266C2D9E2BEB 0x7D0DE7EA b323
    pub inline fn getVehiclePlateType(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x9CCC9525BF2408E0, .{vehicle}); } // 0x9CCC9525BF2408E0 0x65CA9286 b323
    /// in script hook .net 
    /// 
    /// Vehicle v = ...; \
    /// Function.Call(Hash.TRACK_VEHICLE_VISIBILITY, v.Handle);
    pub inline fn trackVehicleVisibility(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x64473AEFDCF47DCA, .{vehicle}); } // 0x64473AEFDCF47DCA 0x78122DC1 b323
    /// must be called after TRACK_VEHICLE_VISIBILITY 
    /// 
    /// it's not instant so probabilly must pass an 'update' to see correct result.
    pub inline fn isVehicleVisible(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAA0A52D24FB98293, .{vehicle}); } // 0xAA0A52D24FB98293 0x7E0D6056 b323
    pub inline fn setVehicleGravity(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x89F149B6131E57DA, .{vehicle, toggle}); } // 0x89F149B6131E57DA 0x07B2A6DC b323
    /// Enable/Disables global slipstream physics
    pub inline fn setEnableVehicleSlipstreaming(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE6C0C80B8C867537, .{toggle}); } // 0xE6C0C80B8C867537 0xD2B8ACBD b323
    pub inline fn setVehicleSlipstreamingShouldTimeOut(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF051D9BFB6BA39C0, .{toggle}); } // 0xF051D9BFB6BA39C0  b877
    /// Returns a float value between 0.0 and 3.0 related to its slipstream draft (boost/speedup).
    pub inline fn getVehicleCurrentTimeInSlipStream(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x36492C2F0D134C56, .{vehicle}); } // 0x36492C2F0D134C56 0xA4A75FCF b323
    /// Returns true if the vehicle is being slipstreamed by another vehicle
    pub inline fn isVehicleProducingSlipStream(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x48C633E94A8142A7, .{vehicle}); } // 0x48C633E94A8142A7  b877
    pub inline fn setVehicleInactiveDuringPlayback(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x06582AFF74894C75, .{vehicle, toggle}); } // 0x06582AFF74894C75 0x50F89338 b323
    pub inline fn setVehicleActiveDuringPlayback(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDFFCEF48E511DB48, .{vehicle, toggle}); } // 0xDFFCEF48E511DB48 0xEB7D7C27 b323
    /// Returns false if the vehicle has the FLAG_NO_RESPRAY flag set.
    pub inline fn isVehicleSprayable(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8D474C8FAEFF6CDE, .{vehicle}); } // 0x8D474C8FAEFF6CDE 0x5EB00A6A b323
    pub inline fn setVehicleEngineCanDegrade(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x983765856F2564F9, .{vehicle, toggle}); } // 0x983765856F2564F9 0x081DAC12 b323
    /// Adds some kind of shadow to the vehicle.
    /// 
    /// p1 and p2 use values from 0-255 and both make the shadow darker the lower the value is. -1 disables the effect.
    pub inline fn disableVehcileDynamicAmbientScales(vehicle: types.Vehicle, p_1: c_int, p_2: c_int) !void { try invoker.invoke(void, 0xF0E4BA16D1DB546C, .{vehicle, p_1, p_2}); } // 0xF0E4BA16D1DB546C 0x5BD8D82D b323
    /// Remove the weird shadow applied by DISABLE_VEHCILE_DYNAMIC_AMBIENT_SCALES.
    pub inline fn enableVehicleDynamicAmbientScales(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xF87D9F2301F7D206, .{vehicle}); } // 0xF87D9F2301F7D206 0x450AD03A b323
    pub inline fn isPlaneLandingGearIntact(plane: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4198AB0022B15F87, .{plane}); } // 0x4198AB0022B15F87 0xBD085DCA b323
    pub inline fn arePlanePropellersIntact(plane: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x755D6D5267CBBD7E, .{plane}); } // 0x755D6D5267CBBD7E 0xABBDD5C6 b323
    pub inline fn setPlanePropellerHealth(plane: types.Vehicle, health: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4C815EB175086F84, .{plane, health}); } // 0x4C815EB175086F84  b1103
    pub inline fn setVehicleCanDeformWheels(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x0CDDA42F9E360CA6, .{vehicle, toggle}); } // 0x0CDDA42F9E360CA6 0x9B581DE7 b323
    /// Only returns true if the vehicle was marked as stolen with SET_VEHICLE_IS_STOLEN.
    pub inline fn isVehicleStolen(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4AF9BD80EEBEB453, .{vehicle}); } // 0x4AF9BD80EEBEB453 0x20B61DDE b323
    pub inline fn setVehicleIsStolen(vehicle: types.Vehicle, is_stolen: windows.BOOL) !void { try invoker.invoke(void, 0x67B2C79AA7FF5738, .{vehicle, is_stolen}); } // 0x67B2C79AA7FF5738 0x70912E42 b323
    /// This native sets the turbulence multiplier. It only works for planes. \
    /// 0.0 = no turbulence at all. \
    /// 1.0 = heavy turbulence. \
    /// Works by just calling it once, does not need to be called every tick.
    pub inline fn setPlaneTurbulenceMultiplier(vehicle: types.Vehicle, multiplier: f32) !void { try invoker.invoke(void, 0xAD2D28A1AFDFF131, .{vehicle, multiplier}); } // 0xAD2D28A1AFDFF131 0xED159AE6 b323
    pub inline fn areWingsOfPlaneIntact(plane: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5991A01434CE9677, .{plane}); } // 0x5991A01434CE9677 0xAF8CB3DF b323
    /// This native doesn't seem to do anything, might be a debug-only native.
    /// 
    /// Confirmed, it is a debug native.
    pub inline fn allowAmbientVehiclesToAvoidAdverseConditions(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xB264C4D2F2B0A78B, .{vehicle}); } // 0xB264C4D2F2B0A78B 0x45F72495 b323
    pub inline fn detachVehicleFromCargobob(vehicle: types.Vehicle, cargobob: types.Vehicle) !void { try invoker.invoke(void, 0x0E21D3DF1051399D, .{vehicle, cargobob}); } // 0x0E21D3DF1051399D 0x83D3D331 b323
    pub inline fn detachVehicleFromAnyCargobob(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xADF7BE450512C12F, .{vehicle}); } // 0xADF7BE450512C12F 0x50E0EABE b323
    pub inline fn detachEntityFromCargobob(cargobob: types.Vehicle, entity: types.Entity) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAF03011701811146, .{cargobob, entity}); } // 0xAF03011701811146  b678
    pub inline fn isVehicleAttachedToCargobob(cargobob: types.Vehicle, vehicle_attached: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD40148F22E81A1D9, .{cargobob, vehicle_attached}); } // 0xD40148F22E81A1D9 0x5DEEC76C b323
    /// Returns attached vehicle (Vehicle in parameter must be cargobob)
    pub inline fn getVehicleAttachedToCargobob(cargobob: types.Vehicle) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x873B82D42AC2B9E5, .{cargobob}); } // 0x873B82D42AC2B9E5 0x301A1D24 b323
    pub inline fn getEntityAttachedToCargobob(p_0: types.Any) !types.Entity { return try invoker.invoke(types.Entity, 0x99093F60746708CA, .{p_0}); } // 0x99093F60746708CA  b1103
    pub inline fn attachVehicleToCargobob(cargobob: types.Vehicle, vehicle: types.Vehicle, p_2: c_int, vec: types.Vector3) !void { try invoker.invoke(void, 0x4127F1D84E347769, .{cargobob, vehicle, p_2, vec.x, vec.y, vec.z}); } // 0x4127F1D84E347769 0x607DC9D5 b323
    pub inline fn attachEntityToCargobob(p_0: types.Any, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any, p_5: types.Any) !void { try invoker.invoke(void, 0xA1DD82F3CCF9A01E, .{p_0, p_1, p_2, p_3, p_4, p_5}); } // 0xA1DD82F3CCF9A01E 0xAEB29F98 b944
    /// Stops cargobob from being able to detach the attached vehicle.
    pub inline fn setCargobobForceDontDetachVehicle(cargobob: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x571FEB383F629926, .{cargobob, toggle}); } // 0x571FEB383F629926 0x49949FDA b323
    pub inline fn setCargobobExcludeFromPickupEntity(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x1F34B0626C594380, .{p_0, p_1}); } // 0x1F34B0626C594380  b757
    pub inline fn canCargobobPickUpEntity(p_0: types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2C1D8B3B19E517CC, .{p_0, p_1}); } // 0x2C1D8B3B19E517CC  b757
    /// Gets the position of the cargobob hook, in world coords.
    pub inline fn getAttachedPickUpHookPosition(cargobob: types.Vehicle) !types.Vector3 { return try invoker.invoke(types.Vector3, 0xCBDB9B923CACC92D, .{cargobob}); } // 0xCBDB9B923CACC92D 0xE6633DCF b323
    /// Returns true only when the hook is active, will return false if the magnet is active
    pub inline fn doesCargobobHavePickUpRope(cargobob: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1821D91AD4B56108, .{cargobob}); } // 0x1821D91AD4B56108 0xAF769B81 b323
    /// Drops the Hook/Magnet on a cargobob
    /// 
    /// state \
    /// enum eCargobobHook \
    /// { \
    ///   CARGOBOB_HOOK = 0,
    ///     CARGOBOB_MAGNET = 1,
    /// };
    pub inline fn createPickUpRopeForCargobob(cargobob: types.Vehicle, state: c_int) !void { try invoker.invoke(void, 0x7BEB0C7A235F6F3B, .{cargobob, state}); } // 0x7BEB0C7A235F6F3B 0x4D3C9A99 b323
    /// Retracts the hook on the cargobob.
    /// 
    /// Note: after you retract it the natives for dropping the hook no longer work
    pub inline fn removePickUpRopeForCargobob(cargobob: types.Vehicle) !void { try invoker.invoke(void, 0x9768CF648F54C804, .{cargobob}); } // 0x9768CF648F54C804 0xA8211EE9 b323
    /// min: 1.9f, max: 100.0f
    pub inline fn setPickupRopeLengthForCargobob(cargobob: types.Vehicle, length_1: f32, length_2: f32, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x877C1EAEAC531023, .{cargobob, length_1, length_2, p_3}); } // 0x877C1EAEAC531023 0x3A8AB081 b323
    pub inline fn setPickupRopeLengthWithoutCreatingRopeForCargobob(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0xC0ED6438E6D39BA8, .{p_0, p_1, p_2}); } // 0xC0ED6438E6D39BA8  b944
    pub inline fn setCargobobPickupRopeDampingMultiplier(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xCF1182F682F65307, .{p_0, p_1}); } // 0xCF1182F682F65307 0x7D927E1B b323
    pub inline fn setCargobobPickupRopeType(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x0D5F65A8F4EBDAB5, .{p_0, p_1}); } // 0x0D5F65A8F4EBDAB5 0xF258ADA1 b1103
    /// Returns true only when the magnet is active, will return false if the hook is active
    pub inline fn doesCargobobHavePickupMagnet(cargobob: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6E08BF5B3722BAC9, .{cargobob}); } // 0x6E08BF5B3722BAC9 0x4778CA0A b323
    /// Won't attract or magnetize to any helicopters or planes of course, but that's common sense.
    pub inline fn setCargobobPickupMagnetActive(cargobob: types.Vehicle, is_active: windows.BOOL) !void { try invoker.invoke(void, 0x9A665550F8DA349B, .{cargobob, is_active}); } // 0x9A665550F8DA349B 0xF57066DA b323
    pub inline fn setCargobobPickupMagnetStrength(cargobob: types.Vehicle, strength: f32) !void { try invoker.invoke(void, 0xBCBFCD9D1DAC19E2, .{cargobob, strength}); } // 0xBCBFCD9D1DAC19E2 0xCC3CF97D b323
    pub inline fn setCargobobPickupMagnetFalloff(cargobob: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0xA17BAD153B51547E, .{cargobob, p_1}); } // 0xA17BAD153B51547E  b323
    pub inline fn setCargobobPickupMagnetReducedStrength(cargobob: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0x66979ACF5102FD2F, .{cargobob, p_1}); } // 0x66979ACF5102FD2F  b323
    pub inline fn setCargobobPickupMagnetReducedFalloff(cargobob: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0x6D8EAC07506291FB, .{cargobob, p_1}); } // 0x6D8EAC07506291FB  b323
    pub inline fn setCargobobPickupMagnetPullStrength(cargobob: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0xED8286F71A819BAA, .{cargobob, p_1}); } // 0xED8286F71A819BAA 0x8191BC1A b323
    pub inline fn setCargobobPickupMagnetPullRopeLength(vehicle: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0x685D5561680D088B, .{vehicle, p_1}); } // 0x685D5561680D088B  b323
    pub inline fn setCargobobPickupMagnetSetTargetedMode(vehicle: types.Vehicle, cargobob: types.Vehicle) !void { try invoker.invoke(void, 0xE301BD63E9E13CF0, .{vehicle, cargobob}); } // 0xE301BD63E9E13CF0  b323
    pub inline fn setCargobobPickupMagnetSetAmbientMode(vehicle: types.Vehicle, p_1: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0x9BDDC73CC6A115D4, .{vehicle, p_1, p_2}); } // 0x9BDDC73CC6A115D4 0x50CDB295 b323
    pub inline fn setCargobobPickupMagnetEnsurePickupEntityUpright(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x56EB5E94318D3FB6, .{vehicle, p_1}); } // 0x56EB5E94318D3FB6 0x30F43FE3 b323
    pub inline fn doesVehicleHaveWeapons(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x25ECB9F8017D98E0, .{vehicle}); } // 0x25ECB9F8017D98E0 0xB2E1E1FB b323
    pub inline fn setVehicleWillTellOthersToHurry(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0x2C4A1590ABF43E8B, .{vehicle, p_1}); } // 0x2C4A1590ABF43E8B 0x2EC19A8B b323
    /// Full list of weapons by DurtyFree (Search for VEHICLE_*): https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn disableVehicleWeapon(disabled: windows.BOOL, weapon_hash: types.Hash, vehicle: types.Vehicle, owner: types.Ped) !void { try invoker.invoke(void, 0xF4FC6A6F67D8D856, .{disabled, weapon_hash, vehicle, owner}); } // 0xF4FC6A6F67D8D856 0xA688B7D1 b323
    /// Full list of weapons by DurtyFree (Search for VEHICLE_*): https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn isVehicleWeaponDisabled(weapon_hash: types.Hash, vehicle: types.Vehicle, owner: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x563B65A643ED072E, .{weapon_hash, vehicle, owner}); } // 0x563B65A643ED072E  b1011
    pub inline fn setVehicleUsedForPilotSchool(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE05DD0E9707003A3, .{vehicle, toggle}); } // 0xE05DD0E9707003A3 0x123E5B90 b323
    pub inline fn setVehicleActiveForPedNavigation(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x21115BCD6E44656A, .{vehicle, toggle}); } // 0x21115BCD6E44656A 0xEBC225C1 b323
    /// Returns an int
    /// 
    /// Vehicle Classes: \
    /// 0: Compacts \
    /// 1: Sedans \
    /// 2: SUVs \
    /// 3: Coupes \
    /// 4: Muscle \
    /// 5: Sports Classics \
    /// 6: Sports \
    /// 7: Super \
    /// 8: Motorcycles \
    /// 9: Off-road \
    /// 10: Industrial \
    /// 11: Utility \
    /// 12: Vans \
    /// 13: Cycles \
    /// 14: Boats \
    /// 15: Helicopters \
    /// 16: Planes \
    /// 17: Service \
    /// 18: Emergency \
    /// 19: Military \
    /// 20: Commercial \
    /// 21: Trains
    /// 
    /// char buffer[128]; \
    /// std::sprintf(buffer, "VEH_CLASS_%i", VEHICLE::GET_VEHICLE_CLASS(vehicle));
    /// 
    /// const char* className = HUD::GET_FILENAME_FOR_AUDIO_CONVERSATION(buffer);
    pub inline fn getVehicleClass(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x29439776AAA00A62, .{vehicle}); } // 0x29439776AAA00A62 0xC025338E b323
    /// char buffer[128]; \
    /// std::sprintf(buffer, "VEH_CLASS_%i", VEHICLE::GET_VEHICLE_CLASS_FROM_NAME (hash));
    /// 
    /// const char* className = HUD::GET_FILENAME_FOR_AUDIO_CONVERSATION(buffer);
    /// 
    /// Full list of vehicles by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/vehicles.json
    pub inline fn getVehicleClassFromName(model_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xDEDF1C8BD47C2200, .{model_hash}); } // 0xDEDF1C8BD47C2200 0xEA469980 b323
    pub inline fn setPlayersLastVehicle(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xBCDF8BAF56C87B6A, .{vehicle}); } // 0xBCDF8BAF56C87B6A 0xDE86447D b323
    pub inline fn setVehicleCanBeUsedByFleeingPeds(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x300504B23BD3B711, .{vehicle, toggle}); } // 0x300504B23BD3B711 0x5130DB1E b323
    pub inline fn setAircraftPilotSkillNoiseScalar(vehicle: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0xE5810AC70602F2F5, .{vehicle, p_1}); } // 0xE5810AC70602F2F5 0xB6BE07E0 b323
    /// Money pickups are created around cars when they explode. Only works when the vehicle model is a car. A single pickup is between 1 and 18 dollars in size. All car models seem to give the same amount of money.
    /// 
    /// youtu.be/3arlUxzHl5Y  \
    /// i.imgur.com/WrNpYFs.jpg
    pub inline fn setVehicleDropsMoneyWhenBlownUp(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x068F64F2470F9656, .{vehicle, toggle}); } // 0x068F64F2470F9656 0x4BB5605D b323
    pub inline fn setVehicleKeepEngineOnWhenAbandoned(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB8FBC8B1330CA9B4, .{vehicle, toggle}); } // 0xB8FBC8B1330CA9B4 0x51E0064F b323
    /// Seems to copy some values in vehicle
    pub inline fn setVehicleImpatienceTimer(vehicle: types.Vehicle, p_1: types.Any) !void { try invoker.invoke(void, 0x6A973569BA094650, .{vehicle, p_1}); } // 0x6A973569BA094650  b1604
    /// Use the "AIHandling" string found in handling.meta
    pub inline fn setVehicleHandlingOverride(vehicle: types.Vehicle, hash: types.Hash) !void { try invoker.invoke(void, 0x10655FAB9915623D, .{vehicle, hash}); } // 0x10655FAB9915623D  b323
    /// Max value is 32767
    pub inline fn setVehicleExtendedRemovalRange(vehicle: types.Vehicle, range: c_int) !void { try invoker.invoke(void, 0x79DF7E806202CE01, .{vehicle, range}); } // 0x79DF7E806202CE01 0xAEF9611C b323
    pub inline fn setVehicleSteeringBiasScalar(p_0: types.Any, p_1: f32) !void { try invoker.invoke(void, 0x9007A2F21DC108D4, .{p_0, p_1}); } // 0x9007A2F21DC108D4 0x585E49B6 b323
    /// value between 0.0 and 1.0
    pub inline fn setHeliControlLaggingRateScalar(helicopter: types.Vehicle, multiplier: f32) !void { try invoker.invoke(void, 0x6E0859B530A365CC, .{helicopter, multiplier}); } // 0x6E0859B530A365CC 0x6E67FD35 b323
    /// Seems to be related to the metal parts, not tyres (like i was expecting lol)
    pub inline fn setVehicleFrictionOverride(vehicle: types.Vehicle, friction: f32) !void { try invoker.invoke(void, 0x1837AF7C627009BA, .{vehicle, friction}); } // 0x1837AF7C627009BA 0x32AFD42E b323
    pub inline fn setVehicleWheelsCanBreakOffWhenBlowUp(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xA37B9A517B133349, .{vehicle, toggle}); } // 0xA37B9A517B133349 0x670913A4 b323
    pub inline fn arePlaneControlPanelsIntact(vehicle: types.Vehicle, p_1: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF78F94D60248C737, .{vehicle, p_1}); } // 0xF78F94D60248C737 0x3B51B348 b323
    pub inline fn setVehicleCeilingHeight(vehicle: types.Vehicle, height: f32) !void { try invoker.invoke(void, 0xA46413066687A328, .{vehicle, height}); } // 0xA46413066687A328 0x98A10A86 b323
    pub inline fn setVehicleNoExplosionDamageFromDriver(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5E569EC46EC21CAE, .{vehicle, toggle}); } // 0x5E569EC46EC21CAE 0xBC649C49 b323
    pub inline fn clearVehicleRouteHistory(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x6D6AF961B72728AE, .{vehicle}); } // 0x6D6AF961B72728AE 0x8DD9AA0C b323
    pub inline fn doesVehicleExistWithDecorator(decorator: [*c]const u8) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x956B409B984D9BF7, .{decorator}); } // 0x956B409B984D9BF7 0x39E68EDD b323
    /// Used to be incorrectly named SET_VEHICLE_EXCLUSIVE_DRIVER \
    /// Toggles a flag related to SET_VEHICLE_EXCLUSIVE_DRIVER, however, doesn't enable that feature (or trigger script events related to it).
    pub inline fn setVehicleAiCanUseExclusiveSeats(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x41062318F23ED854, .{vehicle, toggle}); } // 0x41062318F23ED854  b323
    /// index: 0 - 1
    /// 
    /// Used to be incorrectly named _SET_VEHICLE_EXCLUSIVE_DRIVER_2
    pub inline fn setVehicleExclusiveDriver(vehicle: types.Vehicle, ped: types.Ped, index: c_int) !void { try invoker.invoke(void, 0xB5C51B5502E85E83, .{vehicle, ped, index}); } // 0xB5C51B5502E85E83 0xAA8BD440 b323
    pub inline fn isPedExclusiveDriverOfVehicle(ped: types.Ped, vehicle: types.Vehicle, out_index: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB09D25E77C33EB3F, .{ped, vehicle, out_index}); } // 0xB09D25E77C33EB3F  b463
    pub inline fn disableIndividualPlanePropeller(vehicle: types.Vehicle, propeller: c_int) !void { try invoker.invoke(void, 0x500873A45724C863, .{vehicle, propeller}); } // 0x500873A45724C863 0x004926A3 b323
    pub inline fn enableIndividualPlanePropeller_(vehicle: types.Vehicle, propeller: c_int) !void { try invoker.invoke(void, 0xDC05D2777F855F44, .{vehicle, propeller}); } // 0xDC05D2777F855F44  b3407
    pub inline fn setVehicleForceAfterburner(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB055A34527CB8FD7, .{vehicle, toggle}); } // 0xB055A34527CB8FD7 0xC195803B b323
    /// R* used it to "remove" vehicle windows when "nightshark" had some mod, which adding some kind of armored windows. When enabled, you can't break vehicles glass. All your bullets wiil shoot through glass. You also will not able to break the glass with any other way (hitting and etc)
    pub inline fn setDontProcessVehicleGlass(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1087BC8EC540DAEB, .{vehicle, toggle}); } // 0x1087BC8EC540DAEB  b1103
    pub inline fn setDisableWantedConesResponse(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x4AD280EB48B2D8E6, .{vehicle, toggle}); } // 0x4AD280EB48B2D8E6  b1868
    pub inline fn setUseDesiredZCruiseSpeedForLanding(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB68CFAF83A02768D, .{vehicle, toggle}); } // 0xB68CFAF83A02768D  b1290
    pub inline fn setArriveDistanceOverrideForVehiclePersuitAttack(vehicle: types.Vehicle, p_1: f32) !void { try invoker.invoke(void, 0x0205F5365292D2EB, .{vehicle, p_1}); } // 0x0205F5365292D2EB  b1290
    pub inline fn setVehicleReadyForCleanup(p_0: types.Any) !void { try invoker.invoke(void, 0xCF9159024555488C, .{p_0}); } // 0xCF9159024555488C  b944
    /// Toggles to render distant vehicles. They may not be vehicles but images to look like vehicles.
    pub inline fn setDistantCarsEnabled(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF796359A959DF65D, .{toggle}); } // 0xF796359A959DF65D 0xB5CC548B b323
    /// Sets the color of the neon lights of the specified vehicle.
    pub inline fn setVehicleNeonColour(vehicle: types.Vehicle, r: c_int, g: c_int, b: c_int) !void { try invoker.invoke(void, 0x8E0A582209A62695, .{vehicle, r, g, b}); } // 0x8E0A582209A62695  b323
    /// Index references CVehicleModelColor
    pub inline fn setVehicleNeonIndexColour(vehicle: types.Vehicle, index: c_int) !void { try invoker.invoke(void, 0xB93B2867F7B479D1, .{vehicle, index}); } // 0xB93B2867F7B479D1  b1493
    /// Gets the color of the neon lights of the specified vehicle.
    /// 
    /// See SET_VEHICLE_NEON_COLOUR (0x8E0A582209A62695) for more information
    pub inline fn getVehicleNeonColour(vehicle: types.Vehicle, r: [*c]c_int, g: [*c]c_int, b: [*c]c_int) !void { try invoker.invoke(void, 0x7619EEE8C886757F, .{vehicle, r, g, b}); } // 0x7619EEE8C886757F  b323
    /// Sets the neon lights of the specified vehicle on/off.
    /// 
    /// Indices: \
    /// 0 = Left \
    /// 1 = Right \
    /// 2 = Front \
    /// 3 = Back
    pub inline fn setVehicleNeonEnabled(vehicle: types.Vehicle, index: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2AA720E4287BF269, .{vehicle, index, toggle}); } // 0x2AA720E4287BF269  b323
    /// indices: \
    /// 0 = Left \
    /// 1 = Right \
    /// 2 = Front \
    /// 3 = Back
    pub inline fn getVehicleNeonEnabled(vehicle: types.Vehicle, index: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8C4B92553E4766A5, .{vehicle, index}); } // 0x8C4B92553E4766A5  b323
    pub inline fn setAmbientVehicleNeonEnabled(p_0: windows.BOOL) !void { try invoker.invoke(void, 0x35E0654F4BAD7971, .{p_0}); } // 0x35E0654F4BAD7971  b323
    pub inline fn suppressNeonsOnVehicle(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x83F813570FF519DE, .{vehicle, toggle}); } // 0x83F813570FF519DE  b573
    pub inline fn setDisableSuperdummy(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xB088E9A47AE6EDD5, .{vehicle, p_1}); } // 0xB088E9A47AE6EDD5  b323
    pub inline fn requestVehicleDial(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xDBA3C090E3D74690, .{vehicle}); } // 0xDBA3C090E3D74690  b323
    /// Seems related to vehicle health, like the one in IV. \
    /// Max 1000, min 0. \
    /// Vehicle does not necessarily explode or become undrivable at 0.
    pub inline fn getVehicleBodyHealth(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xF271147EB7B40F12, .{vehicle}); } // 0xF271147EB7B40F12 0x2B2FCC28 b323
    /// p2 often set to 1000.0 in the decompiled scripts.
    pub inline fn setVehicleBodyHealth(vehicle: types.Vehicle, value: f32) !void { try invoker.invoke(void, 0xB77D05AC8C78AADB, .{vehicle, value}); } // 0xB77D05AC8C78AADB 0x920C2517 b323
    /// Outputs 2 Vector3's. \
    /// Scripts check if out2.x - out1.x > someshit.x \
    /// Could be suspension related, as in max suspension height and min suspension height, considering the natives location.
    pub inline fn getVehicleSize(vehicle: types.Vehicle, out_1: [*c]types.Vector3, out_2: [*c]types.Vector3) !void { try invoker.invoke(void, 0xDF7E3EEB29642C38, .{vehicle, out_1, out_2}); } // 0xDF7E3EEB29642C38  b323
    /// Gets the height of the vehicle's suspension. \
    /// The higher the value the lower the suspension. Each 0.002 corresponds with one more level lowered. \
    /// 0.000 is the stock suspension. \
    /// 0.008 is Ultra Suspension.
    pub inline fn getFakeSuspensionLoweringAmount(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0x53952FD2BAA19F17, .{vehicle}); } // 0x53952FD2BAA19F17 0xB73A1486 b323
    pub inline fn setCarHighSpeedBumpSeverityMultiplier(multiplier: f32) !void { try invoker.invoke(void, 0x84FD40F56075E816, .{multiplier}); } // 0x84FD40F56075E816  b323
    pub inline fn getNumberOfVehicleDoors(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0x92922A607497B14D, .{vehicle}); } // 0x92922A607497B14D  b463
    /// If false, lowers hydraulics (if raised) and disables hydraulics controls. If true, raises hydraulics and enables hydraulics controls.
    /// 
    /// Only used once in each carmod script, on a car that does not have hydraulics to begin with.
    pub inline fn setHydraulicsControl(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x28B18377EB6E25F6, .{vehicle, toggle}); } // 0x28B18377EB6E25F6  b505
    pub inline fn setCanAdjustGroundClearance(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xA7DCDF4DED40A8F4, .{vehicle, p_1}); } // 0xA7DCDF4DED40A8F4  b323
    /// 0 min 100 max \
    /// starts at 100 \
    /// Seams to have health zones \
    /// Front of vehicle when damaged goes from 100-50 and stops at 50. \
    /// Rear can be damaged from 100-0 \
    /// Only tested with two cars.
    /// 
    /// any idea how this differs from the first one?
    /// 
    /// -- \
    /// May return the vehicle health on a scale of 0.0 - 100.0 (needs to be confirmed)
    /// 
    /// example:
    /// 
    /// v_F = ENTITY::GET_ENTITY_MODEL(v_3); \
    /// if (((v_F == ${tanker}) || (v_F == ${armytanker})) || (v_F == ${tanker2})) { \
    ///     if (VEHICLE::GET_VEHICLE_HEALTH_PERCENTAGE(v_3) <= 1.0) {
    ///         NETWORK::NETWORK_EXPLODE_VEHICLE(v_3, 1, 1, -1);
    ///     }
    /// }
    pub inline fn getVehicleHealthPercentage(vehicle: types.Vehicle, max_engine_health: f32, max_petrol_tank_health: f32, max_body_health: f32, max_main_rotor_health: f32, max_tail_rotor_health: f32, max_unk_health: f32) !f32 { return try invoker.invoke(f32, 0xB8EF61207C2393A9, .{vehicle, max_engine_health, max_petrol_tank_health, max_body_health, max_main_rotor_health, max_tail_rotor_health, max_unk_health}); } // 0xB8EF61207C2393A9 0x196BA503 b323
    pub inline fn getVehicleIsMercenary(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD4C4642CB7F50B5D, .{vehicle}); } // 0xD4C4642CB7F50B5D 0x575504DE b323
    pub inline fn setVehicleBrokenPartsDontAffectAiHandling(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xC361AA040D6637A8, .{vehicle, p_1}); } // 0xC361AA040D6637A8 0x819CD954 b323
    pub inline fn setVehicleKersAllowed(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x99C82F8A139F3E4E, .{vehicle, toggle}); } // 0x99C82F8A139F3E4E 0x71CDD52F b323
    /// Returns true if the vehicle has a HF_HAS_KERS (strHandlingFlags 0x4) handing flag set, for instance the lectro/vindicator bikes or the open wheelers.
    pub inline fn getVehicleHasKers(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x50634E348C8D44EF, .{vehicle}); } // 0x50634E348C8D44EF 0x0761E635 b372
    pub inline fn setPlaneResistToExplosion(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xE16142B94664DEFD, .{vehicle, toggle}); } // 0xE16142B94664DEFD 0xFBBA699A b323
    pub inline fn setHeliResistToExplosion(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8074CC1886802912, .{vehicle, toggle}); } // 0x8074CC1886802912  b2545
    pub inline fn setDisableBmxExtraTrickForces(p_0: types.Any) !void { try invoker.invoke(void, 0x26D99D5A82FD18E8, .{p_0}); } // 0x26D99D5A82FD18E8  b463
    /// Works only on vehicles that support hydraulics.
    pub inline fn setHydraulicSuspensionRaiseFactor(vehicle: types.Vehicle, wheel_id: c_int, value: f32) !void { try invoker.invoke(void, 0x84EA99C62CB3EF0C, .{vehicle, wheel_id, value}); } // 0x84EA99C62CB3EF0C  b505
    pub inline fn getHydraulicSuspensionRaiseFactor(vehicle: types.Vehicle, wheel_id: c_int) !f32 { return try invoker.invoke(f32, 0x0BB5CBDDD0F25AE3, .{vehicle, wheel_id}); } // 0x0BB5CBDDD0F25AE3  b2372
    pub inline fn setCanUseHydraulics(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1201E8A3290A3B98, .{vehicle, toggle}); } // 0x1201E8A3290A3B98  b505
    /// States: \
    /// 4 = raise \
    /// 5 = lower \
    /// 6 = jump
    pub inline fn setHydraulicVehicleState(vehicle: types.Vehicle, state: c_int) !void { try invoker.invoke(void, 0x8EA86DF356801C7D, .{vehicle, state}); } // 0x8EA86DF356801C7D  b505
    /// Sets vehicle wheel hydraulic states transition. Known states: \
    /// 0 - reset \
    /// 1 - raise wheel (uses value arg, works just like _SET_VEHICLE_HYDRAULIC_WHEEL_VALUE) \
    /// 2 - jump using wheel
    pub inline fn setHydraulicWheelState(vehicle: types.Vehicle, wheel_id: c_int, state: c_int, value: f32, p_4: types.Any) !void { try invoker.invoke(void, 0xC24075310A8B9CD1, .{vehicle, wheel_id, state, value, p_4}); } // 0xC24075310A8B9CD1  b505
    pub inline fn hasVehiclePetroltankSetOnFireByEntity(p_0: types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5BA68A0840D546AC, .{p_0, p_1}); } // 0x5BA68A0840D546AC  b463
    pub inline fn clearVehiclePetroltankFireCulprit(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x4419966C9936071A, .{vehicle}); } // 0x4419966C9936071A  b463
    /// Controls how fast bobbleheads and tsurikawas move on each axis.
    /// 
    /// p2 is probably z, but changing that value didn't seem to have a noticeable effect.
    pub inline fn setVehicleBobbleheadVelocity(vec: types.Vector2, p_2: f32) !void { try invoker.invoke(void, 0x870B8B7A766615C8, .{vec.x, vec.y, p_2}); } // 0x870B8B7A766615C8  b505
    pub inline fn getVehicleIsDummy(p_0: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8533CAFDE1F0F336, .{p_0}); } // 0x8533CAFDE1F0F336  b505
    pub inline fn setVehicleDamageScale(vehicle: types.Vehicle, p_1: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4E20D2A627011E8E, .{vehicle, p_1}); } // 0x4E20D2A627011E8E  b757
    /// Does not actually return anything.
    pub inline fn setVehicleExplosiveDamageScale_(vehicle: types.Vehicle, scale: f32) !types.Any { return try invoker.invoke(types.Any, 0x84D7FFD223CAAFFD, .{vehicle, scale}); } // 0x84D7FFD223CAAFFD  b3407
    pub inline fn setVehicleWeaponDamageScale(vehicle: types.Vehicle, multiplier: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x45A561A9421AB6AD, .{vehicle, multiplier}); } // 0x45A561A9421AB6AD  b944
    pub inline fn setDisableDamageWithPickedUpEntity(p_0: types.Any, p_1: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD4196117AF7BB974, .{p_0, p_1}); } // 0xD4196117AF7BB974  b757
    pub inline fn setVehicleUsesMpPlayerDamageMultiplier(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0xBB2333BB87DDD87F, .{p_0, p_1}); } // 0xBB2333BB87DDD87F  b757
    /// When enabled, the player won't fall off the bike when landing from large heights.
    pub inline fn setBikeEasyToLand(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x73561D4425A021A2, .{vehicle, toggle}); } // 0x73561D4425A021A2  b791
    /// Inverts vehicle's controls. So INPUT_VEH_ACCELERATE will be INPUT_VEH_BRAKE and vise versa (same for A/D controls) \
    /// Doesn't work for planes/helis.
    pub inline fn setInvertVehicleControls(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0x5B91B229243351A8, .{vehicle, state}); } // 0x5B91B229243351A8  b791
    /// Disables the screen effects and sound effects when driving over a speed boost pad.
    pub inline fn setSpeedBoostEffectDisabled(disabled: windows.BOOL) !void { try invoker.invoke(void, 0x7BBE7FF626A591FE, .{disabled}); } // 0x7BBE7FF626A591FE  b877
    /// Disables the screen effects and sound effects when driving over a slowdown pad.
    pub inline fn setSlowDownEffectDisabled(disabled: windows.BOOL) !void { try invoker.invoke(void, 0x65B080555EA48149, .{disabled}); } // 0x65B080555EA48149  b1011
    pub inline fn setFormationLeader(vehicle: types.Vehicle, vec: types.Vector3, p_4: f32) !void { try invoker.invoke(void, 0x428AD3E26C8D9EB0, .{vehicle, vec.x, vec.y, vec.z, p_4}); } // 0x428AD3E26C8D9EB0  b877
    /// Resets the effect of SET_FORMATION_LEADER
    pub inline fn resetFormationLeader() !void { try invoker.invoke(void, 0xE2F53F172B45EDE1, .{}); } // 0xE2F53F172B45EDE1  b877
    pub inline fn getIsBoatCapsized(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBA91D045575699AD, .{vehicle}); } // 0xBA91D045575699AD  b877
    pub inline fn setAllowRammingSoopOrRamp(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x80E3357FDEF45C21, .{p_0, p_1}); } // 0x80E3357FDEF45C21  b944
    pub inline fn setScriptRampImpulseScale(vehicle: types.Vehicle, impulse_scale: f32) !void { try invoker.invoke(void, 0xEFC13B1CE30D755D, .{vehicle, impulse_scale}); } // 0xEFC13B1CE30D755D  b944
    /// doorId: see SET_VEHICLE_DOOR_SHUT
    pub inline fn getIsDoorValid(vehicle: types.Vehicle, door_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x645F4B6E8499F632, .{vehicle, door_id}); } // 0x645F4B6E8499F632  b944
    pub inline fn setScriptRocketBoostRechargeTime(vehicle: types.Vehicle, seconds: f32) !void { try invoker.invoke(void, 0xE00F2AB100B76E89, .{vehicle, seconds}); } // 0xE00F2AB100B76E89  b944
    pub inline fn getHasRocketBoost(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x36D782F68B309BDA, .{vehicle}); } // 0x36D782F68B309BDA  b944
    pub inline fn isRocketBoostActive(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3D34E80EED4AE3BE, .{vehicle}); } // 0x3D34E80EED4AE3BE  b944
    pub inline fn setRocketBoostActive(vehicle: types.Vehicle, active: windows.BOOL) !void { try invoker.invoke(void, 0x81E1552E35DC3839, .{vehicle, active}); } // 0x81E1552E35DC3839  b944
    pub inline fn getHasRetractableWheels(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDCA174A42133F08C, .{vehicle}); } // 0xDCA174A42133F08C  b944
    pub inline fn getIsWheelsRetracted(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1DA0DA9CB3F0C8BF, .{vehicle}); } // 0x1DA0DA9CB3F0C8BF  b944
    pub inline fn setWheelsExtendedInstantly(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xF660602546D27BA8, .{vehicle}); } // 0xF660602546D27BA8  b944
    pub inline fn setWheelsRetractedInstantly(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x5335BE58C083E74E, .{vehicle}); } // 0x5335BE58C083E74E  b1011
    /// Returns true if the vehicle has the FLAG_JUMPING_CAR flag set.
    pub inline fn getCarHasJump(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x9078C0C5EF8C19E9, .{vehicle}); } // 0x9078C0C5EF8C19E9  b944
    /// Allows vehicles with the FLAG_JUMPING_CAR flag to jump higher (i.e. Ruiner 2000).
    pub inline fn setUseHigherCarJump(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF06A16CA55D138D8, .{vehicle, toggle}); } // 0xF06A16CA55D138D8  b944
    pub inline fn setClearFreezeWaitingOnCollisionOncePlayerEnters(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB2E0C0D6922D31F2, .{vehicle, toggle}); } // 0xB2E0C0D6922D31F2  b944
    /// Set vehicle's primary mounted weapon 2 ammo. For example, use it on APC. \
    /// For example, you can "remove" any vehicle weapon from any vehicle. \
    /// ammoAmount -1 = infinite ammo (default value for any spawned vehicle tho)
    pub inline fn setVehicleWeaponRestrictedAmmo(vehicle: types.Vehicle, weapon_index: c_int, capacity: c_int) !void { try invoker.invoke(void, 0x44CD1F493DB2A0A6, .{vehicle, weapon_index, capacity}); } // 0x44CD1F493DB2A0A6  b944
    pub inline fn getVehicleWeaponRestrictedAmmo(vehicle: types.Vehicle, weapon_index: c_int) !c_int { return try invoker.invoke(c_int, 0x8181CE2F25CB9BB7, .{vehicle, weapon_index}); } // 0x8181CE2F25CB9BB7  b1011
    pub inline fn getVehicleHasParachute(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC9CFF381338CB4F, .{vehicle}); } // 0xBC9CFF381338CB4F  b944
    pub inline fn getVehicleCanDeployParachute(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA916396DF4154EE3, .{vehicle}); } // 0xA916396DF4154EE3  b944
    pub inline fn vehicleStartParachuting(vehicle: types.Vehicle, active: windows.BOOL) !void { try invoker.invoke(void, 0x0BFFB028B3DD0A97, .{vehicle, active}); } // 0x0BFFB028B3DD0A97  b944
    pub inline fn isVehicleParachuteDeployed(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3DE51E9C80B116CF, .{vehicle}); } // 0x3DE51E9C80B116CF  b1011
    pub inline fn vehicleSetRampAndRammingCarsTakeDamage(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x28D034A93FE31BF5, .{vehicle, toggle}); } // 0x28D034A93FE31BF5  b944
    pub inline fn vehicleSetEnableRampCarSideImpulse(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x1BBAC99C0BC53656, .{p_0, p_1}); } // 0x1BBAC99C0BC53656  b944
    pub inline fn vehicleSetEnableNormaliseRampCarVerticalVeloctiy(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x756AE6E962168A04, .{p_0, p_1}); } // 0x756AE6E962168A04  b944
    pub inline fn vehicleSetJetWashForceEnabled(p_0: types.Any) !void { try invoker.invoke(void, 0x9D30687C57BAA0BB, .{p_0}); } // 0x9D30687C57BAA0BB  b1011
    pub inline fn setVehicleWeaponCanTargetObjects(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x86B4B6212CB8B627, .{vehicle, toggle}); } // 0x86B4B6212CB8B627  b1011
    /// Used for blazer5. Changes the quadbike-jetski transformation input from raise/lower convertible roof (hold H by default) to horn (press E by default.)
    pub inline fn setVehicleUseBoostButtonForWheelRetract(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x41290B40FA63E6DA, .{toggle}); } // 0x41290B40FA63E6DA  b1011
    pub inline fn setVehicleUseHornButtonForNitrous_(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x1980F68872CC2C3D, .{toggle}); } // 0x1980F68872CC2C3D  b3095
    /// Parachute models: \
    /// - sr_prop_specraces_para_s_01 \
    /// - imp_prop_impexp_para_s (SecuroServ; Default) \
    /// Plus, many more props can be used as vehicle parachutes, like umbrellas (prop_beach_parasol_03), and unlike SET_PLAYER_PARACHUTE_MODEL_OVERRIDE, you won't get stuck mid-air when using an umbrella.
    pub inline fn vehicleSetParachuteModelOverride(vehicle: types.Vehicle, model_hash: types.Hash) !void { try invoker.invoke(void, 0x4D610C6B56031351, .{vehicle, model_hash}); } // 0x4D610C6B56031351  b1011
    /// Variations available for the generic parachute (sr_prop_specraces_para_s_01): \
    /// - 0: Rainbow \
    /// - 1: Red \
    /// - 2: White, blue, yellow \
    /// - 3: Black, red, white \
    /// - 4: Red, white, blue \
    /// - 5: Blue \
    /// - 6: Black \
    /// - 7: Black, yellow
    pub inline fn vehicleSetParachuteModelTintIndex(vehicle: types.Vehicle, texture_variation: c_int) !void { try invoker.invoke(void, 0xA74AD2439468C883, .{vehicle, texture_variation}); } // 0xA74AD2439468C883  b1011
    pub inline fn vehicleSetOverrideExtenableSideRatio(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0x0419B167EE128F33, .{p_0, p_1}); } // 0x0419B167EE128F33  b1103
    pub inline fn vehicleSetExtenableSideTargetRatio(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0xF3B0E0AED097A3F5, .{p_0, p_1}); } // 0xF3B0E0AED097A3F5  b1103
    pub inline fn vehicleSetOverrideSideRatio(p_0: types.Any, p_1: types.Any) !c_int { return try invoker.invoke(c_int, 0xD3E51C0AB8C26EEE, .{p_0, p_1}); } // 0xD3E51C0AB8C26EEE  b1103
    pub inline fn getAllVehicles(vehs_struct: [*c]types.Any) !c_int { return try invoker.invoke(c_int, 0x9B8E1BF04B51F2E8, .{vehs_struct}); } // 0x9B8E1BF04B51F2E8  b1103
    pub inline fn setCargobobExtaPickupRange(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x72BECCF4B829522E, .{p_0, p_1}); } // 0x72BECCF4B829522E  b1103
    pub inline fn setOverrideVehicleDoorTorque(p_0: types.Any, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x66E3AAFACE2D1EB8, .{p_0, p_1, p_2}); } // 0x66E3AAFACE2D1EB8  b1103
    /// Enables/disables the ability to wheelie on motorcycles.
    pub inline fn setWheelieEnabled(vehicle: types.Vehicle, enabled: windows.BOOL) !void { try invoker.invoke(void, 0x1312DDD8385AEE4E, .{vehicle, enabled}); } // 0x1312DDD8385AEE4E  b1103
    /// Prevents the vehicle from exploding when taking body damage. Only works for helis and planes.
    pub inline fn setDisableHeliExplodeFromBodyDamage(vehicle: types.Vehicle, disable: windows.BOOL) !void { try invoker.invoke(void, 0xEDBC8405B3895CC9, .{vehicle, disable}); } // 0xEDBC8405B3895CC9  b1103
    /// Prevents the vehicle from exploding when taking body damage if it was caused by a collision. Only works for planes.
    pub inline fn setDisableExplodeFromBodyDamageOnCollision(vehicle: types.Vehicle, disable: windows.BOOL) !void { try invoker.invoke(void, 0x26E13D440E7F6064, .{vehicle, disable}); } // 0x26E13D440E7F6064  b1290
    /// Prevents the vehicle from exploding when taking body damage if the inflictor is an AI-controlled vehicle. Only works for planes.
    pub inline fn setDisableExplodeFromBodyDamageReceivedByAiVehicle_(vehicle: types.Vehicle, disable: windows.BOOL) !void { try invoker.invoke(void, 0xB0B7DF5CB876FF5E, .{vehicle, disable}); } // 0xB0B7DF5CB876FF5E  b3407
    pub inline fn setTrailerAttachmentEnabled(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x2FA2494B47FDD009, .{p_0, p_1}); } // 0x2FA2494B47FDD009  b1103
    pub inline fn setRocketBoostFill(vehicle: types.Vehicle, percentage: f32) !void { try invoker.invoke(void, 0xFEB2DDED3509562E, .{vehicle, percentage}); } // 0xFEB2DDED3509562E  b1103
    /// Set state to true to extend the wings, false to retract them.
    pub inline fn setGliderActive(vehicle: types.Vehicle, state: windows.BOOL) !void { try invoker.invoke(void, 0x544996C0081ABDEB, .{vehicle, state}); } // 0x544996C0081ABDEB  b1103
    /// Resets the vehicle's turret to its default position in scripted cameras. Doesn't seem to affect turrets that are occupied by a ped.
    pub inline fn setShouldResetTurretInScriptedCameras(vehicle: types.Vehicle, should_reset: windows.BOOL) !void { try invoker.invoke(void, 0x78CEEE41F49F421F, .{vehicle, should_reset}); } // 0x78CEEE41F49F421F  b1103
    pub inline fn setVehicleDisableCollisionUponCreation(vehicle: types.Vehicle, disable: windows.BOOL) !void { try invoker.invoke(void, 0xAF60E6A2936F982A, .{vehicle, disable}); } // 0xAF60E6A2936F982A  b1103
    pub inline fn setGroundEffectReducesDrag(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x430A7631A84C9BE7, .{toggle}); } // 0x430A7631A84C9BE7  b1180
    /// Disables collision for this vehicle (maybe it also supports other entities, not sure). \
    /// Only world/building/fixed world objects will have their collisions disabled, props, peds, or any other entity still collides with the vehicle. \
    /// Example: https://streamable.com/6n45d5 \
    /// Not sure if there is a native (and if so, which one) that resets the collisions.
    pub inline fn setDisableMapCollision(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x75627043C6AA90AD, .{vehicle}); } // 0x75627043C6AA90AD  b1180
    pub inline fn setDisablePedStandOnTop(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8235F1BEAD557629, .{vehicle, toggle}); } // 0x8235F1BEAD557629  b1180
    pub inline fn setVehicleDamageScales(vehicle: types.Vehicle, p_1: types.Any, p_2: types.Any, p_3: types.Any, p_4: types.Any) !void { try invoker.invoke(void, 0x9640E30A7F395E4B, .{vehicle, p_1, p_2, p_3, p_4}); } // 0x9640E30A7F395E4B  b1290
    pub inline fn setPlaneSectionDamageScale(vehicle: types.Vehicle, p_1: types.Any, p_2: types.Any) !void { try invoker.invoke(void, 0x0BBB9A7A8FFE931B, .{vehicle, p_1, p_2}); } // 0x0BBB9A7A8FFE931B  b1290
    pub inline fn setPlaneControlSectionsShouldBreakOffFromExplosions(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xDD8A2D3337F04196, .{vehicle, toggle}); } // 0xDD8A2D3337F04196  b3407
    /// Stops the cargobob from being able to attach any vehicle
    pub inline fn setHeliCanPickupEntityThatHasPickUpDisabled(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x94A68DA412C4007D, .{vehicle, toggle}); } // 0x94A68DA412C4007D  b1180
    /// Sets the amount of bombs that this vehicle has. As far as I know, this does _not_ impact vehicle weapons or the ammo of those weapons in any way, it is just a way to keep track of the amount of bombs in a specific plane.
    pub inline fn setVehicleBombAmmo(vehicle: types.Vehicle, bomb_count: c_int) !void { try invoker.invoke(void, 0xF4B2ED59DEB5D774, .{vehicle, bomb_count}); } // 0xF4B2ED59DEB5D774  b1180
    /// Gets the amount of bombs that this vehicle has. As far as I know, this does _not_ impact vehicle weapons or the ammo of those weapons in any way, it is just a way to keep track of the amount of bombs in a specific plane.
    pub inline fn getVehicleBombAmmo(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xEA12BD130D7569A1, .{vehicle}); } // 0xEA12BD130D7569A1  b1180
    /// Similar to SET_VEHICLE_BOMB_AMMO, this sets the amount of countermeasures that are present on this vehicle. \
    /// Use GET_VEHICLE_BOMB_AMMO to get the current amount.
    pub inline fn setVehicleCountermeasureAmmo(vehicle: types.Vehicle, counter_measure_count: c_int) !void { try invoker.invoke(void, 0x9BDA23BF666F0855, .{vehicle, counter_measure_count}); } // 0x9BDA23BF666F0855  b1180
    /// Similar to `GET_VEHICLE_BOMB_AMMO`, this gets the amount of countermeasures that are present on this vehicle. \
    /// Use SET_VEHICLE_COUNTERMEASURE_AMMO to set the current amount.
    pub inline fn getVehicleCountermeasureAmmo(vehicle: types.Vehicle) !c_int { return try invoker.invoke(c_int, 0xF846AA63DF56B804, .{vehicle}); } // 0xF846AA63DF56B804  b1180
    pub inline fn setHeliCombatOffset(vehicle: types.Vehicle, vec: types.Vector3) !void { try invoker.invoke(void, 0x0A3F820A9A9A9AC5, .{vehicle, vec.x, vec.y, vec.z}); } // 0x0A3F820A9A9A9AC5  b1180
    /// Used in decompiled scripts in combination with GET_VEHICLE_SIZE \
    /// p7 is usually 2 \
    /// p8 is usually 1
    pub inline fn getCanVehicleBePlacedHere(vehicle: types.Vehicle, vec: types.Vector3, rot__: types.Vector3, p_7: c_int, p_8: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x51F30DB60626A20E, .{vehicle, vec.x, vec.y, vec.z, rot__.x, rot__.y, rot__.z, p_7, p_8}); } // 0x51F30DB60626A20E  b1180
    /// Sets a flag on heli and another vehicle type.
    pub inline fn setDisableAutomaticCrashTask(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x97841634EF7DF1D6, .{vehicle, toggle}); } // 0x97841634EF7DF1D6  b1180
    /// Used in conjunction with SET_SPECIAL_FLIGHT_MODE_TARGET_RATIO, in Rockstar's scripts. Using this will instantly transform the vehicle into hover mode starting from the given ratio (ranging from 0.0 to 1.0, values greater than 1.0 will put the vehicle into a glitched state.) If this is not used alongside SET_SPECIAL_FLIGHT_MODE_TARGET_RATIO, the vehicle will automatically transform back into car mode.
    /// 
    /// Usable only with the deluxo and other vehicles with deluxo-like hover mode toggle, modded or otherwise. Does nothing when used on oppressor2.
    /// 
    /// Example: \
    /// Ped playerPed = PLAYER::PLAYER_PED_ID(); \
    /// Vehicle veh = PED::GET_VEHICLE_PED_IS_USING(playerPed); \
    /// VEHICLE::SET_SPECIAL_FLIGHT_MODE_RATIO(veh, 0.7f); \
    /// VEHICLE::SET_SPECIAL_FLIGHT_MODE_TARGET_RATIO(veh, 1.0f);
    pub inline fn setSpecialFlightModeRatio(vehicle: types.Vehicle, ratio: f32) !void { try invoker.invoke(void, 0xD138FA15C9776837, .{vehicle, ratio}); } // 0xD138FA15C9776837  b1290
    /// Used in conjunction with SET_SPECIAL_FLIGHT_MODE_RATIO, in Rockstar's scripts. The vehicle will transform into the given targetRatio, starting from the vehicle's current hover mode transform ratio (which can also be manually set by SET_SPECIAL_FLIGHT_MODE_RATIO,) i.e. setting targetRatio to 0.0 while the vehicle is in hover mode will transform the vehicle into car mode, likewise setting targetRatio to 1.0 while the vehicle is in car mode will transform the vehicle into hover mode, and if the current transform ratio is set to 0.7 while targetRatio is 1.0 the vehicle will transform into hover mode starting from being already partially transformed.
    /// 
    /// targetRatio is recommended to always be 0.0 or 1.0, otherwise the vehicle will transform into a glitched state.
    /// 
    /// Usable only with the deluxo and other vehicles with deluxo-like hover mode toggle, modded or otherwise. Does nothing when used on oppressor2.
    /// 
    /// Example: \
    /// Ped playerPed = PLAYER::PLAYER_PED_ID(); \
    /// Vehicle veh = PED::GET_VEHICLE_PED_IS_USING(playerPed); \
    /// VEHICLE::SET_SPECIAL_FLIGHT_MODE_RATIO(veh, 0.7f); \
    /// VEHICLE::SET_SPECIAL_FLIGHT_MODE_TARGET_RATIO(veh, 1.0f);
    pub inline fn setSpecialFlightModeTargetRatio(vehicle: types.Vehicle, target_ratio: f32) !void { try invoker.invoke(void, 0x438B3D7CA026FE91, .{vehicle, target_ratio}); } // 0x438B3D7CA026FE91  b1290
    /// It will override the ability to transform deluxo. For oppressor it will work just like SET_DISABLE_HOVER_MODE_FLIGHT
    pub inline fn setSpecialFlightModeAllowed(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xF1211889DF15A763, .{vehicle, toggle}); } // 0xF1211889DF15A763  b1290
    /// Disables "wings" for some flying vehicles. Works only for oppressor _2_ and deluxo. \
    /// For deluxo it just immediately removes vehicle's "wings" and you will be not able to fly up. \
    /// For oppressor 2 it will remove wings right after you land. And you will not able to fly up anymore too. \
    /// But for opressor 2 you still can fly if you somehow get back in the air.
    pub inline fn setDisableHoverModeFlight(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2D55FE374D5FDB91, .{vehicle, toggle}); } // 0x2D55FE374D5FDB91  b1290
    /// Checks if Chernobog's stabilizers are deployed or not. \
    /// These are the metal supports that allow it to fire. \
    /// This native only applies to the Chernobog.
    pub inline fn getOutriggersDeployed(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3A9128352EAC9E85, .{vehicle}); } // 0x3A9128352EAC9E85  b1290
    /// Native is significantly more complicated than simply generating a random vector & length. \
    /// The 'point' is either 400.0 or 250.0 units away from the Ped's current coordinates; and paths into functions like rage::grcViewport___IsSphereVisible
    pub inline fn findSpawnCoordinatesForHeli(ped: types.Ped) !types.Vector3 { return try invoker.invoke(types.Vector3, 0x8DC9675797123522, .{ped}); } // 0x8DC9675797123522  b1290
    /// Only used with the "akula" and "annihilator2" in the decompiled native scripts.
    pub inline fn setDeployFoldingWings(vehicle: types.Vehicle, deploy: windows.BOOL, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xB251E0B33E58B424, .{vehicle, deploy, p_2}); } // 0xB251E0B33E58B424  b1290
    /// Only used with the "akula" and "annihilator2" in the decompiled native scripts.
    pub inline fn areFoldingWingsDeployed(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xAEF12960FA943792, .{vehicle}); } // 0xAEF12960FA943792  b1290
    pub inline fn setDeployMissileBays_(vehicle: types.Vehicle, deploy: windows.BOOL) !void { try invoker.invoke(void, 0x0C02468829E4AA65, .{vehicle, deploy}); } // 0x0C02468829E4AA65  b2944
    pub inline fn areMissileBaysDeployed_(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xEA4743874D515F13, .{vehicle}); } // 0xEA4743874D515F13  b2944
    pub inline fn setDipStraightDownWhenCrashingPlane(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAA653AE61924B0A0, .{vehicle, toggle}); } // 0xAA653AE61924B0A0  b1290
    /// Toggles specific flag on turret
    pub inline fn setTurretHidden(vehicle: types.Vehicle, index: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC60060EB0D8AC7B1, .{vehicle, index, toggle}); } // 0xC60060EB0D8AC7B1  b1290
    pub inline fn setHoverModeWingRatio(vehicle: types.Vehicle, ratio: f32) !void { try invoker.invoke(void, 0x70A252F60A3E036B, .{vehicle, ratio}); } // 0x70A252F60A3E036B  b1365
    /// Disables turret movement when called in a loop. You can still fire and aim. You cannot shoot backwards though.
    pub inline fn setDisableTurretMovement(vehicle: types.Vehicle, turret_id: c_int) !void { try invoker.invoke(void, 0xE615BB7A7752C76A, .{vehicle, turret_id}); } // 0xE615BB7A7752C76A  b1365
    pub inline fn setForceFixLinkMatrices(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x887FA38787DE8C72, .{vehicle}); } // 0x887FA38787DE8C72  b1365
    /// Affects the playback speed of the submarine car conversion animations. Does not affect hardcoded animations such as the wheels being retracted.
    pub inline fn setTransformRateForAnimation(vehicle: types.Vehicle, transform_rate: f32) !void { try invoker.invoke(void, 0x498218259FB7C72D, .{vehicle, transform_rate}); } // 0x498218259FB7C72D  b1365
    /// When set to true, the key to transform a car to submarine mode changes from raise/lower convertible roof (hold H by default) to special vehicle transform (press X by default.)
    pub inline fn setTransformToSubmarineUsesAlternateInput(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x41B9FB92EDED32A6, .{vehicle, toggle}); } // 0x41B9FB92EDED32A6  b1365
    /// Does nothing. It's a nullsub.
    pub inline fn setVehicleCombatMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x36DE109527A2C0C4, .{toggle}); } // 0x36DE109527A2C0C4  b1604
    /// Does nothing. It's a nullsub.
    pub inline fn setVehicleDetonationMode(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x82E0AC411E41A5B4, .{toggle}); } // 0x82E0AC411E41A5B4  b1604
    /// Does nothing. It's a nullsub.
    pub inline fn setVehicleShuntOnStick(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x99A05839C46CE316, .{toggle}); } // 0x99A05839C46CE316  b1604
    pub inline fn isVehicleOnBoostPad_(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71C6302CBCA6CA35, .{vehicle}); } // 0x71C6302CBCA6CA35  b3407
    pub inline fn getIsVehicleShunting(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xA2459F72C14E2E8D, .{vehicle}); } // 0xA2459F72C14E2E8D  b1604
    pub inline fn getHasVehicleBeenHitByShunt(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE8718FAF591FD224, .{vehicle}); } // 0xE8718FAF591FD224  b1604
    /// Returns last vehicle that was rammed by the given vehicle using the shunt boost.
    pub inline fn getLastShuntVehicle(vehicle: types.Vehicle) !types.Vehicle { return try invoker.invoke(types.Vehicle, 0x04F2FA6E234162F7, .{vehicle}); } // 0x04F2FA6E234162F7  b1604
    pub inline fn setDisableVehicleExplosionsDamage(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x143921E45EC44D62, .{toggle}); } // 0x143921E45EC44D62  b1604
    pub inline fn setOverrideNitrousLevel(vehicle: types.Vehicle, toggle: windows.BOOL, level: f32, power: f32, recharge_time: f32, disable_sound: windows.BOOL) !void { try invoker.invoke(void, 0xC8E9B6B71B8E660D, .{vehicle, toggle, level, power, recharge_time, disable_sound}); } // 0xC8E9B6B71B8E660D  b1604
    pub inline fn setNitrousIsVisible_(vehicle: types.Vehicle, enabled: windows.BOOL) !void { try invoker.invoke(void, 0x465EEA70AF251045, .{vehicle, enabled}); } // 0x465EEA70AF251045  b3095
    pub inline fn setOverrideTractionLossMultiplier_(vehicle: types.Vehicle, modifier: f32) !void { try invoker.invoke(void, 0xAFD262ACCA64479A, .{vehicle, modifier}); } // 0xAFD262ACCA64479A  b3095
    /// First two floats relate to rumble, the last is a threshold
    pub inline fn setDriftSlipAngleLimits_(vehicle: types.Vehicle, duration_scalar: f32, amplitude_scalar: f32, slip_angle_limit: f32) !void { try invoker.invoke(void, 0xDAF4C98C18AC6F06, .{vehicle, duration_scalar, amplitude_scalar, slip_angle_limit}); } // 0xDAF4C98C18AC6F06  b3095
    pub inline fn setMinimumTimeBetweenGearShifts_(vehicle: types.Vehicle, time: c_int) !void { try invoker.invoke(void, 0x16CFBC5E7EB32861, .{vehicle, time}); } // 0x16CFBC5E7EB32861  b3095
    pub inline fn fullyChargeNitrous(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x1A2BCC8C636F9226, .{vehicle}); } // 0x1A2BCC8C636F9226  b3095
    pub inline fn setRemainingNitrousDuration_(vehicle: types.Vehicle, duration: f32) !void { try invoker.invoke(void, 0x1AD0F63A94E10EFF, .{vehicle, duration}); } // 0x1AD0F63A94E10EFF  b3407
    pub inline fn getRemainingNitrousDuration_(vehicle: types.Vehicle) !f32 { return try invoker.invoke(f32, 0xBEC4B8653462450E, .{vehicle}); } // 0xBEC4B8653462450E  b3095
    pub inline fn isNitrousActive(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x491E822B2C464FE4, .{vehicle}); } // 0x491E822B2C464FE4  b3095
    pub inline fn clearNitrous(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0xC889AE921400E1ED, .{vehicle}); } // 0xC889AE921400E1ED  b3095
    pub inline fn setNitrousIsActive(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x9E566EA551F4F1A6, .{vehicle, toggle}); } // 0x9E566EA551F4F1A6  b3407
    pub inline fn setIncreaseWheelCrushDamage(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x2970EAA18FD5E42F, .{vehicle, toggle}); } // 0x2970EAA18FD5E42F  b1604
    /// Sets some global vehicle related bool
    pub inline fn setDisableWeaponBladeForces(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x211E95CE9903940C, .{toggle}); } // 0x211E95CE9903940C  b1604
    /// Changes the car jump control to require a double-tap to activate.
    pub inline fn setUseDoubleClickForCarJump(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5BBCF35BF6E456F7, .{toggle}); } // 0x5BBCF35BF6E456F7  b1604
    /// Returns true only if the "tombstone" bone is attached to the vehicle, irrespective of "FLAG_HAS_TOMBSTONE" being present or not. Detaching the tombstone will return false.
    pub inline fn getDoesVehicleHaveTombstone(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x71AFB258CCED3A27, .{vehicle}); } // 0x71AFB258CCED3A27  b1604
    /// Disables detachable bumber from domnator4, dominator5, dominator6, see https://gfycat.com/SecondUnluckyGosling
    pub inline fn hideTombstone(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xAE71FB656C600587, .{vehicle, toggle}); } // 0xAE71FB656C600587  b1604
    pub inline fn applyEmpEffect(vehicle: types.Vehicle) !void { try invoker.invoke(void, 0x249249D74F813EB2, .{vehicle}); } // 0x249249D74F813EB2  b3095
    /// Returns whether this vehicle is currently disabled by an EMP mine.
    pub inline fn getIsVehicleDisabledByEmp(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0506ED94363AD905, .{vehicle}); } // 0x0506ED94363AD905  b1604
    pub inline fn setDisableRetractingWeaponBlades(toggle: windows.BOOL) !void { try invoker.invoke(void, 0x8F0D5BA1C2CC91D7, .{toggle}); } // 0x8F0D5BA1C2CC91D7  b1604
    /// Usable wheels: \
    /// 0: wheel_lf \
    /// 1: wheel_rf \
    /// 2: wheel_lm1 \
    /// 3: wheel_rm1 \
    /// 4: wheel_lr \
    /// 5: wheel_rr
    pub inline fn getTyreHealth(vehicle: types.Vehicle, wheel_index: c_int) !f32 { return try invoker.invoke(f32, 0x55EAB010FAEE9380, .{vehicle, wheel_index}); } // 0x55EAB010FAEE9380  b1868
    /// SET_TYRE_WEAR_RATE must be active, otherwise values set to <1000.0f will default to 350.0f
    /// 
    /// Usable wheels: \
    /// 0: wheel_lf \
    /// 1: wheel_rf \
    /// 2: wheel_lm1 \
    /// 3: wheel_rm1 \
    /// 4: wheel_lr \
    /// 5: wheel_rr
    pub inline fn setTyreHealth(vehicle: types.Vehicle, wheel_index: c_int, health: f32) !void { try invoker.invoke(void, 0x74C68EF97645E79D, .{vehicle, wheel_index, health}); } // 0x74C68EF97645E79D  b1868
    /// Returns the multiplier value from SET_TYRE_WEAR_RATE
    /// 
    /// Usable wheels: \
    /// 0: wheel_lf \
    /// 1: wheel_rf \
    /// 2: wheel_lm1 \
    /// 3: wheel_rm1 \
    /// 4: wheel_lr \
    /// 5: wheel_rr
    pub inline fn getTyreWearRate(vehicle: types.Vehicle, wheel_index: c_int) !f32 { return try invoker.invoke(f32, 0x6E387895952F4F71, .{vehicle, wheel_index}); } // 0x6E387895952F4F71  b2060
    /// Needs to be run for tire wear to work. Multiplier affects the downforce and how fast the tires will wear out, higher values essentially make the vehicle slower on straights and its tires will wear down quicker when cornering. Value must be >0f. \
    /// Default value in Rockstar's Open Wheel Race JSON's ("owrtws", "owrtwm", "owrtwh") is 1.0
    /// 
    /// Usable wheels: \
    /// 0: wheel_lf \
    /// 1: wheel_rf \
    /// 2: wheel_lm1 \
    /// 3: wheel_rm1 \
    /// 4: wheel_lr \
    /// 5: wheel_rr
    pub inline fn setTyreWearRate(vehicle: types.Vehicle, wheel_index: c_int, multiplier: f32) !void { try invoker.invoke(void, 0x01894E2EDE923CA2, .{vehicle, wheel_index, multiplier}); } // 0x01894E2EDE923CA2  b1868
    /// Controls how fast the tires wear out.
    /// 
    /// Default values from Rockstar's Open Wheel Race JSON's: \
    /// "owrtss" (Soft): 2.2 \
    /// "owrtsm" (Medium): 1.7 \
    /// "owrtsh" (Hard): 1.2
    /// 
    /// Usable wheels: \
    /// 0: wheel_lf \
    /// 1: wheel_rf \
    /// 2: wheel_lm1 \
    /// 3: wheel_rm1 \
    /// 4: wheel_lr \
    /// 5: wheel_rr
    pub inline fn setTyreWearRateScale(vehicle: types.Vehicle, wheel_index: c_int, multiplier: f32) !void { try invoker.invoke(void, 0x392183BB9EA57697, .{vehicle, wheel_index, multiplier}); } // 0x392183BB9EA57697  b2060
    /// Controls how much traction the wheel loses.
    /// 
    /// Default values from Rockstar's Open Wheel Race JSON's: \
    /// "owrtds" (Soft): 0.05 \
    /// "owrtdm" (Medium): 0.45 \
    /// "owrtdh" (Hard): 0.8
    /// 
    /// Usable wheels: \
    /// 0: wheel_lf \
    /// 1: wheel_rf \
    /// 2: wheel_lm1 \
    /// 3: wheel_rm1 \
    /// 4: wheel_lr \
    /// 5: wheel_rr
    pub inline fn setTyreMaximumGripDifferenceDueToWearRate(vehicle: types.Vehicle, wheel_index: c_int, multiplier: f32) !void { try invoker.invoke(void, 0xC970D0E0FC31D768, .{vehicle, wheel_index, multiplier}); } // 0xC970D0E0FC31D768  b2060
    pub inline fn setAircraftIgnoreHightmapOptimisation(vehicle: types.Vehicle, p_1: c_int) !void { try invoker.invoke(void, 0xF8B49F5BA7F850E7, .{vehicle, p_1}); } // 0xF8B49F5BA7F850E7  b2060
    /// Lowers the vehicle's stance. Only works for vehicles that have strAdvancedFlags 0x8000 and 0x4000000 set.
    pub inline fn setReducedSuspensionForce(vehicle: types.Vehicle, enable: windows.BOOL) !void { try invoker.invoke(void, 0x3A375167F5782A65, .{vehicle, enable}); } // 0x3A375167F5782A65  b2372
    pub inline fn setDriftTyres(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x5AC79C98C5C17F05, .{vehicle, toggle}); } // 0x5AC79C98C5C17F05  b2372
    pub inline fn getDriftTyresSet(vehicle: types.Vehicle) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2F5A72430E78C8D3, .{vehicle}); } // 0x2F5A72430E78C8D3  b2372
    /// Implemented only for trains.
    pub inline fn networkUseHighPrecisionTrainBlending(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEC0C1D4922AF9754, .{vehicle, toggle}); } // 0xEC0C1D4922AF9754  b2372
    /// Only used in R* Script fm_content_cargo
    pub inline fn setCheckForEnoughRoomForPed(vehicle: types.Vehicle, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xEF9D388F8D377F44, .{vehicle, p_1}); } // 0xEF9D388F8D377F44  b2699
    /// _SET_ALLOW_R* - _SET_ALLOW_V*
    pub inline fn setAllowCollisionWhenInVehicle_(vehicle: types.Vehicle, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x27D27223E8EF22ED, .{vehicle, toggle}); } // 0x27D27223E8EF22ED  b3095
    pub inline fn isVehicleGen9ExclusiveModel_(vehicle_model: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6638C0F19DE692FE, .{vehicle_model}); } // 0x6638C0F19DE692FE  b3095
    pub inline fn getVehicleMaxExhaustBoneCount_() !c_int { return try invoker.invoke(c_int, 0x3EE18B00CD86C54F, .{}); } // 0x3EE18B00CD86C54F  b3095
    pub inline fn getVehicleExhaustBone_(vehicle: types.Vehicle, index: c_int, bone_index: [*c]c_int, axis_x: [*c]windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xE728F090D538CB18, .{vehicle, index, bone_index, axis_x}); } // 0xE728F090D538CB18  b3095
};

pub const Water = struct
{
    /// This function set height to the value of z-axis of the water surface.
    /// 
    /// This function works with sea and lake. However it does not work with shallow rivers (e.g. raton canyon will return -100000.0f)
    /// 
    /// note: seems to return true when you are in water
    pub inline fn getWaterHeight(vec: types.Vector3, height: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF6829842C06AE524, .{vec.x, vec.y, vec.z, height}); } // 0xF6829842C06AE524 0xD864E17C b323
    pub inline fn getWaterHeightNoWaves(vec: types.Vector3, height: [*c]f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8EE6B53CE13A9794, .{vec.x, vec.y, vec.z, height}); } // 0x8EE6B53CE13A9794 0x262017F8 b323
    pub inline fn testProbeAgainstWater(vec_1__: types.Vector3, vec_2__: types.Vector3, result: [*c]types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xFFA5D878809819DB, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, result}); } // 0xFFA5D878809819DB 0xAA4AE00C b323
    /// enum eScriptWaterTestResult \
    /// { \
    ///     SCRIPT_WATER_TEST_RESULT_NONE,
    ///     SCRIPT_WATER_TEST_RESULT_WATER,
    ///     SCRIPT_WATER_TEST_RESULT_BLOCKED,
    /// };
    pub inline fn testProbeAgainstAllWater(vec_1__: types.Vector3, vec_2__: types.Vector3, flags: c_int, water_height: [*c]f32) !c_int { return try invoker.invoke(c_int, 0x8974647ED222EA5F, .{vec_1__.x, vec_1__.y, vec_1__.z, vec_2__.x, vec_2__.y, vec_2__.z, flags, water_height}); } // 0x8974647ED222EA5F 0x4A962D55 b323
    /// See TEST_PROBE_AGAINST_ALL_WATER.
    pub inline fn testVerticalProbeAgainstAllWater(vec: types.Vector3, flags: c_int, water_height: [*c]f32) !c_int { return try invoker.invoke(c_int, 0x2B3451FA1E3142E2, .{vec.x, vec.y, vec.z, flags, water_height}); } // 0x2B3451FA1E3142E2 0x4C71D143 b323
    /// Sets the water height for a given position and radius.
    /// 
    pub inline fn modifyWater(vec: types.Vector2, radius: f32, height: f32) !void { try invoker.invoke(void, 0xC443FD757C3BA637, .{vec.x, vec.y, radius, height}); } // 0xC443FD757C3BA637 0xC49E005A b323
    pub inline fn addExtraCalmingQuad(low__: types.Vector2, high__: types.Vector2, height: f32) !c_int { return try invoker.invoke(c_int, 0xFDBF4CDBC07E1706, .{low__.x, low__.y, high__.x, high__.y, height}); } // 0xFDBF4CDBC07E1706 0xA9419B6D b323
    /// p0 is the handle returned from ADD_EXTRA_CALMING_QUAD
    pub inline fn removeExtraCalmingQuad(calming_quad: c_int) !void { try invoker.invoke(void, 0xB1252E3E59A82AAF, .{calming_quad}); } // 0xB1252E3E59A82AAF 0x45268B6F b323
    /// Sets a value that determines how aggressive the ocean waves will be. Values of 2.0 or more make for very aggressive waves like you see during a thunderstorm.
    /// 
    /// Works only ~200 meters around the player.
    pub inline fn setDeepOceanScaler(intensity: f32) !void { try invoker.invoke(void, 0xB96B00E976BE977F, .{intensity}); } // 0xB96B00E976BE977F 0x53B694B1 b323
    /// Gets the aggressiveness factor of the ocean waves.
    pub inline fn getDeepOceanScaler() !f32 { return try invoker.invoke(f32, 0x2B2A2CC86778B619, .{}); } // 0x2B2A2CC86778B619 0xBD0A67FB b323
    pub inline fn setCalmedWaveHeightScaler(height: f32) !void { try invoker.invoke(void, 0x547237AA71AB44DE, .{height}); } // 0x547237AA71AB44DE  b573
    /// Sets the waves intensity back to original (1.0 in most cases).
    pub inline fn resetDeepOceanScaler() !void { try invoker.invoke(void, 0x5E5E99285AE812DB, .{}); } // 0x5E5E99285AE812DB 0x4AD23212 b323
};

pub const Weapon = struct
{
    /// Enables laser sight on any weapon.
    /// 
    /// It doesn't work. Neither on tick nor OnKeyDown
    pub inline fn enableLaserSightRendering(toggle: windows.BOOL) !void { try invoker.invoke(void, 0xC8B46D7727D864AA, .{toggle}); } // 0xC8B46D7727D864AA 0xE3438955 b323
    pub inline fn getWeaponComponentTypeModel(component_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0x0DB57B41EC1DB083, .{component_hash}); } // 0x0DB57B41EC1DB083 0x324FA47A b323
    /// Returns the model of any weapon.
    /// 
    /// Can also take an ammo hash? \
    /// sub_6663a(&l_115B, WEAPON::GET_WEAPONTYPE_MODEL(${ammo_rpg}));
    pub inline fn getWeapontypeModel(weapon_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0xF46CDC33180FDA94, .{weapon_hash}); } // 0xF46CDC33180FDA94 0x44E1C269 b323
    pub inline fn getWeapontypeSlot(weapon_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0x4215460B9B8B7FA0, .{weapon_hash}); } // 0x4215460B9B8B7FA0 0x2E3759AF b323
    pub inline fn getWeapontypeGroup(weapon_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0xC3287EE3050FB74C, .{weapon_hash}); } // 0xC3287EE3050FB74C 0x5F2DE833 b323
    /// Returns the amount of extra components the specified component has. \
    /// Returns -1 if the component isn't of type CWeaponComponentVariantModel.
    pub inline fn getWeaponComponentVariantExtraCount(component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x6558AC7C17BFEF58, .{component_hash}); } // 0x6558AC7C17BFEF58  b372
    /// Returns the model hash of the extra component at specified index.
    pub inline fn getWeaponComponentVariantExtraModel(component_hash: types.Hash, extra_component_index: c_int) !types.Hash { return try invoker.invoke(types.Hash, 0x4D1CB8DC40208A17, .{component_hash, extra_component_index}); } // 0x4D1CB8DC40208A17  b372
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setCurrentPedWeapon(ped: types.Ped, weapon_hash: types.Hash, b_force_in_hand: windows.BOOL) !void { try invoker.invoke(void, 0xADF692B254977C0C, .{ped, weapon_hash, b_force_in_hand}); } // 0xADF692B254977C0C 0xB8278882 b323
    /// The return value seems to indicate returns true if the hash of the weapon object weapon equals the weapon hash. \
    /// p2 seems to be 1 most of the time.
    /// 
    /// 
    /// 
    /// 
    /// 
    /// p2 is not implemented
    /// 
    /// disassembly said that?
    /// 
    pub inline fn getCurrentPedWeapon(ped: types.Ped, weapon_hash: [*c]types.Hash, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x3A87E44BB9A01D54, .{ped, weapon_hash, p_2}); } // 0x3A87E44BB9A01D54 0xB0237302 b323
    pub inline fn getCurrentPedWeaponEntityIndex(ped: types.Ped, p_1: types.Any) !types.Entity { return try invoker.invoke(types.Entity, 0x3B390A939AF0B5FC, .{ped, p_1}); } // 0x3B390A939AF0B5FC 0x5D73CD20 b323
    /// p1 is always 0 in the scripts.
    pub inline fn getBestPedWeapon(ped: types.Ped, p_1: windows.BOOL) !types.Hash { return try invoker.invoke(types.Hash, 0x8483E98E8B888AE2, .{ped, p_1}); } // 0x8483E98E8B888AE2 0xB998D444 b323
    /// Full list of weapons by DurtyFree (Search for VEHICLE_*): https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setCurrentPedVehicleWeapon(ped: types.Ped, weapon_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x75C55983C2C39DAA, .{ped, weapon_hash}); } // 0x75C55983C2C39DAA 0x8E6F2AF1 b323
    /// Example in VB
    /// 
    ///     Public Shared Function GetVehicleCurrentWeapon(Ped As Ped) As Integer
    ///         Dim arg As New OutputArgument()
    ///         Native.Function.Call(Hash.GET_CURRENT_PED_VEHICLE_WEAPON, Ped, arg)
    ///         Return arg.GetResult(Of Integer)()
    ///     End Function
    /// 
    /// Usage: \
    /// If GetVehicleCurrentWeapon(Game.Player.Character) = -821520672 Then ...Do something \
    /// Note: -821520672 = VEHICLE_WEAPON_PLANE_ROCKET
    pub inline fn getCurrentPedVehicleWeapon(ped: types.Ped, weapon_hash: [*c]types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x1017582BCD3832DC, .{ped, weapon_hash}); } // 0x1017582BCD3832DC 0xF26C5D65 b323
    pub inline fn setPedCycleVehicleWeaponsOnly(ped: types.Ped) !void { try invoker.invoke(void, 0x50276EF8172F5F12, .{ped}); } // 0x50276EF8172F5F12  b1734
    /// Checks if the ped is currently equipped with a weapon matching a bit specified using a bitwise-or in typeFlags.
    /// 
    /// Type flag bit values: \
    /// 1 = Melee weapons \
    /// 2 = Explosive weapons \
    /// 4 = Any other weapons
    /// 
    /// Not specifying any bit will lead to the native *always* returning 'false', and for example specifying '4 | 2' will check for any weapon except fists and melee weapons. \
    /// 7 returns true if you are equipped with any weapon except your fists. \
    /// 6 returns true if you are equipped with any weapon except melee weapons. \
    /// 5 returns true if you are equipped with any weapon except the Explosives weapon group. \
    /// 4 returns true if you are equipped with any weapon except Explosives weapon group AND melee weapons. \
    /// 3 returns true if you are equipped with either Explosives or Melee weapons (the exact opposite of 4). \
    /// 2 returns true only if you are equipped with any weapon from the Explosives weapon group. \
    /// 1 returns true only if you are equipped with any Melee weapon. \
    /// 0 never returns true.
    /// 
    /// Note: When I say "Explosives weapon group", it does not include the Jerry can and Fire Extinguisher.
    pub inline fn isPedArmed(ped: types.Ped, type_flags: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x475768A975D5AD17, .{ped, type_flags}); } // 0x475768A975D5AD17 0x0BFC892C b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn isWeaponValid(weapon_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x937C71165CF334B3, .{weapon_hash}); } // 0x937C71165CF334B3 0x38CA2954 b323
    /// p2 should be FALSE, otherwise it seems to always return FALSE
    /// 
    /// Bool does not check if the weapon is current equipped, unfortunately. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn hasPedGotWeapon(ped: types.Ped, weapon_hash: types.Hash, p_2: windows.BOOL) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8DECB02F88F428BC, .{ped, weapon_hash, p_2}); } // 0x8DECB02F88F428BC 0x43D2FA82 b323
    pub inline fn isPedWeaponReadyToShoot(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB80CA294F2F26749, .{ped}); } // 0xB80CA294F2F26749 0x02A32CB0 b323
    pub inline fn getPedWeapontypeInSlot(ped: types.Ped, weapon_slot: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0xEFFED78E9011134D, .{ped, weapon_slot}); } // 0xEFFED78E9011134D 0x9BC64E16 b323
    /// WEAPON::GET_AMMO_IN_PED_WEAPON(PLAYER::PLAYER_PED_ID(), a_0)
    /// 
    /// From decompiled scripts \
    /// Returns total ammo in weapon
    /// 
    /// GTALua Example : \
    /// natives.WEAPON.GET_AMMO_IN_PED_WEAPON(plyPed, WeaponHash) \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getAmmoInPedWeapon(ped: types.Ped, weaponhash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x015A522136D7F951, .{ped, weaponhash}); } // 0x015A522136D7F951 0x0C755733 b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn addAmmoToPed(ped: types.Ped, weapon_hash: types.Hash, ammo: c_int) !void { try invoker.invoke(void, 0x78F0424C34306220, .{ped, weapon_hash, ammo}); } // 0x78F0424C34306220 0x7F0580C7 b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setPedAmmo(ped: types.Ped, weapon_hash: types.Hash, ammo: c_int, p_3: windows.BOOL) !void { try invoker.invoke(void, 0x14E56BC5B5DB6A19, .{ped, weapon_hash, ammo, p_3}); } // 0x14E56BC5B5DB6A19 0xBF90DF1A b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setPedInfiniteAmmo(ped: types.Ped, toggle: windows.BOOL, weapon_hash: types.Hash) !void { try invoker.invoke(void, 0x3EDCB0505123623B, .{ped, toggle, weapon_hash}); } // 0x3EDCB0505123623B 0x9CB8D278 b323
    pub inline fn setPedInfiniteAmmoClip(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x183DADC6AA953186, .{ped, toggle}); } // 0x183DADC6AA953186 0x5A5E3B67 b323
    pub inline fn setPedStunGunFiniteAmmo(p_0: types.Any, p_1: types.Any) !void { try invoker.invoke(void, 0x24C024BA8379A70A, .{p_0, p_1}); } // 0x24C024BA8379A70A  b1868
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn giveWeaponToPed(ped: types.Ped, weapon_hash: types.Hash, ammo_count: c_int, is_hidden: windows.BOOL, b_force_in_hand: windows.BOOL) !void { try invoker.invoke(void, 0xBF0FD6E56C964FCB, .{ped, weapon_hash, ammo_count, is_hidden, b_force_in_hand}); } // 0xBF0FD6E56C964FCB 0xC4D88A85 b323
    /// Gives a weapon to PED with a delay, example:
    /// 
    /// WEAPON::GIVE_DELAYED_WEAPON_TO_PED(PED::PLAYER_PED_ID(), MISC::GET_HASH_KEY("WEAPON_PISTOL"), 1000, false) \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn giveDelayedWeaponToPed(ped: types.Ped, weapon_hash: types.Hash, ammo_count: c_int, b_force_in_hand: windows.BOOL) !void { try invoker.invoke(void, 0xB282DC6EBD803C75, .{ped, weapon_hash, ammo_count, b_force_in_hand}); } // 0xB282DC6EBD803C75 0x5868D20D b323
    /// setting the last params to false it does that same so I would suggest its not a toggle
    pub inline fn removeAllPedWeapons(ped: types.Ped, p_1: windows.BOOL) !void { try invoker.invoke(void, 0xF25DF915FA38C5F3, .{ped, p_1}); } // 0xF25DF915FA38C5F3 0xA44CE817 b323
    /// This native removes a specified weapon from your selected ped.
    /// 
    /// Example: \
    /// C#: \
    /// Function.Call(Hash.REMOVE_WEAPON_FROM_PED, Game.Player.Character, 0x99B507EA);
    /// 
    /// C++: \
    /// WEAPON::REMOVE_WEAPON_FROM_PED(PLAYER::PLAYER_PED_ID(), 0x99B507EA);
    /// 
    /// The code above removes the knife from the player. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn removeWeaponFromPed(ped: types.Ped, weapon_hash: types.Hash) !void { try invoker.invoke(void, 0x4899CB088EDF59B8, .{ped, weapon_hash}); } // 0x4899CB088EDF59B8 0x9C37F220 b323
    /// Hides the players weapon during a cutscene.
    pub inline fn hidePedWeaponForScriptedCutscene(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x6F6981D2253C208F, .{ped, toggle}); } // 0x6F6981D2253C208F 0x00CFD6E9 b323
    /// Has 5 parameters since latest patches.
    pub inline fn setPedCurrentWeaponVisible(ped: types.Ped, visible: windows.BOOL, deselect_weapon: windows.BOOL, p_3: windows.BOOL, p_4: windows.BOOL) !void { try invoker.invoke(void, 0x0725A4CCFDED9A70, .{ped, visible, deselect_weapon, p_3, p_4}); } // 0x0725A4CCFDED9A70 0x00BECD77 b323
    pub inline fn setPedDropsWeaponsWhenDead(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x476AE72C1D19D1A8, .{ped, toggle}); } // 0x476AE72C1D19D1A8 0x8A444056 b323
    /// It determines what weapons caused damage:
    /// 
    /// If you want to define only a specific weapon, second parameter=weapon hash code, third parameter=0 \
    /// If you want to define any melee weapon, second parameter=0, third parameter=1. \
    /// If you want to identify any weapon (firearms, melee, rockets, etc.), second parameter=0, third parameter=2. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn hasPedBeenDamagedByWeapon(ped: types.Ped, weapon_hash: types.Hash, weapon_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2D343D2219CD027A, .{ped, weapon_hash, weapon_type}); } // 0x2D343D2219CD027A 0xCDFBBCC6 b323
    /// Does NOT seem to work with HAS_PED_BEEN_DAMAGED_BY_WEAPON. Use CLEAR_ENTITY_LAST_WEAPON_DAMAGE and HAS_ENTITY_BEEN_DAMAGED_BY_WEAPON instead.
    pub inline fn clearPedLastWeaponDamage(ped: types.Ped) !void { try invoker.invoke(void, 0x0E98F88A24C5F4B8, .{ped}); } // 0x0E98F88A24C5F4B8 0x52C68832 b323
    /// It determines what weapons caused damage:
    /// 
    /// If you want to define only a specific weapon, second parameter=weapon hash code, third parameter=0 \
    /// If you want to define any melee weapon, second parameter=0, third parameter=1. \
    /// If you want to identify any weapon (firearms, melee, rockets, etc.), second parameter=0, third parameter=2. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn hasEntityBeenDamagedByWeapon(entity: types.Entity, weapon_hash: types.Hash, weapon_type: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x131D401334815E94, .{entity, weapon_hash, weapon_type}); } // 0x131D401334815E94 0x6DAABB39 b323
    pub inline fn clearEntityLastWeaponDamage(entity: types.Entity) !void { try invoker.invoke(void, 0xAC678E40BE7C74D2, .{entity}); } // 0xAC678E40BE7C74D2 0xCEC2732B b323
    pub inline fn setPedDropsWeapon(ped: types.Ped) !void { try invoker.invoke(void, 0x6B7513D9966FBEC0, .{ped}); } // 0x6B7513D9966FBEC0 0x3D3329FA b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setPedDropsInventoryWeapon(ped: types.Ped, weapon_hash: types.Hash, offset__: types.Vector3, ammo_count: c_int) !void { try invoker.invoke(void, 0x208A1888007FC0E6, .{ped, weapon_hash, offset__.x, offset__.y, offset__.z, ammo_count}); } // 0x208A1888007FC0E6 0x81FFB874 b323
    /// p2 is mostly 1 in the scripts. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getMaxAmmoInClip(ped: types.Ped, weapon_hash: types.Hash, p_2: windows.BOOL) !c_int { return try invoker.invoke(c_int, 0xA38DCFFCEA8962FA, .{ped, weapon_hash, p_2}); } // 0xA38DCFFCEA8962FA 0x6961E2A4 b323
    pub inline fn getTimeBeforeVehicleWeaponReloadFinishes_(vehicle: types.Vehicle, seat: c_int) !c_int { return try invoker.invoke(c_int, 0xC8C6F4B1CDEB40EF, .{vehicle, seat}); } // 0xC8C6F4B1CDEB40EF  b3407
    pub inline fn hasWeaponReloadingInVehicle_(vehicle: types.Vehicle, seat: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8062F07153F4446F, .{vehicle, seat}); } // 0x8062F07153F4446F  b3407
    pub inline fn getVehicleWeaponReloadTime_(vehicle: types.Vehicle, seat: c_int) !f32 { return try invoker.invoke(f32, 0xD0AD348FFD7A6868, .{vehicle, seat}); } // 0xD0AD348FFD7A6868  b3407
    pub inline fn getAmmoInVehicleWeaponClip_(vehicle: types.Vehicle, seat: c_int, ammo: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2857938C5D407AFA, .{vehicle, seat, ammo}); } // 0x2857938C5D407AFA  b3407
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getAmmoInClip(ped: types.Ped, weapon_hash: types.Hash, ammo: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x2E1202248937775C, .{ped, weapon_hash, ammo}); } // 0x2E1202248937775C 0x73C100C3 b323
    pub inline fn setAmmoInVehicleWeaponClip_(vehicle: types.Vehicle, seat: c_int, ammo: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x873906720EE842C3, .{vehicle, seat, ammo}); } // 0x873906720EE842C3  b3407
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setAmmoInClip(ped: types.Ped, weapon_hash: types.Hash, ammo: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDCD2A934D65CB497, .{ped, weapon_hash, ammo}); } // 0xDCD2A934D65CB497 0xA54B0B10 b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getMaxAmmo(ped: types.Ped, weapon_hash: types.Hash, ammo: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDC16122C7A20C933, .{ped, weapon_hash, ammo}); } // 0xDC16122C7A20C933 0x0B294796 b323
    /// Returns the max ammo for an ammo type. Ammo types: https://gist.github.com/root-cause/faf41f59f7a6d818b7db0b839bd147c1
    pub inline fn getMaxAmmoByType(ped: types.Ped, ammo_type_hash: types.Hash, ammo: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x585847C5E4E11709, .{ped, ammo_type_hash, ammo}); } // 0x585847C5E4E11709  b1103
    /// Ammo types: https://gist.github.com/root-cause/faf41f59f7a6d818b7db0b839bd147c1
    pub inline fn addPedAmmoByType(ped: types.Ped, ammo_type_hash: types.Hash, ammo: c_int) !void { try invoker.invoke(void, 0x2472622CE1F2D45F, .{ped, ammo_type_hash, ammo}); } // 0x2472622CE1F2D45F  b1103
    /// Ammo types: https://gist.github.com/root-cause/faf41f59f7a6d818b7db0b839bd147c1
    pub inline fn setPedAmmoByType(ped: types.Ped, ammo_type_hash: types.Hash, ammo: c_int) !void { try invoker.invoke(void, 0x5FD1E1F011E76D7E, .{ped, ammo_type_hash, ammo}); } // 0x5FD1E1F011E76D7E 0x311C52BB b323
    pub inline fn getPedAmmoByType(ped: types.Ped, ammo_type_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x39D22031557946C1, .{ped, ammo_type_hash}); } // 0x39D22031557946C1 0x54077C4D b323
    pub inline fn setPedAmmoToDrop(ped: types.Ped, p_1: c_int) !void { try invoker.invoke(void, 0xA4EFEF9440A5B0EF, .{ped, p_1}); } // 0xA4EFEF9440A5B0EF 0x2386A307 b323
    pub inline fn setPickupAmmoAmountScaler(p_0: f32) !void { try invoker.invoke(void, 0xE620FD3512A04F18, .{p_0}); } // 0xE620FD3512A04F18 0xD6460EA2 b323
    /// Returns the current ammo type of the specified ped's specified weapon. \
    /// MkII magazines will change the return value, like Pistol MkII returning AMMO_PISTOL without any components and returning AMMO_PISTOL_TRACER after Tracer Rounds component is attached. \
    /// Use 0xF489B44DD5AF4BD9 if you always want AMMO_PISTOL. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getPedAmmoTypeFromWeapon(ped: types.Ped, weapon_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0x7FEAD38B326B9F74, .{ped, weapon_hash}); } // 0x7FEAD38B326B9F74 0x09337863 b323
    /// Returns the base/default ammo type of the specified ped's specified weapon. \
    /// Use GET_PED_AMMO_TYPE_FROM_WEAPON if you want current ammo type (like AMMO_MG_INCENDIARY/AMMO_MG_TRACER while using MkII magazines) and use this if you want base ammo type. (AMMO_MG) \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getPedOriginalAmmoTypeFromWeapon(ped: types.Ped, weapon_hash: types.Hash) !types.Hash { return try invoker.invoke(types.Hash, 0xF489B44DD5AF4BD9, .{ped, weapon_hash}); } // 0xF489B44DD5AF4BD9  b1103
    /// Pass ped. Pass address of Vector3. \
    /// The coord will be put into the Vector3. \
    /// The return will determine whether there was a coord found or not.
    pub inline fn getPedLastWeaponImpactCoord(ped: types.Ped, coords: [*c]types.Vector3) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x6C4D0409BA1A2BC2, .{ped, coords}); } // 0x6C4D0409BA1A2BC2 0x9B266079 b323
    /// p1/gadgetHash was always 0xFBAB5776 ("GADGET_PARACHUTE"). \
    /// p2 is always true.
    pub inline fn setPedGadget(ped: types.Ped, gadget_hash: types.Hash, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xD0D7B1E680ED4A1A, .{ped, gadget_hash, p_2}); } // 0xD0D7B1E680ED4A1A 0x8A256D0A b323
    /// gadgetHash - was always 0xFBAB5776 ("GADGET_PARACHUTE").
    pub inline fn getIsPedGadgetEquipped(ped: types.Ped, gadget_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xF731332072F5156C, .{ped, gadget_hash}); } // 0xF731332072F5156C 0x8DDD0B5B b323
    /// Returns the hash of the weapon. 
    /// 
    ///             var num7 = WEAPON::GET_SELECTED_PED_WEAPON(num4);
    ///             sub_27D3(num7);
    ///             switch (num7)
    ///             {
    ///                 case 0x24B17070:
    /// 
    /// Also see WEAPON::GET_CURRENT_PED_WEAPON. Difference?
    /// 
    /// -------------------------------------------------------------------------
    /// 
    /// The difference is that GET_SELECTED_PED_WEAPON simply returns the ped's current weapon hash but GET_CURRENT_PED_WEAPON also checks the weapon object and returns true if the hash of the weapon object equals the weapon hash \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getSelectedPedWeapon(ped: types.Ped) !types.Hash { return try invoker.invoke(types.Hash, 0x0A6DB4965674D243, .{ped}); } // 0x0A6DB4965674D243 0xD240123E b323
    ///              WEAPON::EXPLODE_PROJECTILES(PLAYER::PLAYER_PED_ID(), func_221(0x00000003), 0x00000001);
    pub inline fn explodeProjectiles(ped: types.Ped, weapon_hash: types.Hash, p_2: windows.BOOL) !void { try invoker.invoke(void, 0xFC4BD125DE7611E4, .{ped, weapon_hash, p_2}); } // 0xFC4BD125DE7611E4 0x35A0B955 b323
    /// If `explode` true, then removal is done through exploding the projectile. Basically the same as EXPLODE_PROJECTILES but without defining the owner ped.
    pub inline fn removeAllProjectilesOfType(weapon_hash: types.Hash, explode: windows.BOOL) !void { try invoker.invoke(void, 0xFC52E0F37E446528, .{weapon_hash, explode}); } // 0xFC52E0F37E446528 0xA5F89919 b323
    pub inline fn getLockonDistanceOfCurrentPedWeapon(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0x840F03E9041E2C9C, .{ped}); } // 0x840F03E9041E2C9C 0x3612110D b323
    pub inline fn getMaxRangeOfCurrentPedWeapon(ped: types.Ped) !f32 { return try invoker.invoke(f32, 0x814C9D19DFD69679, .{ped}); } // 0x814C9D19DFD69679 0xB2B2BBAA b323
    /// Fourth Parameter = unsure, almost always -1
    pub inline fn hasVehicleGotProjectileAttached(driver: types.Ped, vehicle: types.Vehicle, weapon_hash: types.Hash, p_3: types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x717C8481234E3B88, .{driver, vehicle, weapon_hash, p_3}); } // 0x717C8481234E3B88 0xA57E2E80 b323
    /// Full list of weapons & components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn giveWeaponComponentToPed(ped: types.Ped, weapon_hash: types.Hash, component_hash: types.Hash) !void { try invoker.invoke(void, 0xD966D51AA5B28BB9, .{ped, weapon_hash, component_hash}); } // 0xD966D51AA5B28BB9 0x3E1E286D b323
    /// Full list of weapons & components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn removeWeaponComponentFromPed(ped: types.Ped, weapon_hash: types.Hash, component_hash: types.Hash) !void { try invoker.invoke(void, 0x1E8BE90C74FB4C09, .{ped, weapon_hash, component_hash}); } // 0x1E8BE90C74FB4C09 0x412AA00D b323
    /// Full list of weapons & components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn hasPedGotWeaponComponent(ped: types.Ped, weapon_hash: types.Hash, component_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xC593212475FAE340, .{ped, weapon_hash, component_hash}); } // 0xC593212475FAE340 0xDC0FC145 b323
    /// Full list of weapons & components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn isPedWeaponComponentActive(ped: types.Ped, weapon_hash: types.Hash, component_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0D78DE0572D3969E, .{ped, weapon_hash, component_hash}); } // 0x0D78DE0572D3969E 0x7565FB19 b323
    pub inline fn refillAmmoInstantly(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x8C0D57EA686FAD87, .{ped}); } // 0x8C0D57EA686FAD87 0x82EEAF0F b323
    /// Forces a ped to reload only if they are able to; if they have a full magazine, they will not reload.
    pub inline fn makePedReload(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x20AE33F3AC9C0033, .{ped}); } // 0x20AE33F3AC9C0033 0x515292C2 b323
    pub inline fn triggerVehicleWeaponReload_(vehicle: types.Vehicle, seat: c_int, ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5B1513F27F279A44, .{vehicle, seat, ped}); } // 0x5B1513F27F279A44  b3407
    /// Nearly every instance of p1 I found was 31. Nearly every instance of p2 I found was 0.
    /// 
    /// REQUEST_WEAPON_ASSET(iLocal_1888, 31, 26);
    pub inline fn requestWeaponAsset(weapon_hash: types.Hash, p_1: c_int, p_2: c_int) !void { try invoker.invoke(void, 0x5443438F033E29C3, .{weapon_hash, p_1, p_2}); } // 0x5443438F033E29C3 0x65D139A5 b323
    pub inline fn hasWeaponAssetLoaded(weapon_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x36E353271F0E90EE, .{weapon_hash}); } // 0x36E353271F0E90EE 0x1891D5BB b323
    pub inline fn removeWeaponAsset(weapon_hash: types.Hash) !void { try invoker.invoke(void, 0xAA08EF13F341C8FC, .{weapon_hash}); } // 0xAA08EF13F341C8FC 0x2C0DFE3C b323
    /// Now has 8 params.
    pub inline fn createWeaponObject(weapon_hash: types.Hash, ammo_count: c_int, vec: types.Vector3, show_world_model: windows.BOOL, scale: f32, p_7: types.Any, p_8: types.Any, p_9: types.Any) !types.Object { return try invoker.invoke(types.Object, 0x9541D3CF0D398F36, .{weapon_hash, ammo_count, vec.x, vec.y, vec.z, show_world_model, scale, p_7, p_8, p_9}); } // 0x9541D3CF0D398F36 0x62F5987F b323
    /// componentHash: \
    /// (use WEAPON::GET_WEAPON_COMPONENT_TYPE_MODEL() to get hash value) \
    /// ${component_at_ar_flsh}, ${component_at_ar_supp}, ${component_at_pi_flsh}, ${component_at_scope_large}, ${component_at_ar_supp_02}
    pub inline fn giveWeaponComponentToWeaponObject(weapon_object: types.Object, component_hash: types.Hash) !void { try invoker.invoke(void, 0x33E179436C0B31DB, .{weapon_object, component_hash}); } // 0x33E179436C0B31DB 0xF7612A37 b323
    /// see DOES_WEAPON_TAKE_WEAPON_COMPONENT for full list of weapons & components
    pub inline fn removeWeaponComponentFromWeaponObject(object: types.Object, component_hash: types.Hash) !void { try invoker.invoke(void, 0xF7D82B0D66777611, .{object, component_hash}); } // 0xF7D82B0D66777611 0xA6E7ED3C b323
    /// see DOES_WEAPON_TAKE_WEAPON_COMPONENT for full list of weapons & components
    pub inline fn hasWeaponGotWeaponComponent(weapon: types.Object, component_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x76A18844E743BF91, .{weapon, component_hash}); } // 0x76A18844E743BF91 0x1D368510 b323
    pub inline fn giveWeaponObjectToPed(weapon_object: types.Object, ped: types.Ped) !void { try invoker.invoke(void, 0xB1FA61371AF7C4B7, .{weapon_object, ped}); } // 0xB1FA61371AF7C4B7 0x639AF3EF b323
    /// Full list of weapons & components by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn doesWeaponTakeWeaponComponent(weapon_hash: types.Hash, component_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x5CEE3DF569CECAB0, .{weapon_hash, component_hash}); } // 0x5CEE3DF569CECAB0 0xB1817BAA b323
    /// Drops the current weapon and returns the object
    /// 
    /// Unknown behavior when unarmed.
    pub inline fn getWeaponObjectFromPed(ped: types.Ped, p_1: windows.BOOL) !types.Object { return try invoker.invoke(types.Object, 0xCAE1DC9A0E22A16D, .{ped, p_1}); } // 0xCAE1DC9A0E22A16D 0xDF939A38 b323
    /// Gives the specified loadout to the specified ped.  \
    /// Loadouts are defined in common.rpf\data\ai\loadouts.meta
    pub inline fn giveLoadoutToPed(ped: types.Ped, loadout_hash: types.Hash) !void { try invoker.invoke(void, 0x68F8BE6AF5CDF8A6, .{ped, loadout_hash}); } // 0x68F8BE6AF5CDF8A6  b505
    /// tintIndex can be the following:
    /// 
    /// 0 - Normal \
    /// 1 - Green \
    /// 2 - Gold \
    /// 3 - Pink \
    /// 4 - Army \
    /// 5 - LSPD \
    /// 6 - Orange \
    /// 7 - Platinum \
    /// Full list of weapons, components & tint indexes by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setPedWeaponTintIndex(ped: types.Ped, weapon_hash: types.Hash, tint_index: c_int) !void { try invoker.invoke(void, 0x50969B9B89ED5738, .{ped, weapon_hash, tint_index}); } // 0x50969B9B89ED5738 0xEB2A7B23 b323
    /// Full list of weapons, components & tint indexes by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getPedWeaponTintIndex(ped: types.Ped, weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x2B9EEDC07BD06B9F, .{ped, weapon_hash}); } // 0x2B9EEDC07BD06B9F 0x3F9C90A7 b323
    /// Full list of weapons, components & tint indexes by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setWeaponObjectTintIndex(weapon: types.Object, tint_index: c_int) !void { try invoker.invoke(void, 0xF827589017D4E4A9, .{weapon, tint_index}); } // 0xF827589017D4E4A9 0x44ACC1DA b323
    pub inline fn getWeaponObjectTintIndex(weapon: types.Object) !c_int { return try invoker.invoke(c_int, 0xCD183314F7CD2E57, .{weapon}); } // 0xCD183314F7CD2E57 0xD91D9576 b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getWeaponTintCount(weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x5DCF6C5CAB2E9BF7, .{weapon_hash}); } // 0x5DCF6C5CAB2E9BF7 0x99E4EAAB b323
    /// Colors: \
    /// 0 = Gray \
    /// 1 = Dark Gray \
    /// 2 = Black \
    /// 3 = White \
    /// 4 = Blue \
    /// 5 = Cyan \
    /// 6 = Aqua \
    /// 7 = Cool Blue \
    /// 8 = Dark Blue \
    /// 9 = Royal Blue \
    /// 10 = Plum \
    /// 11 = Dark Purple \
    /// 12 = Purple \
    /// 13 = Red \
    /// 14 = Wine Red \
    /// 15 = Magenta \
    /// 16 = Pink \
    /// 17 = Salmon \
    /// 18 = Hot Pink \
    /// 19 = Rust Orange \
    /// 20 = Brown \
    /// 21 = Earth \
    /// 22 = Orange \
    /// 23 = Light Orange \
    /// 24 = Dark Yellow \
    /// 25 = Yellow \
    /// 26 = Light Brown \
    /// 27 = Lime Green \
    /// 28 = Olive \
    /// 29 = Moss \
    /// 30 = Turquoise \
    /// 31 = Dark Green \
    /// Full list of weapons, components, tint indexes & weapon liveries by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setPedWeaponComponentTintIndex(ped: types.Ped, weapon_hash: types.Hash, camo_component_hash: types.Hash, color_index: c_int) !void { try invoker.invoke(void, 0x9FE5633880ECD8ED, .{ped, weapon_hash, camo_component_hash, color_index}); } // 0x9FE5633880ECD8ED  b1103
    /// Returns -1 if camoComponentHash is invalid/not attached to the weapon. \
    /// Full list of weapons, components, tint indexes & weapon liveries by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getPedWeaponComponentTintIndex(ped: types.Ped, weapon_hash: types.Hash, camo_component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xF0A60040BE558F2D, .{ped, weapon_hash, camo_component_hash}); } // 0xF0A60040BE558F2D  b1103
    /// Colors: \
    /// 0 = Gray \
    /// 1 = Dark Gray \
    /// 2 = Black \
    /// 3 = White \
    /// 4 = Blue \
    /// 5 = Cyan \
    /// 6 = Aqua \
    /// 7 = Cool Blue \
    /// 8 = Dark Blue \
    /// 9 = Royal Blue \
    /// 10 = Plum \
    /// 11 = Dark Purple \
    /// 12 = Purple \
    /// 13 = Red \
    /// 14 = Wine Red \
    /// 15 = Magenta \
    /// 16 = Pink \
    /// 17 = Salmon \
    /// 18 = Hot Pink \
    /// 19 = Rust Orange \
    /// 20 = Brown \
    /// 21 = Earth \
    /// 22 = Orange \
    /// 23 = Light Orange \
    /// 24 = Dark Yellow \
    /// 25 = Yellow \
    /// 26 = Light Brown \
    /// 27 = Lime Green \
    /// 28 = Olive \
    /// 29 = Moss \
    /// 30 = Turquoise \
    /// 31 = Dark Green \
    /// Full list of weapons, components, tint indexes & weapon liveries by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setWeaponObjectComponentTintIndex(weapon_object: types.Object, camo_component_hash: types.Hash, color_index: c_int) !void { try invoker.invoke(void, 0x5DA825A85D0EA6E6, .{weapon_object, camo_component_hash, color_index}); } // 0x5DA825A85D0EA6E6  b1103
    /// Returns -1 if camoComponentHash is invalid/not attached to the weapon object. \
    /// Full list of weapons, components, tint indexes & weapon liveries by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getWeaponObjectComponentTintIndex(weapon_object: types.Object, camo_component_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xB3EA4FEABF41464B, .{weapon_object, camo_component_hash}); } // 0xB3EA4FEABF41464B  b1103
    pub inline fn getPedWeaponCamoIndex(ped: types.Ped, weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0xA2C9AC24B4061285, .{ped, weapon_hash}); } // 0xA2C9AC24B4061285  b1103
    pub inline fn setWeaponObjectCamoIndex(weapon_object: types.Object, p_1: c_int) !void { try invoker.invoke(void, 0x977CA98939E82E4B, .{weapon_object, p_1}); } // 0x977CA98939E82E4B  b1103
    /// struct WeaponHudStatsData \
    /// { \
    ///     BYTE hudDamage; // 0x0000
    ///     char _0x0001[0x7]; // 0x0001
    ///     BYTE hudSpeed; // 0x0008
    ///     char _0x0009[0x7]; // 0x0009
    ///     BYTE hudCapacity; // 0x0010
    ///     char _0x0011[0x7]; // 0x0011
    ///     BYTE hudAccuracy; // 0x0018
    ///     char _0x0019[0x7]; // 0x0019
    ///     BYTE hudRange; // 0x0020
    /// };
    /// 
    /// Usage:
    /// 
    /// WeaponHudStatsData data; \
    /// if (GET_WEAPON_HUD_STATS(weaponHash, (int *)&data)) \
    /// { \
    ///     // BYTE damagePercentage = data.hudDamage and so on
    /// } \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getWeaponHudStats(weapon_hash: types.Hash, out_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xD92C739EE34C9EBA, .{weapon_hash, out_data}); } // 0xD92C739EE34C9EBA 0xA9AD3D98 b323
    pub inline fn getWeaponComponentHudStats(component_hash: types.Hash, out_data: [*c]types.Any) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xB3CAF387AE12E9F8, .{component_hash, out_data}); } // 0xB3CAF387AE12E9F8 0xBB5498F4 b323
    /// This native does not return damages of weapons from the melee and explosive group. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getWeaponDamage(weapon_hash: types.Hash, component_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x3133B907D8B32053, .{weapon_hash, component_hash}); } // 0x3133B907D8B32053 0xE81649C0 b323
    /// // Returns the size of the default weapon component clip.
    /// 
    /// Use it like this:
    /// 
    /// char cClipSize[32]; \
    /// Hash cur; \
    /// if (WEAPON::GET_CURRENT_PED_WEAPON(playerPed, &cur, 1)) \
    /// { \
    ///     if (WEAPON::IS_WEAPON_VALID(cur))
    ///     {
    ///         int iClipSize = WEAPON::GET_WEAPON_CLIP_SIZE(cur);
    ///         sprintf_s(cClipSize, "ClipSize: %.d", iClipSize);
    ///         vDrawString(cClipSize, 0.5f, 0.5f);
    ///     }
    /// } \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getWeaponClipSize(weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x583BE370B1EC6EB4, .{weapon_hash}); } // 0x583BE370B1EC6EB4 0x8D515E66 b323
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getWeaponTimeBetweenShots(weapon_hash: types.Hash) !f32 { return try invoker.invoke(f32, 0x065D2AACAD8CF7A4, .{weapon_hash}); } // 0x065D2AACAD8CF7A4  b1290
    pub inline fn setPedChanceOfFiringBlanks(ped: types.Ped, bias__: types.Vector2) !void { try invoker.invoke(void, 0x8378627201D5497D, .{ped, bias__.x, bias__.y}); } // 0x8378627201D5497D 0xB4F44C6E b323
    /// Returns handle of the projectile.
    pub inline fn setPedShootOrdnanceWeapon(ped: types.Ped, p_1: f32) !types.Object { return try invoker.invoke(types.Object, 0xB4C8D77C80C0421E, .{ped, p_1}); } // 0xB4C8D77C80C0421E 0xEC2E5304 b323
    pub inline fn requestWeaponHighDetailModel(weapon_object: types.Entity) !void { try invoker.invoke(void, 0x48164DBB970AC3F0, .{weapon_object}); } // 0x48164DBB970AC3F0 0xE3BD00F9 b323
    pub inline fn setWeaponPedDamageModifier_(weapon: types.Hash, damage_modifier: f32) !void { try invoker.invoke(void, 0x1091922715B68DF0, .{weapon, damage_modifier}); } // 0x1091922715B68DF0  b3095
    /// Changes the weapon damage output by the given multiplier value. Must be run every frame. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setWeaponDamageModifier(weapon_hash: types.Hash, damage_multiplier: f32) !void { try invoker.invoke(void, 0x4757F00BC6323CFE, .{weapon_hash, damage_multiplier}); } // 0x4757F00BC6323CFE  b505
    pub inline fn setWeaponAoeModifier(weapon_hash: types.Hash, multiplier: f32) !void { try invoker.invoke(void, 0x4AE5AC8B852D642C, .{weapon_hash, multiplier}); } // 0x4AE5AC8B852D642C  b2372
    /// ex, WEAPON::SET_WEAPON_EFFECT_DURATION_MODIFIER(joaat("vehicle_weapon_mine_slick"), 1.0);
    pub inline fn setWeaponEffectDurationModifier(p_0: types.Hash, p_1: f32) !void { try invoker.invoke(void, 0xE6D2CEDD370FF98E, .{p_0, p_1}); } // 0xE6D2CEDD370FF98E  b2372
    /// This native returns a true or false value.
    /// 
    /// Ped ped = The ped whose weapon you want to check.
    pub inline fn isPedCurrentWeaponSilenced(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x65F0C5AE05943EC7, .{ped}); } // 0x65F0C5AE05943EC7 0xBAF7BFBE b323
    pub inline fn isFlashLightOn(ped: types.Ped) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x4B7620C47217126C, .{ped}); } // 0x4B7620C47217126C 0x76876154 b323
    pub inline fn setFlashLightFadeDistance(distance: f32) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCEA66DAD478CD39B, .{distance}); } // 0xCEA66DAD478CD39B 0xB0127EA7 b323
    /// Enables/disables flashlight on ped's weapon.
    pub inline fn setFlashLightActiveHistory(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0x988DB6FE9B3AC000, .{ped, toggle}); } // 0x988DB6FE9B3AC000  b2060
    /// Changes the selected ped aiming animation style.  \
    /// Note : You must use GET_HASH_KEY!
    /// 
    /// Strings to use with GET_HASH_KEY :
    /// 
    ///     "Ballistic",
    ///     "Default",
    ///   "Fat",
    ///   "Female",
    ///    "FirstPerson",
    ///   "FirstPersonAiming",
    ///     "FirstPersonFranklin",
    ///   "FirstPersonFranklinAiming",
    ///     "FirstPersonFranklinRNG",
    ///    "FirstPersonFranklinScope",
    ///  "FirstPersonMPFemale", \
    ///   "FirstPersonMichael",
    ///    "FirstPersonMichaelAiming",
    ///  "FirstPersonMichaelRNG", \
    ///     "FirstPersonMichaelScope",
    ///   "FirstPersonRNG",
    ///    "FirstPersonScope",
    ///  "FirstPersonTrevor", \
    ///     "FirstPersonTrevorAiming",
    ///   "FirstPersonTrevorRNG",
    ///  "FirstPersonTrevorScope", \
    ///    "Franklin",
    ///  "Gang", \
    ///  "Gang1H", \
    ///    "GangFemale",
    ///    "Hillbilly",
    ///     "MP_F_Freemode",
    ///     "Michael",
    ///   "SuperFat",
    ///  "Trevor"
    pub inline fn setWeaponAnimationOverride(ped: types.Ped, anim_style: types.Hash) !void { try invoker.invoke(void, 0x1055AC3A667F09D9, .{ped, anim_style}); } // 0x1055AC3A667F09D9 0xA5DF7484 b323
    /// enum class eDamageType \
    /// { \
    ///     UNKNOWN = 0,
    ///     NONE = 1,
    ///     MELEE = 2,
    ///     BULLET = 3,
    ///     BULLET_RUBBER = 4,
    ///     EXPLOSIVE = 5,
    ///     FIRE = 6,
    ///     COLLISION = 7,
    ///     FALL = 8,
    ///     DROWN = 9,
    ///     ELECTRIC = 10,
    ///     BARBED_WIRE = 11,
    ///     FIRE_EXTINGUISHER = 12,
    ///     SMOKE = 13,
    ///     WATER_CANNON = 14,
    ///     TRANQUILIZER = 15,
    /// };
    /// 
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn getWeaponDamageType(weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x3BE0BB12D25FB305, .{weapon_hash}); } // 0x3BE0BB12D25FB305 0x013AFC13 b323
    pub inline fn setEqippedWeaponStartSpinningAtFullSpeed(ped: types.Ped) !void { try invoker.invoke(void, 0xE4DCEC7FD5B739A5, .{ped}); } // 0xE4DCEC7FD5B739A5 0x64646F1D b323
    /// this returns if you can use the weapon while using a parachute \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn canUseWeaponOnParachute(weapon_hash: types.Hash) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xBC7BE5ABC0879F74, .{weapon_hash}); } // 0xBC7BE5ABC0879F74 0x135E7AD4 b323
    /// Both coordinates are from objects in the decompiled scripts. Native related to 0xECDC202B25E5CF48 p1 value. The only weapon hash used in the decompiled scripts is weapon_air_defence_gun. These two natives are used by the yacht script, decompiled scripts suggest it and the weapon hash used (valkyrie's rockets) are also used by yachts.
    pub inline fn createAirDefenceSphere(vec: types.Vector3, radius: f32, p_4: f32, p_5: f32, p_6: f32, weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x91EF34584710BE99, .{vec.x, vec.y, vec.z, radius, p_4, p_5, p_6, weapon_hash}); } // 0x91EF34584710BE99  b573
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn createAirDefenceAngledArea(p_0: f32, p_1: f32, p_2: f32, p_3: f32, p_4: f32, p_5: f32, p_6: f32, p_7: f32, p_8: f32, radius: f32, weapon_hash: types.Hash) !c_int { return try invoker.invoke(c_int, 0x9DA58CDBF6BDBC08, .{p_0, p_1, p_2, p_3, p_4, p_5, p_6, p_7, p_8, radius, weapon_hash}); } // 0x9DA58CDBF6BDBC08  b1011
    pub inline fn removeAirDefenceSphere(zone_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0x0ABF535877897560, .{zone_id}); } // 0x0ABF535877897560  b573
    pub inline fn removeAllAirDefenceSpheres() !void { try invoker.invoke(void, 0x1E45B34ADEBEE48E, .{}); } // 0x1E45B34ADEBEE48E  b573
    pub inline fn setPlayerTargettableForAirDefenceSphere(player: types.Player, zone_id: c_int, enable: windows.BOOL) !void { try invoker.invoke(void, 0xECDC202B25E5CF48, .{player, zone_id, enable}); } // 0xECDC202B25E5CF48  b573
    pub inline fn isAirDefenceSphereInArea(vec: types.Vector3, radius: f32, out_zone_id: [*c]c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xDAB963831DBFD3F4, .{vec.x, vec.y, vec.z, radius, out_zone_id}); } // 0xDAB963831DBFD3F4  b1103
    pub inline fn fireAirDefenceSphereWeaponAtPosition(zone_id: c_int, vec: types.Vector3) !void { try invoker.invoke(void, 0x44F1012B69313374, .{zone_id, vec.x, vec.y, vec.z}); } // 0x44F1012B69313374  b573
    pub inline fn doesAirDefenceSphereExist(zone_id: c_int) !windows.BOOL { return try invoker.invoke(windows.BOOL, 0xCD79A550999D7D4F, .{zone_id}); } // 0xCD79A550999D7D4F  b678
    /// Disables selecting the given weapon. Ped isn't forced to put the gun away. However you can't reselect the weapon if you holster then unholster. Weapon is also grayed out on the weapon wheel. \
    /// Full list of weapons by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/weapons.json
    pub inline fn setCanPedSelectInventoryWeapon(ped: types.Ped, weapon_hash: types.Hash, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xB4771B9AAF4E68E4, .{ped, weapon_hash, toggle}); } // 0xB4771B9AAF4E68E4  b1103
    /// Disable all weapons. Does the same as 0xB4771B9AAF4E68E4 except for all weapons.
    pub inline fn setCanPedSelectAllWeapons(ped: types.Ped, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xEFF296097FF1E509, .{ped, toggle}); } // 0xEFF296097FF1E509  b1103
};

pub const Zone = struct
{
    pub inline fn getZoneAtCoords(vec: types.Vector3) !c_int { return try invoker.invoke(c_int, 0x27040C25DE6CB2F4, .{vec.x, vec.y, vec.z}); } // 0x27040C25DE6CB2F4 0xC9018181 b323
    /// 'zoneName' corresponds to an entry in 'popzone.ipl'.
    /// 
    /// AIRP = Los Santos International Airport \
    /// ALAMO = Alamo Sea \
    /// ALTA = Alta \
    /// ARMYB = Fort Zancudo \
    /// BANHAMC = Banham Canyon Dr \
    /// BANNING = Banning \
    /// BEACH = Vespucci Beach \
    /// BHAMCA = Banham Canyon \
    /// BRADP = Braddock Pass \
    /// BRADT = Braddock Tunnel \
    /// BURTON = Burton \
    /// CALAFB = Calafia Bridge \
    /// CANNY = Raton Canyon \
    /// CCREAK = Cassidy Creek \
    /// CHAMH = Chamberlain Hills \
    /// CHIL = Vinewood Hills \
    /// CHU = Chumash \
    /// CMSW = Chiliad Mountain State Wilderness \
    /// CYPRE = Cypress Flats \
    /// DAVIS = Davis \
    /// DELBE = Del Perro Beach \
    /// DELPE = Del Perro \
    /// DELSOL = La Puerta \
    /// DESRT = Grand Senora Desert \
    /// DOWNT = Downtown \
    /// DTVINE = Downtown Vinewood \
    /// EAST_V = East Vinewood \
    /// EBURO = El Burro Heights \
    /// ELGORL = El Gordo Lighthouse \
    /// ELYSIAN = Elysian Island \
    /// GALFISH = Galilee \
    /// GOLF = GWC and Golfing Society \
    /// GRAPES = Grapeseed \
    /// GREATC = Great Chaparral \
    /// HARMO = Harmony \
    /// HAWICK = Hawick \
    /// HORS = Vinewood Racetrack \
    /// HUMLAB = Humane Labs and Research \
    /// JAIL = Bolingbroke Penitentiary \
    /// KOREAT = Little Seoul \
    /// LACT = Land Act Reservoir \
    /// LAGO = Lago Zancudo \
    /// LDAM = Land Act Dam \
    /// LEGSQU = Legion Square \
    /// LMESA = La Mesa \
    /// LOSPUER = La Puerta \
    /// MIRR = Mirror Park \
    /// MORN = Morningwood \
    /// MOVIE = Richards Majestic \
    /// MTCHIL = Mount Chiliad \
    /// MTGORDO = Mount Gordo \
    /// MTJOSE = Mount Josiah \
    /// MURRI = Murrieta Heights \
    /// NCHU = North Chumash \
    /// NOOSE = N.O.O.S.E \
    /// OCEANA = Pacific Ocean \
    /// PALCOV = Paleto Cove \
    /// PALETO = Paleto Bay \
    /// PALFOR = Paleto Forest \
    /// PALHIGH = Palomino Highlands \
    /// PALMPOW = Palmer-Taylor Power Station \
    /// PBLUFF = Pacific Bluffs \
    /// PBOX = Pillbox Hill \
    /// PROCOB = Procopio Beach \
    /// RANCHO = Rancho \
    /// RGLEN = Richman Glen \
    /// RICHM = Richman \
    /// ROCKF = Rockford Hills \
    /// RTRAK = Redwood Lights Track \
    /// SANAND = San Andreas \
    /// SANCHIA = San Chianski Mountain Range \
    /// SANDY = Sandy Shores \
    /// SKID = Mission Row \
    /// SLAB = Stab City \
    /// STAD = Maze Bank Arena \
    /// STRAW = Strawberry \
    /// TATAMO = Tataviam Mountains \
    /// TERMINA = Terminal \
    /// TEXTI = Textile City \
    /// TONGVAH = Tongva Hills \
    /// TONGVAV = Tongva Valley \
    /// VCANA = Vespucci Canals \
    /// VESP = Vespucci \
    /// VINE = Vinewood \
    /// WINDF = Ron Alternates Wind Farm \
    /// WVINE = West Vinewood \
    /// ZANCUDO = Zancudo River \
    /// ZP_ORT = Port of South Los Santos \
    /// ZQ_UAR = Davis Quartz
    /// 
    /// Full list of zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/zones.json
    pub inline fn getZoneFromNameId(zone_name: [*c]const u8) !c_int { return try invoker.invoke(c_int, 0x98CD1D2934B76CC1, .{zone_name}); } // 0x98CD1D2934B76CC1 0x8EC68304 b323
    pub inline fn getZonePopschedule(zone_id: c_int) !c_int { return try invoker.invoke(c_int, 0x4334BC40AA0CB4BB, .{zone_id}); } // 0x4334BC40AA0CB4BB 0x20AB2FC9 b323
    /// AIRP = Los Santos International Airport \
    /// ALAMO = Alamo Sea \
    /// ALTA = Alta \
    /// ARMYB = Fort Zancudo \
    /// BANHAMC = Banham Canyon Dr \
    /// BANNING = Banning \
    /// BEACH = Vespucci Beach \
    /// BHAMCA = Banham Canyon \
    /// BRADP = Braddock Pass \
    /// BRADT = Braddock Tunnel \
    /// BURTON = Burton \
    /// CALAFB = Calafia Bridge \
    /// CANNY = Raton Canyon \
    /// CCREAK = Cassidy Creek \
    /// CHAMH = Chamberlain Hills \
    /// CHIL = Vinewood Hills \
    /// CHU = Chumash \
    /// CMSW = Chiliad Mountain State Wilderness \
    /// CYPRE = Cypress Flats \
    /// DAVIS = Davis \
    /// DELBE = Del Perro Beach \
    /// DELPE = Del Perro \
    /// DELSOL = La Puerta \
    /// DESRT = Grand Senora Desert \
    /// DOWNT = Downtown \
    /// DTVINE = Downtown Vinewood \
    /// EAST_V = East Vinewood \
    /// EBURO = El Burro Heights \
    /// ELGORL = El Gordo Lighthouse \
    /// ELYSIAN = Elysian Island \
    /// GALFISH = Galilee \
    /// GOLF = GWC and Golfing Society \
    /// GRAPES = Grapeseed \
    /// GREATC = Great Chaparral \
    /// HARMO = Harmony \
    /// HAWICK = Hawick \
    /// HORS = Vinewood Racetrack \
    /// HUMLAB = Humane Labs and Research \
    /// JAIL = Bolingbroke Penitentiary \
    /// KOREAT = Little Seoul \
    /// LACT = Land Act Reservoir \
    /// LAGO = Lago Zancudo \
    /// LDAM = Land Act Dam \
    /// LEGSQU = Legion Square \
    /// LMESA = La Mesa \
    /// LOSPUER = La Puerta \
    /// MIRR = Mirror Park \
    /// MORN = Morningwood \
    /// MOVIE = Richards Majestic \
    /// MTCHIL = Mount Chiliad \
    /// MTGORDO = Mount Gordo \
    /// MTJOSE = Mount Josiah \
    /// MURRI = Murrieta Heights \
    /// NCHU = North Chumash \
    /// NOOSE = N.O.O.S.E \
    /// OCEANA = Pacific Ocean \
    /// PALCOV = Paleto Cove \
    /// PALETO = Paleto Bay \
    /// PALFOR = Paleto Forest \
    /// PALHIGH = Palomino Highlands \
    /// PALMPOW = Palmer-Taylor Power Station \
    /// PBLUFF = Pacific Bluffs \
    /// PBOX = Pillbox Hill \
    /// PROCOB = Procopio Beach \
    /// RANCHO = Rancho \
    /// RGLEN = Richman Glen \
    /// RICHM = Richman \
    /// ROCKF = Rockford Hills \
    /// RTRAK = Redwood Lights Track \
    /// SANAND = San Andreas \
    /// SANCHIA = San Chianski Mountain Range \
    /// SANDY = Sandy Shores \
    /// SKID = Mission Row \
    /// SLAB = Stab City \
    /// STAD = Maze Bank Arena \
    /// STRAW = Strawberry \
    /// TATAMO = Tataviam Mountains \
    /// TERMINA = Terminal \
    /// TEXTI = Textile City \
    /// TONGVAH = Tongva Hills \
    /// TONGVAV = Tongva Valley \
    /// VCANA = Vespucci Canals \
    /// VESP = Vespucci \
    /// VINE = Vinewood \
    /// WINDF = Ron Alternates Wind Farm \
    /// WVINE = West Vinewood \
    /// ZANCUDO = Zancudo River \
    /// ZP_ORT = Port of South Los Santos \
    /// ZQ_UAR = Davis Quartz
    /// 
    /// Full list of zones by DurtyFree: https://github.com/DurtyFree/gta-v-data-dumps/blob/master/zones.json
    pub inline fn getNameOfZone(vec: types.Vector3) ![*c]const u8 { return try invoker.invoke([*c]const u8, 0xCD90657D4C30E1CA, .{vec.x, vec.y, vec.z}); } // 0xCD90657D4C30E1CA 0x7875CE91 b323
    pub inline fn setZoneEnabled(zone_id: c_int, toggle: windows.BOOL) !void { try invoker.invoke(void, 0xBA5ECEEA120E5611, .{zone_id, toggle}); } // 0xBA5ECEEA120E5611 0x04E21B03 b323
    /// cellphone range 1- 5 used for signal bar in iFruit phone
    pub inline fn getZoneScumminess(zone_id: c_int) !c_int { return try invoker.invoke(c_int, 0x5F7B268D15BA0739, .{zone_id}); } // 0x5F7B268D15BA0739 0xB2FB5C4C b323
    /// Only used once in the decompiled scripts. Seems to be related to scripted vehicle generators.
    /// 
    /// Modified example from "am_imp_exp.c4", line 6406: \
    /// /* popSchedules[0] = ZONE::GET_ZONE_POPSCHEDULE(ZONE::GET_ZONE_AT_COORDS(891.3, 807.9, 188.1)); \
    /// etc. \
    /// */ \
    /// ZONE::OVERRIDE_POPSCHEDULE_VEHICLE_MODEL(popSchedules[index], vehicleHash); \
    /// STREAMING::REQUEST_MODEL(vehicleHash);
    pub inline fn overridePopscheduleVehicleModel(schedule_id: c_int, vehicle_hash: types.Hash) !void { try invoker.invoke(void, 0x5F7D596BAC2E7777, .{schedule_id, vehicle_hash}); } // 0x5F7D596BAC2E7777 0x3F0A3680 b323
    /// Only used once in the decompiled scripts. Seems to be related to scripted vehicle generators.
    /// 
    /// Modified example from "am_imp_exp.c4", line 6418: \
    /// /* popSchedules[0] = ZONE::GET_ZONE_POPSCHEDULE(ZONE::GET_ZONE_AT_COORDS(891.3, 807.9, 188.1)); \
    /// etc. \
    /// */ \
    /// STREAMING::SET_MODEL_AS_NO_LONGER_NEEDED(vehicleHash); \
    /// ZONE::CLEAR_POPSCHEDULE_OVERRIDE_VEHICLE_MODEL(popSchedules[index]);
    pub inline fn clearPopscheduleOverrideVehicleModel(schedule_id: c_int) !void { try invoker.invoke(void, 0x5C0DE367AA0D911C, .{schedule_id}); } // 0x5C0DE367AA0D911C 0x7A72A24E b323
    /// Returns a hash representing which part of the map the given coords are located.
    /// 
    /// Possible return values: \
    /// (Hash of) city -> -289320599 \
    /// (Hash of) countryside -> 2072609373
    /// 
    /// C# Example :
    /// 
    /// Ped player = Game.Player.Character; \
    /// Hash h = Function.Call<Hash>(Hash.GET_HASH_OF_MAP_AREA_AT_COORDS, player.Position.X, player.Position.Y, player.Position.Z);
    pub inline fn getHashOfMapAreaAtCoords(vec: types.Vector3) !types.Hash { return try invoker.invoke(types.Hash, 0x7EE64D51E8498728, .{vec.x, vec.y, vec.z}); } // 0x7EE64D51E8498728 0xB5C5C99B b323
};

// zig fmt: on

test "natives" {
    const std = @import("std");
    const testing = std.testing;

    testing.refAllDeclsRecursive(@This());
}
